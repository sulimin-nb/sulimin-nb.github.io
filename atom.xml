<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sulimin-nb.github.io/"/>
  <updated>2020-12-16T14:37:52.720Z</updated>
  <id>https://sulimin-nb.github.io/</id>
  
  <author>
    <name>sulimin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>pandas-第一章</title>
    <link href="https://sulimin-nb.github.io/article/7b8d9bbd.html"/>
    <id>https://sulimin-nb.github.io/article/7b8d9bbd.html</id>
    <published>2020-12-16T14:37:18.000Z</published>
    <updated>2020-12-16T14:37:52.720Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-预备知识"><a href="#第一章-预备知识" class="headerlink" title="第一章 预备知识"></a>第一章 预备知识</h1><h2 id="一、Python基础"><a href="#一、Python基础" class="headerlink" title="一、Python基础"></a>一、Python基础</h2><h3 id="1-列表推导式与条件赋值"><a href="#1-列表推导式与条件赋值" class="headerlink" title="1. 列表推导式与条件赋值"></a>1. 列表推导式与条件赋值</h3><p>在生成一个数字序列的时候，在 <code>Python</code> 中可以如下写出：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">1</span>]: L = []In [<span class="hljs-number">2</span>]: def my_func(x):   ...:     <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*x   ...: In [<span class="hljs-number">3</span>]: <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):   ...:     L.append(my_func(i))   ...: In [<span class="hljs-number">4</span>]: LOut[<span class="hljs-number">4</span>]: [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]</code></pre><p>事实上可以利用列表推导式进行写法上的简化： <code>[* for i in *]</code> 。其中，第一个 <code>*</code> 为映射函数，其输入为后面 <code>i</code> 指代的内容，第二个 <code>*</code> 表示迭代的对象。</p><pre><code class="hljs angelscript">In [<span class="hljs-number">5</span>]: [my_func(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]Out[<span class="hljs-number">5</span>]: [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]</code></pre><p>列表表达式还支持多层嵌套，如下面的例子中第一个 <code>for</code> 为外层循环，第二个为内层循环：</p><pre><code class="hljs prolog"><span class="hljs-symbol">In</span> [<span class="hljs-number">6</span>]: [m+<span class="hljs-string">'_'</span>+n for m in [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>] for n in [<span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]]<span class="hljs-symbol">Out</span>[<span class="hljs-number">6</span>]: [<span class="hljs-string">'a_c'</span>, <span class="hljs-string">'a_d'</span>, <span class="hljs-string">'b_c'</span>, <span class="hljs-string">'b_d'</span>]</code></pre><p>除了列表推导式，另一个实用的语法糖是带有 <code>if</code> 选择的条件赋值，其形式为 <code>value = a if condition else b</code> ：</p><pre><code class="hljs pgsql"><span class="hljs-keyword">In</span> [<span class="hljs-number">7</span>]: <span class="hljs-keyword">value</span> = <span class="hljs-string">'cat'</span> <span class="hljs-keyword">if</span> <span class="hljs-number">2</span>&gt;<span class="hljs-number">1</span> <span class="hljs-keyword">else</span> <span class="hljs-string">'dog'</span><span class="hljs-keyword">In</span> [<span class="hljs-number">8</span>]: <span class="hljs-keyword">value</span><span class="hljs-keyword">Out</span>[<span class="hljs-number">8</span>]: <span class="hljs-string">'cat'</span></code></pre><p>等价于如下的写法：</p><pre><code class="hljs livecodeserver"><span class="hljs-keyword">a</span>, b = <span class="hljs-string">'cat'</span>, <span class="hljs-string">'dog'</span>condition = <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> <span class="hljs-comment"># 此时为True</span><span class="hljs-keyword">if</span> condition:    <span class="hljs-built_in">value</span> = <span class="hljs-keyword">a</span><span class="hljs-keyword">else</span>:    <span class="hljs-built_in">value</span> = b</code></pre><p>下面举一个例子，截断列表中超过5的元素，即超过5的用5代替，小于5的保留原来的值：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">9</span>]: L = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]In [<span class="hljs-number">10</span>]: [i <span class="hljs-keyword">if</span> i &lt;= <span class="hljs-number">5</span> <span class="hljs-keyword">else</span> <span class="hljs-number">5</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> L]Out[<span class="hljs-number">10</span>]: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>]</code></pre><h3 id="2-匿名函数与map方法"><a href="#2-匿名函数与map方法" class="headerlink" title="2. 匿名函数与map方法"></a>2. 匿名函数与map方法</h3><p>有一些函数的定义具有清晰简单的映射关系，例如上面的 <code>my_func</code> 函数，这时候可以用匿名函数的方法简洁地表示：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">11</span>]: my_func = lambda x: <span class="hljs-number">2</span>*xIn [<span class="hljs-number">12</span>]: my_func(<span class="hljs-number">3</span>)Out[<span class="hljs-number">12</span>]: <span class="hljs-number">6</span>In [<span class="hljs-number">13</span>]: multi_para_func = lambda a, b: a + bIn [<span class="hljs-number">14</span>]: multi_para_func(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)Out[<span class="hljs-number">14</span>]: <span class="hljs-number">3</span></code></pre><p>但上面的用法其实违背了“匿名”的含义，事实上它往往在无需多处调用的场合进行使用，例如上面列表推导式中的例子，用户不关心函数的名字，只关心这种映射的关系：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">15</span>]: [(lambda x: <span class="hljs-number">2</span>*x)(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]Out[<span class="hljs-number">15</span>]: [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]</code></pre><p>对于上述的这种列表推导式的匿名函数映射， <code>Python</code> 中提供了 <code>map</code> 函数来完成，它返回的是一个 <code>map</code> 对象，需要通过 <code>list</code> 转为列表：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">16</span>]: list(map(lambda x: <span class="hljs-number">2</span>*x, range(<span class="hljs-number">5</span>)))Out[<span class="hljs-number">16</span>]: [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]</code></pre><p>对于多个输入值的函数映射，可以通过追加迭代对象实现：</p><pre><code class="hljs sas"><span class="hljs-meta">In</span> [17]: <span class="hljs-meta">list</span>(map(lambda <span class="hljs-meta">x</span>, y: str(<span class="hljs-meta">x</span>)+<span class="hljs-string">'_'</span>+y,<span class="hljs-meta"> range(</span>5), <span class="hljs-meta">list</span>(<span class="hljs-string">'abcde'</span>)))<span class="hljs-meta">Out</span>[17]: [<span class="hljs-string">'0_a'</span>, <span class="hljs-string">'1_b'</span>, <span class="hljs-string">'2_c'</span>, <span class="hljs-string">'3_d'</span>, <span class="hljs-string">'4_e'</span>]</code></pre><h3 id="3-zip对象与enumerate方法"><a href="#3-zip对象与enumerate方法" class="headerlink" title="3. zip对象与enumerate方法"></a>3. zip对象与enumerate方法</h3><p>zip函数能够把多个可迭代对象打包成一个元组构成的可迭代对象，它返回了一个 <code>zip</code> 对象，通过 <code>tuple, list</code> 可以得到相应的打包结果：</p><pre><code class="hljs prolog"><span class="hljs-symbol">In</span> [<span class="hljs-number">18</span>]: <span class="hljs-symbol">L1</span>, <span class="hljs-symbol">L2</span>, <span class="hljs-symbol">L3</span> = list(<span class="hljs-string">'abc'</span>), list(<span class="hljs-string">'def'</span>), list(<span class="hljs-string">'hij'</span>)<span class="hljs-symbol">In</span> [<span class="hljs-number">19</span>]: list(zip(<span class="hljs-symbol">L1</span>, <span class="hljs-symbol">L2</span>, <span class="hljs-symbol">L3</span>))<span class="hljs-symbol">Out</span>[<span class="hljs-number">19</span>]: [(<span class="hljs-string">'a'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'h'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'i'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'f'</span>, <span class="hljs-string">'j'</span>)]<span class="hljs-symbol">In</span> [<span class="hljs-number">20</span>]: tuple(zip(<span class="hljs-symbol">L1</span>, <span class="hljs-symbol">L2</span>, <span class="hljs-symbol">L3</span>))<span class="hljs-symbol">Out</span>[<span class="hljs-number">20</span>]: ((<span class="hljs-string">'a'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'h'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'i'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'f'</span>, <span class="hljs-string">'j'</span>))</code></pre><p>往往会在循环迭代的时候使用到 <code>zip</code> 函数：</p><pre><code class="hljs matlab">In [<span class="hljs-number">21</span>]: <span class="hljs-keyword">for</span> <span class="hljs-built_in">i</span>, <span class="hljs-built_in">j</span>, k in zip(L1, L2, L3):   ....:     print(<span class="hljs-built_in">i</span>, <span class="hljs-built_in">j</span>, k)   ....: a d hb e <span class="hljs-built_in">i</span>c f <span class="hljs-built_in">j</span></code></pre><p><code>enumerate</code> 是一种特殊的打包，它可以在迭代时绑定迭代元素的遍历序号：</p><pre><code class="hljs routeros"><span class="hljs-keyword">In</span> [22]: L = list(<span class="hljs-string">'abcd'</span>)<span class="hljs-keyword">In</span> [23]: <span class="hljs-keyword">for</span> index, value <span class="hljs-keyword">in</span> enumerate(L):   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>:     <span class="hljs-builtin-name">print</span>(index, value)   <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>: 0 a1 b2 c3 d</code></pre><p>用 <code>zip</code> 对象也能够简单地实现这个功能：</p><pre><code class="hljs fortran"><span class="hljs-keyword">In</span> [<span class="hljs-number">24</span>]: for <span class="hljs-built_in">index</span>, <span class="hljs-keyword">value</span> <span class="hljs-keyword">in</span> zip(<span class="hljs-built_in">range</span>(len(L)), L):   ....:     <span class="hljs-built_in">print</span>(<span class="hljs-built_in">index</span>, <span class="hljs-keyword">value</span>)   ....: <span class="hljs-number">0</span> a<span class="hljs-number">1</span> b<span class="hljs-number">2</span> c<span class="hljs-number">3</span> d</code></pre><p>当需要对两个列表建立字典映射时，可以利用 <code>zip</code> 对象：</p><pre><code class="hljs prolog"><span class="hljs-symbol">In</span> [<span class="hljs-number">25</span>]: dict(zip(<span class="hljs-symbol">L1</span>, <span class="hljs-symbol">L2</span>))<span class="hljs-symbol">Out</span>[<span class="hljs-number">25</span>]: &#123;<span class="hljs-string">'a'</span>: <span class="hljs-string">'d'</span>, <span class="hljs-string">'b'</span>: <span class="hljs-string">'e'</span>, <span class="hljs-string">'c'</span>: <span class="hljs-string">'f'</span>&#125;</code></pre><p>既然有了压缩函数，那么 <code>Python</code> 也提供了 <code>*</code> 操作符和 <code>zip</code> 联合使用来进行解压操作：</p><pre><code class="hljs prolog"><span class="hljs-symbol">In</span> [<span class="hljs-number">26</span>]: zipped = list(zip(<span class="hljs-symbol">L1</span>, <span class="hljs-symbol">L2</span>, <span class="hljs-symbol">L3</span>))<span class="hljs-symbol">In</span> [<span class="hljs-number">27</span>]: zipped<span class="hljs-symbol">Out</span>[<span class="hljs-number">27</span>]: [(<span class="hljs-string">'a'</span>, <span class="hljs-string">'d'</span>, <span class="hljs-string">'h'</span>), (<span class="hljs-string">'b'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'i'</span>), (<span class="hljs-string">'c'</span>, <span class="hljs-string">'f'</span>, <span class="hljs-string">'j'</span>)]<span class="hljs-symbol">In</span> [<span class="hljs-number">28</span>]: list(zip(*zipped)) # 三个元组分别对应原来的列表<span class="hljs-symbol">Out</span>[<span class="hljs-number">28</span>]: [(<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>), (<span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>), (<span class="hljs-string">'h'</span>, <span class="hljs-string">'i'</span>, <span class="hljs-string">'j'</span>)]</code></pre><h2 id="二、Numpy基础"><a href="#二、Numpy基础" class="headerlink" title="二、Numpy基础"></a>二、Numpy基础</h2><h3 id="1-np数组的构造"><a href="#1-np数组的构造" class="headerlink" title="1. np数组的构造"></a>1. np数组的构造</h3><p>最一般的方法是通过 <code>array</code> 来构造：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">29</span>]: <span class="hljs-keyword">import</span> numpy as npIn [<span class="hljs-number">30</span>]: np.<span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])Out[<span class="hljs-number">30</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])</code></pre><p>下面讨论一些特殊数组的生成方式：</p><p>【a】等差序列： <code>np.linspace, np.arange</code></p><pre><code class="hljs angelscript">In [<span class="hljs-number">31</span>]: np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">11</span>) # 起始、终止（包含）、样本个数Out[<span class="hljs-number">31</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">1.</span> , <span class="hljs-number">1.4</span>, <span class="hljs-number">1.8</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">2.6</span>, <span class="hljs-number">3.</span> , <span class="hljs-number">3.4</span>, <span class="hljs-number">3.8</span>, <span class="hljs-number">4.2</span>, <span class="hljs-number">4.6</span>, <span class="hljs-number">5.</span> ])In [<span class="hljs-number">32</span>]: np.arange(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>) # 起始、终止（不包含）、步长Out[<span class="hljs-number">32</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>])</code></pre><p>【b】特殊矩阵： <code>zeros, eye, full</code></p><pre><code class="hljs angelscript">In [<span class="hljs-number">33</span>]: np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)) # 传入元组表示各维度大小Out[<span class="hljs-number">33</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])In [<span class="hljs-number">34</span>]: np.eye(<span class="hljs-number">3</span>) # <span class="hljs-number">3</span>*<span class="hljs-number">3</span>的单位矩阵Out[<span class="hljs-number">34</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],       [<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>],       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>]])In [<span class="hljs-number">35</span>]: np.eye(<span class="hljs-number">3</span>, k=<span class="hljs-number">1</span>) # 偏移主对角线<span class="hljs-number">1</span>个单位的伪单位矩阵Out[<span class="hljs-number">35</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>],       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>],       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])In [<span class="hljs-number">36</span>]: np.full((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>), <span class="hljs-number">10</span>) # 元组传入大小，<span class="hljs-number">10</span>表示填充数值Out[<span class="hljs-number">36</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>],       [<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>]])In [<span class="hljs-number">37</span>]: np.full((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>), [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]) # 通过传入列表填充每列的值Out[<span class="hljs-number">37</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],       [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])</code></pre><p>【c】随机矩阵： <code>np.random</code></p><p>最常用的随机生成函数为 <code>rand, randn, randint, choice</code> ，它们分别表示0-1均匀分布的随机数组、标准正态的随机数组、随机整数组和随机列表抽样：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">38</span>]: np.random.rand(<span class="hljs-number">3</span>) # 生成服从<span class="hljs-number">0</span><span class="hljs-number">-1</span>均匀分布的三个随机数Out[<span class="hljs-number">38</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">0.33475955</span>, <span class="hljs-number">0.95078732</span>, <span class="hljs-number">0.05285509</span>])In [<span class="hljs-number">39</span>]: np.random.rand(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>) # 注意这里传入的不是元组，每个维度大小分开输入Out[<span class="hljs-number">39</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0.1188322</span> , <span class="hljs-number">0.51993935</span>, <span class="hljs-number">0.73054809</span>],       [<span class="hljs-number">0.97169376</span>, <span class="hljs-number">0.72724319</span>, <span class="hljs-number">0.84687781</span>],       [<span class="hljs-number">0.18001319</span>, <span class="hljs-number">0.8011098</span> , <span class="hljs-number">0.05113275</span>]])</code></pre><p>对于服从区间 aa 到 bb 上的均匀分布可以如下生成：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">40</span>]: a, b = <span class="hljs-number">5</span>, <span class="hljs-number">15</span>In [<span class="hljs-number">41</span>]: (b - a) * np.random.rand(<span class="hljs-number">3</span>) + aOut[<span class="hljs-number">41</span>]: <span class="hljs-built_in">array</span>([ <span class="hljs-number">9.67438882</span>, <span class="hljs-number">12.49445466</span>,  <span class="hljs-number">6.51381903</span>])</code></pre><p><code>randn</code> 生成了 N(0,I)N(0,I) 的标准正态分布：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">42</span>]: np.random.randn(<span class="hljs-number">3</span>)Out[<span class="hljs-number">42</span>]: <span class="hljs-built_in">array</span>([ <span class="hljs-number">0.91321097</span>, <span class="hljs-number">-0.02203455</span>,  <span class="hljs-number">0.44235296</span>])In [<span class="hljs-number">43</span>]: np.random.randn(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)Out[<span class="hljs-number">43</span>]: <span class="hljs-built_in">array</span>([[ <span class="hljs-number">0.49897634</span>, <span class="hljs-number">-1.57842429</span>],       [<span class="hljs-number">-0.09213398</span>,  <span class="hljs-number">0.00613158</span>]])</code></pre><p>对于服从方差为 σ2σ2 均值为 μμ 的一元正态分布可以如下生成：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">44</span>]: sigma, mu = <span class="hljs-number">2.5</span>, <span class="hljs-number">3</span>In [<span class="hljs-number">45</span>]: mu + np.random.randn(<span class="hljs-number">3</span>) * sigmaOut[<span class="hljs-number">45</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">5.89540275</span>, <span class="hljs-number">2.56563403</span>, <span class="hljs-number">1.56208693</span>])</code></pre><p><code>randint</code> 可以指定生成随机整数的最小值最大值（不包含）和维度大小：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">46</span>]: low, high, size = <span class="hljs-number">5</span>, <span class="hljs-number">15</span>, (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>) # 生成<span class="hljs-number">5</span>到<span class="hljs-number">14</span>的随机整数In [<span class="hljs-number">47</span>]: np.random.randint(low, high, size)Out[<span class="hljs-number">47</span>]: <span class="hljs-built_in">array</span>([[ <span class="hljs-number">7</span>,  <span class="hljs-number">9</span>],       [<span class="hljs-number">13</span>,  <span class="hljs-number">7</span>]])</code></pre><p><code>choice</code> 可以从给定的列表中，以一定概率和方式抽取结果，当不指定概率时为均匀采样，默认抽取方式为有放回抽样：</p><pre><code class="hljs prolog"><span class="hljs-symbol">In</span> [<span class="hljs-number">48</span>]: my_list = [<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>]<span class="hljs-symbol">In</span> [<span class="hljs-number">49</span>]: np.random.choice(my_list, <span class="hljs-number">2</span>, replace=<span class="hljs-symbol">False</span>, p=[<span class="hljs-number">0.1</span>, <span class="hljs-number">0.7</span>, <span class="hljs-number">0.1</span> ,<span class="hljs-number">0.1</span>])<span class="hljs-symbol">Out</span>[<span class="hljs-number">49</span>]: array([<span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>], dtype=<span class="hljs-string">'&lt;U1'</span>)<span class="hljs-symbol">In</span> [<span class="hljs-number">50</span>]: np.random.choice(my_list, (<span class="hljs-number">3</span>,<span class="hljs-number">3</span>))<span class="hljs-symbol">Out</span>[<span class="hljs-number">50</span>]: array([[<span class="hljs-string">'a'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'d'</span>],       [<span class="hljs-string">'d'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>],       [<span class="hljs-string">'d'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>]], dtype=<span class="hljs-string">'&lt;U1'</span>)</code></pre><p>当返回的元素个数与原列表相同时，等价于使用 <code>permutation</code> 函数，即打散原列表：</p><pre><code class="hljs less"><span class="hljs-selector-tag">In</span> <span class="hljs-selector-attr">[51]</span>: <span class="hljs-selector-tag">np</span><span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.permutation</span>(my_list)<span class="hljs-selector-tag">Out</span><span class="hljs-selector-attr">[51]</span>: <span class="hljs-selector-tag">array</span>([<span class="hljs-string">'d'</span>, <span class="hljs-string">'c'</span>, <span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>], dtype=<span class="hljs-string">'&lt;U1'</span>)</code></pre><p>最后，需要提到的是随机种子，它能够固定随机数的输出结果：</p><pre><code class="hljs css"><span class="hljs-selector-tag">In</span> <span class="hljs-selector-attr">[52]</span>: <span class="hljs-selector-tag">np</span><span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.seed</span>(0)<span class="hljs-selector-tag">In</span> <span class="hljs-selector-attr">[53]</span>: <span class="hljs-selector-tag">np</span><span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.rand</span>()<span class="hljs-selector-tag">Out</span><span class="hljs-selector-attr">[53]</span>: 0<span class="hljs-selector-class">.5488135039273248</span><span class="hljs-selector-tag">In</span> <span class="hljs-selector-attr">[54]</span>: <span class="hljs-selector-tag">np</span><span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.seed</span>(0)<span class="hljs-selector-tag">In</span> <span class="hljs-selector-attr">[55]</span>: <span class="hljs-selector-tag">np</span><span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.rand</span>()<span class="hljs-selector-tag">Out</span><span class="hljs-selector-attr">[55]</span>: 0<span class="hljs-selector-class">.5488135039273248</span></code></pre><h3 id="2-np数组的变形与合并"><a href="#2-np数组的变形与合并" class="headerlink" title="2. np数组的变形与合并"></a>2. np数组的变形与合并</h3><p>【a】转置： <code>T</code></p><pre><code class="hljs angelscript">In [<span class="hljs-number">56</span>]: np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)).TOut[<span class="hljs-number">56</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])</code></pre><p>【b】合并操作： <code>r_, c_</code></p><p>对于二维数组而言， <code>r_</code> 和 <code>c_</code> 分别表示上下合并和左右合并：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">57</span>]: np.r_[np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)),np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))]Out[<span class="hljs-number">57</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])In [<span class="hljs-number">58</span>]: np.c_[np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)),np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))]Out[<span class="hljs-number">58</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])</code></pre><p>一维数组和二维数组进行合并时，应当把其视作列向量，在长度匹配的情况下只能够使用左右合并的 <code>c_</code> 操作：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">59</span>]: <span class="hljs-keyword">try</span>:   ....:     np.r_[np.<span class="hljs-built_in">array</span>([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]),np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))]   ....: except Exception as e:   ....:     Err_Msg = e   ....: In [<span class="hljs-number">60</span>]: Err_MsgOut[<span class="hljs-number">60</span>]: ValueError(<span class="hljs-string">'all the input arrays must have same number of dimensions, but the array at index 0 has 1 dimension(s) and the array at index 1 has 2 dimension(s)'</span>)In [<span class="hljs-number">61</span>]: np.r_[np.<span class="hljs-built_in">array</span>([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]),np.zeros(<span class="hljs-number">2</span>)]Out[<span class="hljs-number">61</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>])In [<span class="hljs-number">62</span>]: np.c_[np.<span class="hljs-built_in">array</span>([<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]),np.zeros((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))]Out[<span class="hljs-number">62</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>],       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>]])</code></pre><p>【c】维度变换： <code>reshape</code></p><p><code>reshape</code> 能够帮助用户把原数组按照新的维度重新排列。在使用时有两种模式，分别为 <code>C</code> 模式和 <code>F</code> 模式，分别以逐行和逐列的顺序进行填充读取。</p><pre><code class="hljs angelscript">In [<span class="hljs-number">63</span>]: target = np.arange(<span class="hljs-number">8</span>).reshape(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)In [<span class="hljs-number">64</span>]: targetOut[<span class="hljs-number">64</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],       [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]])In [<span class="hljs-number">65</span>]: target.reshape((<span class="hljs-number">4</span>,<span class="hljs-number">2</span>), order=<span class="hljs-string">'C'</span>) # 按照行读取和填充Out[<span class="hljs-number">65</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],       [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>],       [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>],       [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>]])In [<span class="hljs-number">66</span>]: target.reshape((<span class="hljs-number">4</span>,<span class="hljs-number">2</span>), order=<span class="hljs-string">'F'</span>) # 按照列读取和填充Out[<span class="hljs-number">66</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>],       [<span class="hljs-number">4</span>, <span class="hljs-number">6</span>],       [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>],       [<span class="hljs-number">5</span>, <span class="hljs-number">7</span>]])</code></pre><p>特别地，由于被调用数组的大小是确定的， reshape 允许有一个维度存在空缺，此时只需填充-1即可：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">67</span>]: target.reshape((<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>))Out[<span class="hljs-number">67</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],       [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>],       [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>],       [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>]])</code></pre><p>下面将 <code>n*1</code> 大小的数组转为1维数组的操作是经常使用的：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">68</span>]: target = np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">1</span>))In [<span class="hljs-number">69</span>]: targetOut[<span class="hljs-number">69</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">1.</span>],       [<span class="hljs-number">1.</span>],       [<span class="hljs-number">1.</span>]])In [<span class="hljs-number">70</span>]: target.reshape(<span class="hljs-number">-1</span>)Out[<span class="hljs-number">70</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>])</code></pre><h3 id="3-np数组的切片与索引"><a href="#3-np数组的切片与索引" class="headerlink" title="3. np数组的切片与索引"></a>3. np数组的切片与索引</h3><p>数组的切片模式支持使用 <code>slice</code> 类型的 <code>start:end:step</code> 切片，还可以直接传入列表指定某个维度的索引进行切片：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">71</span>]: target = np.arange(<span class="hljs-number">9</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>)In [<span class="hljs-number">72</span>]: targetOut[<span class="hljs-number">72</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],       [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>],       [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>]])In [<span class="hljs-number">73</span>]: target[:<span class="hljs-number">-1</span>, [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]]Out[<span class="hljs-number">73</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>],       [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>]])</code></pre><p>此外，还可以利用 <code>np.ix_</code> 在对应的维度上使用布尔索引，但此时不能使用 <code>slice</code> 切片：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">74</span>]: target[np.ix_([True, False, True], [True, False, True])]Out[<span class="hljs-number">74</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>],       [<span class="hljs-number">6</span>, <span class="hljs-number">8</span>]])In [<span class="hljs-number">75</span>]: target[np.ix_([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>], [True, False, True])]Out[<span class="hljs-number">75</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">3</span>, <span class="hljs-number">5</span>],       [<span class="hljs-number">6</span>, <span class="hljs-number">8</span>]])</code></pre><p>当数组维度为1维时，可以直接进行布尔索引，而无需 <code>np.ix_</code> ：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">76</span>]: new = target.reshape(<span class="hljs-number">-1</span>)In [<span class="hljs-number">77</span>]: new[new%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>]Out[<span class="hljs-number">77</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>])</code></pre><h3 id="4-常用函数"><a href="#4-常用函数" class="headerlink" title="4. 常用函数"></a>4. 常用函数</h3><p>为了简单起见，这里假设下述函数输入的数组都是一维的。</p><p>【a】 <code>where</code></p><p><code>where</code> 是一种条件函数，可以指定满足条件与不满足条件位置对应的填充值：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">78</span>]: a = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>])In [<span class="hljs-number">79</span>]: np.where(a&gt;<span class="hljs-number">0</span>, a, <span class="hljs-number">5</span>) # 对应位置为True时填充a对应元素，否则填充<span class="hljs-number">5</span>Out[<span class="hljs-number">79</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>])</code></pre><p>【b】 <code>nonzero, argmax, argmin</code></p><p>这三个函数返回的都是索引， <code>nonzero</code> 返回非零数的索引， <code>argmax, argmin</code> 分别返回最大和最小数的索引：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">80</span>]: a = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">-2</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>])In [<span class="hljs-number">81</span>]: np.nonzero(a)Out[<span class="hljs-number">81</span>]: (<span class="hljs-built_in">array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>], dtype=<span class="hljs-built_in">int</span>64),)In [<span class="hljs-number">82</span>]: a.argmax()Out[<span class="hljs-number">82</span>]: <span class="hljs-number">4</span>In [<span class="hljs-number">83</span>]: a.argmin()Out[<span class="hljs-number">83</span>]: <span class="hljs-number">1</span></code></pre><p>【c】 <code>any, all</code></p><pre><code class="hljs pgsql"><span class="hljs-keyword">any</span>` 指当序列至少 存在一个 `<span class="hljs-keyword">True</span>` 或非零元素时返回 `<span class="hljs-keyword">True</span>` ，否则返回 `<span class="hljs-keyword">False</span><span class="hljs-keyword">all</span>` 指当序列元素 全为 `<span class="hljs-keyword">True</span>` 或非零元素时返回 `<span class="hljs-keyword">True</span>` ，否则返回 `<span class="hljs-keyword">False</span><span class="hljs-keyword">In</span> [<span class="hljs-number">84</span>]: a = np.<span class="hljs-keyword">array</span>([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>])<span class="hljs-keyword">In</span> [<span class="hljs-number">85</span>]: a.<span class="hljs-keyword">any</span>()<span class="hljs-keyword">Out</span>[<span class="hljs-number">85</span>]: <span class="hljs-keyword">True</span><span class="hljs-keyword">In</span> [<span class="hljs-number">86</span>]: a.<span class="hljs-keyword">all</span>()<span class="hljs-keyword">Out</span>[<span class="hljs-number">86</span>]: <span class="hljs-keyword">False</span></code></pre><p>【d】 <code>cumprod, cumsum, diff</code></p><p><code>cumprod, cumsum</code> 分别表示累乘和累加函数，返回同长度的数组， <code>diff</code> 表示和前一个元素做差，由于第一个元素为缺失值，因此在默认参数情况下，返回长度是原数组减1</p><pre><code class="hljs angelscript">In [<span class="hljs-number">87</span>]: a = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])In [<span class="hljs-number">88</span>]: a.cumprod()Out[<span class="hljs-number">88</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">6</span>], dtype=<span class="hljs-built_in">int</span>32)In [<span class="hljs-number">89</span>]: a.cumsum()Out[<span class="hljs-number">89</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>], dtype=<span class="hljs-built_in">int</span>32)In [<span class="hljs-number">90</span>]: np.diff(a)Out[<span class="hljs-number">90</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">1</span>])</code></pre><p>【e】 统计函数</p><p>常用的统计函数包括 <code>max, min, mean, median, std, var, sum, quantile</code> ，其中分位数计算是全局方法，因此不能通过 <code>array.quantile</code> 的方法调用：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">91</span>]: target = np.arange(<span class="hljs-number">5</span>)In [<span class="hljs-number">92</span>]: targetOut[<span class="hljs-number">92</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])In [<span class="hljs-number">93</span>]: target.max()Out[<span class="hljs-number">93</span>]: <span class="hljs-number">4</span>In [<span class="hljs-number">94</span>]: np.quantile(target, <span class="hljs-number">0.5</span>) # <span class="hljs-number">0.5</span>分位数Out[<span class="hljs-number">94</span>]: <span class="hljs-number">2.0</span></code></pre><p>但是对于含有缺失值的数组，它们返回的结果也是缺失值，如果需要略过缺失值，必须使用 <code>nan*</code> 类型的函数，上述的几个统计函数都有对应的 <code>nan*</code> 函数。</p><pre><code class="hljs angelscript">In [<span class="hljs-number">95</span>]: target = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, np.nan])In [<span class="hljs-number">96</span>]: targetOut[<span class="hljs-number">96</span>]: <span class="hljs-built_in">array</span>([ <span class="hljs-number">1.</span>,  <span class="hljs-number">2.</span>, nan])In [<span class="hljs-number">97</span>]: target.max()Out[<span class="hljs-number">97</span>]: nanIn [<span class="hljs-number">98</span>]: np.nanmax(target)Out[<span class="hljs-number">98</span>]: <span class="hljs-number">2.0</span>In [<span class="hljs-number">99</span>]: np.nanquantile(target, <span class="hljs-number">0.5</span>)Out[<span class="hljs-number">99</span>]: <span class="hljs-number">1.5</span></code></pre><p>对于协方差和相关系数分别可以利用 <code>cov, corrcoef</code> 如下计算：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">100</span>]: target1 = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>])In [<span class="hljs-number">101</span>]: target2 = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">-9</span>])In [<span class="hljs-number">102</span>]: np.cov(target1, target2)Out[<span class="hljs-number">102</span>]: <span class="hljs-built_in">array</span>([[ <span class="hljs-number">11.66666667</span>, <span class="hljs-number">-16.66666667</span>],       [<span class="hljs-number">-16.66666667</span>,  <span class="hljs-number">38.66666667</span>]])In [<span class="hljs-number">103</span>]: np.corrcoef(target1, target2)Out[<span class="hljs-number">103</span>]: <span class="hljs-built_in">array</span>([[ <span class="hljs-number">1.</span>        , <span class="hljs-number">-0.78470603</span>],       [<span class="hljs-number">-0.78470603</span>,  <span class="hljs-number">1.</span>        ]])</code></pre><p>最后，需要说明二维 <code>Numpy</code> 数组中统计函数的 <code>axis</code> 参数，它能够进行某一个维度下的统计特征计算，当 <code>axis=0</code> 时结果为列的统计指标，当 <code>axis=1</code> 时结果为行的统计指标：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">104</span>]: target = np.arange(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>).reshape(<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>)In [<span class="hljs-number">105</span>]: targetOut[<span class="hljs-number">105</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>],       [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>],       [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>]])In [<span class="hljs-number">106</span>]: target.sum(<span class="hljs-number">0</span>)Out[<span class="hljs-number">106</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">18</span>])In [<span class="hljs-number">107</span>]: target.sum(<span class="hljs-number">1</span>)Out[<span class="hljs-number">107</span>]: <span class="hljs-built_in">array</span>([ <span class="hljs-number">6</span>, <span class="hljs-number">15</span>, <span class="hljs-number">24</span>])</code></pre><h3 id="5-广播机制"><a href="#5-广播机制" class="headerlink" title="5. 广播机制"></a>5. 广播机制</h3><p>广播机制用于处理两个不同维度数组之间的操作，这里只讨论不超过两维的数组广播机制。</p><p>【a】标量和数组的操作</p><p>当一个标量和数组进行运算时，标量会自动把大小扩充为数组大小，之后进行逐元素操作：</p><pre><code class="hljs angelscript">In [<span class="hljs-number">108</span>]: res = <span class="hljs-number">3</span> * np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)) + <span class="hljs-number">1</span>In [<span class="hljs-number">109</span>]: resOut[<span class="hljs-number">109</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>],       [<span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>]])In [<span class="hljs-number">110</span>]: res = <span class="hljs-number">1</span> / resIn [<span class="hljs-number">111</span>]: resOut[<span class="hljs-number">111</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0.25</span>, <span class="hljs-number">0.25</span>],       [<span class="hljs-number">0.25</span>, <span class="hljs-number">0.25</span>]])</code></pre><p>【b】二维数组之间的操作</p><p>当两个数组维度完全一致时，使用对应元素的操作，否则会报错，除非其中的某个数组的维度是 m×1m×1 或者 1×n1×n ，那么会扩充其具有 11 的维度为另一个数组对应维度的大小。例如， 1×21×2 数组和 3×23×2 数组做逐元素运算时会把第一个数组扩充为 3×23×2 ，扩充时的对应数值进行赋值。但是，需要注意的是，如果第一个数组的维度是 1×31×3 ，那么由于在第二维上的大小不匹配且不为 11 ，此时报错。</p><pre><code class="hljs angelscript">In [<span class="hljs-number">112</span>]: res = np.ones((<span class="hljs-number">3</span>,<span class="hljs-number">2</span>))In [<span class="hljs-number">113</span>]: resOut[<span class="hljs-number">113</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],       [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>],       [<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>]])In [<span class="hljs-number">114</span>]: res * np.<span class="hljs-built_in">array</span>([[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]]) # 扩充第一维度为<span class="hljs-number">3</span>Out[<span class="hljs-number">114</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>],       [<span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>],       [<span class="hljs-number">2.</span>, <span class="hljs-number">3.</span>]])In [<span class="hljs-number">115</span>]: res * np.<span class="hljs-built_in">array</span>([[<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>]]) # 扩充第二维度为<span class="hljs-number">2</span>Out[<span class="hljs-number">115</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],       [<span class="hljs-number">3.</span>, <span class="hljs-number">3.</span>],       [<span class="hljs-number">4.</span>, <span class="hljs-number">4.</span>]])In [<span class="hljs-number">116</span>]: res * np.<span class="hljs-built_in">array</span>([[<span class="hljs-number">2</span>]]) # 等价于两次扩充Out[<span class="hljs-number">116</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],       [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],       [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>]])</code></pre><p>【c】一维数组与二维数组的操作</p><p>当一维数组 AkAk 与二维数组 Bm,nBm,n 操作时，等价于把一维数组视作 A1,kA1,k 的二维数组，使用的广播法则与【b】中一致，当 k!=nk!=n 且 k,nk,n 都不是 11 时报错。</p><pre><code class="hljs angelscript">In [<span class="hljs-number">117</span>]: np.ones(<span class="hljs-number">3</span>) + np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))Out[<span class="hljs-number">117</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],       [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>]])In [<span class="hljs-number">118</span>]: np.ones(<span class="hljs-number">3</span>) + np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))Out[<span class="hljs-number">118</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],       [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>]])In [<span class="hljs-number">119</span>]: np.ones(<span class="hljs-number">1</span>) + np.ones((<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))Out[<span class="hljs-number">119</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>],       [<span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>, <span class="hljs-number">2.</span>]])</code></pre><h3 id="6-向量与矩阵的计算"><a href="#6-向量与矩阵的计算" class="headerlink" title="6. 向量与矩阵的计算"></a>6. 向量与矩阵的计算</h3><p>【a】向量内积： <code>dot</code></p><p>a⋅b=∑iaibia⋅b=∑iaibi</p><pre><code class="hljs angelscript">In [<span class="hljs-number">120</span>]: a = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])In [<span class="hljs-number">121</span>]: b = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>])In [<span class="hljs-number">122</span>]: a.dot(b)Out[<span class="hljs-number">122</span>]: <span class="hljs-number">22</span></code></pre><p>【b】向量范数和矩阵范数： <code>np.linalg.norm</code></p><p>在矩阵范数的计算中，最重要的是 <code>ord</code> 参数，可选值如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">ord</th><th style="text-align:left">norm for matrices</th><th style="text-align:left">norm for vectors</th></tr></thead><tbody><tr><td style="text-align:left">None</td><td style="text-align:left">Frobenius norm</td><td style="text-align:left">2-norm</td></tr><tr><td style="text-align:left">‘fro’</td><td style="text-align:left">Frobenius norm</td><td style="text-align:left">–</td></tr><tr><td style="text-align:left">‘nuc’</td><td style="text-align:left">nuclear norm</td><td style="text-align:left">–</td></tr><tr><td style="text-align:left">inf</td><td style="text-align:left">max(sum(abs(x), axis=1))</td><td style="text-align:left">max(abs(x))</td></tr><tr><td style="text-align:left">-inf</td><td style="text-align:left">min(sum(abs(x), axis=1))</td><td style="text-align:left">min(abs(x))</td></tr><tr><td style="text-align:left">0</td><td style="text-align:left">–</td><td style="text-align:left">sum(x != 0)</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">max(sum(abs(x), axis=0))</td><td style="text-align:left">as below</td></tr><tr><td style="text-align:left">-1</td><td style="text-align:left">min(sum(abs(x), axis=0))</td><td style="text-align:left">as below</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">2-norm (largest sing. value)</td><td style="text-align:left">as below</td></tr><tr><td style="text-align:left">-2</td><td style="text-align:left">smallest singular value</td><td style="text-align:left">as below</td></tr><tr><td style="text-align:left">other</td><td style="text-align:left">–</td><td style="text-align:left">sum(abs(x)<strong>ord)</strong>(1./ord)</td></tr></tbody></table></div><pre><code class="hljs angelscript">In [<span class="hljs-number">123</span>]: martix_target =  np.arange(<span class="hljs-number">4</span>).reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>)In [<span class="hljs-number">124</span>]: martix_targetOut[<span class="hljs-number">124</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],       [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])In [<span class="hljs-number">125</span>]: np.linalg.norm(martix_target, <span class="hljs-string">'fro'</span>)Out[<span class="hljs-number">125</span>]: <span class="hljs-number">3.7416573867739413</span>In [<span class="hljs-number">126</span>]: np.linalg.norm(martix_target, np.inf)Out[<span class="hljs-number">126</span>]: <span class="hljs-number">5.0</span>In [<span class="hljs-number">127</span>]: np.linalg.norm(martix_target, <span class="hljs-number">2</span>)Out[<span class="hljs-number">127</span>]: <span class="hljs-number">3.702459173643833</span>In [<span class="hljs-number">128</span>]: vector_target =  np.arange(<span class="hljs-number">4</span>)In [<span class="hljs-number">129</span>]: vector_targetOut[<span class="hljs-number">129</span>]: <span class="hljs-built_in">array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])In [<span class="hljs-number">130</span>]: np.linalg.norm(vector_target, np.inf)Out[<span class="hljs-number">130</span>]: <span class="hljs-number">3.0</span>In [<span class="hljs-number">131</span>]: np.linalg.norm(vector_target, <span class="hljs-number">2</span>)Out[<span class="hljs-number">131</span>]: <span class="hljs-number">3.7416573867739413</span>In [<span class="hljs-number">132</span>]: np.linalg.norm(vector_target, <span class="hljs-number">3</span>)Out[<span class="hljs-number">132</span>]: <span class="hljs-number">3.3019272488946263</span></code></pre><p>【c】矩阵乘法： <code>@</code></p><p>[Am×pBp×n]ij=∑k=1pAikBkj[Am×pBp×n]ij=∑k=1pAikBkj</p><pre><code class="hljs angelscript">In [<span class="hljs-number">133</span>]: a = np.arange(<span class="hljs-number">4</span>).reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>)In [<span class="hljs-number">134</span>]: aOut[<span class="hljs-number">134</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>],       [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]])In [<span class="hljs-number">135</span>]: b = np.arange(<span class="hljs-number">-4</span>,<span class="hljs-number">0</span>).reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>)In [<span class="hljs-number">136</span>]: bOut[<span class="hljs-number">136</span>]: <span class="hljs-built_in">array</span>([[<span class="hljs-number">-4</span>, <span class="hljs-number">-3</span>],       [<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>]])In [<span class="hljs-number">137</span>]: <span class="hljs-symbol">a@</span>bOut[<span class="hljs-number">137</span>]: <span class="hljs-built_in">array</span>([[ <span class="hljs-number">-2</span>,  <span class="hljs-number">-1</span>],       [<span class="hljs-number">-14</span>,  <span class="hljs-number">-9</span>]])</code></pre><h2 id="三、练习"><a href="#三、练习" class="headerlink" title="三、练习"></a>三、练习</h2><h3 id="Ex1：利用列表推导式写矩阵乘法"><a href="#Ex1：利用列表推导式写矩阵乘法" class="headerlink" title="Ex1：利用列表推导式写矩阵乘法"></a>Ex1：利用列表推导式写矩阵乘法</h3><p>一般的矩阵乘法根据公式，可以由三重循环写出：</p><pre><code class="hljs markdown">In [138]: M1 = np.random.rand(2,3)In [139]: M2 = np.random.rand(3,4)In [140]: res = np.empty((M1.shape[0],M2.shape[1]))In [141]: for i in range(M1.shape[0]):   .....:     for j in range(M2.shape[1]):   .....:         item = 0   .....:         for k in range(M1.shape[1]):   .....:             item += M1[<span class="hljs-string">i</span>][<span class="hljs-symbol">k</span>] * M2[<span class="hljs-string">k</span>][<span class="hljs-symbol">j</span>]   .....:         res[<span class="hljs-string">i</span>][<span class="hljs-symbol">j</span>] = item   .....: In [142]: ((M1@M2 - res) <span class="xml"><span class="hljs-tag">&lt; <span class="hljs-attr">1e-15</span>)<span class="hljs-attr">.all</span>() # 排除数值误差</span></span><span class="xml">Out[142]: True</span></code></pre><p>请将其改写为列表推导式的形式。</p><h3 id="Ex2：更新矩阵"><a href="#Ex2：更新矩阵" class="headerlink" title="Ex2：更新矩阵"></a>Ex2：更新矩阵</h3><p>设矩阵 Am×nAm×n ，现在对 AA 中的每一个元素进行更新生成矩阵 BB ，更新方法是 Bij=Aij∑k=1n1AikBij=Aij∑k=1n1Aik ，例如下面的矩阵为 AA ，则 B2,2=5×(14+15+16)=3712B2,2=5×(14+15+16)=3712 ，请利用 <code>Numpy</code> 高效实现。</p><p>A=⎡⎣⎢147258369⎤⎦⎥A=[123456789]</p><h3 id="Ex3：卡方统计量"><a href="#Ex3：卡方统计量" class="headerlink" title="Ex3：卡方统计量"></a>Ex3：卡方统计量</h3><p>设矩阵 Am×nAm×n ，记 Bij=(∑mi=1Aij)×(∑nj=1Aij)∑mi=1∑nj=1AijBij=(∑i=1mAij)×(∑j=1nAij)∑i=1m∑j=1nAij ，定义卡方值如下：</p><p>χ2=∑i=1m∑j=1n(Aij−Bij)2Bijχ2=∑i=1m∑j=1n(Aij−Bij)2Bij</p><p>请利用 <code>Numpy</code> 对给定的矩阵 AA 计算 χ2χ2 。</p><pre><code class="hljs angelscript">In [<span class="hljs-number">143</span>]: np.random.seed(<span class="hljs-number">0</span>)In [<span class="hljs-number">144</span>]: A = np.random.randint(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, (<span class="hljs-number">8</span>, <span class="hljs-number">5</span>))</code></pre><h3 id="Ex4：改进矩阵计算的性能"><a href="#Ex4：改进矩阵计算的性能" class="headerlink" title="Ex4：改进矩阵计算的性能"></a>Ex4：改进矩阵计算的性能</h3><p>设 ZZ 为 m×nm×n 的矩阵， BB 和 UU 分别是 m×pm×p 和 p×np×n 的矩阵， BiBi 为 BB 的第 ii 行， UjUj 为 UU 的第 jj 列，下面定义 R=∑i=1m∑j=1n∥Bi−Uj∥22ZijR=∑i=1m∑j=1n‖Bi−Uj‖22Zij ，其中 ∥a∥22‖a‖22 表示向量 aa 的分量平方和 ∑ia2i∑iai2 。</p><p>现有某人根据如下给定的样例数据计算 RR 的值，请充分利用 <code>Numpy</code> 中的函数，基于此问题改进这段代码的性能。</p><pre><code class="hljs angelscript">In [<span class="hljs-number">145</span>]: np.random.seed(<span class="hljs-number">0</span>)In [<span class="hljs-number">146</span>]: m, n, p = <span class="hljs-number">100</span>, <span class="hljs-number">80</span>, <span class="hljs-number">50</span>In [<span class="hljs-number">147</span>]: B = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, (m, p))In [<span class="hljs-number">148</span>]: U = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, (p, n))In [<span class="hljs-number">149</span>]: Z = np.random.randint(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, (m, n))In [<span class="hljs-number">150</span>]: def solution(B=B, U=U, Z=Z):   .....:     L_res = []   .....:     <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(m):   .....:         <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n):   .....:             norm_value = ((B[i]-U[:,j])**<span class="hljs-number">2</span>).sum()   .....:             L_res.append(norm_value*Z[i][j])   .....:     <span class="hljs-keyword">return</span> sum(L_res)   .....: In [<span class="hljs-number">151</span>]: solution(B, U, Z)Out[<span class="hljs-number">151</span>]: <span class="hljs-number">100566</span></code></pre><h3 id="Ex5：连续整数的最大长度"><a href="#Ex5：连续整数的最大长度" class="headerlink" title="Ex5：连续整数的最大长度"></a>Ex5：连续整数的最大长度</h3><p>输入一个整数的 <code>Numpy</code> 数组，返回其中递增连续整数子数组的最大长度。例如，输入 [1,2,5,6,7]，[5,6,7]为具有最大长度的递增连续整数子数组，因此输出3；输入[3,2,1,2,3,4,6]，[1,2,3,4]为具有最大长度的递增连续整数子数组，因此输出4。请充分利用 <code>Numpy</code> 的内置函数完成。（提示：考虑使用 <code>nonzero, diff</code> 函数）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一章-预备知识&quot;&gt;&lt;a href=&quot;#第一章-预备知识&quot; class=&quot;headerlink&quot; title=&quot;第一章 预备知识&quot;&gt;&lt;/a&gt;第一章 预备知识&lt;/h1&gt;&lt;h2 id=&quot;一、Python基础&quot;&gt;&lt;a href=&quot;#一、Python基础&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="pandas" scheme="https://sulimin-nb.github.io/categories/pandas/"/>
    
    
      <category term="pandas" scheme="https://sulimin-nb.github.io/tags/pandas/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer17-分治算法-打印从1到最大的n位数</title>
    <link href="https://sulimin-nb.github.io/article/5da0ddee.html"/>
    <id>https://sulimin-nb.github.io/article/5da0ddee.html</id>
    <published>2020-12-04T02:43:49.000Z</published>
    <updated>2020-12-04T02:43:49.145Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer16-分治算法-数值的整数次方</title>
    <link href="https://sulimin-nb.github.io/article/656c137f.html"/>
    <id>https://sulimin-nb.github.io/article/656c137f.html</id>
    <published>2020-11-22T06:33:35.000Z</published>
    <updated>2020-11-23T08:38:04.098Z</updated>
    
    <content type="html"><![CDATA[<p>实现函数double Power(double base, in exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。</p><p>示例1：</p><pre><code class="hljs angelscript">输入：<span class="hljs-number">2.00000</span>， <span class="hljs-number">10</span>输出：<span class="hljs-number">1024.00000</span></code></pre><p>示例2：</p><pre><code class="hljs angelscript">输入：<span class="hljs-number">2.10000</span>，<span class="hljs-number">3</span>输出：<span class="hljs-number">9.26100</span></code></pre><p>示例3：</p><pre><code class="hljs angelscript">输入：<span class="hljs-number">2.00000</span>，<span class="hljs-number">-2</span>输出：<span class="hljs-number">0.25000</span>解释：<span class="hljs-number">2</span>^<span class="hljs-number">-2</span> = (<span class="hljs-number">1</span>/<span class="hljs-number">2</span>)^<span class="hljs-number">2</span> = (<span class="hljs-number">1</span>/<span class="hljs-number">4</span>) = <span class="hljs-number">0.25</span></code></pre><p>说明：</p><ul><li>-100.0 &lt; x &lt; 100.0</li><li>n是32位有符号整数，其数值范围是$[-2^{31},2^{31}-1]$。</li></ul><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution:</span><span class="hljs-symbol">def</span> <span class="hljs-symbol">myPow</span>(<span class="hljs-symbol">self, <span class="hljs-symbol">x</span>, <span class="hljs-symbol">n</span></span>):</code></pre><p>解题思路：</p><p>求$x^n$最简单的方法是通过循环将$n$个$x$乘起来，依次求$x^1,x^2,\cdots,x^{n-1},x^n$，时间复杂度为$O(n)$。</p><p>快速幂法 可将时间复杂度降低至$O(logn)$，以下从分治法和二进制两个角度解析快速幂法。</p><p>快速幂解析(分治法角度)：</p><blockquote><p>快速幂实际上是分治思想的一种应用。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现函数double Power(double base, in exponent)，求base的exponent次方。不得使用库函数，同时不需要考虑大数问题。&lt;/p&gt;
&lt;p&gt;示例1：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs angelscript&quot;&gt;输入：&lt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer07-分治算法-重建二叉树</title>
    <link href="https://sulimin-nb.github.io/article/d8259341.html"/>
    <id>https://sulimin-nb.github.io/article/d8259341.html</id>
    <published>2020-11-18T08:19:07.000Z</published>
    <updated>2020-11-23T08:38:07.111Z</updated>
    
    <content type="html"><![CDATA[<p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p><p>例如，给出</p><pre><code class="hljs angelscript">前序遍历 preorder = [<span class="hljs-number">3</span>,<span class="hljs-number">9</span>,<span class="hljs-number">20</span>,<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]中序遍历 inorder = [<span class="hljs-number">9</span>,<span class="hljs-number">3</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">7</span>]</code></pre><p>返回如下的二叉树：</p><pre><code class="hljs angelscript"><span class="hljs-number">3</span></code></pre><p>限制：</p><p>0 &lt;= 节点个数 &lt;= 5000</p><p>注意：本题与主站105题重复</p><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-comment"># class TreeNode:</span><span class="hljs-comment"># def __init__(self, x):</span><span class="hljs-comment"># self.val = x</span><span class="hljs-comment"># self.left = None</span><span class="hljs-comment"># self.right = None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(self, preorder, inorder)</span>:</span></code></pre><p>解题思路：</p><p>前序遍历性质：节点按照[根节点|左子树|右子树]排序。</p><p>中序遍历性质：节点按照[左子树|根节点|右子树]排序。</p><p>以题目示例为例：</p><ul><li>前序遍历划分[3|9|20 15 7]</li><li>中序遍历划分[9|3|15 20 7]</li></ul><p>根据以上性质，可得出以下推论：</p><ol><li>前序遍历的首元素为树的根节点node的值。</li><li>在中序遍历中搜索根节点node的索引，可将中序遍历划分为[左子树|根节点|右子树]。</li><li>根据中序遍历中的左(右)子树的节点数量，可将前序遍历划分为[根节点|左子树|右子树]。</li></ol><p>以上子树的递推性质是分治算法的体现，考虑通过递归对所有子树进行划分。</p><p>分治算法解析：</p><ul><li><p>递推参数：根节点在前序遍历的索引root、子树在中序遍历的左边界left、子树在中序遍历的右边界right;</p></li><li><p>终止条件：当left&gt;right，代表已经越过叶节点，此时返回null;</p></li><li><p>递推公式：</p><ol><li>建立根节点node：节点值为preorder[root];</li><li>划分左右子树：查找根节点在中序遍历inorder中的索引i;</li></ol><blockquote><p>为了提升效率，本文使用哈希表dic存储中序遍历的值与索引的映射，查找操作的时间复杂度为$O(1)$。</p></blockquote><ol><li>构建左右子树：开启左右子树递归：<ul><li>返回值：回溯返回node，作为上一层递归中根节点的左/右节点；</li></ul></li></ol></li></ul><p>复杂度分析：</p><ul><li>时间复杂度$O(N)$：其中$N$为树的节点数量。初始化HashMap需遍历inorder，占用$O(N)$。递归共建立N个节点，每层递归中的节点建立，搜索操作占用$O(1)$，因此使用$O(N)$时间。</li><li>空间复杂度$O(N)$：HashMap使用$O(N)$额外空间。最差情况下，树退化为链表，递归深度达到N，占用$O(N)$额外空间；最好情况下，树为满二叉树，递归深度为$logN$，占用$O(logN)$额外空间。</li></ul><p>代码：</p><p>注意：本文方法只适用于”无重复节点值”的二叉树。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">buildTree</span><span class="hljs-params">(self, preorder, inorder)</span>:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recur</span><span class="hljs-params">(root, left, right)</span>:</span>            <span class="hljs-keyword">if</span> left &gt; right: <span class="hljs-keyword">return</span>  <span class="hljs-comment"># 递归终止</span>            node = TreeNode(preorder[root]) <span class="hljs-comment"># 建立根节点</span>            i = dic[preorder[root]] <span class="hljs-comment"># 划分根节点，左子树，右子树</span>            node.left = recur(root+<span class="hljs-number">1</span>, left, i<span class="hljs-number">-1</span>) <span class="hljs-comment"># 开启左子树递归</span>            node.right = recur(i-left+root+<span class="hljs-number">1</span>,i+<span class="hljs-number">1</span>,right) <span class="hljs-comment"># 开启右子树递归</span>            <span class="hljs-keyword">return</span> node <span class="hljs-comment"># 回溯返回根节点</span>        dic, preorder = &#123;&#125;, preorder        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(inorder)):            dic[inorder[i]] = i       <span class="hljs-keyword">return</span> recur(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,len(inorder)<span class="hljs-number">-1</span>)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。&lt;/p&gt;
&lt;p&gt;例如，给出&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs angelscript&quot;&gt;前序遍历 preorder = [&lt;span class
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer53-查找算法-II.0~n-1中缺失的数字</title>
    <link href="https://sulimin-nb.github.io/article/813ea1e5.html"/>
    <id>https://sulimin-nb.github.io/article/813ea1e5.html</id>
    <published>2020-11-18T08:05:05.000Z</published>
    <updated>2020-11-18T09:35:45.748Z</updated>
    
    <content type="html"><![CDATA[<p>一个长度为n-1的递增排序数组中所有数字都是唯一的，并且每个数字都在范围0~n-1之内。在范围0-n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p><p>示例1：</p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>]输出：<span class="hljs-number">2</span></code></pre><p>限制：</p><p>1 &lt;= 数组长度 &lt;= 10000</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">missingNumber</span><span class="hljs-params">(self, nums)</span>:</span></code></pre><p>解题思路：</p><p>排序数组中的搜索问题，首先想到二分法解决。根据题意，数组可以按照以下规则划分为两部分。</p><ul><li>左子数组：$nums[i] = i$；</li><li>右子数组：$nums[i] \neq i$;</li></ul><p>算法解析：</p><p>1.初始化：左边界$i=0$，有边界$j=len(nums)-1$；代表闭区间$[i,j]$。</p><p>2.循环二分：当$i&lt;j$时循环(即当闭区间$[i,j]$为空时跳出)；</p><ol><li><pre><code class="hljs kotlin"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:<span class="hljs-type"></span></span>def missingNumber(self, nums):i,j = <span class="hljs-number">0</span>, len(nums) - <span class="hljs-number">1</span><span class="hljs-keyword">while</span> i &lt;$=$ j:m = (i + j) <span class="hljs-comment">// 2</span><span class="hljs-keyword">if</span> nums[m] == m: i = m+<span class="hljs-number">1</span><span class="hljs-keyword">else</span>: j = m-<span class="hljs-number">1</span><span class="hljs-keyword">return</span> i</code></pre></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一个长度为n-1的递增排序数组中所有数字都是唯一的，并且每个数字都在范围0~n-1之内。在范围0-n-1内的n个数字中有且只有一个数字不在该数组中，请找出这个数字。&lt;/p&gt;
&lt;p&gt;示例1：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs angelscript&quot;&gt;输入
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer53-I在排序数组中查找数字I</title>
    <link href="https://sulimin-nb.github.io/article/e24f4d15.html"/>
    <id>https://sulimin-nb.github.io/article/e24f4d15.html</id>
    <published>2020-11-18T07:39:26.000Z</published>
    <updated>2020-11-18T09:35:31.130Z</updated>
    
    <content type="html"><![CDATA[<p>t统计一个数字在排序数组中出现的次数。</p><p>示例1：</p><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>,<span class="hljs-number">10</span>],target = <span class="hljs-number">8</span>输出：<span class="hljs-number">2</span></code></pre><p>限制：</p><p>0 &lt;= 数组长度 &lt;= 50000</p><p>解题思路：</p><p>排序数组中的搜索问题，首先想到二分法解决。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;t统计一个数字在排序数组中出现的次数。&lt;/p&gt;
&lt;p&gt;示例1：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs angelscript&quot;&gt;输入：nums = [&lt;span class=&quot;hljs-number&quot;&gt;5&lt;/span&gt;,&lt;span class=&quot;hljs-n
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer50-查找算法-第一个只出现一次的字符</title>
    <link href="https://sulimin-nb.github.io/article/55724620.html"/>
    <id>https://sulimin-nb.github.io/article/55724620.html</id>
    <published>2020-11-18T07:26:10.000Z</published>
    <updated>2020-11-18T07:38:54.203Z</updated>
    
    <content type="html"><![CDATA[<p>在字符串s中找出一个只出现一次的字符。如果没有，返回一个单空格。s只包含小写字母。</p><p>示例：</p><pre><code class="hljs abnf"><span class="hljs-attribute">s</span> = <span class="hljs-string">"abaccdeff"</span>返回<span class="hljs-string">"b"</span><span class="hljs-attribute">s</span> = <span class="hljs-string">""</span>返回 <span class="hljs-string">" "</span></code></pre><p>限制：</p><p>0 &lt;= s的长度 &lt;= 50000</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(self, s)</span>:</span></code></pre><p>方法一：哈希表</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(self, s)</span>:</span>dic = &#123;&#125;<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:dic[c] = <span class="hljs-keyword">not</span> c <span class="hljs-keyword">in</span> dic<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:<span class="hljs-keyword">if</span> dic[c]: <span class="hljs-keyword">return</span> c<span class="hljs-keyword">return</span> <span class="hljs-string">' '</span></code></pre><p>方法二：有序哈希表</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">firstUniqChar</span><span class="hljs-params">(self, s)</span>:</span>dic = collections.OrderedDict()<span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> s:dic[c] = <span class="hljs-keyword">not</span> c <span class="hljs-keyword">in</span> dic<span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> dic.items():<span class="hljs-keyword">if</span> v: <span class="hljs-keyword">return</span> k<span class="hljs-keyword">return</span> <span class="hljs-string">" "</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在字符串s中找出一个只出现一次的字符。如果没有，返回一个单空格。s只包含小写字母。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs abnf&quot;&gt;&lt;span class=&quot;hljs-attribute&quot;&gt;s&lt;/span&gt; = &lt;span class
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer04-二维数组中的查找</title>
    <link href="https://sulimin-nb.github.io/article/efc5bc08.html"/>
    <id>https://sulimin-nb.github.io/article/efc5bc08.html</id>
    <published>2020-11-18T06:45:18.000Z</published>
    <updated>2020-11-18T06:53:24.633Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findNumberIn2DArray</span><span class="hljs-params">(self, matrix, target)</span>:</span>i,j = len(matrix) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span><span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> j &lt; len(matrix[<span class="hljs-number">0</span>]):<span class="hljs-keyword">if</span> matrix[i][j] &gt; target: i -= <span class="hljs-number">1</span><span class="hljs-keyword">elif</span> matrix[i][j] &lt; target: j += <span class="hljs-number">1</span><span class="hljs-keyword">else</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code class=&quot;hljs python&quot;&gt;&lt;span class=&quot;hljs-class&quot;&gt;&lt;span class=&quot;hljs-keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;hljs-title&quot;&gt;Solution&lt;/span&gt;:&lt;/s
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer65-位运算-不用加减乘除做加法</title>
    <link href="https://sulimin-nb.github.io/article/c8b5b105.html"/>
    <id>https://sulimin-nb.github.io/article/c8b5b105.html</id>
    <published>2020-11-18T03:22:50.000Z</published>
    <updated>2020-11-18T06:44:31.824Z</updated>
    
    <content type="html"><![CDATA[<p>写一个函数，求两个整数之和，要求在函数体内不得使用”+”,”-“,”*”,”/“四则运算符号。</p><p>示例：</p><pre><code class="hljs routeros">输入：<span class="hljs-attribute">a</span>=1, <span class="hljs-attribute">b</span>=1输出：2</code></pre><p>提示：</p><ul><li>a,b均可能是负数或0</li><li>结果不会溢出32位整数</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span><span class="hljs-params">(self, a, b)</span>:</span></code></pre><p>解题思路：</p><p>本题考察对位运算的灵活使用，即使用位运算实现加法。</p><p>设两数字的</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution:</span><span class="hljs-symbol">def</span> <span class="hljs-symbol">add</span>(<span class="hljs-symbol">self, <span class="hljs-symbol">a</span>, <span class="hljs-symbol">b</span></span>):<span class="hljs-symbol">x</span> = <span class="hljs-symbol">0xffffffff</span><span class="hljs-symbol">a, <span class="hljs-symbol">b</span></span> = <span class="hljs-symbol">a</span> &amp; <span class="hljs-symbol">x, <span class="hljs-symbol">b</span></span> &amp; <span class="hljs-symbol">x</span><span class="hljs-symbol">whlie</span> <span class="hljs-symbol">b</span> != <span class="hljs-symbol">0:</span><span class="hljs-symbol">a, <span class="hljs-symbol">b</span></span> = (<span class="hljs-symbol">a</span> ^ <span class="hljs-symbol">b</span>), (<span class="hljs-symbol">a</span> &amp; <span class="hljs-symbol">b</span>) &lt;&lt; <span class="hljs-symbol">1</span> &amp; <span class="hljs-symbol">x</span><span class="hljs-symbol">return</span> <span class="hljs-symbol">a</span> <span class="hljs-symbol">if</span> <span class="hljs-symbol">a</span> &lt;= <span class="hljs-symbol">0x7fffffff</span> <span class="hljs-symbol">else</span> ~(<span class="hljs-symbol">a</span> ^ <span class="hljs-symbol">x</span>)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;写一个函数，求两个整数之和，要求在函数体内不得使用”+”,”-“,”*”,”/“四则运算符号。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs routeros&quot;&gt;输入：&lt;span class=&quot;hljs-attribute&quot;&gt;a&lt;/span&gt;=
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer56-位运算-II数组中数字出现的次数II</title>
    <link href="https://sulimin-nb.github.io/article/774e6244.html"/>
    <id>https://sulimin-nb.github.io/article/774e6244.html</id>
    <published>2020-11-18T02:16:11.000Z</published>
    <updated>2020-11-18T09:35:55.721Z</updated>
    
    <content type="html"><![CDATA[<p>z在一个数组$nums$中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。</p><p>示例1：</p><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]输出：<span class="hljs-number">4</span></code></pre><p>示例2：</p><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">9</span>,<span class="hljs-number">1</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>,<span class="hljs-number">9</span>,<span class="hljs-number">7</span>]输出：<span class="hljs-number">1</span></code></pre><p>限制：</p><ul><li>1 &lt;= nums.length &lt;= 10000</li><li>1 &lt;= nums[i] &lt; 2^31</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(self, nums)</span>:</span></code></pre><p>解题思路：</p><p>如下图所示，考虑数字的二进制形式，对于出现三次的数字，各二进制位出现的次数都是3的倍数。</p><p>因此，统计所有数字的各二进制中1的出现次数，并对3求余，结果则为只出现一次的数字。</p><p>方法一：有限状态自动机</p><p>各二进制位的位运算规则相同，因此只需考虑一位即可。如下图所示，对于所有数字中的某二进制1的个数，存在3种状态，即对3余数为0，1，2。</p><p>如下图所示，由于二进制只能表示0，1，因此需要使用两个二进制位来表示3个状态。设此两位分别为two，one，则状态转换变为：</p><p>00-&gt;01-&gt;10-&gt;00-&gt;…</p><p>接下来，需要通过状态转换表导出状态转换的计算公式。首先回忆以下位运算特点，对于任意二进制位$x$，有：</p><ul><li>异或运算：$x^0=x, x^1=~x$</li><li>与运算：x &amp; 0 = 0, x &amp; 1 = x​</li></ul><p>计算one方法：</p><p>设当前状态为two one，此时输入二进制位$n$。如下图所示，通过对状态表的情况拆分，可推出one的计算方法为：</p><pre><code class="hljs livecodeserver"><span class="hljs-keyword">if</span> <span class="hljs-literal">two</span> == <span class="hljs-number">0</span>:<span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:<span class="hljs-literal">one</span> = <span class="hljs-literal">one</span><span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:<span class="hljs-literal">one</span> = ~<span class="hljs-literal">one</span><span class="hljs-keyword">if</span> <span class="hljs-literal">two</span> == <span class="hljs-number">1</span>:<span class="hljs-literal">one</span> = <span class="hljs-number">0</span></code></pre><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(self, nums)</span>:</span>ones, twos = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:ones = ones ^ num &amp; ~twostwos = twos ^ num &amp; ~ones<span class="hljs-keyword">return</span> ones</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;z在一个数组$nums$中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字。&lt;/p&gt;
&lt;p&gt;示例1：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs angelscript&quot;&gt;输入：nums = [&lt;span class=&quot;hljs-numb
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer15-位运算-二进制中1的个数</title>
    <link href="https://sulimin-nb.github.io/article/139a697c.html"/>
    <id>https://sulimin-nb.github.io/article/139a697c.html</id>
    <published>2020-11-17T13:49:14.000Z</published>
    <updated>2020-11-18T09:35:58.245Z</updated>
    
    <content type="html"><![CDATA[<p>q请实现一个函数，输入一个整数(以二进制串形式)，输出该数二进制表示中1的个数。例如，把9表示成二进制是1001，有2位是1。因此，如果输入9，则该函数输出2。</p><p>示例1：</p><pre><code class="hljs plain"></code></pre><p>提示：</p><ul><li>输入必须是长度为32的二进制串。</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hummingWeight</span><span class="hljs-params">(self, n)</span>:</span></code></pre><p>方法一：逐位判断</p><ul><li><p>根据与运算定义，设二进制数字$n$，则有：</p><ul><li>若n&amp;1=0，则n二进制最右一位为0.</li><li>若n&amp;1=1，则n二进制最右一位为1.</li></ul></li><li><p>根据以上特点，考虑以下循环判断：</p><ol><li>判断n最右一位是否为1，根据结果计数。</li><li>将n右移一位(本题要求把数字n看作无符号数，因此使用无符号右移操作)。</li></ol><p>算法流程：</p><ol><li>初始化数量统计变量$res=0$。</li><li>循环逐位判断：当$n=0$时跳出。</li><li></li></ol></li></ul><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution:</span><span class="hljs-symbol">def</span> <span class="hljs-symbol">hammingWeight</span>(<span class="hljs-symbol">self, <span class="hljs-symbol">n</span></span>):<span class="hljs-symbol">res</span> = <span class="hljs-symbol">0</span><span class="hljs-symbol">while</span> <span class="hljs-symbol">n:</span><span class="hljs-symbol">res</span> += <span class="hljs-symbol">n</span> &amp; <span class="hljs-symbol">1</span><span class="hljs-symbol">n</span> &gt;&gt; <span class="hljs-symbol">1</span><span class="hljs-symbol">return</span> <span class="hljs-symbol">res</span></code></pre><p>方法二：巧用n&amp;(n-1)</p><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">hammingWeight</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, n)</span></span><span class="hljs-symbol">:</span>res = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> <span class="hljs-symbol">n:</span>res += <span class="hljs-number">1</span>n &amp;= n - <span class="hljs-number">1</span><span class="hljs-keyword">return</span> res</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;q请实现一个函数，输入一个整数(以二进制串形式)，输出该数二进制表示中1的个数。例如，把9表示成二进制是1001，有2位是1。因此，如果输入9，则该函数输出2。&lt;/p&gt;
&lt;p&gt;示例1：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs plain&quot;&gt;
&lt;/code&gt;&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer58-双指针-I翻转单词顺序</title>
    <link href="https://sulimin-nb.github.io/article/af05aca5.html"/>
    <id>https://sulimin-nb.github.io/article/af05aca5.html</id>
    <published>2020-11-17T13:27:06.000Z</published>
    <updated>2020-11-17T13:48:44.340Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student.”，则输出”student. a am I”。</p><p>示例1：</p><pre><code class="hljs smalltalk">输入：<span class="hljs-comment">"the sky is blue"</span>输出：<span class="hljs-comment">"blue is sky the"</span></code></pre><p>注意：本题与<a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">主站151题</a>相同</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseWords</span><span class="hljs-params">(self, s)</span>:</span></code></pre><p>方法一：双指针</p><p>算法解析：</p><ul><li>倒序遍历字符串$s$，记录单词左右索引边界$i,j$；</li><li>每确定一个单词的边界，则将其添加至单词列表$res$;</li><li>最终，将单词列表拼接为字符串，并返回即可。</li></ul><p>复杂度分析：</p><ul><li>时间复杂度$O(N)$：其中$N$为字符串$s$的长度，线性遍历字符串。</li><li>空间复杂度$O(N)$：新建的list(Python)或StringBuilder(Java)中的字符串总长度&lt;=N，占用$O(N)$大小的额外空间。</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">reverseWords</span><span class="hljs-params">(self, s)</span>:</span>        s = s.strip() <span class="hljs-comment"># 删除空格</span>        i = j = len(s) - <span class="hljs-number">1</span>        res = []        <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span>:            <span class="hljs-keyword">while</span> i &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> s[i] != <span class="hljs-string">' '</span>: i -= <span class="hljs-number">1</span>            res.append(s[i+<span class="hljs-number">1</span>, j+<span class="hljs-number">1</span>])            <span class="hljs-keyword">while</span> s[i] == <span class="hljs-string">' '</span>: i -= <span class="hljs-number">1</span>            j = i        <span class="hljs-keyword">return</span> <span class="hljs-string">' '</span>.join(res)</code></pre><p>方法二：分割+倒序</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。例如输入字符串”I am a student.”，则输出”student. a am I”。&lt;/p&gt;
&lt;p&gt;示例1：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer57-双指针-和为s的两个数字</title>
    <link href="https://sulimin-nb.github.io/article/82284efe.html"/>
    <id>https://sulimin-nb.github.io/article/82284efe.html</id>
    <published>2020-11-17T13:05:46.000Z</published>
    <updated>2020-11-17T13:17:57.286Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。</p><p>限制：</p><ul><li>1 &lt;= nums.length &lt;= 10^5</li><li>1 &lt;= nums[i] &lt;= 10^6</li></ul><p>复杂度分析：</p><ul><li>时间复杂度$O(N)$：$N$为数组$nums$的长度；双指针共同线性遍历整个数组。</li><li>空间复杂度$O(1)$：变量$i,j$使用常数大小的额外空间。</li></ul><pre><code class="hljs matlab">class Solution:def twoSum(self, nums, target):<span class="hljs-built_in">i</span>,<span class="hljs-built_in">j</span> = <span class="hljs-number">0</span>, len(nums) - <span class="hljs-number">1</span><span class="hljs-keyword">while</span> <span class="hljs-built_in">i</span> &lt; <span class="hljs-built_in">j</span>:s = nums[<span class="hljs-built_in">i</span>] + nums[<span class="hljs-built_in">j</span>]<span class="hljs-keyword">if</span> s &gt; target: <span class="hljs-built_in">j</span> -= <span class="hljs-number">1</span>elif s &lt; target: <span class="hljs-built_in">i</span> += <span class="hljs-number">1</span><span class="hljs-keyword">else</span>: <span class="hljs-keyword">return</span> nums[<span class="hljs-built_in">i</span>], num[<span class="hljs-built_in">j</span>]<span class="hljs-keyword">return</span> []</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，则输出任意一对即可。&lt;/p&gt;
&lt;p&gt;限制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1 &amp;lt;= nums.length &amp;lt;= 10^5&lt;/li&gt;
&lt;li&gt;1 &amp;lt;= nu
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer25-双指针-合并两个排序的链表</title>
    <link href="https://sulimin-nb.github.io/article/5c4f5294.html"/>
    <id>https://sulimin-nb.github.io/article/5c4f5294.html</id>
    <published>2020-11-17T12:04:01.000Z</published>
    <updated>2020-11-17T13:05:06.151Z</updated>
    
    <content type="html"><![CDATA[<p>输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。</p><p>示例1：</p><pre><code class="hljs angelscript">输入：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">4</span>, <span class="hljs-number">1</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>输出：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">4</span></code></pre><p>限制：</p><p>0 &lt;= 链表长度 &lt;= 1000</p><p>注意：本题与<a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">主站21题</a>相同。</p><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment"># def __init__(self, x):</span><span class="hljs-comment"># self.val = x</span><span class="hljs-comment"># self.next = None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(self, l1, l2)</span>:</span></code></pre><p>解题思路：</p><ul><li>根据题目描述，链表$l1,l2$是递增的，因此容易想到使用双指针$l1$和$l2$遍历两链表，根据$l1.val$和$l2.val$的大小关系确定节点添加顺序，两节点指针交替前进，直至遍历完毕。</li><li>引入伪头节点：由于初始状态合并链表中无节点，因此循环第一轮时无法将节点添加到合并链表中。解决方案：初始化一个辅助节点$dum$作为合并链表的伪头节点，将各节点添加至$dum$之后。</li></ul><p>算法流程：</p><ol><li>初始化：伪头节点$dum$，节点$cur$指向$dum$。</li><li>循环合并：当$l1$或$l2$为空时跳出；<ol><li>当$l1.val&lt;l2.val$时，$cur$的后继节点指定为$l1$，同时$l1$向前走一步；</li><li>当$l1.val&gt;=l2.val$：$cur$的后继节点指定为$l2$，同时$l2$向前走一步；</li><li>节点$cur$向前走一步，即$cur=cur.next$。</li></ol></li><li>合并剩余尾部：跳出时有两种情况，即$l1$为空或$l2$为空。<ol><li>若$l1 \neq null$：将$l1$添加至节点$cur$之后；</li><li>否则：将$l2$添加至节点$cur$之后。</li></ol></li><li>返回值：合并链表在伪头节点$dum$之后，因此返回$dum.next$即可。</li></ol><p>复杂度分析：</p><ul><li>时间复杂度$O(M+N)$：$M,N$分别为链表$l1,l2$的长度，合并操作需遍历两链表。</li><li>空间复杂度$O(1)$：节点引用$dum,cur$使用常数大小的额外空间。</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(self, l1, l2)</span>:</span>cur = dum = ListNode(<span class="hljs-number">0</span>)<span class="hljs-keyword">while</span> l1 <span class="hljs-keyword">and</span> l2:<span class="hljs-keyword">if</span> l1.val &lt; l2.val:cur.next, l1 = l1, l1.next<span class="hljs-keyword">else</span>:                cur.next, l2 = l2, l2.next            cur = cur.next       cur.next = l1 <span class="hljs-keyword">if</span> l1 <span class="hljs-keyword">else</span> l2        <span class="hljs-keyword">return</span> dum.next</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。&lt;/p&gt;
&lt;p&gt;示例1：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs angelscript&quot;&gt;输入：&lt;span class=&quot;hljs-number&quot;&gt;1&lt;/span&gt;-&amp;gt;&lt;span
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer22-双指针-链表中倒数第k个节点</title>
    <link href="https://sulimin-nb.github.io/article/5bbaf6b8.html"/>
    <id>https://sulimin-nb.github.io/article/5bbaf6b8.html</id>
    <published>2020-11-17T09:10:16.000Z</published>
    <updated>2020-11-17T13:05:01.700Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。</p><p>示例：</p><pre><code class="hljs angelscript">给定一个链表：<span class="hljs-number">1</span>-&gt;<span class="hljs-number">2</span>-&gt;<span class="hljs-number">3</span>-&gt;<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>，和k=<span class="hljs-number">2.</span>返回链表 <span class="hljs-number">4</span>-&gt;<span class="hljs-number">5.</span></code></pre><pre><code class="hljs ruby"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment"># def __init__(self, x):</span><span class="hljs-comment"># self.val = x</span><span class="hljs-comment"># self.next = None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, head, k)</span></span><span class="hljs-symbol">:</span></code></pre><p><strong>解题思路</strong>：</p><ol><li>先遍历统计链表长度，记为n;</li><li>设置一个指针走(n-k)步，即可找到链表倒数第k个节点。</li></ol><p>使用双指针则可以不同统计链表长度。</p><p>算法流程：</p><ol><li>初始化：前指针$former$、后指针$latter$，双指针都指向头节点$head$。</li><li>构建双指针距离：前指针$former$先向前走$k$步(结束后，双指针$former$和$latter$间相距$k$步)。</li><li>双指针共同移动：循环中，双指针$former$和$latter$每轮都向前走一步，直到$former$走过链表尾节点时跳出(跳出后，$latter$与尾节点距离为$k-1$，即$latter$指向倒数第$k$个节点)。</li><li>返回值：返回$latter$即可。</li></ol><p>复杂度分析：</p><ul><li>时间复杂度$O(N)$：$N$为链表长度；总体看，$former$走了$N$步，$latter$走了$N-k$步。</li><li>空间复杂度$O(1)$：双指针$former$，$latter$使用常数大小的额外空间。</li></ul><p>代码：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getKthFromEnd</span><span class="hljs-params">(self, head, k)</span>:</span>        former, latter = head, head        <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(k):            former = former.next        <span class="hljs-keyword">while</span> former:            former, latter = former.next, latter.next</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。例如，一个链表有6个节点，从头节点开始，它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个节点是值为4的节点。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer21-双指针-调整数组顺序使奇数位于偶数前面</title>
    <link href="https://sulimin-nb.github.io/article/b61b3feb.html"/>
    <id>https://sulimin-nb.github.io/article/b61b3feb.html</id>
    <published>2020-11-17T08:53:02.000Z</published>
    <updated>2020-11-17T13:04:57.736Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p><p>示例：</p><pre><code class="hljs angelscript">输入：nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]输出：[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]注：[<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">4</span>]也是正确答案</code></pre><p>提示：</p><ol><li>1 &lt;= nums.length &lt;= 50000</li><li>1 &lt;= nums[i] &lt;= 10000</li></ol><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution:</span><span class="hljs-symbol">def</span> <span class="hljs-symbol">exchange</span>(<span class="hljs-symbol">self, <span class="hljs-symbol">nums</span></span>):</code></pre><p>解题思路：</p><p>考虑定义双指针$i,j$分列数组左右两端，循环执行：</p><ol><li>指针$i$从左向右寻找偶数；</li><li>指针$j$从右向左寻找奇数；</li><li>将偶数$nums[i]$和奇数$nums[j]$交换。</li></ol><p>可始终保证：指针$i$左边都是奇数，指针$j$右边都是偶数。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exchange</span><span class="hljs-params">(self, nums)</span>:</span>i, j = <span class="hljs-number">0</span>, len(nums) - <span class="hljs-number">1</span><span class="hljs-keyword">while</span> i &lt; j:<span class="hljs-keyword">while</span> i &lt; j <span class="hljs-keyword">and</span> nums[i] &amp; <span class="hljs-number">1</span> == <span class="hljs-number">1</span>: i += <span class="hljs-number">1</span><span class="hljs-keyword">while</span> i &lt; j <span class="hljs-keyword">and</span> nums[j] &amp; <span class="hljs-number">1</span> == <span class="hljs-number">0</span>: j -= <span class="hljs-number">1</span>nums[i], nums[j] = nums[j], nums[i]<span class="hljs-keyword">return</span> nums</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs angelscript&quot;&gt;输入：nums = [&lt;span class=&quot;hlj
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer18-双指针-删除链表的节点</title>
    <link href="https://sulimin-nb.github.io/article/477ccd40.html"/>
    <id>https://sulimin-nb.github.io/article/477ccd40.html</id>
    <published>2020-11-17T07:34:47.000Z</published>
    <updated>2020-11-17T08:48:31.280Z</updated>
    
    <content type="html"><![CDATA[<p>给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。</p><p>返回删除后的链表的头节点。</p><p>注意：此题对比原题有改动。</p><p><strong>示例1</strong>：</p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>], val = <span class="hljs-number">5</span>输出：[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>]解释：给定链表中值为<span class="hljs-number">5</span>的第二个节点，那么在调用了函数之后，该链表应变为<span class="hljs-number">4</span>-&gt;<span class="hljs-number">10</span>-&gt;<span class="hljs-number">9.</span></code></pre><p>示例2：</p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>],val=<span class="hljs-number">1</span>输出：[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]解释：给定链表中值为<span class="hljs-number">1</span>的第三个节点，那么调用了函数之后，该链表应变为<span class="hljs-number">4</span>-&gt;<span class="hljs-number">5</span>-&gt;<span class="hljs-number">9.</span></code></pre><p>说明：</p><ul><li>题目保证链表中节点的值互不相同</li><li>若使用C或C++语言，你不需要free或delete被删除的节点</li></ul><pre><code class="hljs python"><span class="hljs-comment"># Definition for singly-linked list.</span><span class="hljs-comment"># class ListNode:</span><span class="hljs-comment"># def __init__(self, x):</span><span class="hljs-comment"># self.val = x</span><span class="hljs-comment"># self.next = None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(self, head, val)</span>:</span></code></pre><p>解题思路：</p><p>本题删除值为$val$的节点需分为两步：定位节点，修改引用。</p><ol><li>定位节点：遍历链表，直到$head.val == val$时跳出，即可定位目标节点。</li><li>修改引用：设节点$cur$的前驱节点为$pre$，后继节点为$cur.next$；则执行$pre.next = cur.next$，即可实现删除$cur$节点。</li></ol><p>算法流程：</p><ol><li>特例处理：当应删除头节点$head$时，直接返回$head.next$即可。</li><li>初始化：$pre=head,cur=head.next$。</li><li>定位节点：当$cur$为空或$cur$节点值等于$val$时跳出。<ol><li>保存当前节点索引，即$pre=cur$。</li><li>遍历下一节点，即$cur=cur.next$。</li></ol></li><li>删除节点：若$cur$指向某节点，则执行$pre.next=cur.next$;若$cur$指向$null$，代表链表中不包含值为$val$的节点。</li><li>返回值：返回链表头部节点$head$即可。</li></ol><p>复杂度分析：</p><ul><li>时间复杂度$O(N)$：$N$为链表长度，删除操作平均需循环$N/2$次，最差$N$次。</li><li>空间复杂度$O(1)$：$cur$，$pre$占用常数大小额外空间。</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deleteNode</span><span class="hljs-params">(self, head, val)</span>:</span>        <span class="hljs-keyword">if</span> head.val == val: <span class="hljs-keyword">return</span> head.next        pre, cur = head, head.next        <span class="hljs-keyword">while</span> cur <span class="hljs-keyword">and</span> cur.val != val:            pre, cur = cur, cur.next        <span class="hljs-keyword">if</span> cur: pre.next = cur.next        <span class="hljs-keyword">return</span> head</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。&lt;/p&gt;
&lt;p&gt;返回删除后的链表的头节点。&lt;/p&gt;
&lt;p&gt;注意：此题对比原题有改动。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs ange
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer61-排序-扑克牌中的顺子</title>
    <link href="https://sulimin-nb.github.io/article/d47daa0e.html"/>
    <id>https://sulimin-nb.github.io/article/d47daa0e.html</id>
    <published>2020-11-17T05:04:42.000Z</published>
    <updated>2020-11-17T08:49:27.590Z</updated>
    
    <content type="html"><![CDATA[<p>从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张拍是不是连续的。2~10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为0，可以看成任意数字。A不能视为14。</p><p>限制：</p><p>数组长度为5</p><p>数组的数取值为[0,13]。</p><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution:</span><span class="hljs-symbol">def</span> <span class="hljs-symbol">isStraight</span>(<span class="hljs-symbol">self, <span class="hljs-symbol">nums</span></span>):</code></pre><p><strong>解题思路</strong>：</p><p>根据题意，此5张牌是顺子的充分条件如下：</p><ol><li>除大小王外，所有牌无重复；</li><li>设此5张牌中最大的牌为$max$，最小的牌为$min$(大小王除外)，则需满足：</li></ol><script type="math/tex; mode=display">max - min < 5</script><p>因此可将问题转化为：此5张牌是否满足以上条件？</p><p>方法一：集合Set+遍历</p><ul><li>遍历五张牌，遇到大小王(即0)直接跳过。</li><li>判别重复：利用Set实现遍历判重，Set的查找方法的时间复杂度为$O(1)$;</li><li>获取最大/最小的牌：借助辅助变量$ma$和$mi$，遍历统计即可。</li></ul><p>复杂度分析:</p><ul><li>时间复杂度$O(1)$：本题中给定牌数量$N=5$；遍历数组使用$O(N)=O(5)=O(1)$时间。</li><li>空间复杂度$O(1)$：勇于判重的辅助Set使用$O(N)=O(1)$额外空间。</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(self, nums)</span>:</span>repeat = set()ma, mi = <span class="hljs-number">0</span>, <span class="hljs-number">14</span><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:<span class="hljs-keyword">if</span> num == <span class="hljs-number">0</span>: <span class="hljs-keyword">continue</span> <span class="hljs-comment"># 跳过大小王</span>ma = max(ma, num) <span class="hljs-comment"># 最大牌</span>mi = min(mi, num) <span class="hljs-comment"># 最小牌</span><span class="hljs-keyword">if</span> num <span class="hljs-keyword">in</span> repeat: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span> <span class="hljs-comment"># 若有重复，提前返回false</span>repeat.add(num)<span class="hljs-keyword">return</span> ma - mi &lt; <span class="hljs-number">5</span></code></pre><p>方法二：排序+遍历</p><ul><li>先对数组执行排序。</li><li>判别重复：排序数组中的相同元素位置相邻，因此可通过遍历数组，判断$nums[i]=nums[i+1]$是否成立来判重。</li><li>获取最大/最小的牌：排序后，数组末位元素$nums[4]$为最大牌；元素$nums[joker]$为最小牌，其中$joker$为大小王的数量。</li></ul><p>复杂度分析：</p><ul><li>时间复杂度$O(1)$：本题中给定牌数量$N=5$；数组排序使用$O(NlogN)=O(5log5)=O(1)$时间。</li><li>空间复杂度$O(1)$：变量$joker$使用$O(1)$大小的额外空间。</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isStraight</span><span class="hljs-params">(self, nums)</span>:</span>joker = <span class="hljs-number">0</span>nums.sort() <span class="hljs-comment"># 数组排序</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>):<span class="hljs-keyword">if</span> nums[i] == <span class="hljs-number">0</span>: joker += <span class="hljs-number">1</span> <span class="hljs-comment">#统计大小王数量</span>            <span class="hljs-keyword">elif</span> nums[i] == nums[i+<span class="hljs-number">1</span>]: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span> <span class="hljs-comment"># 若有重复，提前返回false</span>       <span class="hljs-keyword">return</span> nums[<span class="hljs-number">4</span>] - nums[joker] &lt; <span class="hljs-number">5</span> <span class="hljs-comment"># 最大牌 - 最小牌 &lt; 5则可构成顺子</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张拍是不是连续的。2~10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为0，可以看成任意数字。A不能视为14。&lt;/p&gt;
&lt;p&gt;限制：&lt;/p&gt;
&lt;p&gt;数组长度为5&lt;/p&gt;
&lt;p&gt;数组的数取值为[0,13]。&lt;/
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer45-排序-将数组排成最小的数</title>
    <link href="https://sulimin-nb.github.io/article/9d5f0517.html"/>
    <id>https://sulimin-nb.github.io/article/9d5f0517.html</id>
    <published>2020-11-17T02:53:37.000Z</published>
    <updated>2020-11-17T08:52:26.939Z</updated>
    
    <content type="html"><![CDATA[<p>s输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。</p><p><strong>示例1</strong>：</p><pre><code class="hljs lsl">输入：[<span class="hljs-number">10</span>,<span class="hljs-number">2</span>]输出：<span class="hljs-string">"102"</span></code></pre><p><strong>示例2</strong>：</p><pre><code class="hljs lsl">输入：[<span class="hljs-number">3</span>,<span class="hljs-number">30</span>,<span class="hljs-number">34</span>,<span class="hljs-number">5</span>,<span class="hljs-number">9</span>]输出：<span class="hljs-string">"3033459"</span></code></pre><p>提示：</p><ul><li>0 &lt; nums.length &lt;= 100</li></ul><p>说明：</p><ul><li>输出结果可能非常大，所以你需要返回一个字符串而不是整数</li><li>拼接起来的数字可能会有前导0，最后结果不需要去掉前导0</li></ul><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">Solution:</span><span class="hljs-symbol">def</span> <span class="hljs-symbol">minNumber</span>(<span class="hljs-symbol">self, <span class="hljs-symbol">nums</span></span>):</code></pre><p>解题思路：</p><ul><li>此题求拼接起来的”最小数字”，本质上是一个排序问题。</li></ul><p>算法流程：</p><ol><li>初始化：字符串列表strs，保存各数字的字符串格式；</li><li>列表排序：应用以上”排序判断规则”，对strs执行排序。</li><li>返回值：拼接strs中的所有字符串，并返回。</li></ol><p>复杂度分析：</p><ul><li>时间复杂度$O(NlogN)$：$N$为最终返回值的字符数量($strs$列表的长度&lt;=N)；使用快排或内置函数的平均时间复杂度为$O(NlogN)$，最差为$O(N^2)$。</li><li>空间复杂度$O(N)$：字符串列表$strs$占用线性大小的额外空间。</li></ul><p>代码：</p><p>本节只列举快速排序和内置函数两种排序方法，其他排序方法也可使用。</p><p>快速排序：</p><p>需修改快速排序函数中的排序判断规则。字符串大小(字典序)对比的实现方法：</p><ul><li>Python/C++中直接用&lt;，&gt;；</li><li>Java中使用A.compareTo(B)。</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minNumber</span><span class="hljs-params">(self, nums)</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fast_sort</span><span class="hljs-params">(l, r)</span>:</span><span class="hljs-keyword">if</span> l &gt;= r: <span class="hljs-keyword">return</span>i, j = l, r<span class="hljs-keyword">while</span> i &lt; j:<span class="hljs-keyword">while</span> strs[j] + strs[l] &gt;= strs[l] + strs[j] <span class="hljs-keyword">and</span> i &lt; j: j-= <span class="hljs-number">1</span><span class="hljs-keyword">while</span> strs[i] + strs[l] &lt;= strs[l] + strs[i] <span class="hljs-keyword">and</span> i &lt; j: i += <span class="hljs-number">1</span>strs[i], strs[j] = strs[j], strs[i]strs[i], strs[l] = strs[l], strs[i]fast_sort(l, i<span class="hljs-number">-1</span>)fast_sort(i+<span class="hljs-number">1</span>, r)strs = [str[num] <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums]fast_sort(<span class="hljs-number">0</span>, len(str) - <span class="hljs-number">1</span>)<span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(strs)</code></pre><p>内置函数：</p><p>需定义排序规则：</p><ul><li>python定义在函数sort_rule(x,y)中；</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minNumber</span><span class="hljs-params">(self, nums)</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sort_rule</span><span class="hljs-params">(x, y)</span>:</span>a, b = x+y, y+x<span class="hljs-keyword">if</span> a &gt; b: <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><span class="hljs-keyword">elif</span> a &lt; b: <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><span class="hljs-keyword">else</span>: <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>strs = [str(num) <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums]strs.sort(key = functools.cmp_to_key(sort_rule))<span class="hljs-keyword">return</span> <span class="hljs-string">''</span>.join(strs)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;s输入一个非负整数数组，把数组里所有数字拼接起来排成一个数，打印能拼接出的所有数字中最小的一个。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例1&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;hljs lsl&quot;&gt;输入：[&lt;span class=&quot;hljs-numbe
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>剑指Offer41-排序-数据流中的中位数</title>
    <link href="https://sulimin-nb.github.io/article/bfabc09a.html"/>
    <id>https://sulimin-nb.github.io/article/bfabc09a.html</id>
    <published>2020-11-16T13:45:37.000Z</published>
    <updated>2020-11-17T02:36:25.172Z</updated>
    
    <content type="html"><![CDATA[<p>如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。</p><p>例如：</p><p>[2,3,4]的中位数是3<br>[2,3]的中位数是(2+3) / 2 = 2.5</p><p>设计一个支持以下两种操作的数据结构：</p><ul><li>void addNum(int num) - 从数据流中添加一个整数到数据结构中。</li><li>double findMedian() - 返回目前所有元素的中位数。</li></ul><p><strong>示例1</strong>：</p><pre><code class="hljs prolog">输入：[<span class="hljs-string">"MedianFinder"</span>,<span class="hljs-string">"addNum"</span>,<span class="hljs-string">"findMedian"</span>,<span class="hljs-string">"addNum"</span>,<span class="hljs-string">"findMedian"</span>][[],[<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>],[],[<span class="hljs-number">3</span>],[]]输出：[null,null,null,<span class="hljs-number">1.50000</span>,null,<span class="hljs-number">2.00000</span>]</code></pre><p><strong>示例2</strong>：</p><pre><code class="hljs prolog">输入：[<span class="hljs-string">"MedianFinder"</span>,<span class="hljs-string">"addNum"</span>,<span class="hljs-string">"findMedian"</span>,<span class="hljs-string">"addNum"</span>,<span class="hljs-string">"findMedian"</span>][[],[<span class="hljs-number">2</span>],[],[<span class="hljs-number">3</span>],[]]输出：[null,null,<span class="hljs-number">2.00000</span>,null,<span class="hljs-number">2.50000</span>]</code></pre><p>限制：</p><ul><li>最多会对$addNum$，$findMedian$进行50000次调用。</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><span class="hljs-string">"""</span><span class="hljs-string">initialize your data structure here.</span><span class="hljs-string">"""</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addNum</span><span class="hljs-params">(self, num)</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMedian</span><span class="hljs-params">(self)</span>:</span><span class="hljs-comment"># Your MedianFinder object will be instantiated and called as such:</span><span class="hljs-comment"># obj = MedianFinder()</span><span class="hljs-comment"># obj.addNum(num)</span><span class="hljs-comment"># param_2 = obj.findMedian()</span></code></pre><p>解题思路：</p><blockquote><p>给定一个长度为$N$的无序数组，其中位数的计算方法：首先对数组执行排序(使用O(NlogN)时间)，然后返回中间元素即可(使用O(1)时间)。</p></blockquote><p>针对本题，根据以上思路，可以将数据流保存在一个列表中，并在添加元素时<strong>保持数组有序</strong>。此方法的时间复杂度为$O(N)$，其中包括：查找元素插入位置$O(logN)$(二分查找)、向数组某位置插入元素$O(N)$(插入位置之后的元素都需要向后移动一位)。</p><blockquote><p>借助堆可进一步优化时间复杂度。</p></blockquote><p>建立一个小顶堆A和大顶堆B，各保存列表的一半元素，且规定：</p><ul><li>A保存较大的一半，长度为$\frac{N}{2}$（N为偶数）或$\frac{N+1}{2}$(N为奇数)；</li><li>B保存较小的一半，长度为$\frac{N}{2}$(N为偶数)或$\frac{N-1}{2}$)(N为奇数)；</li></ul><p>随后，中位数仅根据A,B的堆顶元素计算得到。</p><p><img src="/article/bfabc09a/image-20201117101626334.png" srcset="/img/loading.gif" alt="image-20201117101626334" style="zoom: 80%;"></p><p>算法流程：</p><blockquote><p>设元素总数为N=m+n，其中m和n分别是A和B中的元素个数。</p></blockquote><p>addNum(num)函数：</p><ol><li>当$m=n$(即$N$为偶数)：需向A添加一个元素。实现方法：将新元素$num$插入至B，再将B堆顶元素插入至A;</li><li>当$m \neq n$(即N为奇数)：需向B添加一个元素。实现方法：将新元素num插入至A，再将A堆顶元素插入至B;</li></ol><blockquote><p>假设插入数字num遇到情况1.。由于num可能属于”较小的一半”(即属于B)，因此不能将num直接插入至A。而应先将num插入至B，再将B堆顶元素插入至A。这样就可以始终保持A保存较大一半、B保持较小一半。</p></blockquote><p>findMedian()函数：</p><ol><li>当$m=n$($N$为偶数)：则中位数为(A的堆顶元素+B的堆顶元素)/2。</li><li>当$m \neq n$($N$为奇数)：则中位数为A的堆顶元素。</li></ol><p>复杂度分析：</p><ul><li>时间复杂度：<ul><li>查找中位数$O(1)$：获取堆顶元素使用$O(1)$时间；</li><li>添加元素$O(logN)$：堆的插入和弹出操作使用$O(logN)$时间。</li></ul></li><li>空间复杂度$O(N)$：其中$N$为数据流汇总的元素数量，小顶堆A和大顶堆B最多同时保存$N$个元素。</li></ul><p>代码：</p><p>Python中heapq模块是小顶堆。实现大顶堆方法：小顶堆的插入和弹出操作均将元素取反即可。</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> heapq <span class="hljs-keyword">import</span> *<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        self.A = [] <span class="hljs-comment"># 小顶堆，保存较大的一半</span>        self.B = [] <span class="hljs-comment"># 大顶堆，保存较小的一半</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addNum</span><span class="hljs-params">(self, num)</span>:</span>        <span class="hljs-keyword">if</span> len(self.A) != len(self.B):            heappush(self.A, num)            heappush(self.B, -heappop(self.A))        <span class="hljs-keyword">else</span>:            heappush(self.B, -num)            heappush(self.A, -heappop(self.B))   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMedian</span><span class="hljs-params">(self)</span>:</span><span class="hljs-keyword">return</span> self.A[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> len(A) != len(B) <span class="hljs-keyword">else</span> (self.A[<span class="hljs-number">0</span>] - self.B[<span class="hljs-number">0</span>]) / <span class="hljs-number">2.0</span></code></pre><p>使用heappushpop优化heappush+heappop</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> heapq <span class="hljs-keyword">import</span> *<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span>        self.A = [] <span class="hljs-comment"># 小顶堆，保存较大的一半</span>        self.B = [] <span class="hljs-comment"># 大顶堆，保存较小的一半</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">addNum</span><span class="hljs-params">(self, num)</span>:</span>        <span class="hljs-keyword">if</span> len(self.A) != len(self.B):            heappush(self.B, -heappushpop(self.A, num))        <span class="hljs-keyword">else</span>:            heappush(self.A, -heappushpop(self.B, -num))   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findMedian</span><span class="hljs-params">(self)</span>:</span><span class="hljs-keyword">return</span> self.A[<span class="hljs-number">0</span>] <span class="hljs-keyword">if</span> len(A) != len(B) <span class="hljs-keyword">else</span> (self.A[<span class="hljs-number">0</span>] - self.B[<span class="hljs-number">0</span>]) / <span class="hljs-number">2.0</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，那么中位数就是所有数值排序之后中间两个数的平均值。&lt;/p&gt;
&lt;p&gt;例如：&lt;/p&gt;
&lt;p&gt;[2,3,4]的中位数是3&lt;br&gt;[2,3]的中位
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
