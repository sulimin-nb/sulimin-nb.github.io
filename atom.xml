<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sulimin-nb.github.io/"/>
  <updated>2020-10-16T03:24:45.389Z</updated>
  <id>https://sulimin-nb.github.io/</id>
  
  <author>
    <name>sulimin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>leetcode116-填充每个节点的下一个右侧节点指针</title>
    <link href="https://sulimin-nb.github.io/article/703b70fd.html"/>
    <id>https://sulimin-nb.github.io/article/703b70fd.html</id>
    <published>2020-10-16T02:01:04.000Z</published>
    <updated>2020-10-16T03:24:45.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="116-填充每个节点的下一个右侧节点指针"><a href="#116-填充每个节点的下一个右侧节点指针" class="headerlink" title="116. 填充每个节点的下一个右侧节点指针"></a>116. 填充每个节点的下一个右侧节点指针</h1><p>给定一个<strong>完美二叉树</strong>，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：</p><pre><code class="hljs crmsh">struct <span class="hljs-keyword">Node</span> <span class="hljs-title">&#123;</span><span class="hljs-title">int</span> val;<span class="hljs-keyword">Node</span> <span class="hljs-title">*left</span>;<span class="hljs-keyword">Node</span> <span class="hljs-title">*right</span>;<span class="hljs-keyword">Node</span> <span class="hljs-title">*next</span>;&#125;</code></pre><p>填充它的每个next指针，让这个指针指向下一个右侧节点，如果找不到下一个右侧节点，则将next指针设置为NULL。</p><p>初始状态下，所有next指针都被设置为NULL。</p><p><strong>示例：</strong></p><p><img src="/article/703b70fd/116_sample.png" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs dart">输入：&#123;<span class="hljs-string">"<span class="hljs-subst">$id</span>"</span>:<span class="hljs-string">"1"</span>,<span class="hljs-string">"left"</span>:&#123;<span class="hljs-string">"<span class="hljs-subst">$id</span>"</span>:<span class="hljs-string">"2"</span>,<span class="hljs-string">"left"</span>:&#123;<span class="hljs-string">"<span class="hljs-subst">$id</span>"</span>:<span class="hljs-string">"3"</span>,<span class="hljs-string">"left"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"next"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"right"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"val"</span>:<span class="hljs-number">4</span>&#125;,<span class="hljs-string">"next"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"right"</span>:&#123;<span class="hljs-string">"<span class="hljs-subst">$id</span>"</span>:<span class="hljs-string">"4"</span>,<span class="hljs-string">"left"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"next"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"right"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"val"</span>:<span class="hljs-number">5</span>&#125;,<span class="hljs-string">"val"</span>:<span class="hljs-number">2</span>&#125;,<span class="hljs-string">"next"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"right"</span>:&#123;<span class="hljs-string">"<span class="hljs-subst">$id</span>"</span>:<span class="hljs-string">"5"</span>,<span class="hljs-string">"left"</span>:&#123;<span class="hljs-string">"<span class="hljs-subst">$id</span>"</span>:<span class="hljs-string">"6"</span>,<span class="hljs-string">"left"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"next"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"right"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"val"</span>:<span class="hljs-number">6</span>&#125;,<span class="hljs-string">"next"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"right"</span>:&#123;<span class="hljs-string">"<span class="hljs-subst">$id</span>"</span>:<span class="hljs-string">"7"</span>,<span class="hljs-string">"left"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"next"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"right"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"val"</span>:<span class="hljs-number">7</span>&#125;,<span class="hljs-string">"val"</span>:<span class="hljs-number">3</span>&#125;,<span class="hljs-string">"val"</span>:<span class="hljs-number">1</span>&#125;输出：&#123;<span class="hljs-string">"<span class="hljs-subst">$id</span>"</span>:<span class="hljs-string">"1"</span>,<span class="hljs-string">"left"</span>:&#123;<span class="hljs-string">"<span class="hljs-subst">$id</span>"</span>:<span class="hljs-string">"2"</span>,<span class="hljs-string">"left"</span>:&#123;<span class="hljs-string">"<span class="hljs-subst">$id</span>"</span>:<span class="hljs-string">"3"</span>,<span class="hljs-string">"left"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"next"</span>:&#123;<span class="hljs-string">"<span class="hljs-subst">$id</span>"</span>:<span class="hljs-string">"4"</span>,<span class="hljs-string">"left"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"next"</span>:&#123;<span class="hljs-string">"<span class="hljs-subst">$id</span>"</span>:<span class="hljs-string">"5"</span>,<span class="hljs-string">"left"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"next"</span>:&#123;<span class="hljs-string">"<span class="hljs-subst">$id</span>"</span>:<span class="hljs-string">"6"</span>,<span class="hljs-string">"left"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"next"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"right"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"val"</span>:<span class="hljs-number">7</span>&#125;,<span class="hljs-string">"right"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"val"</span>:<span class="hljs-number">6</span>&#125;,<span class="hljs-string">"right"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"val"</span>:<span class="hljs-number">5</span>&#125;,<span class="hljs-string">"right"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"val"</span>:<span class="hljs-number">4</span>&#125;,<span class="hljs-string">"next"</span>:&#123;<span class="hljs-string">"<span class="hljs-subst">$id</span>"</span>:<span class="hljs-string">"7"</span>,<span class="hljs-string">"left"</span>:&#123;<span class="hljs-string">"<span class="hljs-subst">$ref</span>"</span>:<span class="hljs-string">"5"</span>&#125;,<span class="hljs-string">"next"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"right"</span>:&#123;<span class="hljs-string">"<span class="hljs-subst">$ref</span>"</span>:<span class="hljs-string">"6"</span>&#125;,<span class="hljs-string">"val"</span>:<span class="hljs-number">3</span>&#125;,<span class="hljs-string">"right"</span>:&#123;<span class="hljs-string">"<span class="hljs-subst">$ref</span>"</span>:<span class="hljs-string">"4"</span>&#125;,<span class="hljs-string">"val"</span>:<span class="hljs-number">2</span>&#125;,<span class="hljs-string">"next"</span>:<span class="hljs-keyword">null</span>,<span class="hljs-string">"right"</span>:&#123;<span class="hljs-string">"<span class="hljs-subst">$ref</span>"</span>:<span class="hljs-string">"7"</span>&#125;,<span class="hljs-string">"val"</span>:<span class="hljs-number">1</span>&#125;解释：给定二叉树如图 A 所示，你的函数应该填充它的每个 next 指针，以指向其下一个右侧节点，如图 B 所示。</code></pre><p><strong>提示：</strong></p><ul><li>你只能使用常量级额外空间。</li><li>使用递归解题也符合要求，本题中递归程序占用的栈空间不算做额外的空间复杂度。</li></ul><h2 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h2><h3 id="方法一：层次遍历"><a href="#方法一：层次遍历" class="headerlink" title="方法一：层次遍历"></a>方法一：层次遍历</h3><p>题目要求: 将二叉树的每一层节点都连接起来形成一个链表。<br>直观做法：对二叉树进行层次遍历，遍历过程中，遍历并连接二叉树每一层节点。</p><p>层次遍历：每次将队列中的所有元素进行拓展。保证每次从队列中拿出来遍历的元素属于同一层。遍历过程中修改每个节点的next指针，并拓展下一层的新队列。</p><p>广度优先搜素：每次只取出一个节点拓展。</p><p><strong>代码</strong>：</p><pre><code class="hljs python"><span class="hljs-string">"""</span><span class="hljs-string"># Definition for a Node.</span><span class="hljs-string">class Node:</span><span class="hljs-string">    def __init__(self, val: int = 0, left: 'Node' = None, right: 'Node' = None, next: 'Node' = None):</span><span class="hljs-string">        self.val = val</span><span class="hljs-string">        self.left = left</span><span class="hljs-string">        self.right = right</span><span class="hljs-string">        self.next = next</span><span class="hljs-string">"""</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connect</span><span class="hljs-params">(self, root: <span class="hljs-string">'Node'</span>)</span> -&gt; 'Node':</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> root                Q = collections.deque([root])        <span class="hljs-keyword">while</span> Q:            size = len(Q)            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(size):                curr = Q.popleft()                <span class="hljs-keyword">if</span> i == size - <span class="hljs-number">1</span>:                    <span class="hljs-keyword">pass</span>                <span class="hljs-keyword">else</span>:                    curr.next = Q[<span class="hljs-number">0</span>]                <span class="hljs-keyword">if</span> curr.left:                    Q.append(curr.left)                <span class="hljs-keyword">if</span> curr.right:                    Q.append(curr.right)        <span class="hljs-keyword">return</span> root</code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N)$。每个节点都被访问一次且只会被访问一次。即从队列中弹出并建立next指针。</li><li>空间复杂度：$O(N)$。完美二叉树的最后一个层级包含N/2个节点。广度优先遍历的复杂度取决与一个层级上的最大元素数量。这种情况下空间复杂度为$O(N)$。</li></ul><h3 id="方法二：使用已建立的next指针"><a href="#方法二：使用已建立的next指针" class="headerlink" title="方法二：使用已建立的next指针"></a>方法二：使用已建立的next指针</h3><p>一颗树中，存在两种类型的next指针。</p><ol><li><p>第一种情况是连接同一个父节点的两个子节点。通过同一个节点直接访问。执行以下操作即可完成连接。</p><pre><code class="hljs python">node.left.next = node.right</code></pre></li><li><p>第二种情况在不同父亲的子节点之间建立连接，这种情况下无法直接连接。<br>如果每个节点有指向父节点的指针，可以通过该指针找到next节点。如果不存在该指针，则按照以下思路建立连接：</p></li></ol><p>第N层节点之间建立next指针后，建立第N+1层节点的next指针时，可以通过next指针访问同一层的所有节点。因此可以使用第N层的next指针，为第N+1层节点建立next指针。</p><pre><code class="hljs python">node.right.next = node.next.left</code></pre><p>​        完成当前层的连接后，进入下一层重复操作，直到所有的节点全部连接。进入下一层时，需要更新最左节点，然后从新的最左节点开始遍历该层的所有节点。在完美二叉树的设定下，最左节点一定是当前层最左节点的左孩子。如果当前最左节点的左孩子不存在，说明已经达到该树的最后一层，完成了所有节点的连接。</p><p><strong>代码</strong>：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connect</span><span class="hljs-params">(self, root)</span>:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> root        <span class="hljs-comment"># 从根节点开始</span>        leftmost = root        <span class="hljs-keyword">while</span> leftmost.left:            <span class="hljs-comment"># 遍历这一层节点组织成的链表，为下一层的节点更新next指针</span>            head = leftmost            <span class="hljs-keyword">while</span> head:                <span class="hljs-comment"># connection 1</span>                head.left.next = head.right                                <span class="hljs-comment"># connection 2</span>                <span class="hljs-keyword">if</span> head.next:                    head.right.next = head.next.left                                <span class="hljs-comment"># 指针后移</span>                head = head.next            <span class="hljs-comment"># 去下一层的最左节点</span>            leftmost = leftmost.left        <span class="hljs-keyword">return</span> root</code></pre><p><strong>复杂度分析</strong>：</p><ul><li>时间复杂度：$O(N)$，每个节点只访问一次。</li><li>空间复杂度：$O(1)$，不需要存储额外的节点。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;116-填充每个节点的下一个右侧节点指针&quot;&gt;&lt;a href=&quot;#116-填充每个节点的下一个右侧节点指针&quot; class=&quot;headerlink&quot; title=&quot;116. 填充每个节点的下一个右侧节点指针&quot;&gt;&lt;/a&gt;116. 填充每个节点的下一个右侧节点指针&lt;/h1
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/tags/leetcode/"/>
    
      <category term="每日一题" scheme="https://sulimin-nb.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetocde116-填充每个节点的下一个右侧节点指针</title>
    <link href="https://sulimin-nb.github.io/article/a9a5f398.html"/>
    <id>https://sulimin-nb.github.io/article/a9a5f398.html</id>
    <published>2020-10-15T14:26:44.000Z</published>
    <updated>2020-10-15T14:26:44.774Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>leetcode1002-查找常用字符</title>
    <link href="https://sulimin-nb.github.io/article/31eedc7b.html"/>
    <id>https://sulimin-nb.github.io/article/31eedc7b.html</id>
    <published>2020-10-14T12:30:44.000Z</published>
    <updated>2020-10-14T14:16:52.488Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1002-查找常用字符"><a href="#1002-查找常用字符" class="headerlink" title="1002. 查找常用字符"></a>1002. 查找常用字符</h1><p>给定仅有小写字母组成的字符串数组A，返回列表中的每个字符串中都显示的全部字符(包括重复字符)组成的列表。例如，如果一个字符在每个字符串中出现3次，但不是4次，则需要在最终答案中包含该字符3次。</p><p>你可以按任意顺序返回答案。</p><p>示例1：</p><pre><code class="hljs css">输入：<span class="hljs-selector-attr">[<span class="hljs-string">"bella"</span>, <span class="hljs-string">"label"</span>, <span class="hljs-string">"roller"</span>]</span>输出：<span class="hljs-selector-attr">[<span class="hljs-string">"e"</span>, <span class="hljs-string">"l"</span>, <span class="hljs-string">"l"</span>]</span></code></pre><p>提示：</p><ol><li>$1 &lt;= A.length &lt;= 100$</li><li>$1&lt;= A[i].length &lt;= 100$</li><li>$A[i][j]$是小写字母</li></ol><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="方法一：计数"><a href="#方法一：计数" class="headerlink" title="方法一：计数"></a>方法一：计数</h3><p>根据题目的要求，如果字符$c$在所有字符串中均出现了k次以上，那么最终答案中需要包含$k$个$c$。因此，我们可以使用$minfreq[c]$存储字符$c$在所有字符串中出现次数的最小值。</p><p>我们可以依次遍历每一个字符串。当我们遍历到字符串$s$时，我们使用$freq[c]$统计$s$中每一个字符$c$出现的次数。在统计完成之后，我们再将每一个$minfreq[c]$更新为其本身与$freq[c]$的较小值。这样一来，当我们遍历完所有字符串后，$minfreq[c]$就存储了字符$c$在所有字符串出现次数的最小值。</p><p>由于题目保证了所有的字符均为小写字母，因此我们可以用长度为26的数组分别表示$minfreq$以及$freq$。</p><p>在构造最终的答案时，我们遍历所有的小写字母，并将$minfreq[c]$个$c$添加进答案数组即可。</p><h4 id="code"><a href="#code" class="headerlink" title="code"></a>code</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">commonChars</span><span class="hljs-params">(self, A: List[str])</span> -&gt; List[str]:</span>        minfreq = [float(<span class="hljs-string">"inf"</span>)] * <span class="hljs-number">26</span>        <span class="hljs-comment"># print(minfreq)</span>        <span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> A:            freq = [<span class="hljs-number">0</span>] * <span class="hljs-number">26</span>            <span class="hljs-keyword">for</span> ch <span class="hljs-keyword">in</span> word:                freq[ord(ch) - ord(<span class="hljs-string">"a"</span>)] += <span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">26</span>):                minfreq[i] = min(minfreq[i], freq[i])                <span class="hljs-comment"># print(minfreq[i])</span>        ans = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">26</span>):            <span class="hljs-keyword">if</span> minfreq:                ans.extend([chr(ord(<span class="hljs-string">"a"</span>)+ i)] * minfreq[i])        <span class="hljs-keyword">return</span> ans</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li><p>时间复杂度：$O(n(m+|\sum|))$，其中$n$是数组$A$的长度(即字符串的数目)，$m$是字符串的平均长度，$\sum$为字符集，在本题中字符集为所有小写字母，$|\sum|=26$。</p></li><li><ul><li>遍历所有字符串并计算$freq$的时间复杂度为$O(nm)$;</li><li>使用$freq$更新$minfreq$的时间复杂度为$O(n|\sum|)$;</li><li>由于最终答案包含的字符个数不会超过最短的字符串长度，因此构造最终答案的时间复杂度为$O(m+|\sum|)$。这一项在渐进意义上小于前二者，可以忽略。</li></ul></li><li>空间复杂度：$O(|\sum|)$，这里只计算存储答案之外的空间，我们使用了数组$freq$和$minfreq$，它们的长度均为$|\sum|$。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1002-查找常用字符&quot;&gt;&lt;a href=&quot;#1002-查找常用字符&quot; class=&quot;headerlink&quot; title=&quot;1002. 查找常用字符&quot;&gt;&lt;/a&gt;1002. 查找常用字符&lt;/h1&gt;&lt;p&gt;给定仅有小写字母组成的字符串数组A，返回列表中的每个字符串中都显
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/tags/leetcode/"/>
    
      <category term="每日一题" scheme="https://sulimin-nb.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>leetcode24-两两交换链表中的节点</title>
    <link href="https://sulimin-nb.github.io/article/76a9321a.html"/>
    <id>https://sulimin-nb.github.io/article/76a9321a.html</id>
    <published>2020-10-13T10:55:34.000Z</published>
    <updated>2020-10-13T11:57:07.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h1><p>给定一个链表，两两交换其中的相邻的节点，并返回交换后的链表。<br><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。<br><strong>示例1：</strong></p><p><img src="/article/76a9321a/swap_ex1.jpg" srcset="/img/loading.gif" alt="swap_ex1"></p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]</code></pre><p><strong>示例2：</strong></p><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span>输出：<span class="hljs-comment">[]</span></code></pre><p><strong>示例3：</strong></p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>]输出：[<span class="hljs-number">1</span>]</code></pre><p><strong>提示：</strong></p><ul><li><p>链表中节点的数目在范围[0, 100]内</p></li><li><p>0 &lt;= Node.val &lt;= 100</p></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h2><p>通过递归的方式实现两两交换链表中的节点。<br>递归的终止条件是链表中没有节点或者链表中只有一个节点，此时无法进行交换。<br>如果链表中至少存在两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新链表的第二个节点，原始链表的第二个节点变成新链表的头节点。链表中的其余节点的两两交换可以通过递归实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。</p><p>用head表示原始链表的头节点，newhead表示新链表的头节点，原始链表的第二个节点，则原始链表的其余节点的头节点是newhead.next。令head.next=swapPairs(newhead.next)，表示将其余节点进行两两交换，交换后的新的头节点为head的下一个节点。然后令newhead.next=head，即完成了所有节点的交换。最后返回新的链表的头节点newhead。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swapPairs</span><span class="hljs-params">(self, head: ListNode)</span>-&gt; ListNode:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.next:            <span class="hljs-keyword">return</span> head        newhead = head.next        head.next = self.swapPairs(newhead.next)        newhead.next = head        <span class="hljs-keyword">return</span> newhead</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(n)$，其中$n$是链表的节点数量。需要对每个节点进行更新指针的操作。</li><li>空间复杂度：$O(n)$，其中$n$是链表中的节点数量。空间复杂度主要取决于递归调用的栈空间。</li></ul><h2 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h2><p>通过迭代的方式实现两两交换链表中的节点。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swapPairs</span><span class="hljs-params">(self, head)</span>:</span>dummyhead = ListNode(<span class="hljs-number">0</span>)dummpyhead.next = headtemp = dummpyhead<span class="hljs-keyword">while</span> temp.next <span class="hljs-keyword">and</span> temp.next.next:        node1 = temp.next        node2 = temp.next.next        temp.next = node2        node1.next = node2.next        node2.next = node1        temp = node1   <span class="hljs-keyword">return</span> dummpyhead.next</code></pre><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度： $O(n)$，其中$n$是链表的节点数量。需要对每个节点进行更新指针的操作。</li><li>空间复杂度： $O(1)$。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/" target="_blank" rel="noopener">官方题解(动图好评)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;24-两两交换链表中的节点&quot;&gt;&lt;a href=&quot;#24-两两交换链表中的节点&quot; class=&quot;headerlink&quot; title=&quot;24.两两交换链表中的节点&quot;&gt;&lt;/a&gt;24.两两交换链表中的节点&lt;/h1&gt;&lt;p&gt;给定一个链表，两两交换其中的相邻的节点，并返回交换后
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/tags/leetcode/"/>
    
      <category term="每日一题" scheme="https://sulimin-nb.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>随笔-近来杂谈</title>
    <link href="https://sulimin-nb.github.io/article/426de11c.html"/>
    <id>https://sulimin-nb.github.io/article/426de11c.html</id>
    <published>2020-10-12T13:57:45.000Z</published>
    <updated>2020-10-12T14:51:38.937Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">You must enter the password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="b6e6733a8f96b4cdb41cc0ca15b29910d79f9eed77212f59f01c68454b59698b">d62c84b181f96c70c33a04a16adc5455d6c55bdcd421eb78318dd662ea3adb7d8d52f237ec081b387bdb2df856c6c17115b144a2f8e1ceadd1618288f96f8272bfb46dceec1a99a48e83e26f9e49af80dcf3ed06a83e457443f894a4abd77f39387b81c39fbd36965e9a85763053ae7e71079937ef0a2f40b8d2e52e0286ebb2cef6046399f7844bd6d97c6697c1a90a3853f44bc62d506b12da08c6b143c2434b755002f5ea45334627d7528206ccd14bc88e42db3478ed193a290d42a3040c5ff151a3a27317f41c1b37eee9a5c56927d31593f5672a4081b86f6bb54459f6193f1b3e596430b8c9d29da4ec70d8023de8a1effcc4f4a20d206e532a693dc6a94a3cc961d1ff34c5e5826bae261204831141bce1e64a0bcfa138b60c0564f18d9472ce9b707e06ed8c68db7d01cf18368f3e92eeac293f1c2e9261a91b8729393361dc7898a9d508a52d7bdb5bc21811207416611a7e8bd8cdc007beb2e85c62a76445cd17e8d6d4d647a93e7fcb2418fcacda84794477c5181451a25e4b4d017c380887e0362decd0e9f868b6f9d073df1f9ab8f25c015a3ae21ba37230af4f7643f6c716b7b8c4dee404d6ffa6c4d499b49433b61568e3c940d51d89731c102eaedcecb58315ac423229b9cc740dffbaa6c0c16a4265beb3e3479cc28b39c688f3707aa001680c4f68080441a127e195084ca283d8a336657e55b3790a4a596772a65d6ffa00253d2d73aab160b646b0ef89fe52232661008952d9772838be7dae1d9491c96dda4017cfcbdfb25ff15f1f10e75144a1dca8cae3c7911ecf33f66731dfb836571ba43a0b216d655e99f7126c26f96839c661d83cace62456273999c87467dd5098dcd62aad9b922b5bb493a90735a44a8242a2cf6faf6d9e4ecdbdc170aa907235f68703b8b52e866f2cb1a8cbe10c65849521366f95b6ca5b7258335389aa9089d558f6f6df45c4b395773b04d511ab7d7f3895c762b2a00dc846ec718e0004c174f1ba26b91a06180d9f73baa100069b7189b9dbfa35ee92876cbddd64eed3a93a6acd492317640ff54abeb0bfa1b10945c2eeb420eab418e54fefaf3d861d580eabdb6e00b7fee986807ddaecec3a84cdebe4bf2d104d1530f4386d75630af6de0008ae00eb085d1f5f65d7ea5cf14a085e1eda234e151effebd129e570ce911be4d4923751978edd8e1a57646494ade845f15e72ec45afa8abe546041da0af46041ad5908815e8ba65bc8588d50f9d88031a468ea34c9375e74a5760e98bab202b870f55dbd1e415c4ad23810a3c6758d2e9e1faca99093229b1ace0a6ca0b2e30dd43aebec4aeafe815d0c57e07471ae8cfd727ef88d44df06c3d3e4ab343a57a03c257706aaa2fcef5e914aef9fffccbd3069f7ad30ef0f046c806c91a8b57c8c0d02e1687af6bda52f3d7b8853339f0fa3dd6989df88192581775f32b317cfa405cdaecfb158b0ceeb77ce4690c406b52669aca9bea882e7c3ea8962e70a5a6fd54d6ea917f8403a7fbd9c70f0633d143a34e4a702ea50c28533f8ea351d540a5ff5a8c51b7a82a163aa1681831976c62b7efb539450143cc835f64252ae00c7be9d2ac7fba4899978de6df76c864424e0b5952bf5befa03463d03b272227aa1b42d174a7513a0b2385698f5433f22f0caef5467398ec91deb2c6ee234d31771fbc06d9efb225585a8124c2220b4559ff4bc8f285b99bf56f08a8a85fabb29b9665db534c213bf865c806a87f14437065f622c52ea9422e9213e99c589a606a7d6953c40a20cbecbd1d9ac1e923edd4de241b2f76aeba473a91b1cbec014b5fb438c93a2c565775808169ff5fe01ef3a3f19b07f6eb175c1582993d3aeb37a24a1ec8c818f38d192d62d38643d5ab7e5f3c1a5f45a2d2883281a82e77ef1c2cec74fe747349dcc9d9b8b6862bb2bafd1c759da7dfea1919d0b03d53b5a1df3ff913c71d872ca335d4931713cf2bc5ca53b7dbc0d35da02ab18747cbaa4db3a343175a94489c17edcf3aa2b9cb6163092ec0064f2288bffe1e24e846afc7061265c4b06c24bc7ad5c6276d02709ce229fd5dde3723fd8c78ed4c874400a3fd2c428ae469e0d9478861582b1ee25f749246755de920895824d56afcc2ead3fad3390db4ca5f96eef7a622c31f08fa667d6224adc64e215728cc4e0b90ebc2d49ab7df8578d94dd67950246824f99cd92c3edbb554f10b7bcef9a56e9066aa66f888aff349c0fbbad6075ef67374de5034a2c854c06f0dbc0b86714a6535049e1b983655296b1cf1f1804efd5f622555d70838115c43def7449db3f2d3cb80da03916a70b151756f21b2d65d63acca69ec37731b593b25e9b9e239382923800db0c1396075aa52ac19f8a9514163c09949823778fcb13a42238ca5fff9b5b1bd7a8851f85f1f0461a6dc7be84a21d7689ecdf6af6cc564fdb6375bdced17fe61f389c59e4cb5a202f44a45808c59b851795412ed35287fa72f28f93a4c08987b5da894d2dc4006d98db000b33788bbf423e769067386ae7cdd6faf46723efc1b3114eae1b2ea2736f90776043067b3369ece2c435cbec9ed587c6b5346755de0fa63da3e549378fbaa510fd5358382d32e82294db0c0b9566bf993b10e9d7766849f7d68e8cc46b379aee49b1eb7398732d4ed1c0d863d65c9a143e9829542bd000aacd0f92eea94e3d696154c81705be1250891e4b35ad963c039d36a85e6cef565b1383e38baf0a85d06f2dc609a073e5c963302e1bd87ae22f42f7f2a1e3090358424ace74cb4862663d4e8c75b8525e07173f7069cc8411910872fa7e6707e7e42c538f12a6ffc161c73d72ebf323afaf4f8791d982cd8918c815d53900703fd6fc58441ffd6e0fc17631b6f223bdedc4589187bdc4071fcd18453b9e3ced3cf2c35c78949d0c4abefde0b56998472e7add9596a54e0222b3a01fd2cf6430876293fd37495892f1493f38330651203dd6385d8f5dc29b162a01daa5c9edda4ecd4cd9f04a03bf2683a50a430f3c3f7b3b78337d80f0474acaca3f27c1761add7406e304c66d751e5d3319f90d77b414fb21ea12ee00c3b4d9027ac2f476021113508d6df981f76f68357c1b01ef3573b3a91764ec5bbc12650373c5d37f632a093498fc0d691705a39b58531e7c6f0c477190cce521034c238e024cb7fdece492de43a0776f44503e1735bcab767a338062afb420c07541d74bbb64f5b21ad0c2df33e33a8ee93b11dea51585f98e02e90ca5ca5959ee19527afdd364da971f08e52a9560a2aec01105049b5de8fcafdffb61f09ff716b521934a31d08307656cabb9da6d54ed9b479a4ce48ede4eb36eb4f302b97b97279c37c3f6d7c80c71ef074336d4a0a7a9fdabbeb59b42991c579f193e9a704b927396b4d9701c4be220a77d204a69075903d77d5ee16101e97b7d7050acaad914d51e50d11f3d8d170c6c076fe29aecc373d24745aaeacd62b47cc707182754bb77121daa47180221db832b445ac7c41044e9e390f0fe1640fe82d98ab148bd0cf32e510c1a435095fbf398ea684a0ccff780dd6d32277675b6f169efbc260cb2af144040def23eb8a80a337bfa47c8c72bddaedde8587c58e4347beac8383fec91b31fe78a76eb258c03833716aa294a059686c41a83af74b33d55763412885d3aae678b35e43c2a47872cd963426233a0b4495bcbb56c31932eb38b94419d9000e8622f4080fe868e368a17805e8ba65a00ca40e5ca7a50681de178e24b8097208338b814f0f379c7483f7e57231b2107b4a3e1549cfd51e32a5b5a728863e7d19cca5163bfc8c1d7752dbfe7922c90dc36886bd454b2cd357f717004dd333f98378689374533d2048d0d2a652d60611bc0aee90ae3323a35a76830ae1b36fe555991646a14c3a99ac29b24c25f03d94e2b58bb80ba352e600aa44dcb88778462c2ca106d227a314eabdbc27</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      This blog is encrypted.
    
    </summary>
    
    
      <category term="随笔" scheme="https://sulimin-nb.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://sulimin-nb.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>leetcode530-二叉搜索树的最小绝对差</title>
    <link href="https://sulimin-nb.github.io/article/d3786335.html"/>
    <id>https://sulimin-nb.github.io/article/d3786335.html</id>
    <published>2020-10-12T13:48:15.000Z</published>
    <updated>2020-10-13T02:59:44.139Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h1><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>  git config —global user.email “you@example.com”<br>  git config —global user.name “Your Name”</p><p>对升序数组$a$求任意两个元素之差的绝对值的最小值，答案一定为相邻两个元素之差的最小值，即</p><script type="math/tex; mode=display">ans = min^{n-2}_{i=0}\{a[i+1] - a[i]\}</script><p>其中$n$为数组$a$的长度。<br>二叉搜索树的性质：<strong>二叉搜索树中序遍历得到的值序列是递增有序的。</strong>因此只要得到中序遍历后的值序列就能使用上述方法求解。<br>朴素的方法：经过一次中序遍历后将值保存在一个数组中进行遍历求解。简易：在中序遍历的过程中用$pre$变量保存前驱节点的值，这样能边遍历边更新答案，一次遍历即可得到答案(无需保存数组和再次遍历)。需要注意 的是$pre$的初始值需要设置为任意负数标记开头，代码中设置为1。<br>二叉树的中序遍历有多种方式，包括递归、栈、Morris遍历等。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-comment"># class TreeNode:</span><span class="hljs-comment">#     def __init__(self, x):</span><span class="hljs-comment">#         self.val = x</span><span class="hljs-comment">#         self.left = None</span><span class="hljs-comment">#         self.right = None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    ans = <span class="hljs-number">999</span>    pre = <span class="hljs-number">-1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; int:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root)</span>:</span>            <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:                <span class="hljs-keyword">return</span>            dfs(root.left)            <span class="hljs-keyword">if</span> self.pre == <span class="hljs-number">-1</span>:                self.pre = root.val            <span class="hljs-keyword">else</span>:                self.ans = min(self.ans, abs(root.val - self.pre))                self.pre = root.val            dfs(root.right)        dfs(root)        <span class="hljs-keyword">return</span> self.ans</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：$O(n)$，其中$n$为二叉搜索树节点的个数。每个节点在中序遍历中都会访问一次且只会被访问一次，因此总时间复杂度为$O(n)$。</li><li>空间复杂度：$O(n)$。递归函数的空间复杂度取决于递归的栈深度，而栈深度在二叉搜索树为一条链的情况下会达到$O(n)$的级别。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;二叉搜索树的最小绝对差&quot;&gt;&lt;a href=&quot;#二叉搜索树的最小绝对差&quot; class=&quot;headerlink&quot; title=&quot;二叉搜索树的最小绝对差&quot;&gt;&lt;/a&gt;二叉搜索树的最小绝对差&lt;/h1&gt;&lt;p&gt;给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/categories/leetcode/"/>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/tags/leetcode/"/>
    
      <category term="每日一题" scheme="https://sulimin-nb.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法-查找</title>
    <link href="https://sulimin-nb.github.io/article/bd63ef17.html"/>
    <id>https://sulimin-nb.github.io/article/bd63ef17.html</id>
    <published>2020-08-26T01:15:58.000Z</published>
    <updated>2020-08-26T01:17:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一-查找表"><a href="#一-查找表" class="headerlink" title="一.查找表"></a>一.查找表</h1><h2 id="考虑的基本数据结构"><a href="#考虑的基本数据结构" class="headerlink" title="考虑的基本数据结构"></a>考虑的基本数据结构</h2><p><strong>第一类： 查找有无—set</strong></p><p>元素’a’是否存在，通常用set：集合</p><p>set只存储键，而不需要对应其相应的值。 </p><p>set中的键不允许重复</p><p><strong>第二类： 查找对应关系(键值对应)—dict</strong></p><p>元素’a’出现了几次：dict—&gt;字典</p><p>dict中的键不允许重复</p><p><strong>第三类： 改变映射关系—map</strong></p><p>通过将原有序列的关系映射统一表示为其他</p><h2 id="算法应用"><a href="#算法应用" class="headerlink" title="算法应用"></a>算法应用</h2><h3 id="LeetCode-349-Intersection-Of-Two-Arrays-1"><a href="#LeetCode-349-Intersection-Of-Two-Arrays-1" class="headerlink" title="LeetCode 349 Intersection Of Two Arrays 1"></a>LeetCode 349 Intersection Of Two Arrays 1</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个数组nums,求两个数组的公共元素。</p><pre><code class="hljs angelscript">如nums1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],nums2 = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]结果为[<span class="hljs-number">2</span>]结果中每个元素只能出现一次出现的顺序可以是任意的</code></pre><h4 id="分析实现"><a href="#分析实现" class="headerlink" title="分析实现"></a>分析实现</h4><p>由于每个元素只出现一次，因此不需要关注每个元素出现的次数，用set的数据结构就可以了。记录元素的有和无。</p><p>把nums1记录为set，判断nums2的元素是否在set中，是的话，就放在一个公共的set中，最后公共的set就是我们要的结果。</p><p>代码如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intersection</span><span class="hljs-params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span>        nums1 = set(nums1)        <span class="hljs-keyword">return</span> set([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums2 <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> nums1])</code></pre><p>也可以通过set的内置方法来实现，直接求set的交集：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intersection</span><span class="hljs-params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span>        set1 = set(nums1)        set2 = set(nums2)        <span class="hljs-keyword">return</span> set2 &amp; set1</code></pre><h3 id="LeetCode-350-Intersection-Of-Two-Arrays-2"><a href="#LeetCode-350-Intersection-Of-Two-Arrays-2" class="headerlink" title="LeetCode 350 Intersection Of Two Arrays 2"></a>LeetCode 350 Intersection Of Two Arrays 2</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个数组nums,求两个数组的交集。</p><p>— 如nums1=[1,2,2,1],nums=[2,2]</p><p>— 结果为[2,2]</p><p>— 出现的顺序可以是任意的</p><h4 id="分析实现-1"><a href="#分析实现-1" class="headerlink" title="分析实现"></a>分析实现</h4><p>元素出现的次数有用，那么对于存储次数就是有意义的，所以选择数据结构时，就应该选择dict的结构，通过字典的比较来判断；</p><p>记录每个元素的同时要记录这个元素的频次。</p><p>记录num1的字典，遍历nums2，比较nums1的字典的nums的key是否大于零，从而进行判断。</p><p>代码如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intersect</span><span class="hljs-params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter        nums1_dict = Counter(nums1)        res = []        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums2:            <span class="hljs-keyword">if</span> nums1_dict[num] &gt; <span class="hljs-number">0</span>:                <span class="hljs-comment"># 说明找到了一个元素即在num1也在nums2</span>                res.append(num)                nums1_dict[num] -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre><h3 id="LeetCode-242-Intersection-Of-Two-Arrays-2"><a href="#LeetCode-242-Intersection-Of-Two-Arrays-2" class="headerlink" title="LeetCode 242 Intersection Of Two Arrays 2"></a>LeetCode 242 Intersection Of Two Arrays 2</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><pre><code class="hljs nix">示例<span class="hljs-number">1</span>:输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"anagram"</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">"nagaram"</span>输出: <span class="hljs-literal">true</span>示例 <span class="hljs-number">2</span>:输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"rat"</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">"car"</span>输出: <span class="hljs-literal">false</span></code></pre><h4 id="分析实现-2"><a href="#分析实现-2" class="headerlink" title="分析实现"></a>分析实现</h4><p>判断异位词即判断变换位置后的字符串和原来是否相同，那么不仅需要存储元素，还需要记录元素的个数。可以选择dict的数据结构，将字符串s和t都用dict存储，而后直接比较两个dict是否相同。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(self, s: str, t: str)</span> -&gt; bool:</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter        s = Counter(s)        t = Counter(t)        <span class="hljs-keyword">if</span> s == t:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre><h3 id="LeetCode-202-Happy-number"><a href="#LeetCode-202-Happy-number" class="headerlink" title="LeetCode 202 Happy number"></a>LeetCode 202 Happy number</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>编写一个算法来判断一个数是不是“快乐数”。</p><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><pre><code class="hljs angelscript">示例: 输入: <span class="hljs-number">19</span>输出: <span class="hljs-literal">true</span>解释: <span class="hljs-number">1</span>^<span class="hljs-number">2</span> + <span class="hljs-number">9</span>^<span class="hljs-number">2</span> = <span class="hljs-number">82</span><span class="hljs-number">8</span>^<span class="hljs-number">2</span> + <span class="hljs-number">2</span>^<span class="hljs-number">2</span> = <span class="hljs-number">68</span><span class="hljs-number">6</span>^<span class="hljs-number">2</span> + <span class="hljs-number">8</span>^<span class="hljs-number">2</span> = <span class="hljs-number">100</span><span class="hljs-number">1</span>^<span class="hljs-number">2</span> + <span class="hljs-number">0</span>^<span class="hljs-number">2</span> + <span class="hljs-number">0</span>^<span class="hljs-number">2</span> = <span class="hljs-number">1</span></code></pre><h4 id="分析实现-3"><a href="#分析实现-3" class="headerlink" title="分析实现"></a>分析实现</h4><p>这道题目思路很明显，当n不等于1时就循环，每次循环时，将其最后一位到第一位的数依次平方求和，比较求和是否为1。</p><p>难点在于，什么时候跳出循环？</p><p>开始笔者的思路是，循环个100次，还没得出结果就false，但是小学在算无限循环小数时有一个特征，就是当除的数中，和之前历史的得到的数有重合时，这时就是无限循环小数。</p><p>那么这里也可以按此判断，因为只需要判断有或无，不需要记录次数，故用set的数据结构。每次对求和的数进行append，当新一次求和的值存在于set中时，就return false.</p><p>代码如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(self, n: int)</span> -&gt; bool:</span>        already = set()        <span class="hljs-keyword">while</span> n != <span class="hljs-number">1</span>:            sum = <span class="hljs-number">0</span>            <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:                <span class="hljs-comment"># 取n的最后一位数</span>                tmp = n % <span class="hljs-number">10</span>                   sum += tmp ** <span class="hljs-number">2</span>                <span class="hljs-comment"># 将n的最后一位截掉</span>                n //= <span class="hljs-number">10</span>            <span class="hljs-comment"># 如果求的和在过程中出现过</span>            <span class="hljs-keyword">if</span> sum <span class="hljs-keyword">in</span> already:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                already.add(sum)            n = sum        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><pre><code class="hljs python"><span class="hljs-comment">#一般对多位数计算的套路是：</span><span class="hljs-comment">#循环从后向前取位数</span><span class="hljs-keyword">while</span> n &gt;<span class="hljs-number">0</span> :<span class="hljs-comment">#取最后一位： </span>tmp = n % <span class="hljs-number">10</span><span class="hljs-comment">#再截掉最后一位：</span>n = n // <span class="hljs-number">10</span></code></pre><h3 id="LeetCode-290-Word-Pattern"><a href="#LeetCode-290-Word-Pattern" class="headerlink" title="LeetCode 290 Word Pattern"></a>LeetCode 290 Word Pattern</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出一个模式(pattern)以及一个字符串，判断这个字符串是否符合模式</p><pre><code class="hljs nix">示例<span class="hljs-number">1</span>:输入: <span class="hljs-attr">pattern</span> = <span class="hljs-string">"abba"</span>, <span class="hljs-attr">str</span> = <span class="hljs-string">"dog cat cat dog"</span>输出: <span class="hljs-literal">true</span>示例 <span class="hljs-number">2</span>:输入:<span class="hljs-attr">pattern</span> = <span class="hljs-string">"abba"</span>, <span class="hljs-attr">str</span> = <span class="hljs-string">"dog cat cat fish"</span>输出: <span class="hljs-literal">false</span>示例 <span class="hljs-number">3</span>:输入: <span class="hljs-attr">pattern</span> = <span class="hljs-string">"aaaa"</span>, <span class="hljs-attr">str</span> = <span class="hljs-string">"dog cat cat dog"</span>输出: <span class="hljs-literal">false</span>示例 <span class="hljs-number">4</span>:输入: <span class="hljs-attr">pattern</span> = <span class="hljs-string">"abba"</span>, <span class="hljs-attr">str</span> = <span class="hljs-string">"dog dog dog dog"</span>输出: <span class="hljs-literal">false</span></code></pre><h4 id="分析实现-4"><a href="#分析实现-4" class="headerlink" title="分析实现"></a>分析实现</h4><p>抓住变与不变，笔者开始的思路是选择了dict的数据结构，比较count值和dict对应的keys的个数是否相同，但是这样无法判断顺序的关系，如测试用例：’aba’,’cat cat dog’。</p><p>那么如何能<strong>既考虑顺序</strong>，也考虑<strong>键值对应的关系</strong>呢？</p><p>抓住变与不变，变的是键，但是不变的是各个字典中，对应的相同index下的值，如dict1[index] = dict2[index]，那么我们可以创建两个新的字典，遍历index对两个新的字典赋值，并比较value。</p><p>还有一个思路比较巧妙，既然不同，那么可以考虑怎么让它们相同，将原来的dict通过map映射为相同的key，再比较相同key的dict是否相同。</p><p>代码实现如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wordPattern</span><span class="hljs-params">(self,pattern, str)</span>:</span>        str = str.split()        <span class="hljs-keyword">return</span> list(map(pattern.index,pattern)) == list(map(str.index,str))</code></pre><h4 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h4><ol><li>因为str是字符串，不是由单个字符组成，所以开始需要根据空格拆成字符list：</li></ol><pre><code class="hljs python">str = str.split()</code></pre><ol><li>通过map将字典映射为index的list:</li></ol><pre><code class="hljs python">map(pattern.index, pattern)</code></pre><ol><li>map是通过hash存储的，不能直接进行比较，需要转换为list比较list</li></ol><h3 id="LeetCode-205-Isomorphic-Strings"><a href="#LeetCode-205-Isomorphic-Strings" class="headerlink" title="LeetCode 205 Isomorphic Strings"></a>LeetCode 205 Isomorphic Strings</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p><p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><pre><code class="hljs nix">示例 <span class="hljs-number">1</span>:输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"egg"</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">"add"</span>输出: <span class="hljs-literal">true</span>示例 <span class="hljs-number">2</span>:输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"foo"</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">"bar"</span>输出: <span class="hljs-literal">false</span>示例 <span class="hljs-number">3</span>:输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"paper"</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">"title"</span>输出: <span class="hljs-literal">true</span></code></pre><h4 id="分析实现-5"><a href="#分析实现-5" class="headerlink" title="分析实现"></a>分析实现</h4><p>思路与上题一致，可以考虑通过建两个dict，比较怎样不同，也可以将不同转化为相同。</p><p>直接用上题的套路代码：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(self, s: str, t: str)</span> -&gt; bool:</span>        <span class="hljs-keyword">return</span> list(map(s.index,s)) == list(map(t.index,t))</code></pre><h3 id="LeetCode-451-Sort-Characters-By-Frequency"><a href="#LeetCode-451-Sort-Characters-By-Frequency" class="headerlink" title="LeetCode 451 Sort Characters By Frequency"></a>LeetCode 451 Sort Characters By Frequency</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p><pre><code class="hljs makefile">示例 1:<span class="hljs-section">输入:</span><span class="hljs-string">"tree"</span><span class="hljs-section">输出:</span><span class="hljs-string">"eert"</span>示例 2:<span class="hljs-section">输入:</span><span class="hljs-string">"cccaaa"</span><span class="hljs-section">输出:</span><span class="hljs-string">"cccaaa"</span>示例 3:<span class="hljs-section">输入:</span><span class="hljs-string">"Aabb"</span><span class="hljs-section">输出:</span><span class="hljs-string">"bbAa"</span></code></pre><h4 id="分析实现-6"><a href="#分析实现-6" class="headerlink" title="分析实现"></a>分析实现</h4><p>对于相同频次的字母，顺序任意，需要考虑大小写，返回的是字符串。</p><p>使用字典统计频率，对字典的value进行排序，最终根据key的字符串乘上value次数，组合在一起输出。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">frequencySort</span><span class="hljs-params">(self, s: str)</span> -&gt; str:</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter        s_dict = Counter(s)        <span class="hljs-comment"># sorted返回的是列表元组</span>        s = sorted(s_dict.items(), key=<span class="hljs-keyword">lambda</span> item:item[<span class="hljs-number">1</span>], reverse = <span class="hljs-literal">True</span>)        <span class="hljs-comment"># 因为返回的是字符串</span>        res = <span class="hljs-string">''</span>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> s:            res += key * value           <span class="hljs-keyword">return</span> res</code></pre><h4 id="tips-2"><a href="#tips-2" class="headerlink" title="tips"></a>tips</h4><ol><li>通过sorted的方法进行value排序，对字典排序后无法直接按照字典进行返回，返回的为列表元组：</li></ol><pre><code class="hljs python"><span class="hljs-comment"># 对value值由大到小排序</span>s = sorted(s_dict.items(), key=<span class="hljs-keyword">lambda</span> item:item[<span class="hljs-number">1</span>], reverse = <span class="hljs-literal">True</span>)<span class="hljs-comment"># 对key由小到大排序</span>s = sorted(s_dict.items(), key=<span class="hljs-keyword">lambda</span> item:item[<span class="hljs-number">0</span>])</code></pre><ol><li>输出为字符串的情况下，可以由字符串直接进行拼接:</li></ol><pre><code class="hljs python"><span class="hljs-comment"># 由key和value相乘进行拼接</span><span class="hljs-string">'s'</span> * <span class="hljs-number">5</span> + <span class="hljs-string">'d'</span>*<span class="hljs-number">2</span></code></pre><h1 id="二-对撞指针"><a href="#二-对撞指针" class="headerlink" title="二. 对撞指针"></a>二. 对撞指针</h1><h1 id="LeetCode-1-Two-Sum"><a href="#LeetCode-1-Two-Sum" class="headerlink" title="LeetCode 1 Two Sum"></a>LeetCode 1 Two Sum</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个整型数组nums，返回这个数组中两个数字的索引值i和j，使得nums[i] + nums[j]等于一个给定的target值，两个索引不能相等。</p><p>如：nums= [2,7,11,15],target=9<br>返回[0,1]</p><h2 id="审题"><a href="#审题" class="headerlink" title="审题:"></a>审题:</h2><p>需要考虑：</p><ol><li>开始数组是否有序；</li><li>索引从0开始计算还是1开始计算？</li><li>没有解该怎么办？</li><li>有多个解怎么办？保证有唯一解。</li></ol><h2 id="分析实现-7"><a href="#分析实现-7" class="headerlink" title="分析实现"></a>分析实现</h2><h2 id="暴力法O-n-2"><a href="#暴力法O-n-2" class="headerlink" title="暴力法O(n^2)"></a>暴力法O(n^2)</h2><p>时间复杂度为O(n^2),第一遍遍历数组，第二遍遍历当前遍历值之后的元素，其和等于target则return。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span>        len_nums = len(nums)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len_nums):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>,len_nums):                <span class="hljs-keyword">if</span> nums[i] + nums[j] == target:                    <span class="hljs-keyword">return</span> [i,j]</code></pre><h2 id="排序-指针对撞-O-n-O-nlogn-O-n"><a href="#排序-指针对撞-O-n-O-nlogn-O-n" class="headerlink" title="排序+指针对撞(O(n)+O(nlogn)=O(n))"></a>排序+指针对撞(O(n)+O(nlogn)=O(n))</h2><p>在数组篇的LeetCode 167题中，也遇到了找到两个数使得它们相加之和等于目标数，但那是对于排序的情况，因此也可以使用上述的思路来完成。</p><p>因为问题本身不是有序的，因此需要对原来的数组进行一次排序，排序后就可以用O(n)的指针对撞进行解决。</p><p>但是问题是，返回的是数字的索引，如果只是对数组的值进行排序，那么数组原来表示的索引的信息就会丢失，所以在排序前要进行些处理。</p><p><strong>错误代码示例—只使用dict来进行保存：</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span>        record = dict()        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> range(len(nums)):            record[nums[index]] = index         nums.sort()        l,r = <span class="hljs-number">0</span>,len(nums)<span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> l &lt; r:            <span class="hljs-keyword">if</span> nums[l] + nums[r] == target:                <span class="hljs-keyword">return</span> [record[nums[l]],record[nums[r]]]            <span class="hljs-keyword">elif</span> nums[l] + nums[r] &lt; target:                l += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                r -= <span class="hljs-number">1</span></code></pre><p>当遇到<strong>相同的元素的索引</strong>问题时，会不满足条件：</p><p>如：[3,3]  6</p><p>在排序前先使用一个额外的数组<strong>拷贝</strong>一份原来的数组，对于两个相同元素的索引问题，使用一个<strong>bool型变量</strong>辅助将两个索引都找到，总的时间复杂度为O(n)+O(nlogn) = O(nlogn)</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span>        record = dict()        nums_copy = nums.copy()        sameFlag = <span class="hljs-literal">True</span>;        nums.sort()        l,r = <span class="hljs-number">0</span>,len(nums)<span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> l &lt; r:            <span class="hljs-keyword">if</span> nums[l] + nums[r] == target:                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">elif</span> nums[l] + nums[r] &lt; target:                l += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                r -= <span class="hljs-number">1</span>        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            <span class="hljs-keyword">if</span> nums_copy[i] == nums[l] <span class="hljs-keyword">and</span> sameFlag:                res.append(i)                sameFlag = <span class="hljs-literal">False</span>            <span class="hljs-keyword">elif</span> nums_copy[i] == nums[r]:                res.append(i)        <span class="hljs-keyword">return</span> res</code></pre><h3 id="小套路"><a href="#小套路" class="headerlink" title="小套路:"></a>小套路:</h3><p>如果只是对数组的值进行排序，那么数组原来表示的索引的信息就会丢失的情况，可以在排序前：</p><h3 id="更加pythonic的实现"><a href="#更加pythonic的实现" class="headerlink" title="更加pythonic的实现"></a>更加pythonic的实现</h3><p>通过list(enumerate(nums))开始实现下标和值的绑定，不用专门的再copy加bool判断。</p><pre><code class="hljs python">nums = list(enumerate(nums))nums.sort(key = <span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>])i,j = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span><span class="hljs-keyword">while</span> i &lt; j:    <span class="hljs-keyword">if</span> nums[i][<span class="hljs-number">1</span>] + nums[j][<span class="hljs-number">1</span>] &gt; target:        j -= <span class="hljs-number">1</span>    <span class="hljs-keyword">elif</span> nums[i][<span class="hljs-number">1</span>] + nums[j][<span class="hljs-number">1</span>] &lt; target:        i += <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">if</span> nums[j][<span class="hljs-number">0</span>] &lt; nums[i][<span class="hljs-number">0</span>]:            nums[j],nums[i] = nums[i],nums[j]        <span class="hljs-keyword">return</span> num[i][<span class="hljs-number">0</span>],nums[j][<span class="hljs-number">0</span>]</code></pre><p><strong>拷贝数组 + bool型变量辅助</strong></p><h2 id="查找表—O-n"><a href="#查找表—O-n" class="headerlink" title="查找表—O(n)"></a>查找表—O(n)</h2><p>遍历数组过程中，当遍历到元素v时，可以只看v前面的元素，是否含有target-v的元素存在。</p><ol><li>如果查找成功，就返回解；</li><li>如果没有查找成功，就把v放在查找表中，继续查找下一个解。</li></ol><p>即使v放在了之前的查找表中覆盖了v，也不影响当前v元素的查找。因为只需要找到两个元素，只需要找target-v的另一个元素即可。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span>        record = dict()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            complement = target - nums[i]            <span class="hljs-comment"># 已经在之前的字典中找到这个值</span>            <span class="hljs-keyword">if</span> record.get(complement) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:                res = [i,record[complement]]                <span class="hljs-keyword">return</span> res            record[nums[i]] = i</code></pre><p>只进行一次循环，故时间复杂度O(n),空间复杂度为O(n)</p><h2 id="补充思路："><a href="#补充思路：" class="headerlink" title="补充思路："></a>补充思路：</h2><p>通过enumerate来把索引和值进行绑定，进而对value进行sort，前后对撞指针进行返回。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span>        nums = list(enumerate(nums))        <span class="hljs-comment"># 根据value来排序</span>        nums.sort(key = <span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>])        l,r = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> l &lt; r:            <span class="hljs-keyword">if</span> nums[l][<span class="hljs-number">1</span>] + nums[r][<span class="hljs-number">1</span>] == target:                <span class="hljs-keyword">return</span> nums[l][<span class="hljs-number">0</span>],nums[r][<span class="hljs-number">0</span>]            <span class="hljs-keyword">elif</span> nums[l][<span class="hljs-number">1</span>] + nums[r][<span class="hljs-number">1</span>] &lt; target:                l += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                r -= <span class="hljs-number">1</span></code></pre><h1 id="LeetCode-15-3Sum"><a href="#LeetCode-15-3Sum" class="headerlink" title="LeetCode 15 3Sum"></a>LeetCode 15 3Sum</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个整型数组，寻找其中的所有不同的三元组(a,b,c)，使得a+b+c=0</p><p>注意：答案中不可以包含重复的三元组。</p><p>如：nums = [-1, 0, 1, 2, -1, -4]，</p><p>结果为：[[-1, 0, 1],[-1, -1, 2]]</p><h2 id="审题-1"><a href="#审题-1" class="headerlink" title="审题"></a>审题</h2><ol><li>数组不是有序的；</li><li>返回结果为全部解，多个解的顺序是否需要考虑？—不需要考虑顺序</li><li>什么叫不同的三元组？索引不同即不同，还是值不同？—题目定义的是，值不同才为不同的三元组</li><li>没有解时怎么返回？—空列表</li></ol><h2 id="分析实现-8"><a href="#分析实现-8" class="headerlink" title="分析实现"></a>分析实现</h2><p>因为上篇中已经实现了Two Sum的问题，因此对于3Sum，首先想到的思路就是，开始固定一个k，然后在其后都当成two sum问题来进行解决，但是这样就ok了吗？</p><h3 id="没有考虑重复元素导致错误"><a href="#没有考虑重复元素导致错误" class="headerlink" title="没有考虑重复元素导致错误"></a>没有考虑重复元素导致错误</h3><p>直接使用Two Sum问题中的查找表的解法，根据第一层遍历的i，将i之后的数组作为two sum问题进行解决。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(self, nums: [int])</span> -&gt; [[int]]:</span>        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            num = <span class="hljs-number">0</span> - nums[i]            record = dict()            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i + <span class="hljs-number">1</span>, len(nums)):                complement = num - nums[j]                <span class="hljs-comment"># 已经在之前的字典中找到这个值</span>                <span class="hljs-keyword">if</span> record.get(complement) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:                    res_lis = [nums[i], nums[j], complement]                    res.append(res_lis)                record[nums[j]] = i        <span class="hljs-keyword">return</span> res</code></pre><p>但是这样会导致一个错误，错误用例如下:</p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-4</span>]输出：[[<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>]]预期结果：[[<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]</code></pre><p>代码在实现的过程中没有把第一次遍历的i的索引指向相同元素的情况排除掉，于是出现了当i指针后面位置的元素有和之前访问过的相同的值，于是重复遍历。</p><p>那么可以考虑，开始时对nums数组进行排序，排序后，当第一次遍历的指针k遇到下一个和前一个指向的值重复时，就将其跳过。为了方便计算，在第二层循环中，可以使用<strong>对撞指针</strong>的套路：</p><pre><code class="hljs python"><span class="hljs-comment"># 对撞指针套路</span>l,r = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span><span class="hljs-keyword">while</span> l &lt; r:    <span class="hljs-keyword">if</span> nums[l] + nums[r] == target:        <span class="hljs-keyword">return</span> nums[l],nums[r]    <span class="hljs-keyword">elif</span> nums[l] + nums[r] &lt; target:        l += <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>:        r -= <span class="hljs-number">1</span></code></pre><p>其中需要注意的是，在里层循环中，也要考虑重复值的情况，因此当值相等时，再次移动指针时，需要保证其指向的值和前一次指向的值不重复，因此可以：</p><pre><code class="hljs python"><span class="hljs-comment"># 对撞指针套路</span>l,r = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span><span class="hljs-keyword">while</span> l &lt; r:    sum = nums[i] + nums[l] + nums[r]    <span class="hljs-keyword">if</span> sum == target:        res.append([nums[i],nums[l],nums[r])        l += <span class="hljs-number">1</span>        r -= <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> nums[l] == nums[l<span class="hljs-number">-1</span>]: l += <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> nums[r] == nums[r+<span class="hljs-number">1</span>]: r -= <span class="hljs-number">1</span>    <span class="hljs-keyword">elif</span> sum &lt; target:        l += <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>:        r -= <span class="hljs-number">1</span></code></pre><p>再调整下遍历的范围，因为设了3个索引：i，l，r。边界情况下，r索引指向len-1, l指向len-2，索引i遍历的边界为len-3，故for循环是从0到len-2。</p><p>代码实现如下：</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(self, nums: [int])</span> -&gt; [[int]]:</span>        nums.sort()        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)<span class="hljs-number">-2</span>):            <span class="hljs-comment"># 因为是排序好的数组，如果最小的都大于0可以直接排除</span>            <span class="hljs-keyword">if</span> nums[i] &gt; <span class="hljs-number">0</span>: <span class="hljs-keyword">break</span>            <span class="hljs-comment"># 排除i的重复值</span>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i<span class="hljs-number">-1</span>]: <span class="hljs-keyword">continue</span>            l,r = i+<span class="hljs-number">1</span>, len(nums)<span class="hljs-number">-1</span>            <span class="hljs-keyword">while</span> l &lt; r:                sum = nums[i] + nums[l] + nums[r]                <span class="hljs-keyword">if</span> sum == <span class="hljs-number">0</span>:                    res.append([nums[i],nums[l],nums[r]])                    l += <span class="hljs-number">1</span>                    r -= <span class="hljs-number">1</span>                    <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> nums[l] == nums[l<span class="hljs-number">-1</span>]: l += <span class="hljs-number">1</span>                    <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> nums[r] == nums[r+<span class="hljs-number">1</span>]: r -= <span class="hljs-number">1</span>                <span class="hljs-keyword">elif</span> sum &lt; <span class="hljs-number">0</span>:                    l += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    r -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre><h2 id="小套路-1"><a href="#小套路-1" class="headerlink" title="小套路"></a>小套路</h2><ol><li>采用<strong>for + while</strong>的形式来处理三索引；</li><li>当数组不是有序时需要注意，有序的特点在哪里，有序就可以用哪些方法解决？无序的话不便在哪里？</li><li>对撞指针套路：</li></ol><pre><code class="hljs python"><span class="hljs-comment"># 对撞指针套路</span>l,r = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span><span class="hljs-keyword">while</span> l &lt; r:    <span class="hljs-keyword">if</span> nums[l] + nums[r] == target:        <span class="hljs-keyword">return</span> nums[l],nums[r]    <span class="hljs-keyword">elif</span> nums[l] + nums[r] &lt; target:        l += <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>:        r -= <span class="hljs-number">1</span></code></pre><ol><li>处理重复值的套路：先转换为有序数组，再循环判断其与上一次值是否重复：</li></ol><pre><code class="hljs python"><span class="hljs-comment"># 1.</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):    <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i<span class="hljs-number">-1</span>]: <span class="hljs-keyword">continue</span><span class="hljs-comment"># 2.</span><span class="hljs-keyword">while</span> l &lt; r:    <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> nums[l] == nums[l<span class="hljs-number">-1</span>]: l += <span class="hljs-number">1</span></code></pre><h1 id="LeetCode-18-4Sum"><a href="#LeetCode-18-4Sum" class="headerlink" title="LeetCode 18 4Sum"></a>LeetCode 18 4Sum</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个整形数组，寻找其中的所有不同的四元组(a,b,c,d)，使得a+b+c+d等于一个给定的数字target。</p><pre><code class="hljs angelscript">如:nums = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>]，target = <span class="hljs-number">0</span>结果为：[[<span class="hljs-number">-1</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],[<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],[<span class="hljs-number">-2</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>]]</code></pre><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>4Sum可以当作是3Sum问题的扩展，注意事项仍是一样的，同样是不能返回重复值得解。首先排序。接着从[0,len-1]遍历i，跳过i的重复元素，再在[i+1,len-1]中遍历j，得到i，j后，再选择首尾的l和r，通过对撞指针的思路，四数和大的话r—，小的话l++,相等的话纳入结果list，最后返回。</p><p>套用3Sum得代码，在其前加一层循环，对边界情况进行改动即可:</p><ol><li>原来3个是到len-2,现在外层循环是到len-3;</li><li>在中间层得迭代中，当第二个遍历得值在第一个遍历得值之后且后项大于前项时，认定为重复；</li><li>加些边界条件判断：当len小于4时，直接返回；当只有4个值且长度等于target时，直接返回本身即可。</li></ol><p>代码实现如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fourSum</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span>        nums.sort()        res = []        <span class="hljs-keyword">if</span> len(nums) &lt; <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span> res        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">4</span> <span class="hljs-keyword">and</span> sum(nums) == target:            res.append(nums)            <span class="hljs-keyword">return</span> res        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)<span class="hljs-number">-3</span>):            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i<span class="hljs-number">-1</span>]: <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>,len(nums)<span class="hljs-number">-2</span>):                <span class="hljs-keyword">if</span> j &gt; i+<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[j] == nums[j<span class="hljs-number">-1</span>]: <span class="hljs-keyword">continue</span>                l,r = j+<span class="hljs-number">1</span>, len(nums)<span class="hljs-number">-1</span>                <span class="hljs-keyword">while</span> l &lt; r:                    sum_value = nums[i] + nums[j] + nums[l] + nums[r]                    <span class="hljs-keyword">if</span> sum_value == target:                        res.append([nums[i],nums[j],nums[l],nums[r]])                        l += <span class="hljs-number">1</span>                        r -= <span class="hljs-number">1</span>                        <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> nums[l] == nums[l<span class="hljs-number">-1</span>]: l += <span class="hljs-number">1</span>                        <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> nums[r] == nums[r+<span class="hljs-number">1</span>]: r -= <span class="hljs-number">1</span>                    <span class="hljs-keyword">elif</span> sum_value &lt; target:                        l += <span class="hljs-number">1</span>                    <span class="hljs-keyword">else</span>:                        r -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre><p>还可以使用combinations(nums, 4)来对原数组中得4个元素全排列，在开始sort后，对排列得到得元素进行set去重。但单纯利用combinations实现会超时。</p><h2 id="超出时间限制"><a href="#超出时间限制" class="headerlink" title="超出时间限制"></a>超出时间限制</h2><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fourSum</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span>        nums.sort()        <span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> combinations        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> combinations(nums, <span class="hljs-number">4</span>):            <span class="hljs-keyword">if</span> sum(i) == target:                res.append(i)        res = set(res)        <span class="hljs-keyword">return</span> res</code></pre><h1 id="LeetCode-16-3Sum-Closest"><a href="#LeetCode-16-3Sum-Closest" class="headerlink" title="LeetCode 16 3Sum Closest"></a>LeetCode 16 3Sum Closest</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个整形数组，寻找其中的三个元素a,b,c，使得a+b+c的值最接近另外一个给定的数字target。</p><p>如：给定数组 nums = [-1，2，1，-4], 和 target = 1.</p><p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p><h2 id="分析实现-9"><a href="#分析实现-9" class="headerlink" title="分析实现"></a>分析实现</h2><p>这道题也是2sum,3sum等题组中的，只不过变形的地方在于不是找相等的target，而是找最近的。</p><p>那么开始时可以随机设定一个三个数的和为结果值，在每次比较中，先判断三个数的和是否和target相等，如果相等直接返回和。如果不相等，则判断三个数的和与target的差是否小于这个结果值时，如果小于则进行则进行替换，并保存和的结果值。</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><pre><code class="hljs python"><span class="hljs-comment"># 先排序</span>nums.sort()<span class="hljs-comment"># 随机选择一个和作为结果值</span>res = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>]<span class="hljs-comment"># 记录这个差值</span>diff = abs(nums[<span class="hljs-number">0</span>]+nums[<span class="hljs-number">1</span>]+nums[<span class="hljs-number">2</span>]-target)<span class="hljs-comment"># 第一遍遍历</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):    <span class="hljs-comment"># 标记好剩余元素的l和r</span>    l,r = i+<span class="hljs-number">1</span>, len(nums<span class="hljs-number">-1</span>)    <span class="hljs-keyword">while</span> l &lt; r:        <span class="hljs-keyword">if</span> 后续的值等于target:            <span class="hljs-keyword">return</span> 三个数值得和        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">if</span> 差值小于diff:                更新diff值                更新res值            <span class="hljs-keyword">if</span> 和小于target:                将l移动            <span class="hljs-keyword">else</span>:(开始已经排除了等于得情况，要判断和大于target)                将r移动</code></pre><h3 id="3Sum问题两层遍历得套路代码："><a href="#3Sum问题两层遍历得套路代码：" class="headerlink" title="3Sum问题两层遍历得套路代码："></a>3Sum问题两层遍历得套路代码：</h3><pre><code class="hljs python">nums.sort()res = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)<span class="hljs-number">-2</span>):    l,r = i+<span class="hljs-number">1</span>, len(nums)<span class="hljs-number">-1</span>    <span class="hljs-keyword">while</span> l &lt; r:        sum = nums[i] + nums[l] + nums[r]        <span class="hljs-keyword">if</span> sum == <span class="hljs-number">0</span>:            res.append([nums[i],nums[l],nums[r]])        <span class="hljs-keyword">elif</span> sum &lt; <span class="hljs-number">0</span>:            l += <span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            r -= <span class="hljs-number">1</span></code></pre><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; int:</span>        nums.sort()        diff = abs(nums[<span class="hljs-number">0</span>]+nums[<span class="hljs-number">1</span>]+nums[<span class="hljs-number">2</span>]-target)        res = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            l,r = i+<span class="hljs-number">1</span>,len(nums)<span class="hljs-number">-1</span>            t = target - nums[i]            <span class="hljs-keyword">while</span> l &lt; r:                <span class="hljs-keyword">if</span> nums[l] + nums[r] == t:                    <span class="hljs-keyword">return</span> nums[i] + t                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">if</span> abs(nums[l]+nums[r]-t) &lt; diff:                        diff = abs(nums[l]+nums[r]-t)                        res = nums[i]+nums[l]+nums[r]                    <span class="hljs-keyword">if</span> nums[l]+nums[r] &lt; t:                        l += <span class="hljs-number">1</span>                    <span class="hljs-keyword">else</span>:                        r -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre><p>时间复杂度为O(n^2)，空间复杂度为O(1);</p><h1 id="LeetCode-454-4SumⅡ"><a href="#LeetCode-454-4SumⅡ" class="headerlink" title="LeetCode 454 4SumⅡ"></a>LeetCode 454 4SumⅡ</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出四个整形数组A,B,C,D,寻找有多少i,j,k,l的组合,使得A[i]+B[j]+C[k]+D[l]=0。其中,A,B,C,D中均含有相同的元素个数N，且0&lt;=N&lt;=500；</p><p>输入:</p><p>A = [ 1, 2]<br>B = [-2,-1]<br>C = [-1, 2]<br>D = [ 0, 2]</p><p>输出:2</p><h2 id="分析实现-10"><a href="#分析实现-10" class="headerlink" title="分析实现"></a>分析实现</h2><p>这个问题同样是Sum类问题得变种，其将同一个数组的条件，变为了四个数组中，依然可以用查找表的思想来实现。</p><p>首先可以考虑把D数组中的元素都放入查找表，然后遍历前三个数组，判断target减去每个元素后的值是否在查找表中存在，存在的话，把结果值加1。那么查找表的数据结构选择用set还是dict？考虑到数组中可能存在重复的元素，而重复的元素属于不同的情况，因此用dict存储，最后的结果值加上dict相应key的value，代码如下：</p><h3 id="O-n-3-代码"><a href="#O-n-3-代码" class="headerlink" title="O(n^3)代码"></a>O(n^3)代码</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counterrecord = Counter()<span class="hljs-comment"># 先建立数组D的查找表</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(D)):    record[D[i]] += <span class="hljs-number">1</span>res = <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(A)):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(B)):        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(len(C)):            num_find = <span class="hljs-number">0</span>-A[i]-B[j]-C[k]            <span class="hljs-keyword">if</span> record.get(num_find) != <span class="hljs-literal">None</span>:                res += record(num_find)<span class="hljs-keyword">return</span> res</code></pre><p>但是对于题目中给出的数据规模：N&lt;=500，如果N为500时，n^3的算法依然消耗很大，能否再进行优化呢？</p><p>根据之前的思路继续往前走，如果只遍历两个数组，那么就可以得到O(n^2)级别的算法，但是遍历两个数组，那么还剩下C和D两个数组，上面的值怎么放？</p><p>对于查找表问题而言，<strong>很多时候到底要查找什么</strong>，是解决的关键。对于C和D的数组，可以通过dict来记录其中和的个数，之后遍历结果在和中进行查找。代码如下：</p><h3 id="O-n-2-级代码"><a href="#O-n-2-级代码" class="headerlink" title="O(n^2)级代码"></a>O(n^2)级代码</h3><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(self, A: List[int], B: List[int], C: List[int], D: List[int])</span> -&gt; int:</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter        record = Counter()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(A)):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(B)):                record[A[i]+B[j]] += <span class="hljs-number">1</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(C)):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(D)):                find_num = <span class="hljs-number">0</span> - C[i] - D[j]                <span class="hljs-keyword">if</span> record.get(find_num) != <span class="hljs-literal">None</span>:                    res += record[find_num]        <span class="hljs-keyword">return</span> res</code></pre><p>再使用Pythonic的列表生成式和sum函数进行优化，如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(self, A: List[int], B: List[int], C: List[int], D: List[int])</span> -&gt; int:</span>        record = collections.Counter(a + b <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> A <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> B)        <span class="hljs-keyword">return</span> sum(record.get(- c - d, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> C <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> D)</code></pre><h1 id="LeetCode-49-Group-Anagrams"><a href="#LeetCode-49-Group-Anagrams" class="headerlink" title="LeetCode 49 Group Anagrams"></a>LeetCode 49 Group Anagrams</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个字符串数组，将其中所有可以通过颠倒字符顺序产生相同结果的单词进行分组。</p><pre><code class="hljs prolog">示例:输入: [<span class="hljs-string">"eat"</span>, <span class="hljs-string">"tea"</span>, <span class="hljs-string">"tan"</span>, <span class="hljs-string">"ate"</span>, <span class="hljs-string">"nat"</span>, <span class="hljs-string">"bat"</span>],输出:[[<span class="hljs-string">"ate"</span>,<span class="hljs-string">"eat"</span>,<span class="hljs-string">"tea"</span>],[<span class="hljs-string">"nat"</span>,<span class="hljs-string">"tan"</span>],[<span class="hljs-string">"bat"</span>]]说明：所有输入均为小写字母。不考虑答案输出的顺序。</code></pre><h2 id="分析实现-11"><a href="#分析实现-11" class="headerlink" title="分析实现"></a>分析实现</h2><p>在之前LeetCode 242的问题中，对字符串t和s来判断，判断t是否是s的字母异位词。当时的方法是通过构建t和s的字典，比较字典是否相同来判断是否为异位词。</p><p>在刚开始解决这个问题时，我也局限于了这个思路，以为是通过移动指针，来依次比较两个字符串是否对应的字典相等，进而确定异位词列表，再把异位词列表添加到结果集res中。于是有：</p><h3 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h3><pre><code class="hljs python">nums = [<span class="hljs-string">"eat"</span>, <span class="hljs-string">"tea"</span>, <span class="hljs-string">"tan"</span>, <span class="hljs-string">"ate"</span>, <span class="hljs-string">"nat"</span>, <span class="hljs-string">"bat"</span>]<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Countercum = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):    l,r = i+<span class="hljs-number">1</span>,len(nums)<span class="hljs-number">-1</span>    i_dict = Counter(nums[i])    res = []    <span class="hljs-keyword">if</span> nums[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> cum:        res.append(nums[i])    <span class="hljs-keyword">while</span> l &lt; r:        l_dict = Counter(nums[l])        r_dict = Counter(nums[r])        <span class="hljs-keyword">if</span> i_dict == l_dict <span class="hljs-keyword">and</span> l_dict == r_dict:            res.append(nums[l],nums[r])            l += <span class="hljs-number">1</span>            r -= <span class="hljs-number">1</span>        <span class="hljs-keyword">elif</span> i_dict == l_dict:            res.append(nums[l])            l += <span class="hljs-number">1</span>        <span class="hljs-keyword">elif</span> i_dict == r_dict:            res.append(nums[r])            r -= <span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            l += <span class="hljs-number">1</span>    print(res)    cum.append(res)......................................</code></pre><p>这时发现长长绵绵考虑不完，而且还要注意指针的条件，怎样遍历才能遍历所有的情况且判断列表是否相互间包含。。。</p><p>于是立即开始反思是否哪块考虑错了?回顾第一开始的选择数据结构，在dict和list中，自己错误的选择了list来当作数据结构，进而用指针移动来判断元素的情况。而<strong>没有利用题目中不变的条件</strong>。</p><p>题目的意思，对异位词的进行分组，同异位词的分为一组，那么考虑对这一组内什么是相同的，且这个相同的也能作为不同组的判断条件。</p><p>不同组的判断条件，就可以用数据结构dict中的key来代表，那么什么相同的适合当作key呢？</p><p>这时回顾下下LeetCode 242，当时是因为异位字符串中包含的<strong>字符串的字母个数</strong>都是相同的，故把字母当作key来进行判断是否为异位词。</p><p>但是对于本题，把每个字符串的字母dict，再当作字符串数组的dict的key，显然不太合适，那么对于异位词，还有什么是相同的？</p><p>显然，如果将字符串统一排序，<strong>异位词排序后的字符串</strong>，显然都是相同的。那么就可以把其当作key，把遍历的数组中的异位词当作value，对字典进行赋值，进而遍历字典的value，得到结果list。</p><p>需要注意的细节是，<strong>字符串和list之间的转换</strong>：</p><ol><li>默认构造字典需为list的字典；</li><li>排序使用sorted()函数，而不用list.sort()方法，因为其不返回值；</li><li>通过’’.join(list)，将list转换为字符串；</li><li>通过str.split(‘,’)将字符串整个转换为list中的一项；</li></ol><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">groupAnagrams</span><span class="hljs-params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict        strs_dict = defaultdict(list)        res = []        <span class="hljs-keyword">for</span> str <span class="hljs-keyword">in</span> strs:            key = <span class="hljs-string">''</span>.join(sorted(list(str)))            strs_dict[key] += str.split(<span class="hljs-string">','</span>)        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> strs_dict.values():            res.append(v)        <span class="hljs-keyword">return</span> res</code></pre><p>再将能用列表生成式替换的地方替换掉,代码实现如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">groupAnagrams</span><span class="hljs-params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict        strs_dict = defaultdict(list)        <span class="hljs-keyword">for</span> str <span class="hljs-keyword">in</span> strs:            key = <span class="hljs-string">''</span>.join(sorted(list(str)))            strs_dict[key] += str.split(<span class="hljs-string">','</span>)        <span class="hljs-keyword">return</span> [v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> strs_dict.values()]</code></pre><h1 id="LeetCode-447-Number-of-Boomerangs"><a href="#LeetCode-447-Number-of-Boomerangs" class="headerlink" title="LeetCode 447 Number of Boomerangs"></a>LeetCode 447 Number of Boomerangs</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个平面上的n个点，寻找存在多少个由这些点构成的三元组(i,j,k)，<strong>使得i,j两点的距离等于i,k两点的距离</strong>。</p><p>其中n最多为500,且所有的点坐标的范围在[-10000,10000]之间。</p><pre><code class="hljs angelscript">输入:[[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]]输出:<span class="hljs-number">2</span>解释:两个结果为： [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]] 和 [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]</code></pre><h2 id="分析实现-12"><a href="#分析实现-12" class="headerlink" title="分析实现"></a>分析实现</h2><h3 id="原始思路"><a href="#原始思路" class="headerlink" title="原始思路"></a>原始思路</h3><p>题目的要求是：使得i,j两点的距离等于i,k两点的距离，那么相当于是比较三个点之间距离的，那么开始的思路就是三层遍历，i从0到len，j从i+1到len，k从j+1到len，然后比较三个点的距离，相等则结果数加一。</p><p>显然这样的时间复杂度为O(n^3)，对于这道题目，能否用查找表的思路进行解决优化？</p><h3 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h3><p>之前的查找表问题，大多是通过<strong>构建一个查找表</strong>，而避免了在查找中再内层嵌套循环，从而降低了时间复杂度。那么可以考虑在这道题中，可以通过查找表进行代替哪两层循环。</p><p>当i,j两点距离等于i,k时，用查找表的思路，等价于：对距离key(i,j或i,k的距离)，其值value(个数)为2。</p><p>那么就可以做一个查找表，用来查找相同距离key的个数value是多少。遍历每一个节点i，扫描得到其他点到节点i的距离，在查找表中，对应的键就是距离的值，对应的值就是距离值得个数。</p><p>在拿到对于元素i的距离查找表后，接下来就是排列选择问题了：</p><ol><li>如果当距离为x的值有2个时，那么选择j,k的可能情况有：第一次选择有2种，第二次选择有1种，为2*1；</li><li>如果当距离为x的值有3个时，那么选择j,k的可能的情况有：第一次选择有3种，第二次选择有2种，为3*2;</li><li>那么当距离为x的值有n个时，选择j,k的可能情况有：第一次选择有n种，第二次选择有n-1种。</li></ol><h3 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h3><p>对于距离值的求算，按照欧式距离的方法进行求算的话，容易产生浮点数，可以将根号去掉，用差的平方和来进行比较距离。</p><p>实现代码如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numberOfBoomerangs</span><span class="hljs-params">(self, points: List[List[int]])</span> -&gt; int:</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> points:            record = Counter()            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> points:                <span class="hljs-keyword">if</span> i != j:                    record[self.dis(i,j)] += <span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> record.items():                res += v*(v<span class="hljs-number">-1</span>)        <span class="hljs-keyword">return</span> res    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dis</span><span class="hljs-params">(self,point1,point2)</span>:</span>        <span class="hljs-keyword">return</span> (point1[<span class="hljs-number">0</span>]-point2[<span class="hljs-number">0</span>]) ** <span class="hljs-number">2</span> + (point1[<span class="hljs-number">1</span>]-point2[<span class="hljs-number">1</span>]) ** <span class="hljs-number">2</span></code></pre><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>对实现的代码进行优化：</p><ol><li>将for循环遍历改为列表生成式;</li><li>对sum+=的操作，考虑使用sum函数。</li><li>对不同的函数使用闭包的方式内嵌；</li></ol><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numberOfBoomerangs</span><span class="hljs-params">(self, points: List[List[int]])</span> -&gt; int:</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(x1, y1)</span>:</span>            <span class="hljs-comment"># 对一个i下j,k的距离值求和</span>            d = Counter((x2 - x1) ** <span class="hljs-number">2</span> + (y2 - y1) ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x2, y2 <span class="hljs-keyword">in</span> points)            <span class="hljs-keyword">return</span> sum(t * (t<span class="hljs-number">-1</span>) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> d.values())        <span class="hljs-comment"># 对每个i的距离进行求和</span>        <span class="hljs-keyword">return</span> sum(f(x1, y1) <span class="hljs-keyword">for</span> x1, y1 <span class="hljs-keyword">in</span> points)</code></pre><h1 id="LeetCode-149-Max-Points-on-a-Line"><a href="#LeetCode-149-Max-Points-on-a-Line" class="headerlink" title="LeetCode 149 Max Points on a Line"></a>LeetCode 149 Max Points on a Line</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。</p><pre><code class="hljs angelscript">示例 <span class="hljs-number">1</span>:输入: [[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]]输出: <span class="hljs-number">3</span>示例 <span class="hljs-number">2</span>:输入: [[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]]输出: <span class="hljs-number">4</span></code></pre><h2 id="分析实现-13"><a href="#分析实现-13" class="headerlink" title="分析实现"></a>分析实现</h2><p>本道题目的要求是：看有多少个点在同一条直线上，那么判断点是否在一条直线上，其实就等价于判断i,j两点的斜率是否等于i,k两点的斜率。</p><p>回顾上道447题目中的要求：使得i,j两点的距离等于i,k两点的距离，那么在这里，直接考虑使用查找表实现，即<strong>查找相同斜率key的个数value是多少</strong>。</p><p>在上个问题中，i和j，j和i算是两种不同的情况，但是这道题目中，这是属于相同的两个点，<br>因此在对遍历每个i,查找与i相同斜率的点时，不能再对结果数res++，而应该取查找表中的最大值。如果有两个斜率相同时，返回的应该是3个点，故返回的是结果数+1。</p><p>查找表实现套路如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxPoints</span><span class="hljs-params">(self,points)</span>:</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(points)):            record = defaultdict(int)            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(points)):                <span class="hljs-keyword">if</span> i != j:                    record[self.get_Slope(points,i,j)] += <span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> record.values():                res = max(res, v)        <span class="hljs-keyword">return</span> res + <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_Slope</span><span class="hljs-params">(self,points,i,j)</span>:</span>        <span class="hljs-keyword">return</span> (points[i][<span class="hljs-number">0</span>] - points[j][<span class="hljs-number">0</span>]) / (points[i][<span class="hljs-number">1</span>] - points[j][<span class="hljs-number">1</span>])</code></pre><p>但是这样会出现一个问题，即斜率的求算中，有时会出现直线为垂直的情况，故需要对返回的结果进行判断，如果分母为0，则返回inf，如下：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_Slope</span><span class="hljs-params">(self,points,i,j)</span>:</span>    <span class="hljs-keyword">if</span> points[i][<span class="hljs-number">1</span>] - points[j][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:        <span class="hljs-keyword">return</span> float(<span class="hljs-string">'Inf'</span>)    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> (points[i][<span class="hljs-number">0</span>] - points[j][<span class="hljs-number">0</span>]) / (points[i][<span class="hljs-number">1</span>] - points[j][<span class="hljs-number">1</span>])</code></pre><p>再次提交，发现对于空列表的测试用例会判断错误，于是对边界情况进行判断，如果初始长度小于等于1,则直接返回len：</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> len(points) &lt;= <span class="hljs-number">1</span>:    <span class="hljs-keyword">return</span> len(points)</code></pre><p>再次提交，对于相同元素的测试用例会出现错误，回想刚才的过程，当有相同元素时，题目的要求是算作两个不同的点，但是在程序运行时，会将其考虑为相同的点，return回了inf。但在实际运行时，需要对相同元素的情况单独考虑。</p><p>于是可以设定samepoint值，遍历时判断，如果相同时，same值++,最后取v+same的值作为结果数。</p><p>考虑到如果全是相同值，那么这时dict中的record为空，也要将same值当作结果数返回，代码实现如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxPoints</span><span class="hljs-params">(self,points)</span>:</span>        <span class="hljs-keyword">if</span> len(points) &lt;= <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> len(points)        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(points)):            record = defaultdict(int)            samepoint = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(points)):                <span class="hljs-keyword">if</span> points[i][<span class="hljs-number">0</span>] == points[j][<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> points[i][<span class="hljs-number">1</span>] == points[j][<span class="hljs-number">1</span>]:                    samepoint += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    record[self.get_Slope(points,i,j)] += <span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> record.values():                res = max(res, v+samepoint)            res = max(res, samepoint)        <span class="hljs-keyword">return</span> res    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_Slope</span><span class="hljs-params">(self,points,i,j)</span>:</span>        <span class="hljs-keyword">if</span> points[i][<span class="hljs-number">1</span>] - points[j][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> float(<span class="hljs-string">'Inf'</span>)        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> (points[i][<span class="hljs-number">0</span>] - points[j][<span class="hljs-number">0</span>]) / (points[i][<span class="hljs-number">1</span>] - points[j][<span class="hljs-number">1</span>])</code></pre><p>时间复杂度为O(n^2)，空间复杂度为O(n)</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>遍历时多用索引，而不要直接用值进行遍历；</p><h1 id="三-滑动数组"><a href="#三-滑动数组" class="headerlink" title="三. 滑动数组"></a>三. 滑动数组</h1><h1 id="LeetCode-219-Contains-Dupliccate-Ⅱ"><a href="#LeetCode-219-Contains-Dupliccate-Ⅱ" class="headerlink" title="LeetCode 219 Contains Dupliccate Ⅱ"></a>LeetCode 219 Contains Dupliccate Ⅱ</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个整形数组nums和一个整数k，是否存在索引i和j，使得nums[i]==nums[j]，且i和J之间的差不超过k。</p><pre><code class="hljs angelscript">示例<span class="hljs-number">1</span>:输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">3</span>输出: <span class="hljs-literal">true</span>示例 <span class="hljs-number">2</span>:输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], k = <span class="hljs-number">2</span>输出: <span class="hljs-literal">false</span></code></pre><h2 id="分析实现-14"><a href="#分析实现-14" class="headerlink" title="分析实现"></a>分析实现</h2><p>翻译下这个题目：在这个数组中，如果有两个元素索引i和j，它们对应的元素是相等的，且索引j-i是小于等于k，那么就返回True，否则返回False。</p><p>因为对于这道题目可以用暴力解法双层循环，即：</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>,len(nums)):        <span class="hljs-keyword">if</span> i == j:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre><p>故这道题目可以考虑使用滑动数组来解决：</p><p>固定滑动数组的长度为K+1，当这个滑动数组内如果能找到两个元素的值相等，就可以保证两个元素的索引的差是小于等于k的。如果当前的滑动数组中没有元素相同，就右移滑动数组的右边界r,同时将左边界l右移。查看r++的元素是否在l右移过后的数组里，如果不在就将其添加数组，在的话返回true表示两元素相等。</p><p>因为滑动数组中的元素是不同的，考虑用set作为数据结构：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(self, nums: List[int], k: int)</span> -&gt; bool:</span>        record = set()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            <span class="hljs-keyword">if</span> nums[i] <span class="hljs-keyword">in</span> record:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            record.add(nums[i])            <span class="hljs-keyword">if</span> len(record) == k+<span class="hljs-number">1</span>:                record.remove(nums[i-k])        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre><p>时间复杂度为O(n)，空间复杂度为O(n)</p><h1 id="LeetCode-220-Contains-Dupliccate-Ⅲ"><a href="#LeetCode-220-Contains-Dupliccate-Ⅲ" class="headerlink" title="LeetCode 220 Contains Dupliccate Ⅲ"></a>LeetCode 220 Contains Dupliccate Ⅲ</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得nums [i] 和nums [j]的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。</p><p>示例 1:</p><p>输入: nums = [1,2,3,1], k = 3, t = 0</p><p>输出: true</p><p>示例 2:</p><p>输入: nums = [1,0,1,1], k = 1, t = 2</p><p>输出: true</p><p>示例 3:</p><p>输入: nums = [1,5,9,1,5,9], k = 2, t = 3</p><p>输出: false</p><h2 id="分析实现-15"><a href="#分析实现-15" class="headerlink" title="分析实现"></a>分析实现</h2><p>相比较上一个问题，这个问题多了一个限定条件，条件不仅索引差限定k，数值差也限定为了t。</p><p>将索引的差值固定，于是问题和上道一样，同样转化为了固定长度K+1的滑动窗口内，是否存在两个值的差距不超过 t，考虑使用<strong>滑动窗口</strong>的思想来解决。</p><p>在遍历的过程中，目的是要在“已经出现、但还未滑出滑动窗口”的所有数中查找，是否有一个数与滑动数组中的数的<strong>差的绝对值</strong>最大为 t。对于差的绝对值最大为t，实际上等价于所要找的这个元素v的范围是在v-t到v+t之间，即查找“滑动数组”中的元素有没有[v-t，v+t]范围内的数存在。</p><p>因为只需证明是否存在即可，这时判断的逻辑是：如果在滑动数组<strong>查找比v-t大的最小的元素</strong>,如果这个元素小于等于v+t,即可以证明存在[v-t,v+t]。</p><p>那么实现过程其实和上题是一致的，只是上题中的判断条件是<strong>在查找表中找到和nums[i]相同的元素</strong>，而这题中的判断条件是<strong>查找比v-t大的最小的元素，判断其小于等于v+t</strong>，下面是实现的框架：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(self, nums: List[int], k: int)</span> -&gt; bool:</span>        record = set()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            <span class="hljs-keyword">if</span> 查找的比v-t大的最小的元素 &lt;= v+t:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            record.add(nums[i])            <span class="hljs-keyword">if</span> len(record) == k+<span class="hljs-number">1</span>:                record.remove(nums[i-k])        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre><p>接下来考虑，如何查找比v-t大的最小的元素呢？</p><p>【注：C++中有lower_bound(v-t)的实现，py需要自己写函数】</p><p>当然首先考虑可以通过O(n)的解法来完成，如下：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(self,array,v)</span>:</span>    array = list(array)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(array)):        <span class="hljs-keyword">if</span> array[i] &gt;= v:            <span class="hljs-keyword">return</span> i    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span></code></pre><p>但是滑动数组作为set，是有序的数组。对于有序的数组，应该第一反应就是<strong>二分查找</strong>，于是考虑二分查找实现，查找比v-t大的最小的元素：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(self, nums, target)</span>:</span>    low, high = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span>    <span class="hljs-keyword">while</span> low&lt;high:        mid = int((low+high)/<span class="hljs-number">2</span>)        <span class="hljs-keyword">if</span> nums[mid] &lt; target:            low = mid+<span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            high = mid    <span class="hljs-keyword">return</span> low <span class="hljs-keyword">if</span> nums[low] &gt;= target <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span></code></pre><p>整体代码实现如下，时间复杂度为O(nlogn),空间复杂度为O(n):</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(self, nums, k, t)</span> -&gt; bool:</span>        record = set()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            <span class="hljs-keyword">if</span> len(record) != <span class="hljs-number">0</span>:                rec = list(record)                find_index = self.lower_bound(rec,nums[i]-t)                <span class="hljs-keyword">if</span> find_index != <span class="hljs-number">-1</span> <span class="hljs-keyword">and</span> rec[find_index] &lt;= nums[i] + t:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            record.add(nums[i])            <span class="hljs-keyword">if</span> len(record) == k + <span class="hljs-number">1</span>:                record.remove(nums[i - k])        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(self, nums, target)</span>:</span>        low, high = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> low&lt;high:            mid = int((low+high)/<span class="hljs-number">2</span>)            <span class="hljs-keyword">if</span> nums[mid] &lt; target:                low = mid+<span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                high = mid        <span class="hljs-keyword">return</span> low <span class="hljs-keyword">if</span> nums[low] &gt;= target <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span></code></pre><p>当然。。。在和小伙伴一起刷的时候，这样写的O(n^2)的结果会比上面要高，讨论的原因应该是上面的步骤存在着大量set和list的转换导致，对于py，仍旧是考虑算法思想实现为主，下面是O(n^2)的代码：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(self, nums: List[int], k: int, t: int)</span> -&gt; bool:</span>        <span class="hljs-keyword">if</span> t == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> len(nums) == len(set(nums)):            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>):                <span class="hljs-keyword">if</span> i+j &gt;= len(nums): <span class="hljs-keyword">break</span>                <span class="hljs-keyword">if</span> abs(nums[i+j]-nums[i]) &lt;= t: <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre><h2 id="小套路："><a href="#小套路：" class="headerlink" title="小套路："></a>小套路：</h2><p>二分查找实现，查找比v-t大的最小的元素：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(self, nums, target)</span>:</span>    low, high = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span>    <span class="hljs-keyword">while</span> low&lt;high:        mid = int((low+high)/<span class="hljs-number">2</span>)        <span class="hljs-keyword">if</span> nums[mid] &lt; target:            low = mid+<span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            high = mid    <span class="hljs-keyword">return</span> low <span class="hljs-keyword">if</span> nums[low] &gt;= target <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span></code></pre><p>二分查找实现，查找比v-t大的最小的元素：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">upper_bound</span><span class="hljs-params">(nums, target)</span>:</span>    low, high = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span>    <span class="hljs-keyword">while</span> low&lt;high:        mid=(low+high)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> nums[mid]&lt;=target:            low = mid+<span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:<span class="hljs-comment">#&gt;</span>            high = mid            pos = high    <span class="hljs-keyword">if</span> nums[low]&gt;target:        pos = low    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span></code></pre><h1 id="四-二分查找"><a href="#四-二分查找" class="headerlink" title="四. 二分查找"></a>四. 二分查找</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>查找在算法题中是很常见的，但是怎么最大化查找的效率和写出bugfree的代码才是难的部分。一般查找方法有顺序查找、二分查找和双指针，推荐一开始可以直接用顺序查找，如果遇到TLE的情况再考虑剩下的两种，毕竟AC是最重要的。</p><p>一般二分查找的对象是有序或者由有序部分变化的（可能暂时理解不了，看例题即可），但还存在一种可以运用的地方是按值二分查找，之后会介绍。</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><p>总体来说二分查找是比较简单的算法，网上看到的写法也很多，掌握一种就可以了。<br>以下是我的写法，参考C++标准库里<algorithm>的写法。这种写法比较好的点在于：</algorithm></p><ul><li>1.即使区间为空、答案不存在、有重复元素、搜索开/闭区间的上/下界也同样适用</li><li>2.+-1 的位置调整只出现了一次，而且最后返回lo还是hi都是对的，无需纠结</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">firstBadVersion</span><span class="hljs-params">(self, arr)</span>:</span>        <span class="hljs-comment"># 第一点</span>        lo, hi = <span class="hljs-number">0</span>, len(arr)<span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> lo &lt; hi:            <span class="hljs-comment"># 第二点</span>            mid = (lo+hi) // <span class="hljs-number">2</span>            <span class="hljs-comment"># 第三点</span>            <span class="hljs-keyword">if</span> f(x):                lo = mid + <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hi = mid        <span class="hljs-keyword">return</span> lo</code></pre><p><strong>解释</strong>：</p><ul><li>第一点：lo和hi分别对应搜索的上界和下界，但不一定为0和arr最后一个元素的下标。</li><li><p>第二点：因为Python没有溢出，int型不够了会自动改成long int型，所以无需担心。如果再苛求一点，可以把这一行改成</p><pre><code class="hljs python">mid = lo + (hi-lo) // <span class="hljs-number">2</span><span class="hljs-comment"># 之所以 //2 这部分不用位运算 &gt;&gt; 1 是因为会自动优化，效率不会提升</span></code></pre></li><li><p>第三点：<br>比较重要的就是这个f(x)，在带入模板的情况下，写对函数就完了。</p></li></ul><p>那么我们一步一步地揭开二分查找的神秘面纱，首先来一道简单的题。</p><h2 id="LeetCode-35-Search-Insert-Position"><a href="#LeetCode-35-Search-Insert-Position" class="headerlink" title="LeetCode 35. Search Insert Position"></a>LeetCode 35. Search Insert Position</h2><p>给定排序数组和目标值，如果找到目标，则返回索引。如果不是，则返回按顺序插入索引的位置的索引。 您可以假设数组中没有重复项。</p><p><strong>Example</strong></p><pre><code class="hljs angelscript">Example <span class="hljs-number">1</span>:Input: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-number">5</span>Output: <span class="hljs-number">2</span>Example <span class="hljs-number">2</span>:Input: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-number">2</span>Output: <span class="hljs-number">1</span>Example <span class="hljs-number">3</span>:Input: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-number">7</span>Output: <span class="hljs-number">4</span>Example <span class="hljs-number">4</span>:Input: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-number">0</span>Output: <span class="hljs-number">0</span></code></pre><p><strong>分析：</strong> 这里要注意的点是 high 要设置为 len(nums) 的原因是像第三个例子会超出数组的最大值，所以要让 lo 能到 这个下标。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; int:</span>                lo, hi = <span class="hljs-number">0</span>, len(nums)        <span class="hljs-keyword">while</span> lo &lt; hi:            mid = (lo + hi) // <span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> nums[mid] &lt; target:                lo = mid + <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hi = mid        <span class="hljs-keyword">return</span> lo</code></pre><h2 id="LeetCode540-Single-Element-in-a-Sorted-Array"><a href="#LeetCode540-Single-Element-in-a-Sorted-Array" class="headerlink" title="LeetCode540. Single Element in a Sorted Array"></a>LeetCode540. Single Element in a Sorted Array</h2><p>您将获得一个仅由整数组成的排序数组，其中每个元素精确出现两次，但一个元素仅出现一次。 找到只出现一次的单个元素。</p><p><strong>Example</strong></p><pre><code class="hljs angelscript">Example <span class="hljs-number">1</span>:Input: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>]Output: <span class="hljs-number">2</span>Example <span class="hljs-number">2</span>:Input: [<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">11</span>]Output: <span class="hljs-number">10</span></code></pre><p><strong>分析：</strong> 异或的巧妙应用！如果mid是偶数，那么和1异或的话，那么得到的是mid+1，如果mid是奇数，得到的是mid-1。如果相等的话，那么唯一的元素还在这之后，往后找就可以了。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNonDuplicate</span><span class="hljs-params">(self, nums)</span>:</span>        lo, hi = <span class="hljs-number">0</span>, len(nums) - <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> lo &lt; hi:            mid = (lo + hi) // <span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> nums[mid] == nums[mid ^ <span class="hljs-number">1</span>]:                lo = mid + <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hi = mid        <span class="hljs-keyword">return</span> nums[lo]</code></pre><p><strong>是不是还挺简单哈哈，那我们来道HARD难度的题!</strong></p><h2 id="LeetCode-410-Split-Array-Largest-Sum"><a href="#LeetCode-410-Split-Array-Largest-Sum" class="headerlink" title="LeetCode 410. Split Array Largest Sum"></a>LeetCode 410. Split Array Largest Sum</h2><p>给定一个由非负整数和整数m组成的数组，您可以将该数组拆分为m个非空连续子数组。编写算法以最小化这m个子数组中的最大和。</p><p><strong>Example</strong></p><pre><code class="hljs angelscript">Input:nums = [<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>]m = <span class="hljs-number">2</span>Output:<span class="hljs-number">18</span>Explanation:There are four ways to split nums <span class="hljs-built_in">int</span>o two subarrays.The best way <span class="hljs-keyword">is</span> to split it <span class="hljs-built_in">int</span>o [<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>] <span class="hljs-keyword">and</span> [<span class="hljs-number">10</span>,<span class="hljs-number">8</span>],where the largest sum among the two subarrays <span class="hljs-keyword">is</span> only <span class="hljs-number">18.</span></code></pre><p><strong>分析：</strong></p><ul><li>这其实就是二分查找里的按值二分了，可以看出这里的元素就无序了。但是我们的目标是找到一个合适的最小和，换个角度理解我们要找的值在最小值max(nums)和sum(nums)内，而这两个值中间是连续的。是不是有点难理解，那么看代码吧</li><li>辅助函数的作用是判断当前的“最小和”的情况下，区间数是多少，来和m判断</li><li>这里的下界是数组的最大值是因为如果比最大值小那么一个区间就装不下，数组的上界是数组和因为区间最少是一个，没必要扩大搜索的范围</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(self, nums: List[int], m: int)</span> -&gt; int:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span><span class="hljs-params">(mid)</span>:</span>            res = tmp = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:                <span class="hljs-keyword">if</span> tmp + num &lt;= mid:                    tmp += num                <span class="hljs-keyword">else</span>:                    res += <span class="hljs-number">1</span>                    tmp = num            <span class="hljs-keyword">return</span> res + <span class="hljs-number">1</span>        lo, hi = max(nums), sum(nums)        <span class="hljs-keyword">while</span> lo &lt; hi:            mid = (lo + hi) // <span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> helper(mid) &gt; m:                lo = mid + <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hi = mid        <span class="hljs-keyword">return</span> lo</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&quot;一-查找表&quot;&gt;&lt;a href=&quot;#一-查找表&quot; class=&quot;headerlink&quot; title=&quot;一.查找表&quot;&gt;&lt;/a&gt;一.查找表&lt;/h1&gt;&lt;h2 id=&quot;考虑的基本数据结构&quot;&gt;&lt;a href=&quot;#考虑的基本数据结构&quot; class=&quot;h
      
    
    </summary>
    
    
      <category term="算法" scheme="https://sulimin-nb.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://sulimin-nb.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法-动态规划</title>
    <link href="https://sulimin-nb.github.io/article/e57c001c.html"/>
    <id>https://sulimin-nb.github.io/article/e57c001c.html</id>
    <published>2020-08-24T03:08:16.000Z</published>
    <updated>2020-08-24T03:12:04.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划常常适用于<strong>有重叠子问题</strong>和<strong>最优子结构</strong>性质的问题，动态规划方法<strong>所耗时间往往远少于朴素解法</strong>。</p><h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。</p><p>动态规划法仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量，</p><p>一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。</p><h3 id="动态规划模板步骤："><a href="#动态规划模板步骤：" class="headerlink" title="动态规划模板步骤："></a>动态规划模板步骤：</h3><ul><li><p>确定动态规划状态</p></li><li><p>写出状态转移方程（画出状态转移表）</p></li><li><p>考虑初始化条件</p></li><li><p>考虑输出状态</p></li><li><p>考虑对时间，空间复杂度的优化（Bonus）</p></li></ul><h2 id="例题详解"><a href="#例题详解" class="headerlink" title="例题详解"></a>例题详解</h2><p>接下来，我们对每个步骤进行详细的讲解，并给出不同题目中考虑的不同方式，争取让大家吃透动态规划的套路。<br>我们以最经典的动态规划题目——<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">Leetcode 300.最长上升子序列</a> 为例子。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>,<span class="hljs-number">18</span>]输出: <span class="hljs-number">4</span> 解释: 最长的上升子序列是 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>]，它的长度是 <span class="hljs-number">4</span>。</code></pre><p>说明:</p><pre><code class="hljs reasonml">可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 <span class="hljs-constructor">O(<span class="hljs-params">n2</span>)</span> 。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>第一步：确定动态规划状态</strong></p><ul><li><p>是否存在状态转移?</p></li><li><p>什么样的状态比较好转移，找到对求解问题最方便的状态转移?</p><p>想清楚到底是直接用需要求的，比如长度作为dp保存的变量还是用某个判断问题的状态比如是否是回文子串来作为方便求解的状态</p><p>该题目可以直接用一个一维数组<code>dp</code>来存储转移状态，<code>dp[i]</code>可以定义为以<code>nums[i]</code>这个数结尾的最长递增子序列的长度。举个实际例子，比如在<code>nums[10,9,2,5,3,7,101,18]</code>中，<code>dp[0]</code>表示数字10的最长递增子序列长度，那就是本身，所以为1，对于<code>dp[5]</code>对应的数字7来说的最长递增子序列是<code>[2,5,7]</code>（或者<code>[2,3,7]</code>）所以<code>dp[5]=3</code>。</p></li></ul><p><strong>第二步：写出一个好的状态转移方程</strong></p><ul><li><p>使用<strong>数学归纳法</strong>思维，写出准确的状态方程</p><p>比如还是用刚刚那个<code>nums</code>数组，我们<strong>思考一下是如何得到<code>dp[5]=3</code>的</strong>：既然是递增的子序列，我们只要找到<code>nums[5]</code> (也就是7)前面那些结尾比7小的子序列，然后把7接到最后，就可以形成一个新的递增的子序列，也就是这个新的子序列也就是在找到的前面那些数后面加上7，相当长度加1。当然可能会找到很多不同的子序列，比如刚刚在上面列举的，但是只需要找到长度最长的作为<code>dp[5]</code>的值就行。总结来说就是比较当前<code>dp[i]</code>的长度和<code>dp[i]</code>对应产生新的子序列长度，我们用<code>j</code>来表示所有比<code>i</code>小的组数中的索引，可以用如下代码公式表示</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i):    <span class="hljs-keyword">if</span> nums[i]&gt;nums[j]:    dp[i]=max(dp[i],dp[j]+<span class="hljs-number">1</span>)</code></pre><p><strong>Tips:</strong> 在实际问题中，如果不能很快得出这个递推公式，可以先尝试一步一步把前面几步写出来，如果还是不行很可能就是 dp 数组的定义不够恰当，需要回到第一步重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。</p></li></ul><p><strong>第三步：考虑初始条件</strong></p><p>​    这是决定整个程序能否跑通的重要步骤，当我们确定好状态转移方程，我们就需要考虑一下边界值，边界值考虑主要又分为三个地方：</p><ul><li><p>dp数组整体的初始值</p></li><li><p>dp数组(二维)i=0和j=0的地方</p></li><li><p>dp存放状态的长度，是整个数组的长度还是数组长度加一，这点需要特别注意。</p><p>对于本问题，子序列最少也是自己，所以长度为1，这样我们就可以方便的把所有的<code>dp</code>初始化为1，再考虑长度问题，由于<code>dp[i]</code>代表的是<code>nums[i]​</code>的最长子序列长度，所以并不需要加一。<br>所以用代码表示就是​<code>dp=[1]*len(nums)​</code></p><p><strong>Tips：</strong>还有一点需要注意，找到一个方便的状态转移会使问题变得非常简单。举个例子，对于<a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">Leetcode120.三角形最小路径和</a>问题，大多数人刚开始想到的应该是自顶向下的定义状态转移的思路，也就是从最上面的数开始定义状态转移，但是这题优化的解法则是通过定义由下到上的状态转移方程会大大简化问题，同样的对于<a href="https://leetcode-cn.com/problems/maximum-subarray/solution/" target="_blank" rel="noopener">Leetcode53.最大子序和</a>也是采用从下往上遍历，保证每个子问题都是已经算好的。这个具体我们在题目中会讲到。</p></li></ul><p>  这里额外总结几种Python常用的初始化方法：</p><ul><li><p>对于产生一个全为1，长度为n的数组：</p><pre><code class="hljs python"><span class="hljs-number">1.</span> dp=[<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n)]<span class="hljs-number">2.</span> dp=[<span class="hljs-number">1</span>]*n</code></pre></li><li><p>对于产生一个全为0，长度为m，宽度为n的二维矩阵：</p><pre><code class="hljs python"><span class="hljs-number">1.</span> dp=[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m)]<span class="hljs-number">2.</span> dp=[[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m)]</code></pre></li></ul><p><strong>第四步：考虑输出状态</strong></p><p>主要有以下三种形式，对于具体问题，我们一定要想清楚到底dp数组里存储的是哪些值，最后我们需要的是数组中的哪些值：</p><ul><li><p>返回dp数组中最后一个值作为输出，一般对应二维dp问题。</p></li><li><p>返回dp数组中最大的那个数字，一般对应记录最大值问题。</p></li><li><p>返回保存的最大值，一般是<code>Maxval=max(Maxval,dp[i])</code>这样的形式。</p><p><strong>Tips：</strong>这个公式必须是在满足递增的条件下，也就是<code>nums[i]&gt;nums[j]​</code>的时候才能成立，并不是<code>nums[i]​</code>前面所有数字都满足这个条件的，理解好这个条件就很容易懂接下来在输出时候应该是​<code>max(dp)​</code>而不是​<code>dp[-1]​</code>，原因就是dp数组由于计算递增的子序列长度，所以dp数组里中间可能有值会是比最后遍历的数值大的情况，每次遍历<code>nums[j]</code>所对应的位置都是比<code>nums[i]</code>小的那个数。举个例子，比如<code>nums=[1,3,6,7,9,4,10,5,6]</code>,而最后<code>dp=[1,2,3,4,5,3,6,4,5]</code>。<br>总结一下，最后的结果应该返回dp数组中值最大的数。</p><p>最后加上考虑数组是否为空的判断条件，下面是该问题完整的代码：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(self, nums: List[int])</span> -&gt; int:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>  <span class="hljs-comment">#判断边界条件</span>        dp=[<span class="hljs-number">1</span>]*len(nums)      <span class="hljs-comment">#初始化dp数组状态</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i):                <span class="hljs-keyword">if</span> nums[i]&gt;nums[j]:   <span class="hljs-comment">#根据题目所求得到状态转移方程</span>                    dp[i]=max(dp[i],dp[j]+<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> max(dp)  <span class="hljs-comment">#确定输出状态</span></code></pre></li></ul><p><strong>第五步：考虑对时间，空间复杂度的优化（Bonus）</strong></p><p><strong>切入点：</strong><br>我们看到，之前方法遍历dp列表需要$O(N)$，计算每个<code>dp[i]</code>需要$O(N)$的时间，所以总复杂度是$O(N^2)$</p><p>前面遍历dp列表的时间复杂度肯定无法降低了，但是我们看后面在每轮遍历<code>[0,i]</code>的<code>dp[i]​</code>元素的时间复杂度可以考虑设计状态定义，使得整个dp为一个排序列表，这样我们自然想到了可以利用二分法来把时间复杂度降到了$O(NlogN)$。这里由于篇幅原因，如果大家感兴趣的话详细的解题步骤可以看好心人写的<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/" target="_blank" rel="noopener">二分方法+动态规划详解</a></p><p><strong>模板总结：</strong></p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i):            dp[i]=最值(dp[i],dp[j]+...)</code></pre><p>对于子序列问题，很多也都是用这个模板来进行解题，比如<a href="https://leetcode-cn.com/problems/maximum-subarray/solution/" target="_blank" rel="noopener">Leetcode53.最大子序和</a>。此外，其他情况的子序列问题可能需要二维的dp数组来记录状态，比如：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">Leetcode5. 最长回文子串</a>（下面会讲到） 、  <a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">Leetcode1143. 最长公共子序列</a> (当涉及到两个字符串/数组时)<br>如果你觉得刚刚那题有点难的话，不如我们从简单一点的题目开始理解一下这类子序列问题。接下来所有题目我们都按照那五个步骤考虑</p><h2 id="算法应用"><a href="#算法应用" class="headerlink" title="算法应用"></a>算法应用</h2><h3 id="Leetcode-674-最长连续递增序列"><a href="#Leetcode-674-最长连续递增序列" class="headerlink" title="Leetcode 674.最长连续递增序列"></a><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">Leetcode 674.最长连续递增序列</a></h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个未经排序的整数数组，找到最长且连续的的递增序列。</p><pre><code class="hljs angelscript">示例 <span class="hljs-number">1</span>:输入: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>]输出: <span class="hljs-number">3</span>解释: 最长连续递增序列是 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], 长度为<span class="hljs-number">3</span>。尽管 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>] 也是升序的子序列, 但它不是连续的，因为<span class="hljs-number">5</span>和<span class="hljs-number">7</span>在原数组里被<span class="hljs-number">4</span>隔开。</code></pre><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题是不是一眼看过去和上题非常的像，没错了，这个题目最大的不同就是<strong>连续</strong>两个字，这样就让这个问题简单很多了，因为如果要求连续的话，那么就不需要和上题一样遍历两遍数组，只需要比较前后的值是不是符合递增的关系。</p><ul><li><p><strong>第一步：确定动态规划状态</strong><br>对于这个问题，我们的状态<strong>dp[i]也是以nums[i]这个数结尾的最长递增子序列的长度</strong></p></li><li><p><strong>第二步：写出状态转移方程</strong><br>这个问题，我们需要分两种情况考虑，第一种情况是如果遍历到的数<code>nums[i]</code>后面一个数不是比他大或者前一个数不是比他小，也就是所谓的不是连续的递增，那么这个数列最长连续递增序列就是他本身，也就是长度为1。<br>第二种情况就是如果满足有递增序列，就意味着当前状态只和前一个状态有关，<code>dp[i]</code>只需要在前一个状态基础上加一就能得到当前最长连续递增序列的长度。总结起来，状态的转移方程可以写成<br><code>dp[i]=dp[i-1]+1</code></p></li><li><p><strong>第三步：考虑初始化条件</strong><br>和上面最长子序列相似，这个题目的初始化状态就是一个一维的全为1的数组。</p></li><li><p><strong>第四步：考虑输出状态</strong><br>与上题相似，这个问题输出条件也是求dp数组中最大的数。</p></li><li><p><strong>第五步：考虑是否可以优化</strong><br>这个题目只需要一次遍历就能求出连续的序列，所以在时间上已经没有可以优化的余地了，空间上来看的话也是一维数组，并没有优化余地。</p></li></ul><p>综上所述，可以很容易得到最后的代码：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(self, nums: List[int])</span> -&gt; int:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>  <span class="hljs-comment">#判断边界条件</span>        dp=[<span class="hljs-number">1</span>]*len(nums)      <span class="hljs-comment">#初始化dp数组状态</span>        <span class="hljs-comment">#注意需要得到前一个数，所以从1开始遍历，否则会超出范围</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(nums)):         <span class="hljs-keyword">if</span> nums[i]&gt;nums[i<span class="hljs-number">-1</span>]:<span class="hljs-comment">#根据题目所求得到状态转移方程</span>                    dp[i]=dp[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    dp[i]=<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> max(dp)  <span class="hljs-comment">#确定输出状态</span></code></pre><p><strong>总结: 通过这个题目和例题的比较，我们需要理清子序列和子数组（连续序列）的差别，前者明显比后者要复杂一点，因为前者是不连续的序列，后者是连续的序列，从复杂度来看也很清楚能看到即使穷举子序列也比穷举子数组要复杂很多。</strong></p><p>承接上面的话题，我们接下来继续来看一个子序列问题，这次是另外一种涉及二维状态的题目。</p><h3 id="Leetcode5-最长回文子串"><a href="#Leetcode5-最长回文子串" class="headerlink" title="Leetcode5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">Leetcode5. 最长回文子串</a></h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><pre><code class="hljs 1c">示例 <span class="hljs-number">1</span>：输入: <span class="hljs-string">"babad"</span>输出: <span class="hljs-string">"bab"</span>注意: <span class="hljs-string">"aba"</span> 也是一个有效答案。</code></pre><ul><li><p><strong>第一步：确定动态规划状态</strong><br>与上面两题不同的是，这个题目必须用二维的dp数组来记录状态，主要原因就是子串有回文的限制。用两个指针来记录子串的位置可以很好的实现子串的回文要求，又因为最后结果需要返回的是子串，这里不同于之前题目的用dp保存长度，我们必须找到具体哪个部分符合回文子串的要求。这里插一句，其实也有求回文子串长度的题目<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">Leetcode516. 最长回文子序列</a>,如果有兴趣可以看一下。这里我们定义<code>dp[i][j]</code>表示子串s从i到j是否为回文子串。</p></li><li><p><strong>第二步：写出状态转移方程</strong><br>首先我们需要知道符合回文的条件：</p><ul><li><p>字符串首尾两个字符必须相等，否则肯定不是回文。</p></li><li><p>当字符串首尾两个字符相等时：如果子串是回文，整体就是回文，这里就有了动态规划的思想，出现了子问题；相反，如果子串不是回文，那么整体肯定不是。<br>对于字符串<code>s,s[i,j]</code>的子串是<code>s[i+1,j-1]</code>，如果子串只有本身或者空串，那肯定是回文子串了，所以我们讨论的状态转移方程不是对于<code>j-1-(i+1)+1&lt;2</code>的情况(整理得<code>j-i&lt;3</code>)，当<code>s[i]</code>和<code>s[j]</code>相等并且<code>j-i&lt;3</code>时，我们可以直接得出<code>dp[i][j]</code>是True。</p><p>综上所述，可以得到状态转移方程</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> s[i]==s[j]:<span class="hljs-keyword">if</span> j-i&lt;<span class="hljs-number">3</span>:dp[i][j]=<span class="hljs-literal">True</span><span class="hljs-keyword">else</span>:dp[i][j]=dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]</code></pre></li></ul></li></ul><ul><li><p><strong>第三步：考虑初始化条件</strong><br>我们需要建立一个二维的初始状态是False的来保存状态的数组来表示dp，又因为考虑只有一个字符的时候肯定是回文串，所以dp表格的对角线<code>dp[i][i]</code>肯定是True。</p></li><li><p><strong>第四步：考虑输出状态</strong><br>这里dp表示的是从<code>i</code>到<code>j</code>是否是回文子串，这样一来就告诉我们子串的起始位置和结束位置，但是由于我们需要找到最长的子串，所以我们优化一下可以只记录起始位置和当前长度（当然你要是喜欢记录终止位置和当前长度也是没问题的）</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> dp[i][j]: <span class="hljs-comment">#只要dp[i][j]成立就表示是回文子串，然后我们记录位置，返回有效答案</span>    cur_len=j-i+<span class="hljs-number">1</span>    <span class="hljs-keyword">if</span> cur_len&gt;max_len:    max_len=cur_len    start=i</code></pre></li><li><p><strong>第五步：考虑对时间，空间复杂度的优化</strong><br>对于这个问题，时间和空间都可以进一步优化，对于空间方面的优化：这里采用一种叫中心扩散的方法来进行，而对于时间方面的优化，则是用了Manacher‘s Algorithm（马拉车算法）来进行优化。具体的实现可以参考<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">动态规划、Manacher 算法</a></p><p>这里给出比较容易理解的经典方法的代码：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s: str)</span> -&gt; str:</span>       length=len(s)       <span class="hljs-keyword">if</span> length&lt;<span class="hljs-number">2</span>:  <span class="hljs-comment">#判断边界条件</span>           <span class="hljs-keyword">return</span> s       dp=[[<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(length)]<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(length)] <span class="hljs-comment">#定义dp状态矩阵</span>       <span class="hljs-comment">#定义初试状态，这步其实可以省略</span>       <span class="hljs-comment"># for i in range(length):</span>       <span class="hljs-comment">#     dp[i][i]=True</span>              max_len=<span class="hljs-number">1</span>       start=<span class="hljs-number">0</span> <span class="hljs-comment">#后续记录回文串初试位置</span>       <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,length):           <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(j):               <span class="hljs-comment">#矩阵中逐个遍历</span>               <span class="hljs-keyword">if</span> s[i]==s[j]:                   <span class="hljs-keyword">if</span> j-i&lt;<span class="hljs-number">3</span>:                       dp[i][j]=<span class="hljs-literal">True</span>                   <span class="hljs-keyword">else</span>:                       dp[i][j]=dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]               <span class="hljs-keyword">if</span> dp[i][j]: <span class="hljs-comment">#记录位置，返回有效答案</span>                   cur_len=j-i+<span class="hljs-number">1</span>                   <span class="hljs-keyword">if</span> cur_len&gt;max_len:                       max_len=cur_len                       start=i       <span class="hljs-keyword">return</span> s[start:start+max_len]</code></pre></li></ul><p><strong>总结：这个是一个二维dp的经典题目，需要注意的就是定义dp数组的状态是什么，这里不用长度作为dp值而用是否是回文子串这个状态来存储也是一个比较巧妙的方法，使得题目变得容易理解。</strong></p><p>看了这么多套路相信你也对动态规划有点感觉了，这里再介绍一个求长度的子序列问题。</p><h3 id="Leetcode516-最长回文子序列"><a href="#Leetcode516-最长回文子序列" class="headerlink" title="Leetcode516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">Leetcode516. 最长回文子序列</a></h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p><pre><code class="hljs makefile">示例 1:<span class="hljs-section">输入:</span><span class="hljs-string">"bbbab"</span><span class="hljs-section">输出:</span>4</code></pre><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个问题和上面的例题也非常相似，直接套用动态规划套路也可以很快解决出来：</p><ul><li><p><strong>第一步：确定动态规划状态</strong><br>这里求的是最长子串的长度，所以我们可以直接定义一个二维的<code>dp[i][j]</code>来表示字符串第<code>i</code>个字符到第<code>j</code>个字符的长度，子问题也就是每个子回文字符串的长度。</p></li><li><p><strong>第二步：写出状态转移方程</strong><br>我们先来具体分析一下整个题目状态转移的规律。对于<code>d[i][j]</code>,我们根据上题的分析依然可以看出，<br>当<code>s[i]</code>和<code>s[j]</code>相等时，<code>s[i+1...j-1]</code>这个字符串加上2就是最长回文子序列；<br>当<code>s[i]</code>和<code>s[j]</code>不相等时，就说明可能只有其中一个出现在s[i,j]的最长回文子序列中，我们只需要取<code>s[i-1,j-1]</code>加上<code>s[i]</code>或者<code>s[j]</code>的数值中较大的；<br>综上所述，状态转移方程也就可以写成：</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> s[i]==s[j]:     dp[i][j]= dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span><span class="hljs-keyword">else</span>: dp[i][j]=max(dp[i][j<span class="hljs-number">-1</span>],dp[i+<span class="hljs-number">1</span>][j])</code></pre><p>但是问题来了，具体我们应该怎么求每个状态的值呢？这里介绍一种利用状态转移表法写出状态转移方程，我们通过把<code>dp[i][j]</code>的状态转移直接画成一张二维表格，我们所要做的也就是往这张表中填充所有的状态，进而得到我们想要的结果。如下图：</p></li></ul><p><img src="https://img-blog.csdnimg.cn/2020040820484089.png" srcset="/img/loading.gif" alt></p><p>  我们用字符串为”<strong>cbbd</strong>“作为输入来举例子，每次遍历就是求出右上角那些红色的值，通过上面的图我们会发现，按照一般的习惯都会先计算第一行的数值，但是当我们计算<code>dp[0,2]</code>的时候，我们会需要<code>dp[1,2]</code>，按照这个逻辑，我们就可以很容易发现遍历从下往上遍历会很方便计算。</p><ul><li><p><strong>第三步：考虑初始化条件</strong><br>很明显看出来的当只有一个字符的时候，最长回文子序列就是1，所以可以得到<code>dp[i][j]=1(i=j)</code><br>接下来我们来看看<br>当<code>i&gt;j</code>时，不符合题目要求，不存在子序列，所以直接初始化为0。<br>当<code>i&lt;j</code>时，每次计算表中对应的值就会根据前一个状态的值来计算。</p></li><li><p><strong>第四步：考虑输出状态</strong></p><p>我们想要求最长子序列的时候，我们可以直接看出来<code>dp[0][-1]</code>是最大的值，直接返回这个值就是最后的答案。</p></li><li><p><strong>第五步：考虑对时间，空间复杂度的优化</strong><br>对于这个题目，同样可以考虑空间复杂度的优化，因为我们在计算<code>dp[i][j]</code>的时候，只用到左边和下边。如果改为用一维数组存储，那么左边和下边的信息也需要存在数组里，所以我们可以考虑在每次变化前用临时变量<code>tmp</code>记录会发生变化的左下边信息。所以状态转移方程就变成了：</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> s[i] == s[j]:    tmp, dp[j] = dp[j], tmp + <span class="hljs-number">2</span><span class="hljs-keyword">else</span>:    dp[j] =max(dp[j],dp[j<span class="hljs-number">-1</span>])</code></pre><p>这里给出基本版的实现代码，如果需要优化后的可以看<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/dong-tai-gui-hua-jiang-wei-kong-jian-ya-suo-te-shu/" target="_blank" rel="noopener">空间压缩优化解法</a></p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(self, s: str)</span> -&gt; int:</span>        n=len(s)        dp=[[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n)]  <span class="hljs-comment">#定义动态规划状态转移矩阵</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):  <span class="hljs-comment">#   初始化对角线，单个字符子序列就是1</span>            dp[i][i]=<span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>):  <span class="hljs-comment">#从右下角开始往上遍历</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>,n):                <span class="hljs-keyword">if</span> s[i]==s[j]:   <span class="hljs-comment">#当两个字符相等时，直接子字符串加2</span>                    dp[i][j]= dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span>                  <span class="hljs-keyword">else</span>:           <span class="hljs-comment">#不相等时，取某边最长的字符</span>                    dp[i][j]=max(dp[i][j<span class="hljs-number">-1</span>],dp[i+<span class="hljs-number">1</span>][j])        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">-1</span>]   <span class="hljs-comment">#返回右上角位置的状态就是最长</span></code></pre></li></ul><p><strong>总结：对于二维的数组的动态规划，采用了画状态转移表的方法来得到输出的状态，这种方法更加直观能看出状态转移的具体过程，同时也不容易出错。当然具体选择哪种方法则需要根据具体题目来确定，如果状态转移方程比较复杂的利用这种方法就能简化很多。</strong></p><p><strong>模板总结：</strong></p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n):    <span class="hljs-keyword">if</span> s[i]==s[j]:            dp[i][j]=dp[i][j]+...        <span class="hljs-keyword">else</span>:        dp[i][j]=最值(...)</code></pre><p>当然，动态规划除了解决子序列问题，也可以用来解决其他实际的问题，比如之前提到过的各种AI的经典算法，接下来我们来看一道动态规划的高频面试题，也是实际开发中很常用的。</p><h3 id="Leetcode72-编辑距离"><a href="#Leetcode72-编辑距离" class="headerlink" title="Leetcode72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">Leetcode72. 编辑距离</a></h3><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><pre><code class="hljs python">你可以对一个单词进行如下三种操作：插入一个字符删除一个字符替换一个字符示例 <span class="hljs-number">1</span>:输入: word1 = <span class="hljs-string">"horse"</span>, word2 = <span class="hljs-string">"ros"</span>输出: <span class="hljs-number">3</span>解释: horse -&gt; rorse (将 'h' 替换为 'r')rorse -&gt; rose (删除 'r')rose -&gt; ros (删除 'e')</code></pre><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><strong>第一步：确定动态规划状态</strong></li></ul><p>这个题目涉及到两个字符串，所以我们最先想到就是用两维数组来保存转移状态，定义<code>dp[i][j]</code>为字符串word1长度为<code>i</code>和字符串word2长度为<code>j</code>时，word1转化成word2所执行的最少操作次数的值。</p><ul><li><p><strong>第二步：写出状态转移方程</strong></p><p>关于这个问题的状态转移方程其实很难想到，这里提供的一个方向就是试着举个例子，然后通过例子的变化记录每一步变化得到的最少次数，来找到删除，插入，替换操作的状态转移方程具体应该怎么写。<br>我们采用从末尾开始遍历<code>word1</code>和<code>word2</code>，<br>当<code>word1[i]</code>等于<code>word2[j]</code>时，说明两者完全一样，所以<code>i</code>和<code>j</code>指针可以任何操作都不做，用状态转移式子表示就是<code>dp[i][j]=dp[i-1][j-1]</code>，也就是前一个状态和当前状态是一样的。<br>当<code>word1[i]</code>和<code>word2[j]</code>不相等时，就需要对三个操作进行递归了，这里就需要仔细思考状态转移方程的写法了。<br>对于<strong>插入</strong>操作，当我们在word1中插入一个和word2一样的字符，那么word2就被匹配了，所以可以直接表示为<code>dp[i][j-1]+1</code><br>对于<strong>删除</strong>操作，直接表示为<code>dp[i-1][j]+1</code><br>对于<strong>替换</strong>操作，直接表示为<code>dp[i-1][j-1]+1</code><br>所以状态转移方程可以写成<code>min(dp[i][j-1]+1,dp[i-1][j]+1,dp[i-1][j-1]+1)​</code></p></li><li><p><strong>第三步：考虑初始化条件</strong><br>我们还是利用dp转移表法来找到状态转移的变化（读者可以自行画一张dp表，具体方法在求最长子序列中已经演示过了），这里我们用空字符串来额外加入到word1和word2中，这样的目的是方便记录每一步操作，例如如果其中一个是空字符串，那么另外一个字符至少的操作数都是1，就从1开始计数操作数，以后每一步都执行插入操作，也就是当<code>i=0</code>时，<code>dp[0][j]=j</code>,同理可得，如果另外一个是空字符串，则对当前字符串执行删除操作就可以了，也就是<code>dp[i][0]=i​</code>。</p></li><li><p><strong>第四步：考虑输出状态</strong><br>在转移表中我们可以看到，可以从左上角一直遍历到左下角的值，所以最终的编辑距离就是最后一个状态的值，对应的就是<code>dp[-1][-1]​</code>。</p></li><li><p><strong>第五步：考虑对时间，空间复杂度的优化</strong><br>和上题一样，这里由于<code>dp[i][j]</code>只和dp表中附近的三个状态（左边，右边和左上边）有关，所以同样可以进行压缩状态转移的空间存储，如果觉得有兴趣可以参考<a href="https://leetcode-cn.com/u/lyncien/" target="_blank" rel="noopener">@Lyncien</a>的解法,对于时间方面应该并没有可以优化的方法。</p></li></ul><p>总结起来代码如下：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(self, word1, word2)</span>:</span> <span class="hljs-comment">#m,n 表示两个字符串的长度</span> m=len(word1)  n=len(word2) <span class="hljs-comment">#构建二维数组来存储子问题</span> dp=[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m+<span class="hljs-number">1</span>)] <span class="hljs-comment">#考虑边界条件，第一行和第一列的条件</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>):     dp[<span class="hljs-number">0</span>][i]=i  <span class="hljs-comment">#对于第一行，每次操作都是前一次操作基础上增加一个单位的操作</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(m+<span class="hljs-number">1</span>):     dp[j][<span class="hljs-number">0</span>]=j <span class="hljs-comment">#对于第一列也一样，所以应该是1,2,3,4,5...</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>):  <span class="hljs-comment">#对其他情况进行填充</span>     <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):         <span class="hljs-keyword">if</span> word1[i<span class="hljs-number">-1</span>]==word2[j<span class="hljs-number">-1</span>]: <span class="hljs-comment">#当最后一个字符相等的时候，就不会产生任何操作代价，所以与dp[i-1][j-1]一样</span>             dp[i][j]=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]         <span class="hljs-keyword">else</span>:             dp[i][j]=min(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])+<span class="hljs-number">1</span> <span class="hljs-comment">#分别对应删除，添加和替换操作</span> <span class="hljs-keyword">return</span> dp[<span class="hljs-number">-1</span>][<span class="hljs-number">-1</span>] <span class="hljs-comment">#返回最终状态就是所求最小的编辑距离</span></code></pre><p>如果上面的题目看起来还是有点吃力的话，接下我们来来看轻松一点的题目，下面的题目和斐波那契数列求解类似，既可用迭代也可用动态规划做。</p><h3 id="Leetcode198-打家劫舍"><a href="#Leetcode198-打家劫舍" class="headerlink" title="Leetcode198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">Leetcode198. 打家劫舍</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><pre><code class="hljs angelscript">给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。示例 <span class="hljs-number">1</span>:输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]输出: <span class="hljs-number">4</span>解释: 偷窃 <span class="hljs-number">1</span> 号房屋 (金额 = <span class="hljs-number">1</span>) ，然后偷窃 <span class="hljs-number">3</span> 号房屋 (金额 = <span class="hljs-number">3</span>)。     偷窃到的最高金额 = <span class="hljs-number">1</span> + <span class="hljs-number">3</span> = <span class="hljs-number">4</span> 。</code></pre><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个问题不复杂，其实利用一般的迭代可以直接解出来，但是这里讲动态规划，所以还是按照标准的套路来</p><ul><li><p><strong>第一步：确定动态规划状态</strong><br>直接定义题目所求的偷窃的最高金额，所以<code>dp[i]</code>表示偷窃第<code>i</code>号房子能得到的最高金额。</p></li><li><p><strong>第二步：写出状态转移方程</strong><br>如果我们不考虑限制条件相邻两个房子不能抢，那么问题就很简单。想得到第<code>i</code>个房间偷窃到的最高金额的时候，我们会考虑子问题前<code>i-1​</code>间的最高金额<code>dp[i-1]</code>，然后再加上当前房间的金额，所以最后可以表达为<code>dp[i]=dp[i-1]+nums[i]</code>。<br>需要注意的是，这里限制了相邻两个房子是不能抢的，接下来我们就要考虑两种情况。<br>如果抢了第i个房间，那么第<code>i-1​</code>肯定是不能抢的，这个时候需要再往前一间，用第<code>i-2</code>间的金额加上当前房间的金额，得到的状态转移方程是<code>dp[i]=dp[i-2]+nums[i]</code>。<br>如果没有抢第<code>i​</code>个房间，那么肯定抢了第<code>i-1</code>间的金额，所以直接有<code>dp[i]=dp[i-1]</code>。</p><p>最后综合一下两种情况，就可以很快得到状态转移方程：<code>dp[i]=max(dp[i-2]+nums[i],dp[i-1])​</code></p></li><li><p><strong>第三步：考虑初始化条件</strong><br>初始化条件需要考虑第一个房子和第二个房子，之后的房子都可以按照规律直接求解，当我们只有一个房子的时候，自然只抢那间房子，当有两间房的时候，就抢金额较大的那间。综合起来就是<code>dp[0]=nums[0]，dp[1]=max(nums[0],nums[1])​</code>。</p></li><li><p><strong>第四步:考虑输出状态</strong><br>直接返回状态转移数组的最后一个值就是所求的最大偷窃金额。</p></li><li><p><strong>第五步：考虑对时间，空间复杂度的优化</strong><br>时间复杂度为$O(N)$不能再优化了，空间复杂度方面如果用动态规划是不能优化，但是如果用迭代的方法只存储临时变量来记录每一步计算结果，这样可以降到$O(1)$。</p></li></ul><p>这里给出动态规划版本的实现代码：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span><span class="hljs-params">(self, nums)</span>:</span>   <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> nums):   <span class="hljs-comment">#特殊情况处理</span>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>   <span class="hljs-keyword">if</span> len(nums)==<span class="hljs-number">1</span>:       <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]   n=len(nums)   dp=[<span class="hljs-number">0</span>]*n    <span class="hljs-comment">#初始化状态转移数组</span>   dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>]  <span class="hljs-comment">#第一个边界值处理</span>   dp[<span class="hljs-number">1</span>]=max(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>])<span class="hljs-comment">#第二个边界值处理</span>   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,n):       dp[i]=max(dp[i<span class="hljs-number">-2</span>]+nums[i],dp[i<span class="hljs-number">-1</span>]) <span class="hljs-comment">#状态转移方程</span>   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">-1</span>]</code></pre><h3 id="Leetcode213-打家劫舍-II"><a href="#Leetcode213-打家劫舍-II" class="headerlink" title="Leetcode213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">Leetcode213. 打家劫舍 II</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><pre><code class="hljs angelscript">给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。示例 <span class="hljs-number">1</span>:输入: [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]输出: <span class="hljs-number">3</span>解释: 你不能先偷窃 <span class="hljs-number">1</span> 号房屋（金额 = <span class="hljs-number">2</span>），然后偷窃 <span class="hljs-number">3</span> 号房屋（金额 = <span class="hljs-number">2</span>）, 因为他们是相邻的。</code></pre><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><p><strong>第一步：确定动态规划状态</strong></p><p>直接定义题目所求的偷窃的最高金额，所以<code>dp[i]</code>表示偷窃第<code>i</code>号房子能得到的最高金额。</p></li><li><p><strong>第二步：写出状态转移方程</strong></p><p>和上个题目类似，这个题目不一样的是现在所有房屋都围成一个圈，相比于上个问题又增加了一个限制，这样一来第一个房子和最后一个房子只能选择其中一个偷窃了。所有我们把这个问题拆分成两个问题：</p><ul><li>偷窃了第一个房子，此时对应的是<code>nums[1:]</code>，得到最大的金额value是<code>v1</code>。</li><li>偷窃了最后一个房子，此时对应的是<code>nums[:n-1]</code>(其中n是所有房子的数量)，得到的最大金额value是<code>v2</code>。<br>最后的结果就是取这两种情况的最大值，即<code>max(v1,v2)</code>。</li></ul><p>每个子问题就和上题是一样的了，所以可以直接得到状态转移方程还是<code>dp[i]=max(dp[i-2]+nums[i],dp[i-1])</code></p></li><li><p><strong>第三步：考虑初始化条件</strong><br>初始化一个房子和两个房子的情况就是<code>dp[0]=nums[0]，dp[1]=max(nums[0],nums[1])</code>。</p></li><li><p><strong>第四步：考虑输出状态</strong><br>直接返回状态转移数组的最后一个值就是所求的最大偷窃金额。</p></li><li><p><strong>第五步：考虑对时间，空间复杂度的优化</strong></p></li></ul><p>时间复杂度为$O(N)$不能再优化了，空间复杂度方面如果用动态规划是不能优化，但是如果用迭代的方法只存储临时变量来记录每一步计算结果，这样可以降到$O(1)$。</p><p>最后的代码实现：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span><span class="hljs-params">(self, nums: List[int])</span> -&gt; int:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">elif</span> len(nums)&lt;=<span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> max(nums)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span><span class="hljs-params">(nums)</span>:</span>            <span class="hljs-keyword">if</span> len(nums)&lt;=<span class="hljs-number">2</span>:                <span class="hljs-keyword">return</span> max(nums)            dp=[<span class="hljs-number">0</span>]*len(nums)            dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>]            dp[<span class="hljs-number">1</span>]=max(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>])            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,len(nums)):                dp[i]=max(dp[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>]+nums[i])            <span class="hljs-keyword">return</span> dp[<span class="hljs-number">-1</span>]        <span class="hljs-keyword">return</span> max(helper(nums[<span class="hljs-number">1</span>:]),helper(nums[:<span class="hljs-number">-1</span>]))</code></pre><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>动态规划是算法中比较难的类型，但是其实主要是掌握一种思维，有了这种思维，其实很难的问题都能一步一步解决好。最后再推荐一些比较优质的动态规划文章。</p><p><a href="https://www.jiqizhixin.com/articles/2019-09-29-5" target="_blank" rel="noopener">掌握动态规划，助你成为优秀的算法工程师</a></p><p>推荐MIT的动态规划练习资料，这份资料通过动态规划经典的问题让我们很清晰的了解到这个算法的魅力所在，对于新手入门动态规划是一个很不错的资料。<a href="https://people.cs.clemson.edu/~bcdean/dp_practice/" target="_blank" rel="noopener">Dynamic Programming Practice Problems</a></p><p>五分钟学算法的动态规划系列:<br><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247485288&amp;idx=1&amp;sn=fd043fc723f38bcaecc90d9945981f8a&amp;chksm=fa0e68e9cd79e1ffd965205bb06b1731539bf2e0bbc5991664f5d1d9721b346ec08c85bb9042&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">浅谈什么是动态规划以及相关的「股票」算法题</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247486904&amp;idx=1&amp;sn=099d5560ab25c0163349dff0c7f51490&amp;chksm=fa0e6239cd79eb2fe6e831d7debba60aa906721d592b8766a944ef88bf91bf82568c20d71891&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">有了四步解题法模板，再也不害怕动态规划!</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247486923&amp;idx=2&amp;sn=6c1c8aeb4db68522e67ddf8c1e933660&amp;chksm=fa0e624acd79eb5cdb410808921609a830b9b9221e813e4eb89cf551ca48f317668d44b095d2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">（进阶版）有了四步解题法模板，再也不害怕动态规划！</a></p><p>主要参考的Leetcode 优秀题解：<br><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia/" target="_blank" rel="noopener">动态规划设计方法&amp;&amp;纸牌游戏讲解二分解法</a><br><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">动态规划、Manacher 算法</a><br><a href="https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/" target="_blank" rel="noopener">编辑距离面试题详解</a><br><a href="https://leetcode-cn.com/problems/house-robber-ii/solution/213-da-jia-jie-she-iidong-tai-gui-hua-jie-gou-hua-/" target="_blank" rel="noopener">打家劫舍 II（动态规划，结构化思路，清晰题解）</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h2&gt;&lt;p&gt;动态规划常常适用于&lt;strong&gt;有重叠子问题&lt;/strong&gt;和&lt;strong&gt;最优子结构&lt;/strong&gt;性质的问题，动
      
    
    </summary>
    
    
      <category term="算法" scheme="https://sulimin-nb.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://sulimin-nb.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动手学数据分析-2</title>
    <link href="https://sulimin-nb.github.io/article/dc948b2c.html"/>
    <id>https://sulimin-nb.github.io/article/dc948b2c.html</id>
    <published>2020-08-21T16:12:07.000Z</published>
    <updated>2020-08-21T16:12:18.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>动手学数据分析-1</title>
    <link href="https://sulimin-nb.github.io/article/459dda96.html"/>
    <id>https://sulimin-nb.github.io/article/459dda96.html</id>
    <published>2020-08-19T15:19:39.000Z</published>
    <updated>2020-08-19T16:09:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据载入及观察"><a href="#1-数据载入及观察" class="headerlink" title="1. 数据载入及观察"></a>1. 数据载入及观察</h2><p>在数据处理中，第一步通常都需要导入数据，并进行对数据的初步预览</p><ol><li><strong>导入库</strong> 导入所需数据库:import numpy as np; import pandas as pd</li><li><strong>载入数据</strong> pd.read_csv(‘filename’), csv为文件格式，可替换为其他格式：tsv;xlsx</li><li><strong>逐块读取</strong> 有时数据库过大，为了节约内存需要分批次读取：pd.read_csv(‘filename’, chunksize=int)</li><li><strong>修改column索引名称</strong> pd.read_csv(‘names=[‘a’,‘b’,…],index_col=‘乘客ID’,header=0)</li><li><strong>初步观察</strong> 前(n+1)个数据：head(n),后（n+1)个数据tail(n), 判断数据是否为空isnull()</li><li><strong>保存数据</strong> to_csv(‘filename’)</li></ol><h2 id="2-pandas基础"><a href="#2-pandas基础" class="headerlink" title="2. pandas基础"></a>2. pandas基础</h2><ol><li><strong>数据类型</strong> pandas中有两个数据类型DataFrame, Series; Series比较适合一个属性对应一个数据， DataFrame则适用于一个实例具有多种属性，很符合数据挖掘所需要的数据模式</li><li><strong>查看DataFrame数据的每列的项</strong> 根据数据的列索引可以很容易实现 data[‘Column_name’]</li><li><strong>将多余的列的删除</strong> del data[‘Column_name’]</li><li><strong>将某些列暂时隐藏</strong> data.drop([‘Columb_name’],axis=1)<br>若想完全删除 data.drop([‘Columb_name’]，axis=1, inplace = True)</li><li><strong>显示满足某条件的数据</strong><br>criteria = data[‘Column_name’]&gt; x<br>此时criteria所含元素数据类型皆为bool<br>显示满足条件的数据(bool=True): Desired = data[criteria]</li></ol><p>但此时index为old index, 若想得到此数据集某一行的值，需要重新设置index: Desird.reset_index(drop=True); drop=True将old index隐藏<br>\6. <strong>显示数据集中某行某列的值</strong> data.loc[[index_x,index_y, index_z…],[’Column_x‘,‘Columb_name_y’…]]</p><p>也可以都用索引值 函数：iloc<br>midage.iloc[[100,105,108],[2,3,4]]</p><h2 id="3-探索性数据分析"><a href="#3-探索性数据分析" class="headerlink" title="3. 探索性数据分析"></a>3. 探索性数据分析</h2><ol><li><strong>对数据值进行排序</strong> 一组数据DataFrame.sort_<strong>values</strong>(by=‘column_name’, ascending=False)<br>默认 ascending = True 升序， False 降序<br>两组数据排序(先对第一个排序)<br>DataFrame.sort_<strong>values</strong>(by=[‘column_name1’,‘column_name2’], ascending=False)</li><li><strong>索引排序</strong> 行索引升序排序：DataFrame.sort_<strong>index</strong>()<br>列索引升序排序 DataFrame.sort_<strong>index</strong>(axis = 1)</li><li><strong>算术计算</strong>两个DataFrame运算后，会返回一个新的DataFrame，对应的行和列的值会相加，没有对应的会变成空值NaN</li><li><strong>查看DataFrame数据信息</strong><br>函数：DataFrame.describe()<br>输出:<br>count : 样本数据大小<br>mean : 样本数据的平均值<br>std : 样本数据的标准差<br>min : 样本数据的最小值<br>25% : 样本数据25%的时候的值<br>50% : 样本数据50%的时候的值<br>75% : 样本数据75%的时候的值<br>max : 样本数据的最大值</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-数据载入及观察&quot;&gt;&lt;a href=&quot;#1-数据载入及观察&quot; class=&quot;headerlink&quot; title=&quot;1. 数据载入及观察&quot;&gt;&lt;/a&gt;1. 数据载入及观察&lt;/h2&gt;&lt;p&gt;在数据处理中，第一步通常都需要导入数据，并进行对数据的初步预览&lt;/p&gt;
&lt;ol&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>算法-分治</title>
    <link href="https://sulimin-nb.github.io/article/1768cd4c.html"/>
    <id>https://sulimin-nb.github.io/article/1768cd4c.html</id>
    <published>2020-08-19T10:32:09.000Z</published>
    <updated>2020-08-19T11:07:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>分治算法的主要思想是将原问题<strong>递归地分成</strong>若干个子问题，直到子问题<strong>满足边界条件</strong>，停止递归。将子问题逐个击破(一般是同种方法)，将已经解决的子问题合并，最后，算法会<strong>层层合并</strong>得到原问题的答案。</p><h3 id="分治算法的步骤"><a href="#分治算法的步骤" class="headerlink" title="分治算法的步骤"></a>分治算法的步骤</h3><ul><li>分：<strong>递归地</strong>将问题<strong>分解</strong>为各个的子<strong>问题</strong>(性质相同的、相互独立的子问题)；</li><li>治：将这些规模更小的子问题<strong>逐个击破</strong>；</li><li>合：将已解决的子问题<strong>逐层合并</strong>，最终得出原问题的解；</li></ul><p><img src="https://img-blog.csdnimg.cn/20200408204450701.png" srcset="/img/loading.gif" alt></p><h3 id="分治法适用的情况"><a href="#分治法适用的情况" class="headerlink" title="分治法适用的情况"></a>分治法适用的情况</h3><ul><li>原问题的<strong>计算复杂度</strong>随着问题的规模的增加而增加。</li><li>原问题<strong>能够被分解</strong>成更小的子问题。</li><li>子问题的<strong>结构和性质</strong>与原问题一样，并且<strong>相互独立</strong>，子问题之间<strong>不包含</strong>公共的子子问题。</li><li>原问题分解出的子问题的解<strong>可以合并</strong>为该问题的解。</li></ul><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">divide_conquer</span><span class="hljs-params">(problem, paraml, param2,...)</span>:</span>    <span class="hljs-comment"># 不断切分的终止条件</span>    <span class="hljs-keyword">if</span> problem <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        print_result        <span class="hljs-keyword">return</span>    <span class="hljs-comment"># 准备数据</span>    data=prepare_data(problem)    <span class="hljs-comment"># 将大问题拆分为小问题</span>    subproblems=split_problem(problem, data)    <span class="hljs-comment"># 处理小问题，得到子结果</span>    subresult1=self.divide_conquer(subproblems[<span class="hljs-number">0</span>],p1,..…)    subresult2=self.divide_conquer(subproblems[<span class="hljs-number">1</span>],p1,...)    subresult3=self.divide_conquer(subproblems[<span class="hljs-number">2</span>],p1,.…)    <span class="hljs-comment"># 对子结果进行合并 得到最终结果</span>    result=process_result(subresult1, subresult2, subresult3,...)</code></pre><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>​        通过应用举例分析理解分治算法的原理其实并不难，但是要想灵活应用并在编程中体现这种思想中却并不容易。所以，这里这里用分治算法应用在排序的时候的一个栗子，加深对分治算法的理解。</p><p>相关概念：</p><ul><li><strong>有序度</strong>：表示一组数据的有序程度</li><li><strong>逆序度</strong>：表示一组数据的无序程度</li></ul><p>一般通过<strong>计算有序对或者逆序对的个数</strong>，来表示数据的有序度或逆序度。</p><p>假设我们有 <code>n</code> 个数据，我们期望数据从小到大排列，那完全有序的数据的有序度就是 $n(n-1)/2$，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 $n(n-1)/2$。</p><p><strong>Q：如何编程求出一组数据的有序对个数或者逆序对个数呢？</strong></p><p>因为有序对个数和逆序对个数的求解方式是类似的，所以这里可以只思考逆序对（常接触的）个数的求解方法。</p><ul><li>方法1<ul><li>拿数组里的每个数字跟它后面的数字比较，看有几个比它小的。</li><li>把比它小的数字个数记作 <code>k</code>，通过这样的方式，把每个数字都考察一遍之后，然后对每个数字对应的 <code>k</code> 值求和</li><li>最后得到的总和就是逆序对个数。</li><li>这样操作的时间复杂度是$O(n^2)$（需要两层循环过滤）。那有没有更加高效的处理方法呢？这里尝试套用分治的思想来求数组 A 的逆序对个数。</li></ul></li><li>方法2<ul><li>首先将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2</li><li>然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</li><li>注意使用分治算法其中一个要求是，<strong>子问题合并的代价不能太大</strong>，否则就起不了降低时间复杂度的效果了。</li><li><strong>如何快速计算出两个子问题 A1 与 A2 之间的逆序对个数呢？这里就要借助归并排序算法了。（这里先回顾一下归并排序思想）</strong>如何借助归并排序算法来解决呢？归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。实际上，在这个合并的过程中，可以计算这两个小数组的逆序对个数了。每次合并操作，我们都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。</li></ul></li></ul><h3 id="算法应用"><a href="#算法应用" class="headerlink" title="算法应用"></a>算法应用</h3><h4 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169. 多数元素</a></h4><ul><li><p>题目描述</p><p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 [n/2] 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p><p>示例 1:</p><pre><code class="hljs python">输入: [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]输出: <span class="hljs-number">3</span></code></pre><p>示例 2:</p><pre><code class="hljs python">输入: [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]输出: <span class="hljs-number">2</span></code></pre></li><li><p>解题思路</p><ul><li><p>确定切分的终止条件</p><p>直到所有的子问题都是长度为 1 的数组，停止切分。</p></li><li><p>准备数据，将大问题切分为小问题</p><p>递归地将原数组二分为左区间与右区间，直到最终的数组只剩下一个元素，将其返回</p></li><li><p>处理子问题得到子结果，并合并</p><ul><li><p>长度为 1 的子数组中唯一的数显然是众数，直接返回即可。</p></li><li><p>如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。</p></li><li><p>如果他们的众数不同，比较两个众数在整个区间内出现的次数来决定该区间的众数</p></li></ul></li></ul></li><li><p>代码</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majorityElement2</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># 【不断切分的终止条件】</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]        <span class="hljs-comment"># 【准备数据，并将大问题拆分为小问题】</span>        left = self.majorityElement(nums[:len(nums)//<span class="hljs-number">2</span>])        right = self.majorityElement(nums[len(nums)//<span class="hljs-number">2</span>:])        <span class="hljs-comment"># 【处理子问题，得到子结果】</span>        <span class="hljs-comment"># 【对子结果进行合并 得到最终结果】</span>        <span class="hljs-keyword">if</span> left == right:            <span class="hljs-keyword">return</span> left        <span class="hljs-keyword">if</span> nums.count(left) &gt; nums.count(right):            <span class="hljs-keyword">return</span> left        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> right</code></pre></li></ul><h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h4><ul><li><p>题目描述</p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">4</span>],输出: <span class="hljs-number">6</span>解释: 连续子数组 [<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 的和最大为<span class="hljs-number">6</span>。</code></pre></li><li><p>解题思路</p></li><li><p><img src="/article/1768cd4c/image-20200819190726688.png" srcset="/img/loading.gif" alt="image-20200819190726688"></p></li><li><p>```python<br>from typing import List<br>class Solution:<br>  def maxSubArray(self, nums: List[int]) -&gt; int:</p><pre><code>    ans = nums[0]  pre=0    for x in nums:      pre = max(pre+x, x)        ans = max(ans, pre)      print(pre, ans)    return ans</code></pre><pre><code class="hljs python">  * **方法二：分治**  * 确定切分的终止条件    直到所有的子问题都是长度为 <span class="hljs-number">1</span> 的数组，停止切分。  * 准备数据，将大问题切分为小问题    递归地将原数组二分为左区间与右区间，直到最终的数组只剩下一个元素，将其返回  * 处理子问题得到子结果，并合并    - 将数组切分为左右区间      - 对与左区间：从右到左计算左边的最大子序和      - 对与右区间：从左到右计算右边的最大子序和    - 由于左右区间计算累加和的方向不一致，因此，左右区间直接合并相加之后就是整个区间的和    - 最终返回左区间的元素、右区间的元素、以及整个区间(相对子问题)和的最大值* 代码  ```python  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(self, nums)</span>:</span>          <span class="hljs-string">"""</span><span class="hljs-string">          :type nums: List[int]</span><span class="hljs-string">          :rtype: int</span><span class="hljs-string">          """</span>          <span class="hljs-comment"># 【确定不断切分的终止条件】</span>          n = len(nums)          <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:              <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]            <span class="hljs-comment"># 【准备数据，并将大问题拆分为小的问题】</span>          left = self.maxSubArray(nums[:len(nums)//<span class="hljs-number">2</span>])          right = self.maxSubArray(nums[len(nums)//<span class="hljs-number">2</span>:])            <span class="hljs-comment"># 【处理小问题，得到子结果】</span>          <span class="hljs-comment">#　从右到左计算左边的最大子序和</span>          max_l = nums[len(nums)//<span class="hljs-number">2</span> <span class="hljs-number">-1</span>] <span class="hljs-comment"># max_l为该数组的最右边的元素</span>          tmp = <span class="hljs-number">0</span> <span class="hljs-comment"># tmp用来记录连续子数组的和</span>                    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range( len(nums)//<span class="hljs-number">2</span><span class="hljs-number">-1</span> , <span class="hljs-number">-1</span> , <span class="hljs-number">-1</span> ):<span class="hljs-comment"># 从右到左遍历数组的元素</span>              tmp += nums[i]              max_l = max(tmp ,max_l)                        <span class="hljs-comment"># 从左到右计算右边的最大子序和</span>          max_r = nums[len(nums)//<span class="hljs-number">2</span>]          tmp = <span class="hljs-number">0</span>          <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)//<span class="hljs-number">2</span>,len(nums)):              tmp += nums[i]              max_r = max(tmp,max_r)                        <span class="hljs-comment"># 【对子结果进行合并 得到最终结果】</span>          <span class="hljs-comment"># 返回三个中的最大值</span>          <span class="hljs-keyword">return</span> max(left,right,max_l+ max_r)</code></pre></li></ul><h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h4><ul><li><p>题目描述</p><p>实现 <code>pow(x, n)</code>，即计算 <code>x</code> 的 <code>n</code> 次幂函数。</p><p>示例 1:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">2.00000</span>, <span class="hljs-number">10</span>输出: <span class="hljs-number">1024.00000</span></code></pre><p>示例 2:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">2.10000</span>, <span class="hljs-number">3</span>输出: <span class="hljs-number">9.26100</span></code></pre><p>示例 3:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">2.00000</span>, <span class="hljs-number">-2</span>输出: <span class="hljs-number">0.25000</span>解释: <span class="hljs-number">2</span><span class="hljs-number">-2</span> = <span class="hljs-number">1</span>/<span class="hljs-number">22</span> = <span class="hljs-number">1</span>/<span class="hljs-number">4</span> = <span class="hljs-number">0.25</span></code></pre><p>说明:</p><p><code>-100.0 &lt; x &lt; 100.0</code><br><code>n</code>是 32 位有符号整数，其数值范围是$[−2^{31}, 2^{31} − 1] $。</p></li><li><p>解题思路</p><ul><li><p>确定切分的终止条件</p><p>对<code>n</code>不断除以2，并更新<code>n</code>，直到为0，终止切分</p></li><li><p>准备数据，将大问题切分为小问题</p><p>对<code>n</code>不断除以2，更新</p></li><li><p>处理子问题得到子结果，并合并</p><ul><li><code>x</code>与自身相乘更新<code>x</code></li><li>如果<code>n%2 ==1</code><ul><li>将<code>p</code>乘以<code>x</code>之后赋值给<code>p</code>(初始值为1)，返回<code>p</code></li></ul></li></ul></li><li><p>最终返回<code>p</code></p></li></ul></li><li><p>代码</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: float</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: float</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># 处理n为负的情况</span>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> :            x = <span class="hljs-number">1</span>/x            n = -n        <span class="hljs-comment"># 【确定不断切分的终止条件】</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> :            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        <span class="hljs-comment"># 【准备数据，并将大问题拆分为小的问题】</span>        <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>:          <span class="hljs-comment"># 【处理小问题，得到子结果】</span>          p = x * self.myPow(x,n<span class="hljs-number">-1</span>)<span class="hljs-comment"># 【对子结果进行合并 得到最终结果】</span>          <span class="hljs-keyword">return</span> p        <span class="hljs-keyword">return</span> self.myPow(x*x,n/<span class="hljs-number">2</span>)</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;主要思想&quot;&gt;&lt;a href=&quot;#主要思想&quot; class=&quot;headerlink&quot; title=&quot;主要思想&quot;&gt;&lt;/a&gt;主要思想&lt;/h3&gt;&lt;p&gt;分治算法的主要思想是将原问题&lt;strong&gt;递归地分成&lt;/strong&gt;若干个子问题，直到子问题&lt;strong&gt;满足边界条件
      
    
    </summary>
    
    
      <category term="算法" scheme="https://sulimin-nb.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://sulimin-nb.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>python06-字典、集合和序列</title>
    <link href="https://sulimin-nb.github.io/article/8b342fda.html"/>
    <id>https://sulimin-nb.github.io/article/8b342fda.html</id>
    <published>2020-07-31T15:55:35.000Z</published>
    <updated>2020-07-31T15:56:56.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="1-可变类型与不可变类型"><a href="#1-可变类型与不可变类型" class="headerlink" title="1. 可变类型与不可变类型"></a>1. 可变类型与不可变类型</h2><ul><li>序列是以连续的整数为索引，与此不同的是，字典以”关键字”为索引，关键字可以是任意不可变类型，通常用字符串或数值。</li><li>字典是 Python 唯一的一个 <u>映射类型</u>，字符串、元组、列表属于<u>序列类型</u>。</li></ul><p>那么如何快速判断一个数据类型 <code>X</code> 是不是可变类型的呢？两种方法：</p><ul><li>麻烦方法：用 <code>id(X)</code> 函数，对 X 进行某种操作，比较操作前后的 <code>id</code>，如果不一样，则 <code>X</code> 不可变，如果一样，则 <code>X</code> 可变。</li><li>便捷方法：用 <code>hash(X)</code>，只要不报错，证明 <code>X</code> 可被哈希，即不可变，反过来不可被哈希，即可变。</li></ul><pre><code class="hljs python">i = <span class="hljs-number">1</span>print(id(i))  <span class="hljs-comment"># 140732167000896</span>i = i + <span class="hljs-number">2</span>print(id(i))  <span class="hljs-comment"># 140732167000960</span>l = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]print(id(l))  <span class="hljs-comment"># 4300825160</span>l.append(<span class="hljs-string">'Python'</span>)print(id(l))  <span class="hljs-comment"># 4300825160</span></code></pre><ul><li>整数 <code>i</code> 在加 1 之后的 <code>id</code> 和之前不一样，因此加完之后的这个 <code>i</code> (虽然名字没变)，但不是加之前的那个 <code>i</code> 了，因此整数是不可变类型。</li><li>列表 <code>l</code> 在附加 <code>&#39;Python&#39;</code> 之后的 <code>id</code> 和之前一样，因此列表是可变类型。</li></ul><pre><code class="hljs python">print(hash(<span class="hljs-string">'Name'</span>))  <span class="hljs-comment"># -9215951442099718823</span>print(hash((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'Python'</span>)))  <span class="hljs-comment"># 823362308207799471</span>print(hash([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'Python'</span>]))<span class="hljs-comment"># TypeError: unhashable type: 'list'</span>print(hash(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;))<span class="hljs-comment"># TypeError: unhashable type: 'set'</span></code></pre><ul><li>数值、字符和元组 都能被哈希，因此它们是不可变类型。</li><li>列表、集合、字典不能被哈希，因此它是可变类型。</li></ul><h2 id="2-字典的定义"><a href="#2-字典的定义" class="headerlink" title="2. 字典的定义"></a>2. 字典的定义</h2><p>字典 是无序的 键:值（<code>key:value</code>）对集合，键必须是互不相同的（在同一个字典之内）。</p><ul><li><code>dict</code> 内部存放的顺序和 <code>key</code> 放入的顺序是没有关系的。</li><li><code>dict</code> 查找和插入的速度极快，不会随着 <code>key</code> 的增加而增加，但是需要占用大量的内存。</li></ul><p>字典 定义语法为 <code>{元素1, 元素2, ..., 元素n}</code></p><ul><li>其中每一个元素是一个「键值对」— 键:值 (<code>key:value</code>)</li><li>关键点是「大括号 {}」,「逗号 ,」和「冒号 :」</li><li>大括号 — 把所有元素绑在一起</li><li>逗号 — 将每个键值对分开</li><li>冒号 — 将键和值分开</li></ul><h2 id="3-创建和访问字典"><a href="#3-创建和访问字典" class="headerlink" title="3. 创建和访问字典"></a>3. 创建和访问字典</h2><p>【例子】</p><pre><code class="hljs python">brand = [<span class="hljs-string">'李宁'</span>, <span class="hljs-string">'耐克'</span>, <span class="hljs-string">'阿迪达斯'</span>]slogan = [<span class="hljs-string">'一切皆有可能'</span>, <span class="hljs-string">'Just do it'</span>, <span class="hljs-string">'Impossible is nothing'</span>]print(<span class="hljs-string">'耐克的口号是:'</span>, slogan[brand.index(<span class="hljs-string">'耐克'</span>)])  <span class="hljs-comment"># 耐克的口号是: Just do it</span>dic = &#123;<span class="hljs-string">'李宁'</span>: <span class="hljs-string">'一切皆有可能'</span>, <span class="hljs-string">'耐克'</span>: <span class="hljs-string">'Just do it'</span>, <span class="hljs-string">'阿迪达斯'</span>: <span class="hljs-string">'Impossible is nothing'</span>&#125;print(<span class="hljs-string">'耐克的口号是:'</span>, dic[<span class="hljs-string">'耐克'</span>])  <span class="hljs-comment"># 耐克的口号是: Just do it</span></code></pre><p>通过字符串或数值作为<code>key</code>来创建字典。</p><p>注意：如果我们取的键在字典中不存在，会直接报错<code>KeyError</code>。</p><p>【例子】</p><pre><code class="hljs python">dic1 = &#123;<span class="hljs-number">1</span>: <span class="hljs-string">'one'</span>, <span class="hljs-number">2</span>: <span class="hljs-string">'two'</span>, <span class="hljs-number">3</span>: <span class="hljs-string">'three'</span>&#125;print(dic1)  <span class="hljs-comment"># &#123;1: 'one', 2: 'two', 3: 'three'&#125;</span>print(dic1[<span class="hljs-number">1</span>])  <span class="hljs-comment"># one</span>print(dic1[<span class="hljs-number">4</span>])  <span class="hljs-comment"># KeyError: 4</span>dic2 = &#123;<span class="hljs-string">'rice'</span>: <span class="hljs-number">35</span>, <span class="hljs-string">'wheat'</span>: <span class="hljs-number">101</span>, <span class="hljs-string">'corn'</span>: <span class="hljs-number">67</span>&#125;print(dic2)  <span class="hljs-comment"># &#123;'wheat': 101, 'corn': 67, 'rice': 35&#125;</span>print(dic2[<span class="hljs-string">'rice'</span>])  <span class="hljs-comment"># 35</span></code></pre><p>【例子】通过元组作为<code>key</code>来创建字典，但一般不这样使用。</p><pre><code class="hljs python">dic = &#123;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>): <span class="hljs-string">"Tom"</span>, <span class="hljs-string">"Age"</span>: <span class="hljs-number">12</span>, <span class="hljs-number">3</span>: [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]&#125;print(dic)  <span class="hljs-comment"># &#123;(1, 2, 3): 'Tom', 'Age': 12, 3: [3, 5, 7]&#125;</span>print(type(dic))  <span class="hljs-comment"># &lt;class 'dict'&gt;</span></code></pre><p>通过构造函数<code>dict</code>来创建字典。</p><ul><li><code>dict()</code> -&gt; 创建一个空的字典。</li></ul><p>【例子】通过<code>key</code>直接把数据放入字典中，但一个<code>key</code>只能对应一个<code>value</code>，多次对一个<code>key</code>放入 <code>value</code>，后面的值会把前面的值冲掉。</p><pre><code class="hljs python">dic = dict()dic[<span class="hljs-string">'a'</span>] = <span class="hljs-number">1</span>dic[<span class="hljs-string">'b'</span>] = <span class="hljs-number">2</span>dic[<span class="hljs-string">'c'</span>] = <span class="hljs-number">3</span>print(dic)<span class="hljs-comment"># &#123;'a': 1, 'b': 2, 'c': 3&#125;</span>dic[<span class="hljs-string">'a'</span>] = <span class="hljs-number">11</span>print(dic)<span class="hljs-comment"># &#123;'a': 11, 'b': 2, 'c': 3&#125;</span>dic[<span class="hljs-string">'d'</span>] = <span class="hljs-number">4</span>print(dic)<span class="hljs-comment"># &#123;'a': 11, 'b': 2, 'c': 3, 'd': 4&#125;</span></code></pre><ul><li><code>dict(mapping)</code> -&gt; new dictionary initialized from a mapping object’s (key, value) pairs</li></ul><p>【例子】</p><pre><code class="hljs python">dic1 = dict([(<span class="hljs-string">'apple'</span>, <span class="hljs-number">4139</span>), (<span class="hljs-string">'peach'</span>, <span class="hljs-number">4127</span>), (<span class="hljs-string">'cherry'</span>, <span class="hljs-number">4098</span>)])print(dic1)  <span class="hljs-comment"># &#123;'cherry': 4098, 'apple': 4139, 'peach': 4127&#125;</span>dic2 = dict(((<span class="hljs-string">'apple'</span>, <span class="hljs-number">4139</span>), (<span class="hljs-string">'peach'</span>, <span class="hljs-number">4127</span>), (<span class="hljs-string">'cherry'</span>, <span class="hljs-number">4098</span>)))print(dic2)  <span class="hljs-comment"># &#123;'peach': 4127, 'cherry': 4098, 'apple': 4139&#125;</span></code></pre><ul><li><code>dict(**kwargs)</code> -&gt; new dictionary initialized with the name=value pairs in the keyword argument list.  For example:  dict(one=1, two=2)</li></ul><p>【例子】这种情况下，键只能为字符串类型，并且创建的时候字符串不能加引号，加上就会直接报语法错误。</p><pre><code class="hljs python">dic = dict(name=<span class="hljs-string">'Tom'</span>, age=<span class="hljs-number">10</span>)print(dic)  <span class="hljs-comment"># &#123;'name': 'Tom', 'age': 10&#125;</span>print(type(dic))  <span class="hljs-comment"># &lt;class 'dict'&gt;</span></code></pre><h2 id="4-字典的内置方法"><a href="#4-字典的内置方法" class="headerlink" title="4. 字典的内置方法"></a>4. 字典的内置方法</h2><ul><li><code>dict.fromkeys(seq[, value])</code> 用于创建一个新字典，以序列 <code>seq</code> 中元素做字典的键，<code>value</code> 为字典所有键对应的初始值。</li></ul><p>【例子】</p><pre><code class="hljs python">seq = (<span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>, <span class="hljs-string">'sex'</span>)dic1 = dict.fromkeys(seq)print(<span class="hljs-string">"新的字典为 : %s"</span> % str(dic1))  <span class="hljs-comment"># 新的字典为 : &#123;'name': None, 'age': None, 'sex': None&#125;</span>dic2 = dict.fromkeys(seq, <span class="hljs-number">10</span>)print(<span class="hljs-string">"新的字典为 : %s"</span> % str(dic2))  <span class="hljs-comment"># 新的字典为 : &#123;'name': 10, 'age': 10, 'sex': 10&#125;</span>dic3 = dict.fromkeys(seq, (<span class="hljs-string">'小马'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'男'</span>))print(<span class="hljs-string">"新的字典为 : %s"</span> % str(dic3))  <span class="hljs-comment"># 新的字典为 : &#123;'name': ('小马', '8', '男'), 'age': ('小马', '8', '男'), 'sex': ('小马', '8', '男')&#125;</span></code></pre><ul><li><code>dict.keys()</code>返回一个可迭代对象，可以使用 <code>list()</code> 来转换为列表，列表为字典中的所有键。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;print(dic.keys())  <span class="hljs-comment"># dict_keys(['Name', 'Age'])</span>lst = list(dic.keys())  <span class="hljs-comment"># 转换为列表</span>print(lst)  <span class="hljs-comment"># ['Name', 'Age']</span></code></pre><ul><li><code>dict.values()</code>返回一个迭代器，可以使用 <code>list()</code> 来转换为列表，列表为字典中的所有值。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Sex'</span>: <span class="hljs-string">'female'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>, <span class="hljs-string">'Name'</span>: <span class="hljs-string">'Zara'</span>&#125;print(<span class="hljs-string">"字典所有值为 : "</span>, list(dic.values()))  <span class="hljs-comment"># 字典所有值为 :  [7, 'female', 'Zara']</span></code></pre><ul><li><code>dict.items()</code>以列表返回可遍历的 (键, 值) 元组数组。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;print(<span class="hljs-string">"Value : %s"</span> % dic.items())  <span class="hljs-comment"># Value : dict_items([('Name', 'Lsgogroup'), ('Age', 7)])</span>print(tuple(dic.items()))  <span class="hljs-comment"># (('Name', 'Lsgogroup'), ('Age', 7))</span></code></pre><ul><li><code>dict.get(key, default=None)</code>返回指定键的值，如果值不在字典中返回默认值。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">27</span>&#125;print(<span class="hljs-string">"Age 值为 : %s"</span> % dic.get(<span class="hljs-string">'Age'</span>))  <span class="hljs-comment"># Age 值为 : 27</span>print(<span class="hljs-string">"Sex 值为 : %s"</span> % dic.get(<span class="hljs-string">'Sex'</span>, <span class="hljs-string">"NA"</span>))  <span class="hljs-comment"># Sex 值为 : NA</span></code></pre><ul><li><code>dict.setdefault(key, default=None)</code>和<code>get()</code>方法 类似, 如果键不存在于字典中，将会添加键并将值设为默认值。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;print(<span class="hljs-string">"Age 键的值为 : %s"</span> % dic.setdefault(<span class="hljs-string">'Age'</span>, <span class="hljs-literal">None</span>))  <span class="hljs-comment"># Age 键的值为 : 7</span>print(<span class="hljs-string">"Sex 键的值为 : %s"</span> % dic.setdefault(<span class="hljs-string">'Sex'</span>, <span class="hljs-literal">None</span>))  <span class="hljs-comment"># Sex 键的值为 : None</span>print(<span class="hljs-string">"新字典为："</span>, dic)  <span class="hljs-comment"># 新字典为： &#123;'Age': 7, 'Name': 'Lsgogroup', 'Sex': None&#125;</span></code></pre><ul><li><code>key in dict</code> <code>in</code> 操作符用于判断键是否存在于字典中，如果键在字典 dict 里返回<code>true</code>，否则返回<code>false</code>。而<code>not in</code>操作符刚好相反，如果键在字典 dict 里返回<code>false</code>，否则返回<code>true</code>。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;<span class="hljs-comment"># in 检测键 Age 是否存在</span><span class="hljs-keyword">if</span> <span class="hljs-string">'Age'</span> <span class="hljs-keyword">in</span> dic:    print(<span class="hljs-string">"键 Age 存在"</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"键 Age 不存在"</span>)<span class="hljs-comment"># 检测键 Sex 是否存在</span><span class="hljs-keyword">if</span> <span class="hljs-string">'Sex'</span> <span class="hljs-keyword">in</span> dic:    print(<span class="hljs-string">"键 Sex 存在"</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"键 Sex 不存在"</span>)<span class="hljs-comment"># not in 检测键 Age 是否存在</span><span class="hljs-keyword">if</span> <span class="hljs-string">'Age'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dic:    print(<span class="hljs-string">"键 Age 不存在"</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"键 Age 存在"</span>)<span class="hljs-comment"># 键 Age 存在</span><span class="hljs-comment"># 键 Sex 不存在</span><span class="hljs-comment"># 键 Age 存在</span></code></pre><ul><li><code>dict.pop(key[,default])</code>删除字典给定键 <code>key</code> 所对应的值，返回值为被删除的值。<code>key</code> 值必须给出。若<code>key</code>不存在，则返回 <code>default</code> 值。</li><li><code>del dict[key]</code> 删除字典给定键 <code>key</code> 所对应的值。</li></ul><p>【例子】</p><pre><code class="hljs python">dic1 = &#123;<span class="hljs-number">1</span>: <span class="hljs-string">"a"</span>, <span class="hljs-number">2</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]&#125;print(dic1.pop(<span class="hljs-number">1</span>), dic1)  <span class="hljs-comment"># a &#123;2: [1, 2]&#125;</span><span class="hljs-comment"># 设置默认值，必须添加，否则报错</span>print(dic1.pop(<span class="hljs-number">3</span>, <span class="hljs-string">"nokey"</span>), dic1)  <span class="hljs-comment"># nokey &#123;2: [1, 2]&#125;</span><span class="hljs-keyword">del</span> dic1[<span class="hljs-number">2</span>]print(dic1)  <span class="hljs-comment"># &#123;&#125;</span></code></pre><ul><li><code>dict.popitem()</code>随机返回并删除字典中的一对键和值，如果字典已经为空，却调用了此方法，就报出KeyError异常。</li></ul><p>【例子】</p><pre><code class="hljs python">dic1 = &#123;<span class="hljs-number">1</span>: <span class="hljs-string">"a"</span>, <span class="hljs-number">2</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]&#125;print(dic1.popitem())  <span class="hljs-comment"># (1, 'a')</span>print(dic1)  <span class="hljs-comment"># &#123;2: [1, 2]&#125;</span></code></pre><ul><li><code>dict.clear()</code>用于删除字典内所有元素。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Zara'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;print(<span class="hljs-string">"字典长度 : %d"</span> % len(dic))  <span class="hljs-comment"># 字典长度 : 2</span>dict.clear()print(<span class="hljs-string">"字典删除后长度 : %d"</span> % len(dic))  <span class="hljs-comment"># 字典删除后长度 : 0</span></code></pre><ul><li><code>dict.copy()</code>返回一个字典的浅复制。</li></ul><p>【例子】</p><pre><code class="hljs python">dic1 = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>, <span class="hljs-string">'Class'</span>: <span class="hljs-string">'First'</span>&#125;dic2 = dic1.copy()print(<span class="hljs-string">"新复制的字典为 : "</span>, dic2)  <span class="hljs-comment"># 新复制的字典为 :  &#123;'Age': 7, 'Name': 'Lsgogroup', 'Class': 'First'&#125;</span></code></pre><p>【例子】直接赋值和 copy 的区别</p><pre><code class="hljs python">dic1 = &#123;<span class="hljs-string">'user'</span>: <span class="hljs-string">'lsgogroup'</span>, <span class="hljs-string">'num'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;<span class="hljs-comment"># 引用对象</span>dic2 = dic1  <span class="hljs-comment"># 深拷贝父对象（一级目录），子对象（二级目录）不拷贝，还是引用</span>dic3 = dic1.copy()  print(id(dic1))  <span class="hljs-comment"># 148635574728</span>print(id(dic2))  <span class="hljs-comment"># 148635574728</span>print(id(dic3))  <span class="hljs-comment"># 148635574344</span><span class="hljs-comment"># 修改 data 数据</span>dic1[<span class="hljs-string">'user'</span>] = <span class="hljs-string">'root'</span>dic1[<span class="hljs-string">'num'</span>].remove(<span class="hljs-number">1</span>)<span class="hljs-comment"># 输出结果</span>print(dic1)  <span class="hljs-comment"># &#123;'user': 'root', 'num': [2, 3]&#125;</span>print(dic2)  <span class="hljs-comment"># &#123;'user': 'root', 'num': [2, 3]&#125;</span>print(dic3)  <span class="hljs-comment"># &#123;'user': 'runoob', 'num': [2, 3]&#125;</span></code></pre><ul><li><code>dict.update(dict2)</code>把字典参数 <code>dict2</code> 的 <code>key:value</code>对 更新到字典 <code>dict</code> 里。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;dic2 = &#123;<span class="hljs-string">'Sex'</span>: <span class="hljs-string">'female'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">8</span>&#125;dic.update(dic2)print(<span class="hljs-string">"更新字典 dict : "</span>, dic)  <span class="hljs-comment"># 更新字典 dict :  &#123;'Sex': 'female', 'Age': 8, 'Name': 'Lsgogroup'&#125;</span></code></pre><hr><p><strong>练习题</strong>：</p><p>1、字典基本操作</p><p>字典内容如下:</p><pre><code class="hljs python">dic = &#123;    <span class="hljs-string">'python'</span>: <span class="hljs-number">95</span>,    <span class="hljs-string">'java'</span>: <span class="hljs-number">99</span>,    <span class="hljs-string">'c'</span>: <span class="hljs-number">100</span>    &#125;</code></pre><p>用程序解答下面的题目</p><ul><li>字典的长度是多少</li><li>请修改’java’ 这个key对应的value值为98</li><li>删除 c 这个key</li><li>增加一个key-value对，key值为 php, value是90</li><li>获取所有的key值，存储在列表里</li><li>获取所有的value值，存储在列表里</li><li>判断 javascript 是否在字典中</li><li>获得字典里所有value 的和</li><li>获取字典里最大的value</li><li>获取字典里最小的value</li><li>字典 dic1 = {‘php’: 97}， 将dic1的数据更新到dic中</li></ul><p>2、字典中的value</p><p>有一个字典，保存的是学生各个编程语言的成绩，内容如下</p><pre><code class="hljs prolog">data = &#123;        <span class="hljs-string">'python'</span>: &#123;<span class="hljs-string">'上学期'</span>: <span class="hljs-string">'90'</span>, <span class="hljs-string">'下学期'</span>: <span class="hljs-string">'95'</span>&#125;,        <span class="hljs-string">'c++'</span>: [<span class="hljs-string">'95'</span>, <span class="hljs-string">'96'</span>, <span class="hljs-string">'97'</span>],        <span class="hljs-string">'java'</span>: [&#123;<span class="hljs-string">'月考'</span>:<span class="hljs-string">'90'</span>, <span class="hljs-string">'期中考试'</span>: <span class="hljs-string">'94'</span>, <span class="hljs-string">'期末考试'</span>: <span class="hljs-string">'98'</span>&#125;]        &#125;</code></pre><p>各门课程的考试成绩存储方式并不相同，有的用字典，有的用列表，但是分数都是字符串类型，请实现函数<code>transfer_score(score_dict)</code>，将分数修改成int类型</p><pre><code class="hljs python">   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transfer_score</span><span class="hljs-params">(data)</span>:</span>    <span class="hljs-comment"># your code here</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a&gt;字典&lt;/h1&gt;&lt;h2 id=&quot;1-可变类型与不可变类型&quot;&gt;&lt;a href=&quot;#1-可变类型与不可变类型&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python05-列表、字典和字符串</title>
    <link href="https://sulimin-nb.github.io/article/a112c8e7.html"/>
    <id>https://sulimin-nb.github.io/article/a112c8e7.html</id>
    <published>2020-07-28T16:14:42.000Z</published>
    <updated>2020-07-28T16:17:22.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>简单数据类型</p><ul><li>整型<code>&lt;class &#39;int&#39;&gt;</code></li><li>浮点型<code>&lt;class &#39;float&#39;&gt;</code></li><li>布尔型<code>&lt;class &#39;bool&#39;&gt;</code></li></ul><p>容器数据类型</p><ul><li>列表<code>&lt;class &#39;list&#39;&gt;</code></li><li>元组<code>&lt;class &#39;tuple&#39;&gt;</code></li><li>字典<code>&lt;class &#39;dict&#39;&gt;</code></li><li>集合<code>&lt;class &#39;set&#39;&gt;</code></li><li>字符串<code>&lt;class &#39;str&#39;&gt;</code></li></ul><h2 id="1-列表的定义"><a href="#1-列表的定义" class="headerlink" title="1. 列表的定义"></a>1. 列表的定义</h2><p>列表是有序集合，没有固定大小，能够保存任意数量任意类型的 Python 对象，语法为 <code>[元素1, 元素2, ..., 元素n]</code>。</p><ul><li>关键点是「中括号 []」和「逗号 ,」</li><li>中括号 把所有元素绑在一起</li><li>逗号 将每个元素一一分开</li></ul><h2 id="2-列表的创建"><a href="#2-列表的创建" class="headerlink" title="2. 列表的创建"></a>2. 列表的创建</h2><ul><li>创建一个普通列表</li></ul><p>【例子】 </p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(x, type(x))<span class="hljs-comment"># ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'] &lt;class 'list'&gt;</span>x = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]print(x, type(x))<span class="hljs-comment"># [2, 3, 4, 5, 6, 7] &lt;class 'list'&gt;</span></code></pre><ul><li>利用<code>range()</code>创建列表</li></ul><p>【例子】 </p><pre><code class="hljs python">x = list(range(<span class="hljs-number">10</span>))print(x, type(x))<span class="hljs-comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class 'list'&gt;</span>x = list(range(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">2</span>))print(x, type(x))<span class="hljs-comment"># [1, 3, 5, 7, 9] &lt;class 'list'&gt;</span>x = list(range(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-2</span>))print(x, type(x))<span class="hljs-comment"># [10, 8, 6, 4, 2] &lt;class 'list'&gt;</span></code></pre><ul><li>利用推导式创建列表</li></ul><p>【例子】 </p><pre><code class="hljs python">x = [<span class="hljs-number">0</span>] * <span class="hljs-number">5</span>print(x, type(x))<span class="hljs-comment"># [0, 0, 0, 0, 0] &lt;class 'list'&gt;</span>x = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]print(x, type(x))<span class="hljs-comment"># [0, 0, 0, 0, 0] &lt;class 'list'&gt;</span>x = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)]print(x, type(x))<span class="hljs-comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class 'list'&gt;</span>x = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>)]print(x, type(x))<span class="hljs-comment"># [1, 3, 5, 7, 9] &lt;class 'list'&gt;</span>x = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-2</span>)]print(x, type(x))<span class="hljs-comment"># [10, 8, 6, 4, 2] &lt;class 'list'&gt;</span>x = [i ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)]print(x, type(x))<span class="hljs-comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81] &lt;class 'list'&gt;</span>x = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>) <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> (i % <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>]print(x, type(x))<span class="hljs-comment"># [3, 9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99] &lt;class 'list'&gt;</span></code></pre><ul><li>创建一个 4×3的二维数组</li></ul><p>【例子】</p><pre><code class="hljs python">x = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]print(x, type(x))<span class="hljs-comment"># [[1, 2, 3], [4, 5, 6], [7, 8, 9], [0, 0, 0]] &lt;class 'list'&gt;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x:    print(i, type(i))<span class="hljs-comment"># [1, 2, 3] &lt;class 'list'&gt;</span><span class="hljs-comment"># [4, 5, 6] &lt;class 'list'&gt;</span><span class="hljs-comment"># [7, 8, 9] &lt;class 'list'&gt;</span><span class="hljs-comment"># [0, 0, 0] &lt;class 'list'&gt;</span>x = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>)]print(x, type(x))<span class="hljs-comment"># [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span>x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>print(x, type(x))<span class="hljs-comment"># [[1, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span>x = [[<span class="hljs-number">0</span>] * <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>)]print(x, type(x))<span class="hljs-comment"># [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span>x[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>print(x, type(x))<span class="hljs-comment"># [[0, 0, 0], [0, 1, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span></code></pre><p>注意：</p><p>由于list的元素可以是任何对象，因此列表中所保存的是对象的指针。即使保存一个简单的<code>[1,2,3]</code>，也有3个指针和3个整数对象。</p><p><code>x = [a] * 4</code>操作中，只是创建4个指向list的引用，所以一旦<code>a</code>改变，<code>x</code>中4个<code>a</code>也会随之改变。</p><p>【例子】</p><pre><code class="hljs python">x = [[<span class="hljs-number">0</span>] * <span class="hljs-number">3</span>] * <span class="hljs-number">4</span>print(x, type(x))<span class="hljs-comment"># [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span>x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>print(x, type(x))<span class="hljs-comment"># [[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class 'list'&gt;</span>a = [<span class="hljs-number">0</span>] * <span class="hljs-number">3</span>x = [a] * <span class="hljs-number">4</span>print(x, type(x))<span class="hljs-comment"># [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span>x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>print(x, type(x))<span class="hljs-comment"># [[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class 'list'&gt;</span></code></pre><ul><li>创建一个混合列表</li></ul><p>【例子】 </p><pre><code class="hljs python">mix = [<span class="hljs-number">1</span>, <span class="hljs-string">'lsgo'</span>, <span class="hljs-number">3.14</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]]print(mix)  <span class="hljs-comment"># [1, 'lsgo', 3.14, [1, 2, 3]]</span></code></pre><ul><li>创建一个空列表</li></ul><p>【例子】 </p><pre><code class="hljs python">empty = []print(empty)  <span class="hljs-comment"># []</span></code></pre><p>列表不像元组，列表内容可更改 (mutable)，因此附加 (<code>append</code>, <code>extend</code>)、插入 (<code>insert</code>)、删除 (<code>remove</code>, <code>pop</code>) 这些操作都可以用在它身上。</p><h2 id="3-向列表中添加元素"><a href="#3-向列表中添加元素" class="headerlink" title="3. 向列表中添加元素"></a>3. 向列表中添加元素</h2><ul><li><code>list.append(obj)</code> 在列表末尾添加新的对象，只接受一个参数，参数可以是任何数据类型，被追加的元素在 list 中保持着原结构类型。</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]x.append(<span class="hljs-string">'Thursday'</span>)print(x)  <span class="hljs-comment"># ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Thursday']</span>print(len(x))  <span class="hljs-comment"># 6</span></code></pre><p>此元素如果是一个 list，那么这个 list 将作为一个整体进行追加，注意<code>append()</code>和<code>extend()</code>的区别。</p><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]x.append([<span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Sunday'</span>])print(x)  <span class="hljs-comment"># ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', ['Thursday', 'Sunday']]</span>print(len(x))  <span class="hljs-comment"># 6</span></code></pre><ul><li><code>list.extend(seq)</code> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]x.extend([<span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Sunday'</span>])print(x)  <span class="hljs-comment"># ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Thursday', 'Sunday']</span>print(len(x))  <span class="hljs-comment"># 7</span></code></pre><p>严格来说 <code>append</code> 是追加，把一个东西整体添加在列表后，而 <code>extend</code> 是扩展，把一个东西里的所有元素添加在列表后。</p><ul><li><code>list.insert(index, obj)</code> 在编号 <code>index</code> 位置前插入 <code>obj</code>。</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]x.insert(<span class="hljs-number">2</span>, <span class="hljs-string">'Sunday'</span>)print(x)<span class="hljs-comment"># ['Monday', 'Tuesday', 'Sunday', 'Wednesday', 'Thursday', 'Friday']</span>print(len(x))  <span class="hljs-comment"># 6</span></code></pre><h2 id="4-删除列表中的元素"><a href="#4-删除列表中的元素" class="headerlink" title="4. 删除列表中的元素"></a>4. 删除列表中的元素</h2><ul><li><code>list.remove(obj)</code> 移除列表中某个值的第一个匹配项</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]x.remove(<span class="hljs-string">'Monday'</span>)print(x)  <span class="hljs-comment"># ['Tuesday', 'Wednesday', 'Thursday', 'Friday']</span></code></pre><ul><li><code>list.pop([index=-1])</code> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]y = x.pop()print(y)  <span class="hljs-comment"># Friday</span>y = x.pop(<span class="hljs-number">0</span>)print(y)  <span class="hljs-comment"># Monday</span>y = x.pop(<span class="hljs-number">-2</span>)print(y)  <span class="hljs-comment"># Wednesday</span>print(x)  <span class="hljs-comment"># ['Tuesday', 'Thursday']</span></code></pre><p><code>remove</code> 和 <code>pop</code> 都可以删除元素，前者是指定具体要删除的元素，后者是指定一个索引。</p><ul><li><code>del var1[, var2 ……]</code> 删除单个或多个对象。</li></ul><p>【例子】</p><p>如果知道要删除的元素在列表中的位置，可使用<code>del</code>语句。</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]<span class="hljs-keyword">del</span> x[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]print(x)  <span class="hljs-comment"># ['Wednesday', 'Thursday', 'Friday']</span></code></pre><p>如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用<code>del</code>语句；如果你要在删除元素后还能继续使用它，就使用方法<code>pop()</code>。</p><h2 id="5-获取列表中的元素"><a href="#5-获取列表中的元素" class="headerlink" title="5. 获取列表中的元素"></a>5. 获取列表中的元素</h2><ul><li>通过元素的索引值，从列表获取单个元素，注意，列表索引值是从0开始的。</li><li>通过将索引指定为-1，可让Python返回最后一个列表元素，索引 -2 返回倒数第二个列表元素，以此类推。</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(x[<span class="hljs-number">0</span>], type(x[<span class="hljs-number">0</span>]))  <span class="hljs-comment"># Monday &lt;class 'str'&gt;</span>print(x[<span class="hljs-number">-1</span>], type(x[<span class="hljs-number">-1</span>]))  <span class="hljs-comment"># Friday &lt;class 'str'&gt;</span>print(x[<span class="hljs-number">-2</span>], type(x[<span class="hljs-number">-2</span>]))  <span class="hljs-comment"># Thursday &lt;class 'str'&gt;</span></code></pre><p>切片的通用写法是 <code>start : stop : step</code></p><ul><li>情况 1 - “start :” </li><li>以 <code>step</code> 为 1 (默认) 从编号 <code>start</code> 往列表尾部切片。</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(x[<span class="hljs-number">3</span>:])  <span class="hljs-comment"># ['Thursday', 'Friday']</span>print(x[<span class="hljs-number">-3</span>:])  <span class="hljs-comment"># ['Wednesday', 'Thursday', 'Friday']</span></code></pre><ul><li>情况 2 - “: stop”</li><li>以 <code>step</code> 为 1 (默认) 从列表头部往编号 <code>stop</code> 切片。</li></ul><p>【例子】</p><pre><code class="hljs python">week = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(week[:<span class="hljs-number">3</span>])  <span class="hljs-comment"># ['Monday', 'Tuesday', 'Wednesday']</span>print(week[:<span class="hljs-number">-3</span>])  <span class="hljs-comment"># ['Monday', 'Tuesday']</span></code></pre><ul><li>情况 3 - “start : stop”</li><li>以 <code>step</code> 为 1 (默认) 从编号 <code>start</code> 往编号 <code>stop</code> 切片。</li></ul><p>【例子】</p><pre><code class="hljs python">week = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(week[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])  <span class="hljs-comment"># ['Tuesday', 'Wednesday']</span>print(week[<span class="hljs-number">-3</span>:<span class="hljs-number">-1</span>])  <span class="hljs-comment"># ['Wednesday', 'Thursday']</span></code></pre><ul><li>情况 4 - “start : stop : step”</li><li>以具体的 <code>step</code> 从编号 <code>start</code> 往编号 <code>stop</code> 切片。注意最后把 <code>step</code> 设为 -1，相当于将列表反向排列。</li></ul><p>【例子】</p><pre><code class="hljs python">week = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(week[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>])  <span class="hljs-comment"># ['Tuesday', 'Thursday']</span>print(week[:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>])  <span class="hljs-comment"># ['Monday', 'Wednesday']</span>print(week[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>])  <span class="hljs-comment"># ['Tuesday', 'Thursday']</span>print(week[::<span class="hljs-number">-1</span>])  <span class="hljs-comment"># ['Friday', 'Thursday', 'Wednesday', 'Tuesday', 'Monday']</span></code></pre><ul><li>情况 5 - “ : “</li><li>复制列表中的所有元素（浅拷贝）。</li></ul><p>【例子】</p><pre><code class="hljs python">week = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(week[:])  <span class="hljs-comment"># week的拷贝 ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']</span>list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-number">789</span>, <span class="hljs-number">213</span>]list2 = list1list3 = list1[:]print(list2)  <span class="hljs-comment"># [123, 456, 789, 213]</span>print(list3)  <span class="hljs-comment"># [123, 456, 789, 213]</span>list1.sort()print(list2)  <span class="hljs-comment"># [123, 213, 456, 789] </span>print(list3)  <span class="hljs-comment"># [123, 456, 789, 213]</span>list1 = [[<span class="hljs-number">123</span>, <span class="hljs-number">456</span>], [<span class="hljs-number">789</span>, <span class="hljs-number">213</span>]]list2 = list1list3 = list1[:]print(list2)  <span class="hljs-comment"># [[123, 456], [789, 213]]</span>print(list3)  <span class="hljs-comment"># [[123, 456], [789, 213]]</span>list1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">111</span>print(list2)  <span class="hljs-comment"># [[111, 456], [789, 213]]</span>print(list3)  <span class="hljs-comment"># [[111, 456], [789, 213]]</span></code></pre><h2 id="6-列表的常用操作符"><a href="#6-列表的常用操作符" class="headerlink" title="6. 列表的常用操作符"></a>6. 列表的常用操作符</h2><ul><li>等号操作符：<code>==</code></li><li>连接操作符 <code>+</code></li><li>重复操作符 <code>*</code></li><li>成员关系操作符 <code>in</code>、<code>not in</code></li></ul><p>「等号 ==」，只有成员、成员位置都相同时才返回True。</p><p>和元组拼接一样， 列表拼接也有两种方式，用「加号 +」和「乘号 *」，前者首尾拼接，后者复制拼接。</p><p>【例子】</p><pre><code class="hljs Python">list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>]list2 = [<span class="hljs-number">456</span>, <span class="hljs-number">123</span>]list3 = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>]print(list1 == list2)  <span class="hljs-comment"># False</span>print(list1 == list3)  <span class="hljs-comment"># True</span>list4 = list1 + list2  <span class="hljs-comment"># extend()</span>print(list4)  <span class="hljs-comment"># [123, 456, 456, 123]</span>list5 = list3 * <span class="hljs-number">3</span>print(list5)  <span class="hljs-comment"># [123, 456, 123, 456, 123, 456]</span>list3 *= <span class="hljs-number">3</span>print(list3)  <span class="hljs-comment"># [123, 456, 123, 456, 123, 456]</span>print(<span class="hljs-number">123</span> <span class="hljs-keyword">in</span> list3)  <span class="hljs-comment"># True</span>print(<span class="hljs-number">456</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> list3)  <span class="hljs-comment"># False</span></code></pre><p>前面三种方法（<code>append</code>, <code>extend</code>, <code>insert</code>）可对列表增加元素，它们没有返回值，是直接修改了原数据对象。<br>将两个list相加，需要创建新的 list 对象，从而需要消耗额外的内存，特别是当 list 较大时，尽量不要使用 “+” 来添加list。</p><h2 id="7-列表的其它方法"><a href="#7-列表的其它方法" class="headerlink" title="7. 列表的其它方法"></a>7. 列表的其它方法</h2><p><code>list.count(obj)</code> 统计某个元素在列表中出现的次数</p><p>【例子】</p><pre><code class="hljs python">list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>] * <span class="hljs-number">3</span>print(list1)  <span class="hljs-comment"># [123, 456, 123, 456, 123, 456]</span>num = list1.count(<span class="hljs-number">123</span>)print(num)  <span class="hljs-comment"># 3</span></code></pre><p><code>list.index(x[, start[, end]])</code> 从列表中找出某个值第一个匹配项的索引位置</p><p>【例子】</p><pre><code class="hljs python">list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>] * <span class="hljs-number">5</span>print(list1.index(<span class="hljs-number">123</span>))  <span class="hljs-comment"># 0</span>print(list1.index(<span class="hljs-number">123</span>, <span class="hljs-number">1</span>))  <span class="hljs-comment"># 2</span>print(list1.index(<span class="hljs-number">123</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>))  <span class="hljs-comment"># 4</span></code></pre><p><code>list.reverse()</code> 反向列表中元素</p><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-number">789</span>]x.reverse()print(x)  <span class="hljs-comment"># [789, 456, 123]</span></code></pre><p><code>list.sort(key=None, reverse=False)</code> 对原列表进行排序。</p><ul><li><code>key</code> — 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li><code>reverse</code> — 排序规则，<code>reverse = True</code> 降序， <code>reverse = False</code> 升序（默认）。</li><li>该方法没有返回值，但是会对列表的对象进行排序。</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-number">789</span>, <span class="hljs-number">213</span>]x.sort()print(x)<span class="hljs-comment"># [123, 213, 456, 789]</span>x.sort(reverse=<span class="hljs-literal">True</span>)print(x)<span class="hljs-comment"># [789, 456, 213, 123]</span><span class="hljs-comment"># 获取列表的第二个元素</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takeSecond</span><span class="hljs-params">(elem)</span>:</span>    <span class="hljs-keyword">return</span> elem[<span class="hljs-number">1</span>]x = [(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)]x.sort(key=takeSecond)print(x)<span class="hljs-comment"># [(4, 1), (2, 2), (1, 3), (3, 4)]</span>x.sort(key=<span class="hljs-keyword">lambda</span> a: a[<span class="hljs-number">0</span>])print(x)<span class="hljs-comment"># [(1, 3), (2, 2), (3, 4), (4, 1)]</span></code></pre><hr><p><strong>参考文献</strong>：</p><ul><li><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-tutorial.html</a></li><li><a href="https://www.bilibili.com/video/av4050443" target="_blank" rel="noopener">https://www.bilibili.com/video/av4050443</a></li><li><a href="https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ</a></li></ul><hr><p><strong>练习题</strong>：</p><p>1、列表操作练习</p><p>列表lst 内容如下</p><p>lst = [2, 5, 6, 7, 8, 9, 2, 9, 9]</p><p>请写程序完成下列操作：</p><ol><li>在列表的末尾增加元素15</li><li>在列表的中间位置插入元素20</li><li>将列表[2, 5, 6]合并到lst中</li><li>移除列表中索引为3的元素</li><li>翻转列表里的所有元素</li><li>对列表里的元素进行排序，从小到大一次，从大到小一次</li></ol><p>2、修改列表</p><p>问题描述：</p><p>lst = [1, [4, 6], True]</p><p>请将列表里所有数字修改成原来的两倍</p><p>3、leetcode 852题 山脉数组的峰顶索引</p><p>如果一个数组k符合下面两个属性，则称之为山脉数组</p><p>数组的长度大于等于3</p><p>存在$i$，$i$ &gt;0 且$i&lt;\operatorname{len}(k)-1$， 使得<script type="math/tex">\mathrm{k}[0]<\mathrm{k}[1]<\ldots<\mathrm{k}[\mathrm{i}-1]<\mathrm{k}[\mathrm{j}]>\mathrm{k}[\mathrm{i}+1] \ldots>\mathrm{k}[\operatorname{len}(\mathrm{k})-1]</script></p><p>这个$i$就是顶峰索引。</p><p>现在，给定一个山脉数组，求顶峰索引。</p><p>示例:</p><p>输入：[1, 3, 4, 5, 3]</p><p>输出：True</p><p>输入：[1, 2, 4, 6, 4, 5]</p><p>输出：False</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">peakIndexInMountainArray</span><span class="hljs-params">(self, A: List[int])</span> -&gt; int:</span>           <span class="hljs-comment"># your code here</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h1&gt;&lt;p&gt;简单数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整型&lt;code&gt;&amp;lt;class &amp;#39;int&amp;#39;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python04-异常处理</title>
    <link href="https://sulimin-nb.github.io/article/60fd2cd8.html"/>
    <id>https://sulimin-nb.github.io/article/60fd2cd8.html</id>
    <published>2020-07-25T15:38:18.000Z</published>
    <updated>2020-07-25T15:38:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常就是运行期检测到的错误。计算机语言针对可能出现的错误定义了异常类型，某种错误引发对应的异常时，异常处理程序将被启动，从而恢复程序的正常运行。</p><h2 id="1-Python-标准异常总结"><a href="#1-Python-标准异常总结" class="headerlink" title="1. Python 标准异常总结"></a>1. Python 标准异常总结</h2><ul><li>BaseException：所有异常的 <strong>基类</strong></li><li>Exception：常规异常的 <strong>基类</strong></li><li>StandardError：所有的内建标准异常的基类</li><li>ArithmeticError：所有数值计算异常的基类</li><li>FloatingPointError：浮点计算异常</li><li><u>OverflowError</u>：数值运算超出最大限制</li><li><u>ZeroDivisionError</u>：除数为零</li><li><u>AssertionError</u>：断言语句（assert）失败</li><li><u>AttributeError</u>：尝试访问未知的对象属性</li><li>EOFError：没有内建输入，到达EOF标记</li><li>EnvironmentError：操作系统异常的基类</li><li>IOError：输入/输出操作失败</li><li><u>OSError</u>：操作系统产生的异常（例如打开一个不存在的文件）</li><li>WindowsError：系统调用失败</li><li><u>ImportError</u>：导入模块失败的时候</li><li>KeyboardInterrupt：用户中断执行</li><li>LookupError：无效数据查询的基类</li><li><u>IndexError</u>：索引超出序列的范围</li><li><u>KeyError</u>：字典中查找一个不存在的关键字</li><li><u>MemoryError</u>：内存溢出（可通过删除对象释放内存）</li><li><u>NameError</u>：尝试访问一个不存在的变量</li><li>UnboundLocalError：访问未初始化的本地变量</li><li>ReferenceError：弱引用试图访问已经垃圾回收了的对象</li><li>RuntimeError：一般的运行时异常</li><li>NotImplementedError：尚未实现的方法</li><li><u>SyntaxError</u>：语法错误导致的异常</li><li>IndentationError：缩进错误导致的异常</li><li>TabError：Tab和空格混用</li><li>SystemError：一般的解释器系统异常</li><li><u>TypeError</u>：不同类型间的无效操作</li><li><u>ValueError</u>：传入无效的参数</li><li>UnicodeError：Unicode相关的异常</li><li>UnicodeDecodeError：Unicode解码时的异常</li><li>UnicodeEncodeError：Unicode编码错误导致的异常</li><li>UnicodeTranslateError：Unicode转换错误导致的异常</li></ul><p>异常体系内部有层次关系，Python异常体系中的部分关系如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20200710131404548.png" srcset="/img/loading.gif" alt></p><hr><h2 id="2-Python标准警告总结"><a href="#2-Python标准警告总结" class="headerlink" title="2. Python标准警告总结"></a>2. Python标准警告总结</h2><ul><li>Warning：警告的基类</li><li>DeprecationWarning：关于被弃用的特征的警告</li><li>FutureWarning：关于构造将来语义会有改变的警告</li><li>UserWarning：用户代码生成的警告</li><li>PendingDeprecationWarning：关于特性将会被废弃的警告</li><li>RuntimeWarning：可疑的运行时行为(runtime behavior)的警告</li><li>SyntaxWarning：可疑语法的警告</li><li>ImportWarning：用于在导入模块过程中触发的警告</li><li>UnicodeWarning：与Unicode相关的警告</li><li>BytesWarning：与字节或字节码相关的警告</li><li>ResourceWarning：与资源使用相关的警告</li></ul><hr><h2 id="3-try-except-语句"><a href="#3-try-except-语句" class="headerlink" title="3. try - except 语句"></a>3. try - except 语句</h2><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    检测范围<span class="hljs-keyword">except</span> Exception[<span class="hljs-keyword">as</span> reason]:    出现异常后的处理代码</code></pre><p>try 语句按照如下方式工作：</p><ul><li>首先，执行<code>try</code>子句（在关键字<code>try</code>和关键字<code>except</code>之间的语句）</li><li>如果没有异常发生，忽略<code>except</code>子句，<code>try</code>子句执行后结束。</li><li>如果在执行<code>try</code>子句的过程中发生了异常，那么<code>try</code>子句余下的部分将被忽略。如果异常的类型和<code>except</code>之后的名称相符，那么对应的<code>except</code>子句将被执行。最后执行<code>try</code>语句之后的代码。</li><li>如果一个异常没有与任何的<code>except</code>匹配，那么这个异常将会传递给上层的<code>try</code>中。</li></ul><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    f = open(<span class="hljs-string">'test.txt'</span>)    print(f.read())    f.close()<span class="hljs-keyword">except</span> OSError:    print(<span class="hljs-string">'打开文件出错'</span>)<span class="hljs-comment"># 打开文件出错</span></code></pre><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    f = open(<span class="hljs-string">'test.txt'</span>)    print(f.read())    f.close()<span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> error:    print(<span class="hljs-string">'打开文件出错\n原因是：'</span> + str(error))<span class="hljs-comment"># 打开文件出错</span><span class="hljs-comment"># 原因是：[Errno 2] No such file or directory: 'test.txt'</span></code></pre><p>一个<code>try</code>语句可能包含多个<code>except</code>子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    int(<span class="hljs-string">"abc"</span>)    s = <span class="hljs-number">1</span> + <span class="hljs-string">'1'</span>    f = open(<span class="hljs-string">'test.txt'</span>)    print(f.read())    f.close()<span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> error:    print(<span class="hljs-string">'打开文件出错\n原因是：'</span> + str(error))<span class="hljs-keyword">except</span> TypeError <span class="hljs-keyword">as</span> error:    print(<span class="hljs-string">'类型出错\n原因是：'</span> + str(error))<span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> error:    print(<span class="hljs-string">'数值出错\n原因是：'</span> + str(error))<span class="hljs-comment"># 数值出错</span><span class="hljs-comment"># 原因是：invalid literal for int() with base 10: 'abc'</span></code></pre><p>【例子】</p><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'v'</span>: <span class="hljs-number">22</span>&#125;<span class="hljs-keyword">try</span>:    x = dict1[<span class="hljs-string">'y'</span>]<span class="hljs-keyword">except</span> LookupError:    print(<span class="hljs-string">'查询错误'</span>)<span class="hljs-keyword">except</span> KeyError:    print(<span class="hljs-string">'键错误'</span>)<span class="hljs-keyword">else</span>:    print(x)<span class="hljs-comment"># 查询错误</span></code></pre><p><code>try-except-else</code>语句尝试查询不在<code>dict</code>中的键值对，从而引发了异常。这一异常准确地说应属于<code>KeyError</code>，但由于<code>KeyError</code>是<code>LookupError</code>的子类，且将<code>LookupError</code>置于<code>KeyError</code>之前，因此程序优先执行该<code>except</code>代码块。所以，使用多个<code>except</code>代码块时，必须坚持对其规范排序，要从最具针对性的异常到最通用的异常。</p><p>【例子】</p><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'v'</span>: <span class="hljs-number">22</span>&#125;<span class="hljs-keyword">try</span>:    x = dict1[<span class="hljs-string">'y'</span>]<span class="hljs-keyword">except</span> KeyError:    print(<span class="hljs-string">'键错误'</span>)<span class="hljs-keyword">except</span> LookupError:    print(<span class="hljs-string">'查询错误'</span>)<span class="hljs-keyword">else</span>:    print(x)<span class="hljs-comment"># 键错误</span></code></pre><p>【例子】一个 <code>except</code> 子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    s = <span class="hljs-number">1</span> + <span class="hljs-string">'1'</span>    int(<span class="hljs-string">"abc"</span>)    f = open(<span class="hljs-string">'test.txt'</span>)    print(f.read())    f.close()<span class="hljs-keyword">except</span> (OSError, TypeError, ValueError) <span class="hljs-keyword">as</span> error:    print(<span class="hljs-string">'出错了！\n原因是：'</span> + str(error))<span class="hljs-comment"># 出错了！</span><span class="hljs-comment"># 原因是：unsupported operand type(s) for +: 'int' and 'str'</span></code></pre><hr><h2 id="4-try-except-finally-语句"><a href="#4-try-except-finally-语句" class="headerlink" title="4. try - except - finally 语句"></a>4. try - except - finally 语句</h2><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    检测范围<span class="hljs-keyword">except</span> Exception[<span class="hljs-keyword">as</span> reason]:    出现异常后的处理代码<span class="hljs-keyword">finally</span>:    无论如何都会被执行的代码</code></pre><p>不管<code>try</code>子句里面有没有发生异常，<code>finally</code>子句都会执行。</p><p>如果一个异常在<code>try</code>子句里被抛出，而又没有任何的<code>except</code>把它截住，那么这个异常会在<code>finally</code>子句执行后被抛出。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">divide</span><span class="hljs-params">(x, y)</span>:</span>    <span class="hljs-keyword">try</span>:        result = x / y        print(<span class="hljs-string">"result is"</span>, result)    <span class="hljs-keyword">except</span> ZeroDivisionError:        print(<span class="hljs-string">"division by zero!"</span>)    <span class="hljs-keyword">finally</span>:        print(<span class="hljs-string">"executing finally clause"</span>)divide(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<span class="hljs-comment"># result is 2.0</span><span class="hljs-comment"># executing finally clause</span>divide(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)<span class="hljs-comment"># division by zero!</span><span class="hljs-comment"># executing finally clause</span>divide(<span class="hljs-string">"2"</span>, <span class="hljs-string">"1"</span>)<span class="hljs-comment"># executing finally clause</span><span class="hljs-comment"># TypeError: unsupported operand type(s) for /: 'str' and 'str'</span></code></pre><hr><h2 id="5-try-except-else-语句"><a href="#5-try-except-else-语句" class="headerlink" title="5. try - except - else 语句"></a>5. try - except - else 语句</h2><p>如果在<code>try</code>子句执行时没有发生异常，Python将执行<code>else</code>语句后的语句。</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    检测范围<span class="hljs-keyword">except</span>:    出现异常后的处理代码<span class="hljs-keyword">else</span>:    如果没有异常执行这块代码</code></pre><p>使用<code>except</code>而不带任何异常类型，这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息，因为它捕获所有的异常。</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    检测范围<span class="hljs-keyword">except</span>(Exception1[, Exception2[,...ExceptionN]]]):   发生以上多个异常中的一个，执行这块代码<span class="hljs-keyword">else</span>:    如果没有异常执行这块代码</code></pre><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    fh = open(<span class="hljs-string">"testfile"</span>, <span class="hljs-string">"w"</span>)    fh.write(<span class="hljs-string">"这是一个测试文件，用于测试异常!!"</span>)<span class="hljs-keyword">except</span> IOError:    print(<span class="hljs-string">"Error: 没有找到文件或读取文件失败"</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"内容写入文件成功"</span>)    fh.close()<span class="hljs-comment"># 内容写入文件成功</span></code></pre><p>注意：<code>else</code>语句的存在必须以<code>except</code>语句的存在为前提，在没有<code>except</code>语句的<code>try</code>语句中使用<code>else</code>语句，会引发语法错误。</p><hr><h2 id="6-raise语句"><a href="#6-raise语句" class="headerlink" title="6. raise语句"></a>6. raise语句</h2><p>Python 使用<code>raise</code>语句抛出一个指定的异常。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    <span class="hljs-keyword">raise</span> NameError(<span class="hljs-string">'HiThere'</span>)<span class="hljs-keyword">except</span> NameError:    print(<span class="hljs-string">'An exception flew by!'</span>)    <span class="hljs-comment"># An exception flew by!</span></code></pre><hr><p><strong>练习题</strong>：</p><p>1、猜数字游戏</p><p>题目描述:</p><p>电脑产生一个零到100之间的随机数字，然后让用户来猜，如果用户猜的数字比这个数字大，提示太大，否则提示太小，当用户正好猜中电脑会提示，”恭喜你猜到了这个数是……”。在用户每次猜测之前程序会输出用户是第几次猜测，如果用户输入的根本不是一个数字，程序会告诉用户”输入无效”。</p><p>(尝试使用try catch异常处理结构对输入情况进行处理)</p><p>获取随机数采用random模块。</p><p><img src="https://img-blog.csdnimg.cn/20200714230819193.png" srcset="/img/loading.gif" alt></p><pre><code class="hljs python"><span class="hljs-comment"># your code here</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异常处理&quot;&gt;&lt;a href=&quot;#异常处理&quot; class=&quot;headerlink&quot; title=&quot;异常处理&quot;&gt;&lt;/a&gt;异常处理&lt;/h1&gt;&lt;p&gt;异常就是运行期检测到的错误。计算机语言针对可能出现的错误定义了异常类型，某种错误引发对应的异常时，异常处理程序将被启动，从而
      
    
    </summary>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python03-条件语句</title>
    <link href="https://sulimin-nb.github.io/article/22d0bd28.html"/>
    <id>https://sulimin-nb.github.io/article/22d0bd28.html</id>
    <published>2020-07-23T15:14:44.000Z</published>
    <updated>2020-07-24T05:11:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="1-if-语句"><a href="#1-if-语句" class="headerlink" title="1. if 语句"></a>1. if 语句</h2><pre><code class="hljs python"><span class="hljs-keyword">if</span> expression:    expr_true_suite</code></pre><ul><li>if 语句的 <code>expr_true_suite</code> 代码块只有当条件表达式 <code>expression</code> 结果为真时才执行，否则将继续执行紧跟在该代码块后面的语句。</li><li>单个 if 语句中的 <code>expression</code> 条件表达式可以通过布尔操作符 <code>and</code>，<code>or</code>和<code>not</code> 实现多重条件判断。</li></ul><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-number">2</span> &gt; <span class="hljs-number">3</span>:    print(<span class="hljs-string">'Correct Judgement!'</span>)<span class="hljs-comment"># Correct Judgement!</span></code></pre><h2 id="2-if-else-语句"><a href="#2-if-else-语句" class="headerlink" title="2. if - else 语句"></a>2. if - else 语句</h2><pre><code class="hljs python"><span class="hljs-keyword">if</span> expression:    expr_true_suite<span class="hljs-keyword">else</span>:    expr_false_suite</code></pre><ul><li>Python 提供与 if 搭配使用的 else，如果 if 语句的条件表达式结果布尔值为假，那么程序将执行 else 语句后的代码。</li></ul><p>【例子】</p><pre><code class="hljs python">temp = input(<span class="hljs-string">"猜一猜小姐姐想的是哪个数字？"</span>)guess = int(temp) <span class="hljs-comment"># input 函数将接收的任何数据类型都默认为 str。</span><span class="hljs-keyword">if</span> guess == <span class="hljs-number">666</span>:    print(<span class="hljs-string">"你太了解小姐姐的心思了！"</span>)    print(<span class="hljs-string">"哼，猜对也没有奖励！"</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"猜错了，小姐姐现在心里想的是666！"</span>)print(<span class="hljs-string">"游戏结束，不玩儿啦！"</span>)</code></pre><p><code>if</code>语句支持嵌套，即在一个<code>if</code>语句中嵌入另一个<code>if</code>语句，从而构成不同层次的选择结构。<strong>Python 使用缩进而不是大括号来标记代码块边界</strong>，因此要特别注意<code>else</code>的悬挂问题。</p><p>【例子】</p><pre><code class="hljs python">hi = <span class="hljs-number">6</span><span class="hljs-keyword">if</span> hi &gt; <span class="hljs-number">2</span>:    <span class="hljs-keyword">if</span> hi &gt; <span class="hljs-number">7</span>:        print(<span class="hljs-string">'好棒!好棒!'</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'切~'</span>)</code></pre><p>【例子】</p><pre><code class="hljs python">temp = input(<span class="hljs-string">"不妨猜一下小哥哥现在心里想的是那个数字："</span>)guess = int(temp)<span class="hljs-keyword">if</span> guess &gt; <span class="hljs-number">8</span>:    print(<span class="hljs-string">"大了，大了"</span>)<span class="hljs-keyword">else</span>:    <span class="hljs-keyword">if</span> guess == <span class="hljs-number">8</span>:        print(<span class="hljs-string">"你这么懂小哥哥的心思吗？"</span>)        print(<span class="hljs-string">"哼，猜对也没有奖励！"</span>)    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">"小了，小了"</span>)print(<span class="hljs-string">"游戏结束，不玩儿啦！"</span>)</code></pre><h2 id="3-if-elif-else-语句"><a href="#3-if-elif-else-语句" class="headerlink" title="3. if - elif - else 语句"></a>3. if - elif - else 语句</h2><pre><code class="hljs python"><span class="hljs-keyword">if</span> expression1:    expr1_true_suite<span class="hljs-keyword">elif</span> expression2:    expr2_true_suite    .    .<span class="hljs-keyword">elif</span> expressionN:    exprN_true_suite<span class="hljs-keyword">else</span>:    expr_false_suite</code></pre><ul><li>elif 语句即为 else if，用来检查多个表达式是否为真，并在为真时执行特定代码块中的代码。</li></ul><p>【例子】</p><pre><code class="hljs python">temp = input(<span class="hljs-string">'请输入成绩:'</span>)source = int(temp)<span class="hljs-keyword">if</span> <span class="hljs-number">100</span> &gt;= source &gt;= <span class="hljs-number">90</span>:    print(<span class="hljs-string">'A'</span>)<span class="hljs-keyword">elif</span> <span class="hljs-number">90</span> &gt; source &gt;= <span class="hljs-number">80</span>:    print(<span class="hljs-string">'B'</span>)<span class="hljs-keyword">elif</span> <span class="hljs-number">80</span> &gt; source &gt;= <span class="hljs-number">60</span>:    print(<span class="hljs-string">'C'</span>)<span class="hljs-keyword">elif</span> <span class="hljs-number">60</span> &gt; source &gt;= <span class="hljs-number">0</span>:    print(<span class="hljs-string">'D'</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'输入错误！'</span>)</code></pre><h2 id="4-assert-关键词"><a href="#4-assert-关键词" class="headerlink" title="4. assert 关键词"></a>4. assert 关键词</h2><ul><li><code>assert</code>这个关键词我们称之为“断言”，当这个关键词后边的条件为 False 时，程序自动崩溃并抛出<code>AssertionError</code>的异常。</li></ul><p>【例子】</p><pre><code class="hljs python">my_list = [<span class="hljs-string">'lsgogroup'</span>]my_list.pop(<span class="hljs-number">0</span>)<span class="hljs-keyword">assert</span> len(my_list) &gt; <span class="hljs-number">0</span><span class="hljs-comment"># AssertionError</span></code></pre><ul><li>在进行单元测试时，可以用来在程序中置入检查点，只有条件为 True 才能让程序正常工作。</li></ul><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">assert</span> <span class="hljs-number">3</span> &gt; <span class="hljs-number">7</span><span class="hljs-comment"># AssertionError</span></code></pre><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="1-while-循环"><a href="#1-while-循环" class="headerlink" title="1. while 循环"></a>1. while 循环</h2><p><code>while</code>语句最基本的形式包括一个位于顶部的布尔表达式，一个或多个属于<code>while</code>代码块的缩进语句。</p><pre><code class="hljs python"><span class="hljs-keyword">while</span> 布尔表达式:    代码块</code></pre><p><code>while</code>循环的代码块会一直循环执行，直到布尔表达式的值为布尔假。</p><p>如果布尔表达式不带有<code>&lt;、&gt;、==、！=、in、not in</code>等运算符，仅仅给出数值之类的条件，也是可以的。当<code>while</code>后写入一个非零整数时，视为真值，执行循环体；写入<code>0</code>时，视为假值，不执行循环体。也可以写入<code>str、list</code>或任何序列，长度非零则视为真值，执行循环体；否则视为假值，不执行循环体。</p><p>【例子】</p><pre><code class="hljs python">count = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">3</span>:    temp = input(<span class="hljs-string">"不妨猜一下小哥哥现在心里想的是那个数字："</span>)    guess = int(temp)    <span class="hljs-keyword">if</span> guess &gt; <span class="hljs-number">8</span>:        print(<span class="hljs-string">"大了，大了"</span>)    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">if</span> guess == <span class="hljs-number">8</span>:            print(<span class="hljs-string">"你是小哥哥心里的蛔虫吗？"</span>)            print(<span class="hljs-string">"哼，猜对也没有奖励！"</span>)            count = <span class="hljs-number">3</span>        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">"小了，小了"</span>)    count = count + <span class="hljs-number">1</span>print(<span class="hljs-string">"游戏结束，不玩儿啦！"</span>)</code></pre><p>【例子】布尔表达式返回0，循环终止。</p><pre><code class="hljs python">string = <span class="hljs-string">'abcd'</span><span class="hljs-keyword">while</span> string:    print(string)    string = string[<span class="hljs-number">1</span>:]<span class="hljs-comment"># abcd</span><span class="hljs-comment"># bcd</span><span class="hljs-comment"># cd</span><span class="hljs-comment"># d</span></code></pre><hr><h2 id="2-while-else-循环"><a href="#2-while-else-循环" class="headerlink" title="2. while - else 循环"></a>2. while - else 循环</h2><pre><code class="hljs python"><span class="hljs-keyword">while</span> 布尔表达式:    代码块<span class="hljs-keyword">else</span>:    代码块</code></pre><p><strong>当<code>while</code>循环正常执行完的情况下，执行<code>else</code>输出，如果<code>while</code>循环中执行了跳出循环的语句，比如 <code>break</code>，将不执行<code>else</code>代码块的内容。</strong>    </p><p>【例子】</p><pre><code class="hljs python">count = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">5</span>:    print(<span class="hljs-string">"%d is  less than 5"</span> % count)    count = count + <span class="hljs-number">1</span><span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"%d is not less than 5"</span> % count)    <span class="hljs-comment"># 0 is  less than 5</span><span class="hljs-comment"># 1 is  less than 5</span><span class="hljs-comment"># 2 is  less than 5</span><span class="hljs-comment"># 3 is  less than 5</span><span class="hljs-comment"># 4 is  less than 5</span><span class="hljs-comment"># 5 is not less than 5</span></code></pre><p>【例子】</p><pre><code class="hljs python">count = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">5</span>:    print(<span class="hljs-string">"%d is  less than 5"</span> % count)    count = <span class="hljs-number">6</span>    <span class="hljs-keyword">break</span><span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"%d is not less than 5"</span> % count)<span class="hljs-comment"># 0 is  less than 5</span></code></pre><hr><h2 id="3-for-循环"><a href="#3-for-循环" class="headerlink" title="3. for 循环"></a>3. for 循环</h2><p><code>for</code>循环是迭代循环，在Python中相当于一个通用的序列迭代器，可以遍历任何有序序列，如<code>str、list、tuple</code>等，也可以遍历任何可迭代对象，如<code>dict</code>。</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> 迭代变量 <span class="hljs-keyword">in</span> 可迭代对象:    代码块</code></pre><p>每次循环，迭代变量被设置为可迭代对象的当前元素，提供给代码块使用。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">'ILoveLSGO'</span>:    print(i, end=<span class="hljs-string">' '</span>)  <span class="hljs-comment"># 不换行输出</span><span class="hljs-comment"># I L o v e L S G O</span></code></pre><p>【例子】</p><pre><code class="hljs python">member = [<span class="hljs-string">'张三'</span>, <span class="hljs-string">'李四'</span>, <span class="hljs-string">'刘德华'</span>, <span class="hljs-string">'刘六'</span>, <span class="hljs-string">'周润发'</span>]<span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> member:    print(each)<span class="hljs-comment"># 张三</span><span class="hljs-comment"># 李四</span><span class="hljs-comment"># 刘德华</span><span class="hljs-comment"># 刘六</span><span class="hljs-comment"># 周润发</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(member)):    print(member[i])<span class="hljs-comment"># 张三</span><span class="hljs-comment"># 李四</span><span class="hljs-comment"># 刘德华</span><span class="hljs-comment"># 刘六</span><span class="hljs-comment"># 周润发</span></code></pre><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">4</span>&#125;<span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> dic.items():    print(key, value, sep=<span class="hljs-string">':'</span>, end=<span class="hljs-string">' '</span>)    <span class="hljs-comment"># a:1 b:2 c:3 d:4</span></code></pre><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">4</span>&#125;<span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dic.keys():    print(key, end=<span class="hljs-string">' '</span>)    <span class="hljs-comment"># a b c d</span></code></pre><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">4</span>&#125;<span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> dic.values():    print(value, end=<span class="hljs-string">' '</span>)    <span class="hljs-comment"># 1 2 3 4</span></code></pre><hr><h2 id="4-for-else-循环"><a href="#4-for-else-循环" class="headerlink" title="4. for - else 循环"></a>4. for - else 循环</h2><pre><code class="hljs python"><span class="hljs-keyword">for</span> 迭代变量 <span class="hljs-keyword">in</span> 可迭代对象:    代码块<span class="hljs-keyword">else</span>:    代码块</code></pre><p>当<code>for</code>循环正常执行完的情况下，执行<code>else</code>输出，如果<code>for</code>循环中执行了跳出循环的语句，比如 <code>break</code>，将不执行<code>else</code>代码块的内容，与<code>while - else</code>语句一样。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>):  <span class="hljs-comment"># 迭代 10 到 20 之间的数字</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, num):  <span class="hljs-comment"># 根据因子迭代</span>        <span class="hljs-keyword">if</span> num % i == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 确定第一个因子</span>            j = num / i  <span class="hljs-comment"># 计算第二个因子</span>            print(<span class="hljs-string">'%d 等于 %d * %d'</span> % (num, i, j))            <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 跳出当前循环</span>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 循环的 else 部分</span>        print(num, <span class="hljs-string">'是一个质数'</span>)<span class="hljs-comment"># 10 等于 2 * 5</span><span class="hljs-comment"># 11 是一个质数</span><span class="hljs-comment"># 12 等于 2 * 6</span><span class="hljs-comment"># 13 是一个质数</span><span class="hljs-comment"># 14 等于 2 * 7</span><span class="hljs-comment"># 15 等于 3 * 5</span><span class="hljs-comment"># 16 等于 2 * 8</span><span class="hljs-comment"># 17 是一个质数</span><span class="hljs-comment"># 18 等于 2 * 9</span><span class="hljs-comment"># 19 是一个质数</span></code></pre><hr><h2 id="5-range-函数"><a href="#5-range-函数" class="headerlink" title="5. range() 函数"></a>5. range() 函数</h2><pre><code class="hljs python">range([start,] stop[, step=<span class="hljs-number">1</span>])</code></pre><ul><li>这个BIF（Built-in functions内置函数）有三个参数，其中用中括号括起来的两个表示这两个参数是可选的。</li><li><code>step=1</code> 表示第三个参数的默认值是1。</li><li><code>range</code> 这个BIF的作用是生成一个从<code>start</code>参数的值开始到<code>stop</code>参数的值结束的数字序列，该序列包含<code>start</code>的值但不包含<code>stop</code>的值。</li></ul><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>):  <span class="hljs-comment"># 不包含9</span>    print(i)<span class="hljs-comment"># 2</span><span class="hljs-comment"># 3</span><span class="hljs-comment"># 4</span><span class="hljs-comment"># 5</span><span class="hljs-comment"># 6</span><span class="hljs-comment"># 7</span><span class="hljs-comment"># 8</span></code></pre><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>):    print(i)<span class="hljs-comment"># 1</span><span class="hljs-comment"># 3</span><span class="hljs-comment"># 5</span><span class="hljs-comment"># 7</span><span class="hljs-comment"># 9</span></code></pre><hr><h2 id="6-enumerate-函数"><a href="#6-enumerate-函数" class="headerlink" title="6. enumerate()函数"></a>6. enumerate()函数</h2><pre><code class="hljs python">enumerate(sequence, [start=<span class="hljs-number">0</span>])</code></pre><ul><li>sequence — 一个序列、迭代器或其他支持迭代对象。</li><li>start — 下标起始位置。</li><li>返回 enumerate(枚举) 对象</li></ul><p>【例子】</p><pre><code class="hljs python">seasons = [<span class="hljs-string">'Spring'</span>, <span class="hljs-string">'Summer'</span>, <span class="hljs-string">'Fall'</span>, <span class="hljs-string">'Winter'</span>]lst = list(enumerate(seasons))print(lst)<span class="hljs-comment"># [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]</span>lst = list(enumerate(seasons, start=<span class="hljs-number">1</span>))  <span class="hljs-comment"># 下标从 1 开始</span>print(lst)<span class="hljs-comment"># [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]</span></code></pre><p><code>enumerate()</code>与 for 循环的结合使用</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i, a <span class="hljs-keyword">in</span> enumerate(A)    do something <span class="hljs-keyword">with</span> a</code></pre><p>用 <code>enumerate(A)</code> 不仅返回了 <code>A</code> 中的元素，还顺便给该元素一个索引值 (默认从 0 开始)。此外，用 <code>enumerate(A, j)</code> 还可以确定索引起始值为 <code>j</code>。</p><p>【例子】</p><pre><code class="hljs python">languages = [<span class="hljs-string">'Python'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'Matlab'</span>, <span class="hljs-string">'C++'</span>]<span class="hljs-keyword">for</span> language <span class="hljs-keyword">in</span> languages:    print(<span class="hljs-string">'I love'</span>, language)print(<span class="hljs-string">'Done!'</span>)<span class="hljs-string">'''</span><span class="hljs-string">I love Python</span><span class="hljs-string">I love R</span><span class="hljs-string">I love Matlab</span><span class="hljs-string">I love C++</span><span class="hljs-string">Done!</span><span class="hljs-string">'''</span><span class="hljs-keyword">for</span> i, language <span class="hljs-keyword">in</span> enumerate(languages, <span class="hljs-number">2</span>):    print(i, <span class="hljs-string">'I love'</span>, language)print(<span class="hljs-string">'Done!'</span>)<span class="hljs-string">'''</span><span class="hljs-string">2 I love Python</span><span class="hljs-string">3 I love R</span><span class="hljs-string">4 I love Matlab</span><span class="hljs-string">5 I love C++</span><span class="hljs-string">Done!</span><span class="hljs-string">'''</span></code></pre><hr><h2 id="7-break-语句"><a href="#7-break-语句" class="headerlink" title="7. break 语句"></a>7. break 语句</h2><p><code>break</code>语句可以跳出当前所在层的循环。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> randomsecret = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">#[1,10]之间的随机数</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    temp = input(<span class="hljs-string">"不妨猜一下小哥哥现在心里想的是那个数字："</span>)    guess = int(temp)    <span class="hljs-keyword">if</span> guess &gt; secret:        print(<span class="hljs-string">"大了，大了"</span>)    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">if</span> guess == secret:            print(<span class="hljs-string">"你这样懂小哥哥的心思啊？"</span>)            print(<span class="hljs-string">"哼，猜对也没有奖励！"</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">"小了，小了"</span>)print(<span class="hljs-string">"游戏结束，不玩儿啦！"</span>)</code></pre><hr><h2 id="8-continue-语句"><a href="#8-continue-语句" class="headerlink" title="8. continue 语句"></a>8. continue 语句</h2><p><code>continue</code>终止本轮循环并开始下一轮循环。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):    <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:        print(i)        <span class="hljs-keyword">continue</span>    i += <span class="hljs-number">2</span>    print(i)<span class="hljs-comment"># 2</span><span class="hljs-comment"># 1</span><span class="hljs-comment"># 4</span><span class="hljs-comment"># 3</span><span class="hljs-comment"># 6</span><span class="hljs-comment"># 5</span><span class="hljs-comment"># 8</span><span class="hljs-comment"># 7</span><span class="hljs-comment"># 10</span><span class="hljs-comment"># 9</span></code></pre><hr><h2 id="9-pass-语句"><a href="#9-pass-语句" class="headerlink" title="9. pass 语句"></a>9. pass 语句</h2><p><code>pass</code> 语句的意思是“不做任何事”，如果你在需要有语句的地方不写任何语句，那么解释器会提示出错，而 <code>pass</code> 语句就是用来解决这些问题的。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a_func</span><span class="hljs-params">()</span>:</span><span class="hljs-comment"># SyntaxError: unexpected EOF while parsing</span></code></pre><p>【例子】</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a_func</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">pass</span></code></pre><p><code>pass</code>是空语句，不做任何操作，只起到占位的作用，其作用是为了保持程序结构的完整性。尽管<code>pass</code>语句不做任何操作，但如果暂时不确定要在一个位置放上什么样的代码，可以先放置一个<code>pass</code>语句，让代码可以正常运行。</p><hr><h2 id="10-推导式"><a href="#10-推导式" class="headerlink" title="10. 推导式"></a>10. 推导式</h2><p><strong>列表推导式</strong></p><pre><code class="hljs python">[ expr <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> collection [<span class="hljs-keyword">if</span> condition] ]</code></pre><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-number">-4</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]y = [a * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> x]print(y)<span class="hljs-comment"># [-8, -4, 0, 4, 8]</span></code></pre><p>【例子】</p><pre><code class="hljs python">x = [i ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)]print(x)<span class="hljs-comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></code></pre><p>【例子】</p><pre><code class="hljs python">x = [(i, i ** <span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">6</span>)]print(x)<span class="hljs-comment"># [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]</span></code></pre><p>【例子】</p><pre><code class="hljs python">x = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>) <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> (i % <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>]print(x)<span class="hljs-comment"># [3, 9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99]</span></code></pre><p>【例子】</p><pre><code class="hljs python">a = [(i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)]print(a)<span class="hljs-comment"># [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]</span></code></pre><p>【例子】</p><pre><code class="hljs python">x = [[i, j] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)]print(x)<span class="hljs-comment"># [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]</span>x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>print(x)<span class="hljs-comment"># [[10, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]</span></code></pre><p>【例子】</p><pre><code class="hljs python">a = [(i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">if</span> j &gt; <span class="hljs-number">1</span>]print(a)<span class="hljs-comment"># [(0, 2)]</span></code></pre><p><strong>元组推导式</strong></p><pre><code class="hljs python">( expr <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> collection [<span class="hljs-keyword">if</span> condition] )</code></pre><p>【例子】</p><pre><code class="hljs python">a = (x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>))print(a)<span class="hljs-comment"># &lt;generator object &lt;genexpr&gt; at 0x0000025BE511CC48&gt;</span>print(tuple(a))<span class="hljs-comment"># (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)</span></code></pre><p><strong>字典推导式</strong></p><pre><code class="hljs python">&#123; key_expr: value_expr <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> collection [<span class="hljs-keyword">if</span> condition] &#125;</code></pre><p>【例子】</p><pre><code class="hljs python">b = &#123;i: i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>&#125;print(b)<span class="hljs-comment"># &#123;0: True, 3: False, 6: True, 9: False&#125;</span></code></pre><p><strong>集合推导式</strong></p><pre><code class="hljs clojure">&#123; expr for value in collection [if condition] &#125;</code></pre><p>【例子】</p><pre><code class="hljs python">c = &#123;i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]&#125;print(c)<span class="hljs-comment"># &#123;1, 2, 3, 4, 5, 6&#125;</span></code></pre><p><strong>其它</strong></p><pre><code class="hljs python">d = <span class="hljs-string">'i for i in "I Love Lsgogroup"'</span>print(d)<span class="hljs-comment"># i for i in "I Love Lsgogroup"</span>e = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>))print(e)<span class="hljs-comment"># &lt;generator object &lt;genexpr&gt; at 0x0000007A0B8D01B0&gt;</span>print(next(e))  <span class="hljs-comment"># 0</span>print(next(e))  <span class="hljs-comment"># 1</span><span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> e:    print(each, end=<span class="hljs-string">' '</span>)<span class="hljs-comment"># 2 3 4 5 6 7 8 9</span>s = sum([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">101</span>)])print(s)  <span class="hljs-comment"># 5050</span>s = sum((i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">101</span>)))print(s)  <span class="hljs-comment"># 5050</span></code></pre><hr><h2 id="11-综合例子"><a href="#11-综合例子" class="headerlink" title="11. 综合例子"></a>11. 综合例子</h2><pre><code class="hljs python">passwdList = [<span class="hljs-string">'123'</span>, <span class="hljs-string">'345'</span>, <span class="hljs-string">'890'</span>]valid = <span class="hljs-literal">False</span>count = <span class="hljs-number">3</span><span class="hljs-keyword">while</span> count &gt; <span class="hljs-number">0</span>:    password = input(<span class="hljs-string">'enter password:'</span>)    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> passwdList:        <span class="hljs-keyword">if</span> password == item:            valid = <span class="hljs-literal">True</span>            <span class="hljs-keyword">break</span>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> valid:        print(<span class="hljs-string">'invalid input'</span>)        count -= <span class="hljs-number">1</span>        <span class="hljs-keyword">continue</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">break</span></code></pre><hr><p><strong>参考文献</strong>：</p><ul><li><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-tutorial.html</a></li><li><a href="https://www.bilibili.com/video/av4050443" target="_blank" rel="noopener">https://www.bilibili.com/video/av4050443</a></li><li><a href="https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ</a></li></ul><hr><p><strong>练习题</strong>：</p><p>1、编写一个Python程序来查找那些可以被7除以5的整数的数字，介于1500和2700之间。</p><pre><code class="hljs python"><span class="hljs-comment"># your code here</span></code></pre><p>2、龟兔赛跑游戏</p><p>题目描述：</p><p>话说这个世界上有各种各样的兔子和乌龟，但是研究发现，所有的兔子和乌龟都有一个共同的特点——喜欢赛跑。于是世界上各个角落都不断在发生着乌龟和兔子的比赛，小华对此很感兴趣，于是决定研究不同兔  子和乌龟的赛跑。他发现，兔子虽然跑比乌龟快，但它们有众所周知的毛病——骄傲且懒惰，于是在与乌龟的比赛中，一旦任一秒结束后兔子发现自己领先t米或以  上，它们就会停下来休息s秒。对于不同的兔子，t，s的数值是不同的，但是所有的乌龟却是一致——它们不到终点决不停止。 </p><p>然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子和乌龟的数据——兔子的速度v1（表示每秒兔子能跑v1  米），乌龟的速度v2，以及兔子对应的t，s值，以及赛道的长度l——就能预测出比赛的结果。但是小华很懒，不想通过手工计算推测出比赛的结果，于是他找 到了你——清华大学计算机系的高才生——请求帮助，请你写一个程序，对于输入的一场比赛的数据v1，v2，t，s，l，预测该场比赛的结果。</p><p>输入:</p><p>输入只有一行，包含用空格隔开的五个正整数v1，v2，t，s，l，其中(v1,v2&lt; =100;t&lt; =300;s&lt; =10;l&lt; =10000且为v1,v2的公倍数) </p><p>输出:</p><p>输出包含两行，第一行输出比赛结果——一个大写字母“T”或“R”或“D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点。 </p><p>第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）。 </p><hr><p>样例输入：</p><p>10  5  5  2  20 </p><p>样例输出</p><p>D<br><br>4</p><pre><code class="hljs python"><span class="hljs-comment"># your code here</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;条件语句&quot;&gt;&lt;a href=&quot;#条件语句&quot; class=&quot;headerlink&quot; title=&quot;条件语句&quot;&gt;&lt;/a&gt;条件语句&lt;/h1&gt;&lt;h2 id=&quot;1-if-语句&quot;&gt;&lt;a href=&quot;#1-if-语句&quot; class=&quot;headerlink&quot; title=&quot;1. 
      
    
    </summary>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python02-位运算</title>
    <link href="https://sulimin-nb.github.io/article/392be851.html"/>
    <id>https://sulimin-nb.github.io/article/392be851.html</id>
    <published>2020-07-23T15:09:34.000Z</published>
    <updated>2020-07-24T00:37:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="1-原码、反码和补码"><a href="#1-原码、反码和补码" class="headerlink" title="1. 原码、反码和补码"></a>1. 原码、反码和补码</h2><p>二进制有三种不同的表示形式：原码、反码和补码，<u>计算机内部使用补码来表示</u>。</p><p><strong>原码</strong>：就是其二进制表示（注意，有一位符号位）。</p><pre><code class="hljs python">00 00 00 11 -&gt; 310 00 00 11 -&gt; -3</code></pre><p><strong>反码</strong>：正数的反码就是原码，负数的反码是符号位不变，其余位取反（对应正数按位取反）。</p><pre><code class="hljs python">00 00 00 11 -&gt; 311 11 11 00 -&gt; -3</code></pre><p><strong>补码</strong>：正数的补码就是原码，负数的补码是反码+1。</p><pre><code class="hljs python">00 00 00 11 -&gt; 311 11 11 01 -&gt; -3</code></pre><p><strong>符号位</strong>：最高位为符号位，0表示正数，1表示负数。在位运算中符号位也参与运算。</p><h2 id="2-按位非操作"><a href="#2-按位非操作" class="headerlink" title="2. 按位非操作 ~"></a>2. 按位非操作 ~</h2><pre><code class="hljs python">~ <span class="hljs-number">1</span> = <span class="hljs-number">0</span>~ <span class="hljs-number">0</span> = <span class="hljs-number">1</span></code></pre><p><code>~</code> 把<code>num</code>的补码中的 0 和 1 全部取反（0 变为 1，1 变为 0）有符号整数的符号位在 <code>~</code> 运算中同样会取反。</p><pre><code class="hljs python">00 00 01 01 -&gt; 5~---11 11 10 10 -&gt; -611 11 10 11 -&gt; -5~---00 00 01 00 -&gt; 4</code></pre><h2 id="3-按位与操作-amp"><a href="#3-按位与操作-amp" class="headerlink" title="3. 按位与操作 &amp;"></a>3. 按位与操作 &amp;</h2><pre><code class="hljs python"><span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span> = <span class="hljs-number">1</span><span class="hljs-number">1</span> &amp; <span class="hljs-number">0</span> = <span class="hljs-number">0</span><span class="hljs-number">0</span> &amp; <span class="hljs-number">1</span> = <span class="hljs-number">0</span><span class="hljs-number">0</span> &amp; <span class="hljs-number">0</span> = <span class="hljs-number">0</span></code></pre><p>只有两个对应位都为 1 时才为 1</p><pre><code class="hljs python">00 00 01 01 -&gt; 5&amp;00 00 01 10 -&gt; 6---00 00 01 00 -&gt; 4</code></pre><h2 id="4-按位或操作"><a href="#4-按位或操作" class="headerlink" title="4. 按位或操作 |"></a>4. 按位或操作 |</h2><pre><code class="hljs python"><span class="hljs-number">1</span> | <span class="hljs-number">1</span> = <span class="hljs-number">1</span><span class="hljs-number">1</span> | <span class="hljs-number">0</span> = <span class="hljs-number">1</span><span class="hljs-number">0</span> | <span class="hljs-number">1</span> = <span class="hljs-number">1</span><span class="hljs-number">0</span> | <span class="hljs-number">0</span> = <span class="hljs-number">0</span></code></pre><p>只要两个对应位中有一个 1 时就为 1</p><pre><code class="hljs python">00 00 01 01 -&gt; 5|00 00 01 10 -&gt; 6---00 00 01 11 -&gt; 7</code></pre><h2 id="5-按位异或操作"><a href="#5-按位异或操作" class="headerlink" title="5. 按位异或操作 ^"></a>5. 按位异或操作 ^</h2><pre><code class="hljs python"><span class="hljs-number">1</span> ^ <span class="hljs-number">1</span> = <span class="hljs-number">0</span><span class="hljs-number">1</span> ^ <span class="hljs-number">0</span> = <span class="hljs-number">1</span><span class="hljs-number">0</span> ^ <span class="hljs-number">1</span> = <span class="hljs-number">1</span><span class="hljs-number">0</span> ^ <span class="hljs-number">0</span> = <span class="hljs-number">0</span></code></pre><p>只有两个对应位不同时才为 1</p><pre><code class="hljs python">00 00 01 01 -&gt; 5^00 00 01 10 -&gt; 6---00 00 00 11 -&gt; 3</code></pre><p>异或操作的性质：满足交换律和结合律</p><pre><code class="hljs python">A: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span>B: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">11</span>A^B: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>B^A: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>A^A: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>A^<span class="hljs-number">0</span>: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span>A^B^A: = A^A^B = <span class="hljs-number">0</span>^B = <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">11</span></code></pre><h2 id="6-按位左移操作-lt-lt"><a href="#6-按位左移操作-lt-lt" class="headerlink" title="6. 按位左移操作 &lt;&lt;"></a>6. 按位左移操作 &lt;&lt;</h2><p><code>num &lt;&lt; i</code> 将<code>num</code>的二进制表示向左移动<code>i</code>位所得的值。</p><pre><code class="hljs python">00 00 10 11 -&gt; 11<span class="hljs-number">11</span> &lt;&lt; <span class="hljs-number">3</span>---01 01 10 00 -&gt; 88 = 11 x 8</code></pre><h2 id="7-按位右移操作-gt-gt"><a href="#7-按位右移操作-gt-gt" class="headerlink" title="7. 按位右移操作 &gt;&gt;"></a>7. 按位右移操作 &gt;&gt;</h2><p><code>num &gt;&gt; i</code> 将<code>num</code>的二进制表示向右移动<code>i</code>位所得的值。</p><pre><code class="hljs python">00 00 10 11 -&gt; 11<span class="hljs-number">11</span> &gt;&gt; <span class="hljs-number">2</span>---00 00 00 10 -&gt; 2 = 11 // 4</code></pre><h2 id="8-利用位运算实现快速计算"><a href="#8-利用位运算实现快速计算" class="headerlink" title="8. 利用位运算实现快速计算"></a>8. 利用位运算实现快速计算</h2><p>通过 <code>&lt;&lt;</code>，<code>&gt;&gt;</code> 快速计算2的倍数问题。</p><pre><code class="hljs excel"><span class="hljs-built_in">n</span> &lt;&lt; <span class="hljs-number">1</span> -&gt; 计算 <span class="hljs-built_in">n</span>*<span class="hljs-number">2</span><span class="hljs-built_in">n</span> &gt;&gt; <span class="hljs-number">1</span> -&gt; 计算 <span class="hljs-built_in">n</span>//<span class="hljs-number">2</span>，负奇数的运算不可用<span class="hljs-built_in">n</span> &lt;&lt; m -&gt; 计算 <span class="hljs-built_in">n</span>*(<span class="hljs-number">2</span>^m)，即乘以 <span class="hljs-number">2</span> 的 m 次方<span class="hljs-built_in">n</span> &gt;&gt; m -&gt; 计算 <span class="hljs-built_in">n</span>//(<span class="hljs-number">2</span>^m)，即除以 <span class="hljs-number">2</span> 的 m 次方<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">n</span> -&gt; <span class="hljs-number">2</span>^<span class="hljs-built_in">n</span></code></pre><p>通过 <code>^</code> 快速交换两个整数。</p><pre><code class="hljs c">a ^= bb ^= aa ^= b</code></pre><p>通过 <code>a &amp; (-a)</code> 快速获取<code>a</code>的最后为 1 位置的整数。</p><p><span style="color:blue">(-a) = a的补码+1，最后一个1之后的0全变为1，+1后为0，进一000位后，原先的最后一个1保持不变。</span></p><pre><code class="hljs c"><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span> -&gt; <span class="hljs-number">5</span>&amp;<span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> -&gt; <span class="hljs-number">-5</span>---<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> -&gt; <span class="hljs-number">1</span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">11</span> <span class="hljs-number">10</span> -&gt; <span class="hljs-number">14</span>&amp;<span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> -&gt; <span class="hljs-number">-14</span>---<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> -&gt; <span class="hljs-number">2</span></code></pre><h2 id="9-利用位运算实现整数集合"><a href="#9-利用位运算实现整数集合" class="headerlink" title="9. 利用位运算实现整数集合"></a>9. 利用位运算实现整数集合</h2><p>一个数的二进制表示可以看作是一个集合（0 表示不在集合中，1 表示在集合中）。</p><p>比如集合 <code>{1, 3, 4, 8}</code>，可以表示成 <code>01 00 01 10 10(876543210,1表示在集合中,0表示不在集合中)</code> 而对应的位运算也就可以看作是对集合进行的操作。</p><p>元素与集合的操作：</p><pre><code class="hljs livescript">a | <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>&lt;&lt;i)</span>  -&gt;</span> 把 i 插入到集合中a &amp; ~<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>&lt;&lt;i)</span> -&gt;</span> 把 i 从集合中删除a &amp; <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>&lt;&lt;i)</span>  -&gt;</span> 判断 i 是否属于该集合（<span class="hljs-number">0</span>:不属于，<span class="hljs-number">1</span>:属于）</code></pre><p>集合之间的操作：</p><pre><code class="hljs c">a 补   -&gt; ~aa 交 b -&gt; a &amp; ba 并 b -&gt; a | ba 差 b -&gt; a &amp; (~b)</code></pre><p>注意：整数在内存中是以补码的形式存在的，输出自然也是按照补码输出。</p><p>【例子】C#语言输出负数。</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span><span class="hljs-params">(<span class="hljs-built_in">string</span>[] args)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">string</span> s1 = Convert.ToString(<span class="hljs-number">-3</span>, <span class="hljs-number">2</span>);        <span class="hljs-built_in">Console</span>.WriteLine(s1);         <span class="hljs-comment">// 11111111111111111111111111111101</span>                <span class="hljs-built_in">string</span> s2 = Convert.ToString(<span class="hljs-number">-3</span>, <span class="hljs-number">16</span>);        <span class="hljs-built_in">Console</span>.WriteLine(s2);         <span class="hljs-comment">// fffffffd</span>    &#125;&#125;</code></pre><p>【例子】 Python 的<code>bin()</code> 输出。</p><pre><code class="hljs python">print(bin(<span class="hljs-number">3</span>))  <span class="hljs-comment"># 0b11</span>print(bin(<span class="hljs-number">-3</span>))  <span class="hljs-comment"># -0b11</span>print(bin(<span class="hljs-number">-3</span> &amp; <span class="hljs-number">0xffffffff</span>))  <span class="hljs-comment"># 0b11111111111111111111111111111101</span>print(bin(<span class="hljs-number">0xfffffffd</span>))       <span class="hljs-comment"># 0b11111111111111111111111111111101</span>print(<span class="hljs-number">0xfffffffd</span>)  <span class="hljs-comment"># 4294967293</span></code></pre><p>是不是很颠覆认知，我们从结果可以看出：</p><ul><li>Python中<code>bin</code>一个负数（十进制表示），输出的是它的原码的二进制表示加上个负号，巨坑。</li><li>Python中的整型是补码形式存储的。</li><li>Python中整型是不限制长度的不会超范围溢出。</li></ul><p>所以为了获得负数（十进制表示）的补码，需要手动将其和十六进制数<code>0xffffffff</code>进行按位与操作，再交给<code>bin()</code>进行输出，得到的才是负数的补码表示。</p><hr><p><strong>练习题</strong>：</p><p>leetcode 习题 136. 只出现一次的数字</p><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>尝试使用位运算解决此题。</p><p>题目说明:</p><pre><code class="hljs python"><span class="hljs-string">"""</span><span class="hljs-string">Input file</span><span class="hljs-string">example1: [2,2,1]</span><span class="hljs-string">example2: [4,1,2,1,2]</span><span class="hljs-string"></span><span class="hljs-string">Output file</span><span class="hljs-string">result1: 1</span><span class="hljs-string">result2: 4</span><span class="hljs-string">"""</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(self, nums: List[int])</span> -&gt; int:</span>        <span class="hljs-comment"># your code here</span>        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x,y: x^y, nums)</code></pre><p>思路：</p><p>$a \bigoplus a = 0$, $0 \bigoplus a=a$,$0 \bigoplus 0=0$,所以把所有数字做异或操作，得到$(a_1 \bigoplus a_1) \bigoplus (a_2 \bigoplus a_2) \bigoplus \ldots (a_n) = a_n$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;位运算&quot;&gt;&lt;a href=&quot;#位运算&quot; class=&quot;headerlink&quot; title=&quot;位运算&quot;&gt;&lt;/a&gt;位运算&lt;/h1&gt;&lt;h2 id=&quot;1-原码、反码和补码&quot;&gt;&lt;a href=&quot;#1-原码、反码和补码&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python01-变量、运算符与数据类型</title>
    <link href="https://sulimin-nb.github.io/article/fcab5e80.html"/>
    <id>https://sulimin-nb.github.io/article/fcab5e80.html</id>
    <published>2020-07-22T15:26:59.000Z</published>
    <updated>2020-07-24T04:32:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量、运算符与数据类型"><a href="#变量、运算符与数据类型" class="headerlink" title="变量、运算符与数据类型"></a>变量、运算符与数据类型</h1><h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h2><ul><li>在 Python 中，<code>#</code> 表示注释，作用于整行。</li></ul><p>【例子】单行注释</p><pre><code class="hljs python"><span class="hljs-comment"># 这是一个注释</span>print(<span class="hljs-string">"Hello world"</span>)<span class="hljs-comment"># Hello world</span></code></pre><ul><li><code>&#39;&#39;&#39; &#39;&#39;&#39;</code> 或者 <code>&quot;&quot;&quot; &quot;&quot;&quot;</code> 表示区间注释，在三引号之间的所有内容被注释</li></ul><p>【例子】多行注释</p><pre><code class="hljs python"><span class="hljs-string">'''</span><span class="hljs-string">这是多行注释，用三个单引号</span><span class="hljs-string">这是多行注释，用三个单引号</span><span class="hljs-string">这是多行注释，用三个单引号</span><span class="hljs-string">'''</span>print(<span class="hljs-string">"Hello china"</span>) <span class="hljs-comment"># Hello china</span><span class="hljs-string">"""</span><span class="hljs-string">这是多行注释，用三个双引号</span><span class="hljs-string">这是多行注释，用三个双引号 </span><span class="hljs-string">这是多行注释，用三个双引号</span><span class="hljs-string">"""</span>print(<span class="hljs-string">"hello china"</span>) <span class="hljs-comment"># hello china</span></code></pre><h2 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h2><p><b>算术运算符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>+</code></td><td style="text-align:center">加</td><td style="text-align:center"><code>1 + 1</code></td></tr><tr><td style="text-align:center"><code>-</code></td><td style="text-align:center">减</td><td style="text-align:center"><code>2 - 1</code></td></tr><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center">乘</td><td style="text-align:center"><code>3 * 4</code></td></tr><tr><td style="text-align:center"><code>/</code></td><td style="text-align:center">除</td><td style="text-align:center"><code>3 / 4</code></td></tr><tr><td style="text-align:center"><code>//</code></td><td style="text-align:center">整除（地板除）</td><td style="text-align:center"><code>3 // 4</code></td></tr><tr><td style="text-align:center"><code>%</code></td><td style="text-align:center">取余</td><td style="text-align:center"><code>3 % 4</code></td></tr><tr><td style="text-align:center"><code>**</code></td><td style="text-align:center">幂</td><td style="text-align:center"><code>2 ** 3</code></td></tr></tbody></table></div><p>【例子】</p><pre><code class="hljs python">print(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 2</span>print(<span class="hljs-number">2</span> - <span class="hljs-number">1</span>)  <span class="hljs-comment"># 1</span>print(<span class="hljs-number">3</span> * <span class="hljs-number">4</span>)  <span class="hljs-comment"># 12</span>print(<span class="hljs-number">3</span> / <span class="hljs-number">4</span>)  <span class="hljs-comment"># 0.75</span>print(<span class="hljs-number">3</span> // <span class="hljs-number">4</span>)  <span class="hljs-comment"># 0</span>print(<span class="hljs-number">3</span> % <span class="hljs-number">4</span>)  <span class="hljs-comment"># 3</span>print(<span class="hljs-number">2</span> ** <span class="hljs-number">3</span>)  <span class="hljs-comment"># 8</span></code></pre><p><b>比较运算符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>&gt;</code></td><td style="text-align:center">大于</td><td style="text-align:center"><code>2 &gt; 1</code></td></tr><tr><td style="text-align:center"><code>&gt;=</code></td><td style="text-align:center">大于等于</td><td style="text-align:center"><code>2 &gt;= 4</code></td></tr><tr><td style="text-align:center"><code>&lt;</code></td><td style="text-align:center">小于</td><td style="text-align:center"><code>1 &lt; 2</code></td></tr><tr><td style="text-align:center"><code>&lt;=</code></td><td style="text-align:center">小于等于</td><td style="text-align:center"><code>5 &lt;= 2</code></td></tr><tr><td style="text-align:center"><code>==</code></td><td style="text-align:center">等于</td><td style="text-align:center"><code>3 == 4</code></td></tr><tr><td style="text-align:center"><code>!=</code></td><td style="text-align:center">不等于</td><td style="text-align:center"><code>3 != 5</code></td></tr></tbody></table></div><p>【例子】</p><pre><code class="hljs python">print(<span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span>)  <span class="hljs-comment"># True</span>print(<span class="hljs-number">2</span> &gt;= <span class="hljs-number">4</span>)  <span class="hljs-comment"># False</span>print(<span class="hljs-number">1</span> &lt; <span class="hljs-number">2</span>)  <span class="hljs-comment"># True</span>print(<span class="hljs-number">5</span> &lt;= <span class="hljs-number">2</span>)  <span class="hljs-comment"># False</span>print(<span class="hljs-number">3</span> == <span class="hljs-number">4</span>)  <span class="hljs-comment"># False</span>print(<span class="hljs-number">3</span> != <span class="hljs-number">5</span>)  <span class="hljs-comment"># True</span></code></pre><p><b>逻辑运算符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>and</code></td><td style="text-align:center">与</td><td style="text-align:center"><code>(3 &gt; 2) and (3 &lt; 5)</code></td></tr><tr><td style="text-align:center"><code>or</code></td><td style="text-align:center">或</td><td style="text-align:center"><code>(1 &gt; 3) or (9 &lt; 2)</code></td></tr><tr><td style="text-align:center"><code>not</code></td><td style="text-align:center">非</td><td style="text-align:center"><code>not (2 &gt; 1)</code></td></tr></tbody></table></div><p>【例子】</p><pre><code class="hljs python">print((<span class="hljs-number">3</span> &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">and</span> (<span class="hljs-number">3</span> &lt; <span class="hljs-number">5</span>))  <span class="hljs-comment"># True</span>print((<span class="hljs-number">1</span> &gt; <span class="hljs-number">3</span>) <span class="hljs-keyword">or</span> (<span class="hljs-number">9</span> &lt; <span class="hljs-number">2</span>))  <span class="hljs-comment"># False</span>print(<span class="hljs-keyword">not</span> (<span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span>))  <span class="hljs-comment"># False</span></code></pre><p><b>位运算符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>~</code></td><td style="text-align:center">按位取反</td><td style="text-align:center"><code>~4</code></td></tr><tr><td style="text-align:center"><code>&amp;</code></td><td style="text-align:center">按位与</td><td style="text-align:center"><code>4 &amp; 5</code></td></tr><tr><td style="text-align:center">`</td><td style="text-align:center">`</td><td style="text-align:center">按位或</td><td>`4</td><td>5`</td></tr><tr><td style="text-align:center"><code>^</code></td><td style="text-align:center">按位异或</td><td style="text-align:center"><code>4 ^ 5</code></td></tr><tr><td style="text-align:center"><code>&lt;&lt;</code></td><td style="text-align:center">左移</td><td style="text-align:center"><code>4 &lt;&lt; 2</code></td></tr><tr><td style="text-align:center"><code>&gt;&gt;</code></td><td style="text-align:center">右移</td><td style="text-align:center"><code>4 &gt;&gt; 2</code></td></tr></tbody></table></div><p>【例子】有关二进制的运算，参见“位运算”部分的讲解。</p><pre><code class="hljs python">print(bin(<span class="hljs-number">4</span>))  <span class="hljs-comment"># 0b100</span>print(bin(<span class="hljs-number">5</span>))  <span class="hljs-comment"># 0b101</span>print(bin(~<span class="hljs-number">4</span>), ~<span class="hljs-number">4</span>)  <span class="hljs-comment"># -0b101 -5</span>print(bin(<span class="hljs-number">4</span> &amp; <span class="hljs-number">5</span>), <span class="hljs-number">4</span> &amp; <span class="hljs-number">5</span>)  <span class="hljs-comment"># 0b100 4</span>print(bin(<span class="hljs-number">4</span> | <span class="hljs-number">5</span>), <span class="hljs-number">4</span> | <span class="hljs-number">5</span>)  <span class="hljs-comment"># 0b101 5</span>print(bin(<span class="hljs-number">4</span> ^ <span class="hljs-number">5</span>), <span class="hljs-number">4</span> ^ <span class="hljs-number">5</span>)  <span class="hljs-comment"># 0b1 1</span>print(bin(<span class="hljs-number">4</span> &lt;&lt; <span class="hljs-number">2</span>), <span class="hljs-number">4</span> &lt;&lt; <span class="hljs-number">2</span>)  <span class="hljs-comment"># 0b10000 16</span>print(bin(<span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">2</span>), <span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">2</span>)  <span class="hljs-comment"># 0b1 1</span></code></pre><p><b>三元运算符</b></p><p>【例子】</p><pre><code class="hljs python">x, y = <span class="hljs-number">4</span>, <span class="hljs-number">5</span><span class="hljs-keyword">if</span> x &lt; y:    small = x<span class="hljs-keyword">else</span>:    small = yprint(small)  <span class="hljs-comment"># 4</span></code></pre><p>有了这个三元操作符的条件表达式，你可以使用一条语句来完成以上的条件判断和赋值操作。</p><p>【例子】</p><pre><code class="hljs python">x, y = <span class="hljs-number">4</span>, <span class="hljs-number">5</span>small = x <span class="hljs-keyword">if</span> x &lt; y <span class="hljs-keyword">else</span> yprint(small)  <span class="hljs-comment"># 4</span></code></pre><p><b>其他运算符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>in</code></td><td style="text-align:center">存在</td><td style="text-align:center"><code>&#39;A&#39; in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></td></tr><tr><td style="text-align:center"><code>not in</code></td><td style="text-align:center">不存在</td><td style="text-align:center"><code>&#39;h&#39; not in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></td></tr><tr><td style="text-align:center"><code>is</code></td><td style="text-align:center">是</td><td style="text-align:center"><code>&quot;hello&quot; is &quot;hello&quot;</code></td></tr><tr><td style="text-align:center"><code>is not</code></td><td style="text-align:center">不是</td><td style="text-align:center"><code>&quot;hello&quot; is not &quot;hello&quot;</code></td></tr></tbody></table></div><p>【例子】</p><pre><code class="hljs python">letters = [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>]<span class="hljs-keyword">if</span> <span class="hljs-string">'A'</span> <span class="hljs-keyword">in</span> letters:    print(<span class="hljs-string">'A'</span> + <span class="hljs-string">' exists'</span>)<span class="hljs-keyword">if</span> <span class="hljs-string">'h'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> letters:    print(<span class="hljs-string">'h'</span> + <span class="hljs-string">' not exists'</span>)<span class="hljs-comment"># A exists</span><span class="hljs-comment"># h not exists</span></code></pre><p>【例子】比较的两个变量均指向不可变类型。</p><pre><code class="hljs python">a = <span class="hljs-string">"hello"</span>b = <span class="hljs-string">"hello"</span>print(a <span class="hljs-keyword">is</span> b, a == b)  <span class="hljs-comment"># True True</span>print(a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> b, a != b)  <span class="hljs-comment"># False False</span>print(id(a)) <span class="hljs-comment"># 2085367637744</span>print(id(b)) <span class="hljs-comment"># 2085367637744</span></code></pre><p>【例子】比较的两个变量均指向可变类型。</p><pre><code class="hljs python">a = [<span class="hljs-string">"hello"</span>]b = [<span class="hljs-string">"hello"</span>]print(a <span class="hljs-keyword">is</span> b, a == b)  <span class="hljs-comment"># False True</span>print(a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> b, a != b)  <span class="hljs-comment"># True False</span>print(id(a)) <span class="hljs-comment"># 2085336762952</span>print(id(b)) <span class="hljs-comment"># 2085340033544</span></code></pre><p>【例子】比较的两个变量均指向可变类型。</p><pre><code class="hljs python">e = dprint(e <span class="hljs-keyword">is</span> d, e == d) <span class="hljs-comment"># True True</span>print(e <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> d, e != d) <span class="hljs-comment"># False False</span></code></pre><p>注意：</p><ul><li>is, is not 对比的是两个变量的内存地址</li><li>==, != 对比的是两个变量的值</li><li>比较的两个变量，指向的都是地址不可变的类型（str等），那么is，is not 和 ==，！= 是完全等价的。<ul><li>通常，具有相同值的不可变对象在默认情况下具有相同的id。例如，数字-5到256在CPython中被保存，每个数字都存储在内存中单一且固定的位置，这为常用整数节省了内存。(可使用id()查看内存地址)</li></ul></li><li>对比的两个变量，指向的是地址可变的类型（list，dict，tuple等），则两者是有区别的。<ul><li>可变对象一般具有不同的id。除非是一个对象引用另一个对象，此时is的结果为True。</li></ul></li></ul><p><b>运算符的优先级</b></p><ul><li>一元运算符优于二元运算符。例如<code>3 ** -2</code>等价于<code>3 ** (-2)</code>。</li><li>先算术运算，后移位运算，最后位运算。例如 <code>1 &lt;&lt; 3 + 2 &amp; 7</code>等价于 <code>(1 &lt;&lt; (3 + 2)) &amp; 7</code>。</li><li>逻辑运算最后结合。例如<code>3 &lt; 4 and 4 &lt; 5</code>等价于<code>(3 &lt; 4) and (4 &lt; 5)</code>。</li></ul><p>【例子】</p><pre><code class="hljs python">print(<span class="hljs-number">-3</span> ** <span class="hljs-number">2</span>)  <span class="hljs-comment"># -9</span>print(<span class="hljs-number">3</span> ** <span class="hljs-number">-2</span>)  <span class="hljs-comment"># 0.1111111111111111</span>print(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span> + <span class="hljs-number">2</span> &amp; <span class="hljs-number">7</span>)  <span class="hljs-comment"># 0</span>print(<span class="hljs-number">-3</span> * <span class="hljs-number">2</span> + <span class="hljs-number">5</span> / <span class="hljs-number">-2</span> - <span class="hljs-number">4</span>)  <span class="hljs-comment"># -12.5</span>print(<span class="hljs-number">3</span> &lt; <span class="hljs-number">4</span> <span class="hljs-keyword">and</span> <span class="hljs-number">4</span> &lt; <span class="hljs-number">5</span>)  <span class="hljs-comment"># True</span></code></pre><h2 id="3-变量和赋值"><a href="#3-变量和赋值" class="headerlink" title="3. 变量和赋值"></a>3. 变量和赋值</h2><ul><li>在使用变量之前，需要对其先赋值。</li><li>变量名可以包括字母、数字、下划线、但变量名不能以数字开头。</li><li>Python 变量名是大小写敏感的，foo != Foo。</li></ul><p>【例子】</p><pre><code class="hljs python">teacher = <span class="hljs-string">"hey, bro"</span>print(teacher)  <span class="hljs-comment"># hey, bro</span></code></pre><p>【例子】</p><pre><code class="hljs python">first = <span class="hljs-number">2</span>second = <span class="hljs-number">3</span>third = first + secondprint(third)  <span class="hljs-comment"># 5</span></code></pre><p>【例子】</p><pre><code class="hljs python">myTeacher = <span class="hljs-string">"老马"</span>yourTeacher = <span class="hljs-string">"小马"</span>ourTeacher = myTeacher + <span class="hljs-string">','</span> + yourTeacherprint(ourTeacher)  <span class="hljs-comment"># 老马,小马</span></code></pre><h2 id="4-数据类型与转换"><a href="#4-数据类型与转换" class="headerlink" title="4. 数据类型与转换"></a>4. 数据类型与转换</h2><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">整型 <code>&lt;class &#39;int&#39;&gt;</code></td><td style="text-align:center"><code>-876, 10</code></td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">浮点型<code>&lt;class &#39;float&#39;&gt;</code></td><td style="text-align:center"><code>3.149, 11.11</code></td></tr><tr><td style="text-align:center">bool</td><td style="text-align:center">布尔型<code>&lt;class &#39;bool&#39;&gt;</code></td><td style="text-align:center"><code>True, False</code></td></tr></tbody></table></div><p><b>整型</b></p><p>【例子】通过 <code>print()</code> 可看出 <code>a</code> 的值，以及类 (class) 是<code>int</code>。</p><pre><code class="hljs python">a = <span class="hljs-number">1031</span>print(a, type(a))<span class="hljs-comment"># 1031 &lt;class 'int'&gt;</span></code></pre><p>Python 里面万物皆对象（object），整型也不例外，只要是对象，就有相应的属性 （attributes） 和方法（methods）。</p><p>【例子】</p><pre><code class="hljs python">b = dir(int)print(b)<span class="hljs-comment"># ['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__',</span><span class="hljs-comment"># '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__',</span><span class="hljs-comment"># '__float__', '__floor__', '__floordiv__', '__format__', '__ge__',</span><span class="hljs-comment"># '__getattribute__', '__getnewargs__', '__gt__', '__hash__',</span><span class="hljs-comment"># '__index__', '__init__', '__init_subclass__', '__int__', '__invert__',</span><span class="hljs-comment"># '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__',</span><span class="hljs-comment"># '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__',</span><span class="hljs-comment"># '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__',</span><span class="hljs-comment"># '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__',</span><span class="hljs-comment"># '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__',</span><span class="hljs-comment"># '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__',</span><span class="hljs-comment"># '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__',</span><span class="hljs-comment"># 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag',</span><span class="hljs-comment"># 'numerator', 'real', 'to_bytes']</span></code></pre><p>对它们有个大概印象就可以了，具体怎么用，需要哪些参数 （argument），还需要查文档。看个<code>bit_length()</code>的例子。</p><p>【例子】找到一个整数的二进制表示，再返回其长度。</p><pre><code class="hljs python">a = <span class="hljs-number">1031</span>print(bin(a))  <span class="hljs-comment"># 0b10000000111</span>print(a.bit_length())  <span class="hljs-comment"># 11</span></code></pre><p><b>浮点型</b></p><p>【例子】</p><pre><code class="hljs python">print(<span class="hljs-number">1</span>, type(<span class="hljs-number">1</span>))<span class="hljs-comment"># 1 &lt;class 'int'&gt;</span>print(<span class="hljs-number">1.</span>, type(<span class="hljs-number">1.</span>))<span class="hljs-comment"># 1.0 &lt;class 'float'&gt;</span>a = <span class="hljs-number">0.00000023</span>b = <span class="hljs-number">2.3e-7</span>print(a)  <span class="hljs-comment"># 2.3e-07</span>print(b)  <span class="hljs-comment"># 2.3e-07</span></code></pre><p>有时候我们想保留浮点型的小数点后 <code>n</code> 位。可以用 <code>decimal</code> 包里的 <code>Decimal</code> 对象和 <code>getcontext()</code> 方法来实现。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> decimal<span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal</code></pre><p>Python 里面有很多用途广泛的包 (package)，用什么你就引进 (import) 什么。包也是对象，也可以用上面提到的<code>dir(decimal)</code> 来看其属性和方法。</p><p>【例子】<code>getcontext()</code> 显示了 <code>Decimal</code> 对象的默认精度值是 28 位 (<code>prec=28</code>)。</p><pre><code class="hljs python">a = decimal.getcontext()print(a)<span class="hljs-comment"># Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span><span class="hljs-comment"># capitals=1, clamp=0, flags=[], </span><span class="hljs-comment"># traps=[InvalidOperation, DivisionByZero, Overflow])</span></code></pre><pre><code class="hljs python">b = Decimal(<span class="hljs-number">1</span>) / Decimal(<span class="hljs-number">3</span>)print(b)<span class="hljs-comment"># 0.3333333333333333333333333333</span></code></pre><p>【例子】使 1/3 保留 4 位，用 <code>getcontext().prec</code> 来调整精度。</p><pre><code class="hljs python">decimal.getcontext().prec = <span class="hljs-number">4</span>c = Decimal(<span class="hljs-number">1</span>) / Decimal(<span class="hljs-number">3</span>)print(c)<span class="hljs-comment"># 0.3333</span></code></pre><p><b>布尔型</b></p><p>布尔 (boolean) 型变量只能取两个值，<code>True</code> 和 <code>False</code>。当把布尔型变量用在数字运算中，用 <code>1</code> 和 <code>0</code> 代表 <code>True</code> 和 <code>False</code>。</p><p>【例子】</p><pre><code class="hljs python">print(<span class="hljs-literal">True</span> + <span class="hljs-literal">True</span>)  <span class="hljs-comment"># 2</span>print(<span class="hljs-literal">True</span> + <span class="hljs-literal">False</span>)  <span class="hljs-comment"># 1</span>print(<span class="hljs-literal">True</span> * <span class="hljs-literal">False</span>)  <span class="hljs-comment"># 0</span></code></pre><p>除了直接给变量赋值 <code>True</code> 和 <code>False</code>，还可以用 <code>bool(X)</code> 来创建变量，其中 <code>X</code> 可以是</p><ul><li>基本类型：整型、浮点型、布尔型</li><li>容器类型：字符串、元组、列表、字典和集合</li></ul><p>【例子】<code>bool</code> 作用在基本类型变量：<code>X</code> 只要不是整型 <code>0</code>、浮点型 <code>0.0</code>，<code>bool(X)</code> 就是 <code>True</code>，其余就是 <code>False</code>。</p><pre><code class="hljs python">print(type(<span class="hljs-number">0</span>), bool(<span class="hljs-number">0</span>), bool(<span class="hljs-number">1</span>))<span class="hljs-comment"># &lt;class 'int'&gt; False True</span>print(type(<span class="hljs-number">10.31</span>), bool(<span class="hljs-number">0.00</span>), bool(<span class="hljs-number">10.31</span>))<span class="hljs-comment"># &lt;class 'float'&gt; False True</span>print(type(<span class="hljs-literal">True</span>), bool(<span class="hljs-literal">False</span>), bool(<span class="hljs-literal">True</span>))<span class="hljs-comment"># &lt;class 'bool'&gt; False True</span></code></pre><p>【例子】<code>bool</code> 作用在容器类型变量：<code>X</code> 只要不是空的变量，<code>bool(X)</code> 就是 <code>True</code>，其余就是 <code>False</code>。</p><pre><code class="hljs python">print(type(<span class="hljs-string">''</span>), bool(<span class="hljs-string">''</span>), bool(<span class="hljs-string">'python'</span>))<span class="hljs-comment"># &lt;class 'str'&gt; False True</span>print(type(()), bool(()), bool((<span class="hljs-number">10</span>,)))<span class="hljs-comment"># &lt;class 'tuple'&gt; False True</span>print(type([]), bool([]), bool([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]))<span class="hljs-comment"># &lt;class 'list'&gt; False True</span>print(type(&#123;&#125;), bool(&#123;&#125;), bool(&#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>&#125;))<span class="hljs-comment"># &lt;class 'dict'&gt; False True</span>print(type(set()), bool(set()), bool(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;))<span class="hljs-comment"># &lt;class 'set'&gt; False True</span></code></pre><p>确定<code>bool(X)</code> 的值是 <code>True</code> 还是 <code>False</code>，就看 <code>X</code> 是不是空，空的话就是 <code>False</code>，不空的话就是 <code>True</code>。</p><ul><li>对于数值变量，<code>0</code>, <code>0.0</code> 都可认为是空的。</li><li>对于容器变量，里面没元素就是空的。</li></ul><p><b>获取类型信息</b></p><ul><li>获取类型信息 <code>type(object)</code></li></ul><p>【例子】</p><pre><code class="hljs python">print(type(<span class="hljs-number">1</span>))  <span class="hljs-comment"># &lt;class 'int'&gt;</span>print(type(<span class="hljs-number">5.2</span>))  <span class="hljs-comment"># &lt;class 'float'&gt;</span>print(type(<span class="hljs-literal">True</span>))  <span class="hljs-comment"># &lt;class 'bool'&gt;</span>print(type(<span class="hljs-string">'5.2'</span>))  <span class="hljs-comment"># &lt;class 'str'&gt;</span></code></pre><ul><li>获取类型信息 <code>isinstance(object, classinfo)</code></li></ul><p>【例子】</p><pre><code class="hljs python">print(isinstance(<span class="hljs-number">1</span>, int))  <span class="hljs-comment"># True</span>print(isinstance(<span class="hljs-number">5.2</span>, float))  <span class="hljs-comment"># True</span>print(isinstance(<span class="hljs-literal">True</span>, bool))  <span class="hljs-comment"># True</span>print(isinstance(<span class="hljs-string">'5.2'</span>, str))  <span class="hljs-comment"># True</span></code></pre><p>注：</p><ul><li><code>type()</code> 不会认为子类是一种父类类型，不考虑继承关系。</li><li><code>isinstance()</code> 会认为子类是一种父类类型，考虑继承关系。</li></ul><p>如果要判断两个类型是否相同推荐使用 <code>isinstance()</code>。</p><p><strong>类型转换</strong></p><ul><li>转换为整型 <code>int(x, base=10)</code></li><li>转换为字符串 <code>str(object=&#39;&#39;)</code></li><li>转换为浮点型 <code>float(x)</code></li><li>转换为布尔型 <code>bool(x)</code></li></ul><p>【例子】</p><pre><code class="hljs python">print(int(<span class="hljs-string">'520'</span>))  <span class="hljs-comment"># 520</span>print(int(<span class="hljs-number">520.52</span>))  <span class="hljs-comment"># 520</span>print(float(<span class="hljs-string">'520.52'</span>))  <span class="hljs-comment"># 520.52</span>print(float(<span class="hljs-number">520</span>))  <span class="hljs-comment"># 520.0</span>print(str(<span class="hljs-number">10</span> + <span class="hljs-number">10</span>))  <span class="hljs-comment"># 20</span>print(str(<span class="hljs-number">10.1</span> + <span class="hljs-number">5.2</span>))  <span class="hljs-comment"># 15.3</span>print(bool([])) <span class="hljs-comment"># False</span></code></pre><h2 id="5-print-函数"><a href="#5-print-函数" class="headerlink" title="5. print() 函数"></a>5. print() 函数</h2><pre><code class="hljs python">print(*objects, sep=<span class="hljs-string">' '</span>, end=<span class="hljs-string">'\n'</span>, file=sys.stdout, flush=<span class="hljs-literal">False</span>)</code></pre><ul><li>将对象以字符串表示的方式格式化输出到流文件对象file里。其中所有非关键字参数都按<code>str()</code>方式进行转换为字符串输出；</li><li>关键字参数<code>sep</code>是实现分隔符，比如多个参数输出时想要输出中间的分隔字符；</li><li>关键字参数<code>end</code>是输出结束时的字符，默认是换行符<code>\n</code>；</li><li>关键字参数<code>file</code>是定义流输出的文件，可以是标准的系统输出<code>sys.stdout</code>，也可以重定义为别的文件；</li><li>关键字参数<code>flush</code>是立即把内容输出到流文件，不作缓存。</li></ul><p>【例子】没有参数时，每次输出后都会换行。</p><pre><code class="hljs python">shoplist = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'mango'</span>, <span class="hljs-string">'carrot'</span>, <span class="hljs-string">'banana'</span>]print(<span class="hljs-string">"This is printed without 'end'and 'sep'."</span>)<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> shoplist:    print(item)<span class="hljs-comment"># This is printed without 'end'and 'sep'.</span><span class="hljs-comment"># apple</span><span class="hljs-comment"># mango</span><span class="hljs-comment"># carrot</span><span class="hljs-comment"># banana</span></code></pre><p>【例子】每次输出结束都用<code>end</code>设置的参数<code>&amp;</code>结尾，并没有默认换行。</p><pre><code class="hljs python">shoplist = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'mango'</span>, <span class="hljs-string">'carrot'</span>, <span class="hljs-string">'banana'</span>]print(<span class="hljs-string">"This is printed with 'end='&amp;''."</span>)<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> shoplist:    print(item, end=<span class="hljs-string">'&amp;'</span>)print(<span class="hljs-string">'hello world'</span>)<span class="hljs-comment"># This is printed with 'end='&amp;''.</span><span class="hljs-comment"># apple&amp;mango&amp;carrot&amp;banana&amp;hello world</span></code></pre><p>【例子】<code>item</code>值与<code>&#39;another string&#39;</code>两个值之间用<code>sep</code>设置的参数<code>&amp;</code>分割。由于<code>end</code>参数没有设置，因此默认是输出解释后换行，即<code>end</code>参数的默认值为<code>\n</code>。</p><pre><code class="hljs python">shoplist = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'mango'</span>, <span class="hljs-string">'carrot'</span>, <span class="hljs-string">'banana'</span>]print(<span class="hljs-string">"This is printed with 'sep='&amp;''."</span>)<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> shoplist:    print(item, <span class="hljs-string">'another string'</span>, sep=<span class="hljs-string">'&amp;'</span>)<span class="hljs-comment"># This is printed with 'sep='&amp;''.</span><span class="hljs-comment"># apple&amp;another string</span><span class="hljs-comment"># mango&amp;another string</span><span class="hljs-comment"># carrot&amp;another string</span><span class="hljs-comment"># banana&amp;another string</span></code></pre><hr><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li><p>怎样对python中的代码进行注释？</p><h1 id="：单行注释"><a href="#：单行注释" class="headerlink" title="：单行注释"></a>：单行注释</h1><p><code>&#39;&#39;&#39; &#39;&#39;&#39;</code> 或者 <code>&quot;&quot;&quot; &quot;&quot;&quot;</code> ：区间注释，在三引号之间的所有内容被注释</p></li><li><p>python有哪些运算符，这些运算符的优先级是怎样的？</p><p><b>运算符的优先级</b></p><ul><li>一元运算符优于二元运算符。</li><li>先算术运算，后移位运算，最后位运算。</li><li>逻辑运算最后结合。</li></ul></li><li><p>python 中 <code>is</code>, <code>is not</code> 与 <code>==</code>, <code>!=</code> 的区别是什么？</p><p><code>is</code>，<code>is not</code>对比的是两个变量的内存地址</p><p><code>==</code>，<code>！=</code>对比的是两个变量的值</p></li><li><p>python 中包含哪些数据类型？这些数据类型之间如何转换？</p><p>数据类型：整型，浮点型，字符型，布尔型</p><p><strong>类型转换</strong></p><ul><li>转换为整型 <code>int(x, base=10)</code></li><li>转换为字符串 <code>str(object=&#39;&#39;)</code></li><li>转换为浮点型 <code>float(x)</code></li><li>转换为布尔型 <code>bool(x)</code></li></ul></li></ol><hr><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://github.com/datawhalechina/team-learning-program/blob/master/Python-Language/01. 变量、运算符与数据类型.md" target="_blank" rel="noopener">datawhale-01.变量、运算符与数据类型</a></li><li><a href="https://zhuanlan.zhihu.com/p/105849984" target="_blank" rel="noopener">【译】Python中的 !=与is not不同</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;变量、运算符与数据类型&quot;&gt;&lt;a href=&quot;#变量、运算符与数据类型&quot; class=&quot;headerlink&quot; title=&quot;变量、运算符与数据类型&quot;&gt;&lt;/a&gt;变量、运算符与数据类型&lt;/h1&gt;&lt;h2 id=&quot;1-注释&quot;&gt;&lt;a href=&quot;#1-注释&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理-新闻文本分类</title>
    <link href="https://sulimin-nb.github.io/article/1ddf0dd3.html"/>
    <id>https://sulimin-nb.github.io/article/1ddf0dd3.html</id>
    <published>2020-07-21T14:29:02.000Z</published>
    <updated>2020-08-05T01:50:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="赛题理解"><a href="#赛题理解" class="headerlink" title="赛题理解"></a>赛题理解</h2><ul><li>赛题名称：零基础入门NLP之新闻文本分类</li><li>赛题任务：赛题以自然语言处理为背景，要求选手对新闻文本进行分类，这是一个典型的字符识别问题。</li></ul><h3 id="赛题数据"><a href="#赛题数据" class="headerlink" title="赛题数据"></a>赛题数据</h3><p>赛题以匿名处理后的新闻数据为赛题数据，数据集报名后可见并可下载。赛题数据为新闻文本，并按照字符级别进行匿名处理。整合划分出14个候选分类类别：财经、彩票、房产、股票、家居、教育、科技、社会、时尚、时政、体育、星座、游戏、娱乐的文本数据。</p><p>赛题数据由以下几个部分构成：训练集20w条样本，测试集A包括5w条样本，测试集B包括5w条样本。为了预防选手人工标注测试集的情况，我们将比赛数据的文本按照字符级别进行了匿名处理。</p><h3 id="数据标签"><a href="#数据标签" class="headerlink" title="数据标签"></a>数据标签</h3><p>处理后的赛题训练数据如下：</p><div class="table-container"><table><thead><tr><th>label</th><th>text</th></tr></thead><tbody><tr><td>6</td><td>57 44 66 56 2 3 3 37 5 41 9 57 44 47 45 33 13 63 58 31 17 47 0 1 1 69 26 60 62 15 21 12 49 18 38 20 50 23 57 44 45 33 25 28 47 22 52 35 30 14 24 69 54 7 48 19 11 51 16 43 26 34 53 27 64 8 4 42 36 46 65 69 29 39 15 37 57 44 45 33 69 54 7 25 40 35 30 66 56 47 55 69 61 10 60 42 36 46 65 37 5 41 32 67 6 59 47 0 1 1 68</td></tr></tbody></table></div><p>在数据集中标签的对应的关系如下：{‘科技’: 0, ‘股票’: 1, ‘体育’: 2, ‘娱乐’: 3, ‘时政’: 4, ‘社会’: 5, ‘教育’: 6, ‘财经’: 7, ‘家居’: 8, ‘游戏’: 9, ‘房产’: 10, ‘时尚’: 11, ‘彩票’: 12, ‘星座’: 13}</p><h3 id="评测指标"><a href="#评测指标" class="headerlink" title="评测指标"></a>评测指标</h3><p>评价标准为类别<code>f1_score</code>的均值，选手提交结果与实际测试集的类别进行对比，结果越大越好。</p><h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><p>使用<code>Pandas</code>库完成数据读取操作，并对赛题数据进行分析。</p><h2 id="数据读取与数据分析"><a href="#数据读取与数据分析" class="headerlink" title="数据读取与数据分析"></a>数据读取与数据分析</h2><p>本章主要内容为数据读取和数据分析，具体使用<code>Pandas</code>库完成数据读取操作，并对赛题数据进行分析构成。</p><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>学习使用<code>Pandas</code>读取赛题数据</li><li>分析赛题数据的分布规律</li></ul><h3 id="数据读取-1"><a href="#数据读取-1" class="headerlink" title="数据读取"></a>数据读取</h3><p>赛题数据虽然是文本数据，每个新闻是不定长的，但任然使用csv格式进行存储。因此可以直接用<code>Pandas</code>完成数据读取的操作。</p><pre><code class="hljs reasonml">import pandas <span class="hljs-keyword">as</span> pdtrain_df = pd.read<span class="hljs-constructor">_csv('..<span class="hljs-operator">/</span><span class="hljs-params">input</span><span class="hljs-operator">/</span><span class="hljs-params">train_set</span>.<span class="hljs-params">csv</span>', <span class="hljs-params">sep</span>='\<span class="hljs-params">t</span>', <span class="hljs-params">nrows</span>=100)</span></code></pre><p>这里的<code>read_csv</code>由三部分构成：</p><ul><li>读取的文件路径，这里需要根据改成你本地的路径，可以使用相对路径或绝对路径；</li><li>分隔符<code>sep</code>，为每列分割的字符，设置为<code>\t</code>即可；</li><li>读取行数<code>nrows</code>，为此次读取文件的函数，是数值类型（由于数据集比较大，建议先设置为100）；</li></ul><p><a href="https://camo.githubusercontent.com/3cfb75e212d4e8259de4c4151e52b405dbe256de/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333733303733392e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/3cfb75e212d4e8259de4c4151e52b405dbe256de/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333733303733392e706e67" srcset="/img/loading.gif" alt="task2_train_head"></a></p><p>上图是读取好的数据，是表格的形式。第一列为新闻的类别，第二列为新闻的字符。</p><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><p>在读取完成数据集后，我们还可以对数据集进行数据分析的操作。虽然对于非结构数据并不需要做很多的数据分析，但通过数据分析还是可以找出一些规律的。</p><p>此步骤我们读取了所有的训练集数据，在此我们通过数据分析希望得出以下结论：</p><ul><li>赛题数据中，新闻文本的长度是多少？</li><li>赛题数据的类别分布是怎么样的，哪些类别比较多？</li><li>赛题数据中，字符分布是怎么样的？</li></ul><h4 id="句子长度分析"><a href="#句子长度分析" class="headerlink" title="句子长度分析"></a>句子长度分析</h4><p>在赛题数据中每行句子的字符使用空格进行隔开，所以可以直接统计单词的个数来得到每个句子的长度。统计并如下：</p><pre><code class="hljs sas"><span class="hljs-name">%pylab</span> inlinetrain_df[<span class="hljs-string">'text_len'</span>] = train_df[<span class="hljs-string">'text'</span>].apply(lambda <span class="hljs-meta">x</span>: l<span class="hljs-meta">en(</span><span class="hljs-meta">x</span>.split(<span class="hljs-string">' '</span>)))p<span class="hljs-meta">rint(</span>train_df[<span class="hljs-string">'text_len'</span>].<span class="hljs-meta">describe</span>())</code></pre><p>输出结果为：</p><pre><code class="hljs yaml"><span class="hljs-string">Populating</span> <span class="hljs-string">the</span> <span class="hljs-string">interactive</span> <span class="hljs-string">namespace</span> <span class="hljs-string">from</span> <span class="hljs-string">numpy</span> <span class="hljs-string">and</span> <span class="hljs-string">matplotlib</span><span class="hljs-string">count</span>    <span class="hljs-number">200000.000000</span><span class="hljs-string">mean</span>        <span class="hljs-number">907.207110</span><span class="hljs-string">std</span>         <span class="hljs-number">996.029036</span><span class="hljs-string">min</span>           <span class="hljs-number">2.000000</span><span class="hljs-number">25</span><span class="hljs-string">%</span>         <span class="hljs-number">374.000000</span><span class="hljs-number">50</span><span class="hljs-string">%</span>         <span class="hljs-number">676.000000</span><span class="hljs-number">75</span><span class="hljs-string">%</span>        <span class="hljs-number">1131.000000</span><span class="hljs-string">max</span>       <span class="hljs-number">57921.000000</span><span class="hljs-attr">Name:</span> <span class="hljs-string">text_len,</span> <span class="hljs-attr">dtype:</span> <span class="hljs-string">float64</span></code></pre><p>对新闻句子的统计可以得出，本次赛题给定的文本比较长，每个句子平均由907个字符构成，最短的句子长度为2，最长的句子长度为57921。</p><p>下图将句子长度绘制了直方图，可见大部分句子的长度都几种在2000以内。</p><pre><code class="hljs routeros">_ = plt.hist(train_df[<span class="hljs-string">'text_len'</span>], <span class="hljs-attribute">bins</span>=200)plt.xlabel(<span class="hljs-string">'Text char count'</span>)plt.title(<span class="hljs-string">"Histogram of char count"</span>)</code></pre><p><a href="https://camo.githubusercontent.com/656471f35c5df332c6ca027756cfd048324e5727/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333833363930352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/656471f35c5df332c6ca027756cfd048324e5727/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333833363930352e706e67" srcset="/img/loading.gif" alt="task2_char_hist"></a></p><h4 id="新闻类别分布"><a href="#新闻类别分布" class="headerlink" title="新闻类别分布"></a>新闻类别分布</h4><p>接下来可以对数据集的类别进行分布统计，具体统计每类新闻的样本个数。</p><pre><code class="hljs less"><span class="hljs-selector-tag">train_df</span><span class="hljs-selector-attr">['label']</span><span class="hljs-selector-class">.value_counts</span>()<span class="hljs-selector-class">.plot</span>(kind=<span class="hljs-string">'bar'</span>)<span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.title</span>(<span class="hljs-string">'News class count'</span>)<span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.xlabel</span>(<span class="hljs-string">"category"</span>)</code></pre><p><a href="https://camo.githubusercontent.com/ea8ab6a105f74fa197f29cb09e5dfd97ae6a573e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333932393239362e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ea8ab6a105f74fa197f29cb09e5dfd97ae6a573e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333932393239362e706e67" srcset="/img/loading.gif" alt="task2_class_hist"></a></p><p>在数据集中标签的对应的关系如下：{‘科技’: 0, ‘股票’: 1, ‘体育’: 2, ‘娱乐’: 3, ‘时政’: 4, ‘社会’: 5, ‘教育’: 6, ‘财经’: 7, ‘家居’: 8, ‘游戏’: 9, ‘房产’: 10, ‘时尚’: 11, ‘彩票’: 12, ‘星座’: 13}</p><p>从统计结果可以看出，赛题的数据集类别分布存在较为不均匀的情况。在训练集中科技类新闻最多，其次是股票类新闻，最少的新闻是星座新闻。</p><h4 id="字符分布统计"><a href="#字符分布统计" class="headerlink" title="字符分布统计"></a>字符分布统计</h4><p>接下来可以统计每个字符出现的次数，首先可以将训练集中所有的句子进行拼接进而划分为字符，并统计每个字符的个数。</p><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> collections import Counterall_lines = <span class="hljs-string">' '</span>.join(list(train_df[<span class="hljs-string">'text'</span>]))word_count = Counter(all_lines.split(<span class="hljs-string">" "</span>))word_count = sorted(word_count.items(), <span class="hljs-attribute">key</span>=lambda d:d[1], reverse = <span class="hljs-literal">True</span>)<span class="hljs-builtin-name">print</span>(len(word_count))<span class="hljs-comment"># 6869</span><span class="hljs-builtin-name">print</span>(word_count[0])<span class="hljs-comment"># ('3750', 7482224)</span><span class="hljs-builtin-name">print</span>(word_count[-1])<span class="hljs-comment"># ('3133', 1)</span></code></pre><p>从统计结果中可以看出，在训练集中总共包括6869个字，其中编号3750的字出现的次数最多，编号3133的字出现的次数最少。</p><p>这里还可以根据字在每个句子的出现情况，反推出标点符号。下面代码统计了不同字符在句子中出现的次数，其中字符3750，字符900和字符648在20w新闻的覆盖率接近99%，很有可能是标点符号。</p><pre><code class="hljs vim">train_df[<span class="hljs-string">'text_unique'</span>] = train_df[<span class="hljs-string">'text'</span>].apply(lambda <span class="hljs-keyword">x</span>: <span class="hljs-string">' '</span>.<span class="hljs-keyword">join</span>(<span class="hljs-keyword">list</span>(<span class="hljs-keyword">set</span>(<span class="hljs-keyword">x</span>.<span class="hljs-keyword">split</span>(<span class="hljs-string">' '</span>)))))all_lines = <span class="hljs-string">' '</span>.<span class="hljs-keyword">join</span>(<span class="hljs-keyword">list</span>(train_df[<span class="hljs-string">'text_unique'</span>]))word_count = Counter(all_lines.<span class="hljs-keyword">split</span>(<span class="hljs-string">" "</span>))word_count = sorted(word_count.<span class="hljs-built_in">items</span>(), key=lambda d:<span class="hljs-keyword">int</span>(d[<span class="hljs-number">1</span>]), <span class="hljs-built_in">reverse</span> = True)<span class="hljs-keyword">print</span>(word_count[<span class="hljs-number">0</span>])# (<span class="hljs-string">'3750'</span>, <span class="hljs-number">197997</span>)<span class="hljs-keyword">print</span>(word_count[<span class="hljs-number">1</span>])# (<span class="hljs-string">'900'</span>, <span class="hljs-number">197653</span>)<span class="hljs-keyword">print</span>(word_count[<span class="hljs-number">2</span>])# (<span class="hljs-string">'648'</span>, <span class="hljs-number">191975</span>)</code></pre><h3 id="数据分析的结论"><a href="#数据分析的结论" class="headerlink" title="数据分析的结论"></a>数据分析的结论</h3><p>通过上述分析我们可以得出以下结论：</p><ol><li>赛题中每个新闻包含的字符个数平均为1000个，还有一些新闻字符较长；</li><li>赛题中新闻类别分布不均匀，科技类新闻样本量接近4w，星座类新闻样本量不到1k；</li><li>赛题总共包括7000-8000个字符；</li></ol><p>通过数据分析，我们还可以得出以下结论：</p><ol><li>每个新闻平均字符个数较多，可能需要截断；</li><li>由于类别不均衡，会严重影响模型的精度；</li></ol><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章对赛题数据进行读取，并新闻句子长度、类别和字符进行了可视化分析。</p><h3 id="本章作业"><a href="#本章作业" class="headerlink" title="本章作业"></a>本章作业</h3><ol><li>假设字符3750，字符900和字符648是句子的标点符号，请分析赛题每篇新闻平均由多少个句子构成？</li><li>统计每类新闻中出现次数对多的字符</li></ol><h1 id="基于机器学习的文本分类"><a href="#基于机器学习的文本分类" class="headerlink" title="基于机器学习的文本分类"></a>基于机器学习的文本分类</h1><p>在上一章节，我们对赛题的数据进行了读取，并在末尾给出了两个小作业。如果你顺利完成了作业，那么你基本上对<code>Python</code>也比较熟悉了。在本章我们将使用传统机器学习算法来完成新闻分类的过程，将会结束到赛题的核心知识点。</p><h2 id="基于机器学习的文本分类-1"><a href="#基于机器学习的文本分类-1" class="headerlink" title="基于机器学习的文本分类"></a>基于机器学习的文本分类</h2><p>在本章我们将开始使用机器学习模型来解决文本分类。机器学习发展比较广，且包括多个分支，本章侧重使用传统机器学习，从下一章开始是基于深度学习的文本分类。</p><h3 id="学习目标-1"><a href="#学习目标-1" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>学会TF-IDF的原理和使用</li><li>使用sklearn的机器学习模型完成文本分类</li></ul><h3 id="机器学习模型"><a href="#机器学习模型" class="headerlink" title="机器学习模型"></a>机器学习模型</h3><p>机器学习是对能通过经验自动改进的计算机算法的研究。机器学习通过历史数据<strong>训练</strong>出<strong>模型</strong>对应于人类对经验进行<strong>归纳</strong>的过程，机器学习利用<strong>模型</strong>对新数据进行<strong>预测</strong>对应于人类利用总结的<strong>规律</strong>对新问题进行<strong>预测</strong>的过程。</p><p>机器学习有很多种分支，对于学习者来说应该优先掌握机器学习算法的分类，然后再其中一种机器学习算法进行学习。由于机器学习算法的分支和细节实在是太多，所以如果你一开始就被细节迷住了眼，你就很难知道全局是什么情况的。</p><p>如果你是机器学习初学者，你应该知道如下的事情：</p><ol><li>机器学习能解决一定的问题，但不能奢求机器学习是万能的；</li><li>机器学习算法有很多种，看具体问题需要什么，再来进行选择；</li><li>每种机器学习算法有一定的偏好，需要具体问题具体分析；</li></ol><p><a href="https://camo.githubusercontent.com/d8e9a12417a2a2a754a874af0ae163bb1bddbb0b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333232333235332e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d8e9a12417a2a2a754a874af0ae163bb1bddbb0b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333232333235332e6a7067" srcset="/img/loading.gif" alt="machine_learning_overview"></a></p><h3 id="文本表示方法-Part1"><a href="#文本表示方法-Part1" class="headerlink" title="文本表示方法 Part1"></a>文本表示方法 Part1</h3><p>在机器学习算法的训练过程中，假设给定$N$个样本，每个样本有$M$个特征，这样组成了$N×M$的样本矩阵，然后完成算法的训练和预测。同样的在计算机视觉中可以将图片的像素看作特征，每张图片看作hight×width×3的特征图，一个三维的矩阵来进入计算机进行计算。</p><p>但是在自然语言领域，上述方法却不可行：文本是不定长度的。文本表示成计算机能够运算的数字或向量的方法一般称为词嵌入（Word Embedding）方法。词嵌入将不定长的文本转换到定长的空间内，是文本分类的第一步。</p><h4 id="One-hot"><a href="#One-hot" class="headerlink" title="One-hot"></a>One-hot</h4><p>这里的One-hot与数据挖掘任务中的操作是一致的，即将每一个单词使用一个离散的向量表示。具体将每个字/词编码一个索引，然后根据索引进行赋值。</p><p>One-hot表示方法的例子如下：</p><pre><code class="hljs angelscript">句子<span class="hljs-number">1</span>：我 爱 北 京 天 安 门句子<span class="hljs-number">2</span>：我 喜 欢 上 海</code></pre><p>首先对所有句子的字进行索引，即将每个字确定一个编号：</p><pre><code class="hljs 1c">&#123;'我': <span class="hljs-number">1</span>, '爱': <span class="hljs-number">2</span>, '北': <span class="hljs-number">3</span>, '京': <span class="hljs-number">4</span>, '天': <span class="hljs-number">5</span>,  '安': <span class="hljs-number">6</span>, '门': <span class="hljs-number">7</span>, '喜': <span class="hljs-number">8</span>, '欢': <span class="hljs-number">9</span>, '上': <span class="hljs-number">10</span>, '海': <span class="hljs-number">11</span>&#125;</code></pre><p>在这里共包括11个字，因此每个字可以转换为一个11维度稀疏向量：</p><pre><code class="hljs angelscript">我：[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]爱：[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]...海：[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</code></pre><h4 id="Bag-of-Words"><a href="#Bag-of-Words" class="headerlink" title="Bag of Words"></a>Bag of Words</h4><p>Bag of Words（词袋表示），也称为Count Vectors，每个文档的字/词可以使用其出现次数来进行表示。</p><pre><code class="hljs angelscript">句子<span class="hljs-number">1</span>：我 爱 北 京 天 安 门句子<span class="hljs-number">2</span>：我 喜 欢 上 海</code></pre><p>直接统计每个字出现的次数，并进行赋值：</p><pre><code class="hljs angelscript">句子<span class="hljs-number">1</span>：我 爱 北 京 天 安 门转换为 [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]句子<span class="hljs-number">2</span>：我 喜 欢 上 海转换为 [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]</code></pre><p>在sklearn中可以直接<code>CountVectorizer</code>来实现这一步骤：</p><pre><code class="hljs vbnet"><span class="hljs-keyword">from</span> sklearn.feature_extraction.<span class="hljs-keyword">text</span> import CountVectorizercorpus = [    <span class="hljs-comment">'This is the first document.',</span>    <span class="hljs-comment">'This document is the second document.',</span>    <span class="hljs-comment">'And this is the third one.',</span>    <span class="hljs-comment">'Is this the first document?',</span>]vectorizer = CountVectorizer()vectorizer.fit_transform(corpus).toarray()</code></pre><h4 id="N-gram"><a href="#N-gram" class="headerlink" title="N-gram"></a>N-gram</h4><p>N-gram与Count Vectors类似，不过加入了相邻单词组合成为新的单词，并进行计数。</p><p>如果N取值为2，则句子1和句子2就变为：</p><pre><code class="hljs angelscript">句子<span class="hljs-number">1</span>：我爱 爱北 北京 京天 天安 安门句子<span class="hljs-number">2</span>：我喜 喜欢 欢上 上海</code></pre><h4 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h4><p>TF-IDF 分数由两部分组成：第一部分是<strong>词语频率</strong>（Term Frequency），第二部分是<strong>逆文档频率</strong>（Inverse Document Frequency）。其中计算语料库中文档总数除以含有该词语的文档数量，然后再取对数就是逆文档频率。</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">TF</span><span class="hljs-params">(t)</span></span>= 该词语在当前文档出现的次数 / 当前文档中词语的总数<span class="hljs-function"><span class="hljs-title">IDF</span><span class="hljs-params">(t)</span></span>= log_e（文档总数 / 出现该词语的文档总数）</code></pre><h3 id="基于机器学习的文本分类-2"><a href="#基于机器学习的文本分类-2" class="headerlink" title="基于机器学习的文本分类"></a>基于机器学习的文本分类</h3><p>接下来我们将对比不同文本表示算法的精度，通过本地构建验证集计算F1得分。</p><h4 id="Count-Vectors-RidgeClassifier"><a href="#Count-Vectors-RidgeClassifier" class="headerlink" title="Count Vectors + RidgeClassifier"></a>Count Vectors + RidgeClassifier</h4><pre><code class="hljs reasonml">import pandas <span class="hljs-keyword">as</span> pdfrom sklearn.feature_extraction.text import CountVectorizerfrom sklearn.linear_model import RidgeClassifierfrom sklearn.metrics import f1_scoretrain_df = pd.read<span class="hljs-constructor">_csv('..<span class="hljs-operator">/</span><span class="hljs-params">input</span><span class="hljs-operator">/</span><span class="hljs-params">train_set</span>.<span class="hljs-params">csv</span>', <span class="hljs-params">sep</span>='\<span class="hljs-params">t</span>', <span class="hljs-params">nrows</span>=15000)</span>vectorizer = <span class="hljs-constructor">CountVectorizer(<span class="hljs-params">max_features</span>=3000)</span>train_test = vectorizer.fit<span class="hljs-constructor">_transform(<span class="hljs-params">train_df</span>['<span class="hljs-params">text</span>'])</span>clf = <span class="hljs-constructor">RidgeClassifier()</span>clf.fit(train_test<span class="hljs-literal">[:<span class="hljs-number">10000</span>]</span>, train_df<span class="hljs-literal">['<span class="hljs-identifier">label</span>']</span>.values<span class="hljs-literal">[:<span class="hljs-number">10000</span>]</span>)val_pred = clf.predict(train_test<span class="hljs-literal">[<span class="hljs-number">10000</span>:]</span>)print(f1<span class="hljs-constructor">_score(<span class="hljs-params">train_df</span>['<span class="hljs-params">label</span>'].<span class="hljs-params">values</span>[10000:], <span class="hljs-params">val_pred</span>, <span class="hljs-params">average</span>='<span class="hljs-params">macro</span>')</span>)# <span class="hljs-number">0.74</span></code></pre><h4 id="TF-IDF-RidgeClassifier"><a href="#TF-IDF-RidgeClassifier" class="headerlink" title="TF-IDF + RidgeClassifier"></a>TF-IDF + RidgeClassifier</h4><pre><code class="hljs reasonml">import pandas <span class="hljs-keyword">as</span> pdfrom sklearn.feature_extraction.text import TfidfVectorizerfrom sklearn.linear_model import RidgeClassifierfrom sklearn.metrics import f1_scoretrain_df = pd.read<span class="hljs-constructor">_csv('..<span class="hljs-operator">/</span><span class="hljs-params">input</span><span class="hljs-operator">/</span><span class="hljs-params">train_set</span>.<span class="hljs-params">csv</span>', <span class="hljs-params">sep</span>='\<span class="hljs-params">t</span>', <span class="hljs-params">nrows</span>=15000)</span>tfidf = <span class="hljs-constructor">TfidfVectorizer(<span class="hljs-params">ngram_range</span>=(1,3)</span>, max_features=<span class="hljs-number">3000</span>)train_test = tfidf.fit<span class="hljs-constructor">_transform(<span class="hljs-params">train_df</span>['<span class="hljs-params">text</span>'])</span>clf = <span class="hljs-constructor">RidgeClassifier()</span>clf.fit(train_test<span class="hljs-literal">[:<span class="hljs-number">10000</span>]</span>, train_df<span class="hljs-literal">['<span class="hljs-identifier">label</span>']</span>.values<span class="hljs-literal">[:<span class="hljs-number">10000</span>]</span>)val_pred = clf.predict(train_test<span class="hljs-literal">[<span class="hljs-number">10000</span>:]</span>)print(f1<span class="hljs-constructor">_score(<span class="hljs-params">train_df</span>['<span class="hljs-params">label</span>'].<span class="hljs-params">values</span>[10000:], <span class="hljs-params">val_pred</span>, <span class="hljs-params">average</span>='<span class="hljs-params">macro</span>')</span>)# <span class="hljs-number">0.87</span></code></pre><h2 id="基于深度学习的文本分类"><a href="#基于深度学习的文本分类" class="headerlink" title="基于深度学习的文本分类"></a>基于深度学习的文本分类</h2><p>与传统机器学习不同，深度学习既提供特征提取功能，也可以完成分类的功能。从本章开始我们将学习如何使用深度学习来完成文本表示。</p><h3 id="学习目标-2"><a href="#学习目标-2" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>学习FastText的使用和基础原理</li><li>学会使用验证集进行调参</li></ul><h3 id="文本表示方法-Part2"><a href="#文本表示方法-Part2" class="headerlink" title="文本表示方法 Part2"></a>文本表示方法 Part2</h3><h4 id="现有文本表示方法的缺陷"><a href="#现有文本表示方法的缺陷" class="headerlink" title="现有文本表示方法的缺陷"></a>现有文本表示方法的缺陷</h4><p>在上一章节，我们介绍几种文本表示方法：</p><ul><li>One-hot</li><li>Bag of Words</li><li>N-gram</li><li>TF-IDF</li></ul><p>也通过sklean进行了相应的实践，相信你也有了初步的认知。但上述方法都或多或少存在一定的问题：转换得到的向量维度很高，需要较长的训练实践；没有考虑单词与单词之间的关系，只是进行了统计。</p><p>与这些表示方法不同，深度学习也可以用于文本表示，还可以将其映射到一个低纬空间。其中比较典型的例子有：FastText、Word2Vec和Bert。在本章我们将介绍FastText，将在后面的内容介绍Word2Vec和Bert。</p><h4 id="FastText"><a href="#FastText" class="headerlink" title="FastText"></a>FastText</h4><p>FastText是一种典型的深度学习词向量的表示方法，它非常简单通过Embedding层将单词映射到稠密空间，然后将句子中所有的单词在Embedding空间中进行平均，进而完成分类操作。</p><p>所以FastText是一个三层的神经网络，输入层、隐含层和输出层。</p><p><a href="https://camo.githubusercontent.com/4e01004146c81db5ee15df1b373374b3ff145bfa/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343835363538392e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/4e01004146c81db5ee15df1b373374b3ff145bfa/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343835363538392e706e67" srcset="/img/loading.gif" alt="fast_text"></a></p><p>下图是使用keras实现的FastText网络结构：</p><p><a href="https://camo.githubusercontent.com/d4f33365b75bdddd0c80a857dc1a9e99789f1600/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343234393436332e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d4f33365b75bdddd0c80a857dc1a9e99789f1600/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343234393436332e6a7067" srcset="/img/loading.gif" alt="keras_fasttext"></a></p><p>FastText在文本分类任务上，是优于TF-IDF的：</p><ul><li>FastText用单词的Embedding叠加获得的文档向量，将相似的句子分为一类</li><li>FastText学习到的Embedding空间维度比较低，可以快速进行训练</li></ul><p>如果想深度学习，可以参考论文：</p><p>Bag of Tricks for Efficient Text Classification, <a href="https://arxiv.org/abs/1607.01759" target="_blank" rel="noopener">https://arxiv.org/abs/1607.01759</a></p><h3 id="基于FastText的文本分类"><a href="#基于FastText的文本分类" class="headerlink" title="基于FastText的文本分类"></a>基于FastText的文本分类</h3><p>FastText可以快速的在CPU上进行训练，最好的实践方法就是官方开源的版本： <a href="https://github.com/facebookresearch/fastText/tree/master/python" target="_blank" rel="noopener">https://github.com/facebookresearch/fastText/tree/master/python</a></p><ul><li>pip安装</li></ul><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> fasttext</code></pre><ul><li>源码安装</li></ul><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/facebookresearch/fastText.gitcd fastTextsudo pip install .</code></pre><p>两种安装方法都可以安装，如果你是初学者可以优先考虑使用pip安装。</p><ul><li>分类模型</li></ul><pre><code class="hljs routeros">import pandas as pd<span class="hljs-keyword">from</span> sklearn.metrics import f1_score<span class="hljs-comment"># 转换为FastText需要的格式</span>train_df = pd.read_csv(<span class="hljs-string">'../input/train_set.csv'</span>, <span class="hljs-attribute">sep</span>=<span class="hljs-string">'\t'</span>, <span class="hljs-attribute">nrows</span>=15000)train_df[<span class="hljs-string">'label_ft'</span>] = <span class="hljs-string">'__label__'</span> + train_df[<span class="hljs-string">'label'</span>].astype(str)train_df[[<span class="hljs-string">'text'</span>,<span class="hljs-string">'label_ft'</span>]].iloc[:-5000].to_csv(<span class="hljs-string">'train.csv'</span>, <span class="hljs-attribute">index</span>=None, <span class="hljs-attribute">header</span>=None, <span class="hljs-attribute">sep</span>=<span class="hljs-string">'\t'</span>)import fasttextmodel = fasttext.train_supervised(<span class="hljs-string">'train.csv'</span>, <span class="hljs-attribute">lr</span>=1.0, <span class="hljs-attribute">wordNgrams</span>=2,                                   <span class="hljs-attribute">verbose</span>=2, <span class="hljs-attribute">minCount</span>=1, <span class="hljs-attribute">epoch</span>=25, <span class="hljs-attribute">loss</span>=<span class="hljs-string">"hs"</span>)val_pred = [model.predict(x)[0][0].split(<span class="hljs-string">'__'</span>)[-1] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> train_df.iloc[-5000:][<span class="hljs-string">'text'</span>]]<span class="hljs-builtin-name">print</span>(f1_score(train_df[<span class="hljs-string">'label'</span>].values[-5000:].astype(str), val_pred, <span class="hljs-attribute">average</span>=<span class="hljs-string">'macro'</span>))<span class="hljs-comment"># 0.82</span></code></pre><p>此时数据量比较小得分为0.82，当不断增加训练集数量时，FastText的精度也会不断增加5w条训练样本时，验证集得分可以到0.89-0.90左右。</p><h3 id="如何使用验证集调参"><a href="#如何使用验证集调参" class="headerlink" title="如何使用验证集调参"></a>如何使用验证集调参</h3><p>在使用TF-IDF和FastText中，有一些模型的参数需要选择，这些参数会在一定程度上影响模型的精度，那么如何选择这些参数呢？</p><ul><li>通过阅读文档，要弄清楚这些参数的大致含义，那些参数会增加模型的复杂度</li><li>通过在验证集上进行验证模型精度，找到模型在是否过拟合还是欠拟合</li></ul><p><a href="https://camo.githubusercontent.com/3c19cda9d91954875be0b59abe99fad024552d29/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343430333834342e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/3c19cda9d91954875be0b59abe99fad024552d29/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343430333834342e706e67" srcset="/img/loading.gif" alt="train_val"></a></p><p>这里我们使用10折交叉验证，每折使用9/10的数据进行训练，剩余1/10作为验证集检验模型的效果。这里需要注意每折的划分必须保证标签的分布与整个数据集的分布一致。</p><pre><code class="hljs dockerfile">label2id = &#123;&#125;for i in range(total):    <span class="hljs-keyword">label</span><span class="bash"> = str(all_labels[i])</span>    if <span class="hljs-keyword">label</span><span class="bash"> not <span class="hljs-keyword">in</span> label2id:</span>        label2id[<span class="hljs-keyword">label</span><span class="bash">] = [i]</span>    else:        label2id[<span class="hljs-keyword">label</span><span class="bash">].append(i)</span></code></pre><p>通过10折划分，我们一共得到了10份分布一致的数据，索引分别为0到9，每次通过将一份数据作为验证集，剩余数据作为训练集，获得了所有数据的10种分割。不失一般性，我们选择最后一份完成剩余的实验，即索引为9的一份做为验证集，索引为1-8的作为训练集，然后基于验证集的结果调整超参数，使得模型性能更优。</p><h3 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章介绍了FastText的原理和基础使用，并进行相应的实践。然后介绍了通过10折交叉验证划分数据集。</p><h3 id="本章作业-1"><a href="#本章作业-1" class="headerlink" title="本章作业"></a>本章作业</h3><ul><li>阅读FastText的文档，尝试修改参数，得到更好的分数</li><li>基于验证集的结果调整超参数，使得模型性能更优</li></ul><h2 id="基于深度学习的文本分类-1"><a href="#基于深度学习的文本分类-1" class="headerlink" title="基于深度学习的文本分类"></a>基于深度学习的文本分类</h2><h3 id="学习目标-3"><a href="#学习目标-3" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>了解Transformer的原理和基于预训练语言模型（Bert）的词表示</li><li>学会Bert的使用，具体包括pretrain和finetune</li></ul><h3 id="文本表示方法Part4"><a href="#文本表示方法Part4" class="headerlink" title="文本表示方法Part4"></a>文本表示方法Part4</h3><h4 id="Transformer原理"><a href="#Transformer原理" class="headerlink" title="Transformer原理"></a>Transformer原理</h4><p>Transformer是在”<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Attention is All You Need</a>“中提出的，模型的编码部分是一组编码器的堆叠（论文中依次堆叠六个编码器），模型的解码部分是由相同数量的解码器的堆叠。</p><p><a href="https://camo.githubusercontent.com/1da32c07cd7d544113673ba47624f0a47af51ba6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313034363636382e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1da32c07cd7d544113673ba47624f0a47af51ba6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313034363636382e706e67" srcset="/img/loading.gif" alt="img"></a></p><p>我们重点关注编码部分。他们结构完全相同，但是并不共享参数，每一个编码器都可以拆解成两部分。在对输入序列做词的向量化之后，它们首先流过一个self-attention层，该层帮助编码器在它编码单词的时候能够看到输入序列中的其他单词。self-attention的输出流向一个前向网络（Feed Forward Neural Network），每个输入位置对应的前向网络是独立互不干扰的。最后将输出传入下一个编码器。</p><p><a href="https://camo.githubusercontent.com/70959c74cbf7ac3c3dae3fd0eceddf180715cb39/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313131353934352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/70959c74cbf7ac3c3dae3fd0eceddf180715cb39/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313131353934352e706e67" srcset="/img/loading.gif" alt="img"></a></p><p>这里能看到Transformer的一个关键特性，每个位置的词仅仅流过它自己的编码器路径。在self-attention层中，这些路径两两之间是相互依赖的。<strong>前向网络层则没有这些依赖性</strong>，但这些路径在流经前向网络时可以并行执行。</p><p>Self-Attention中使用多头机制，使得不同的attention heads所关注的的部分不同。</p><p><a href="https://camo.githubusercontent.com/1173d083304d3e60a81342717cd52d3f1a5124e1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313135333638372e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1173d083304d3e60a81342717cd52d3f1a5124e1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313135333638372e706e67" srcset="/img/loading.gif" alt="img"></a></p><p>编码”it”时，一个attention head集中于”the animal”，另一个head集中于“tired”，某种意义上讲，模型对“it”的表达合成了的“animal”和“tired”两者。</p><p>对于自注意力的详细计算，欢迎大家参考<a href="https://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">Jay Alammar</a>关于Transformer的博客，这里不再展开。</p><p>除此之外，为了使模型保持单词的语序，模型中添加了位置编码向量。如下图所示，每行对应一个向量的位置编码。因此，第一行将是我们要添加到输入序列中第一个单词的嵌入的向量。每行包含512个值—每个值都在1到-1之间。因为左侧是用sine函数生成，右侧是用cosine生成，所以可以观察到中间显著的分隔。</p><p><a href="https://camo.githubusercontent.com/1598ac84eeeca72eb271d7bc4696d36f564bc759/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313233323731362e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1598ac84eeeca72eb271d7bc4696d36f564bc759/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313233323731362e706e67" srcset="/img/loading.gif" alt="img"></a></p><p>编码器结构中值得提出注意的一个细节是，在每个子层中（Self-attention, FFNN），都有残差连接，并且紧跟着<a href="https://arxiv.org/abs/1607.06450" target="_blank" rel="noopener">layer-normalization</a>。如果我们可视化向量和LayerNorm操作，将如下所示：</p><p><a href="https://camo.githubusercontent.com/09ac8f9634bff9681b191c398e4b943d34f972c3/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313935353731332e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/09ac8f9634bff9681b191c398e4b943d34f972c3/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313935353731332e706e67" srcset="/img/loading.gif" alt="img"></a></p><h4 id="基于预训练语言模型的词表示"><a href="#基于预训练语言模型的词表示" class="headerlink" title="基于预训练语言模型的词表示"></a>基于预训练语言模型的词表示</h4><p>基于预训练语言模型的词表示由于可以建模上下文信息，进而解决传统静态词向量不能建模“一词多义”语言现象的问题。最早提出的ELMo基于两个单向LSTM，将从左到右和从右到左两个方向的隐藏层向量表示拼接学习上下文词嵌入。而GPT用Transformer代替LSTM作为编码器，首先进行了语言模型预训练，然后在下游任务微调模型参数。但GPT由于仅使用了单向语言模型，因此难以建模上下文信息。为了解决以上问题，研究者们提出了BERT，BERT模型结构如下图所示，它是一个基于Transformer的多层Encoder，通过执行一系列预训练，进而得到深层的上下文表示。</p><p><a href="https://camo.githubusercontent.com/f5297c1c8c1e71180cb62aca463503d21122e911/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313331363136372e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/f5297c1c8c1e71180cb62aca463503d21122e911/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313331363136372e706e67" srcset="/img/loading.gif" alt="bert_elmo"></a></p><p>ELMo论文题目中Deep是指双向双层LSTM，而更关键的在于context。传统方法生成的单词映射表的形式，即先为每个单词生成一个静态的词向量，之后这个单词的表示就被固定住了，不会跟着上下文的变化而做出改变。事实上，由于一词多义的语言现象，静态词向量是有很大的弊端的。以bank为例，如果训练语料的足够大，事先学好的词向量中混杂着所有的语义。而当下游应用时，即使在新句子中，bank的上下文里包含money等词，我们基本可以确定bank是“银行”的语义而不是在其他上下文中的“河床”的语义，但是由于静态词向量不能跟随上下文而进行变化，所以bank的表示中还是混杂着多种语义。为了解决这一问题，ELMo首先进行了语言模型预训练，然后在下游任务中动态调整Word Embedding，因此最后输出的词表示能够充分表达单词在上下文中的特定语义，进而解决一词多义的问题。</p><p>GPT来自于openai，是一种生成式预训练模型。GPT 除了将ELMo中的LSTM替换为Transformer 的Encoder外，更开创了NLP界基于预训练-微调的新范式。尽管GPT采用的也是和ELMo相同的两阶段模式，但GPT在第一个阶段并没有采取ELMo中使用两个单向双层LSTM拼接的结构，而是采用基于自回归式的单向语言模型。</p><p>Google在NAACL 2018发表的论文中提出了BERT，与GPT相同，BERT也采用了预训练-微调这一两阶段模式。但在模型结构方面，BERT采用了ELMO的范式，即使用双向语言模型代替GPT中的单向语言模型，但是BERT的作者认为ELMo使用两个单向语言模型拼接的方式太粗暴，因此在第一阶段的预训练过程中，BERT提出掩码语言模型，即类似完形填空的方式，通过上下文来预测单词本身，而不是从右到左或从左到右建模，这允许模型能够自由地编码每个层中来自两个方向的信息。而为了学习句子的词序关系，BERT将Transformer中的三角函数位置表示替换为可学习的参数，其次为了区别单句和双句输入，BERT还引入了句子类型表征。BERT的输入如图所示。此外，为了充分学习句子间的关系，BERT提出了下一个句子预测任务。具体来说，在训练时，句子对中的第二个句子有50％来自与原有的连续句子，而其余50%的句子则是通过在其他句子中随机采样。同时，消融实验也证明，这一预训练任务对句间关系判断任务具有很大的贡献。除了模型结构不同之外，BERT在预训练时使用的无标签数据规模要比GPT大的多。</p><p><a href="https://camo.githubusercontent.com/1fa48883f724ed604556d3bb9d241511012d1972/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313334383435362e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1fa48883f724ed604556d3bb9d241511012d1972/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313334383435362e706e67" srcset="/img/loading.gif" alt="bert_input"></a></p><p>在第二阶段，与GPT相同，BERT也使用Fine-Tuning模式来微调下游任务。如下图所示，BERT与GPT不同，它极大的减少了改造下游任务的要求，只需在BERT模型的基础上，通过额外添加Linear分类器，就可以完成下游任务。具体来说，对于句间关系判断任务，与GPT类似，只需在句子之间加个分隔符，然后在两端分别加上起始和终止符号。在进行输出时，只需把句子的起始符号[CLS]在BERT最后一层中对应的位置接一个Softmax+Linear分类层即可；对于单句分类问题，也与GPT类似，只需要在句子两段分别增加起始和终止符号，输出部分和句间关系判断任务保持一致即可；对于问答任务，由于需要输出答案在给定段落的起始和终止位置，因此需要先将问题和段落按照句间关系判断任务构造输入，输出只需要在BERT最后一层中第二个句子，即段落的每个单词对应的位置上分别接判断起始和终止位置的分类器；最后，对于NLP中的序列标注问题，输入与单句分类任务一致，不同的是在BERT最后一层中每个单词对应的位置上接分类器即可。</p><p><a href="https://camo.githubusercontent.com/265b6f273c9731886f63f66b7beb2805226cee73/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313430393538322e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/265b6f273c9731886f63f66b7beb2805226cee73/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313430393538322e706e67" srcset="/img/loading.gif" alt="bert_task"></a></p><p>更重要的是，BERT开启了NLP领域“预训练-微调”这种两阶段的全新范式。在第一阶段首先在海量无标注文本上预训练一个双向语言模型，这里特别值得注意的是，将Transformer作为特征提取器在解决并行性和长距离依赖问题上都要领先于传统的RNN或者CNN，通过预训练的方式，可以将训练数据中的词法、句法、语法知识以网络参数的形式提炼到模型当中，在第二阶段使用下游任务的数据Fine-tuning不同层数的BERT模型参数，或者把BERT当作特征提取器生成BERT Embedding，作为新特征引入下游任务。这种两阶段的全新范式尽管是来自于计算机视觉领域，但是在自然语言处理领域一直没有得到很好的运用，而BERT作为近些年NLP突破性进展的集大成者，最大的亮点可以说不仅在于模型性能好，并且几乎所有NLP任务都可以很方便地基于BERT进行改造，进而将预训练学到的语言学知识引入下游任务，进一步提升模型的性能。</p><h3 id="基于Bert的文本分类"><a href="#基于Bert的文本分类" class="headerlink" title="基于Bert的文本分类"></a>基于Bert的文本分类</h3><h4 id="Bert-Pretrain"><a href="#Bert-Pretrain" class="headerlink" title="Bert Pretrain"></a>Bert Pretrain</h4><p>预训练过程使用了Google基于Tensorflow发布的BERT源代码。首先从原始文本中创建训练数据，由于本次比赛的数据都是ID，这里重新建立了词表，并且建立了基于空格的分词器。</p><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WhitespaceTokenizer</span>(<span class="hljs-title">object</span>):</span>    <span class="hljs-string">""</span><span class="hljs-string">"WhitespaceTokenizer with vocab."</span><span class="hljs-string">""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, vocab_file)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">self</span>.vocab = load_vocab(vocab_file)        <span class="hljs-keyword">self</span>.inv_vocab = &#123;<span class="hljs-symbol">v:</span> k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.vocab.items()&#125;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tokenize</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, text)</span></span><span class="hljs-symbol">:</span>        split_tokens = whitespace_tokenize(text)        output_tokens = []        <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> <span class="hljs-symbol">split_tokens:</span>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">vocab:</span>                output_tokens.append(token)            <span class="hljs-symbol">else:</span>                output_tokens.append(<span class="hljs-string">"[UNK]"</span>)        <span class="hljs-keyword">return</span> output_tokens    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert_tokens_to_ids</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, tokens)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">return</span> convert_by_vocab(<span class="hljs-keyword">self</span>.vocab, tokens)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert_ids_to_tokens</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, ids)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">return</span> convert_by_vocab(<span class="hljs-keyword">self</span>.inv_vocab, ids)</code></pre><p>预训练由于去除了NSP预训练任务，因此将文档处理多个最大长度为256的段，如果最后一个段的长度小于256/2则丢弃。每一个段执行按照BERT原文中执行掩码语言模型，然后处理成tfrecord格式。</p><pre><code class="hljs vim">def create_segments_from_document(document, max_segment_length):    <span class="hljs-string">""</span><span class="hljs-string">"Split single document to segments according to max_segment_length."</span><span class="hljs-string">""</span>    assert <span class="hljs-built_in">len</span>(document) == <span class="hljs-number">1</span>    document = document[<span class="hljs-number">0</span>]    document_len = <span class="hljs-built_in">len</span>(document)    <span class="hljs-built_in">index</span> = <span class="hljs-keyword">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, document_len, max_segment_length))    other_len = document_len % max_segment_length    <span class="hljs-keyword">if</span> other_len &gt; max_segment_length / <span class="hljs-number">2</span>:        <span class="hljs-built_in">index</span>.<span class="hljs-keyword">append</span>(document_len)    segments = []    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">index</span>) - <span class="hljs-number">1</span>):        segment = document[<span class="hljs-built_in">index</span>[i]: <span class="hljs-built_in">index</span>[i+<span class="hljs-number">1</span>]]        segments.<span class="hljs-keyword">append</span>(segment)    <span class="hljs-keyword">return</span> segments</code></pre><p>在预训练过程中，也只执行掩码语言模型任务，因此不再计算下一句预测任务的loss。</p><pre><code class="hljs lisp">(<span class="hljs-name">masked_lm_loss</span>, masked_lm_example_loss, masked_lm_log_probs) = get_masked_lm_output(    bert_config, model.get_sequence_output(), model.get_embedding_table(),    masked_lm_positions, masked_lm_ids, masked_lm_weights)total_loss = masked_lm_loss</code></pre><p>为了适配句子的长度，以及减小模型的训练时间，我们采取了BERT-mini模型，详细配置如下。</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"hidden_size"</span>: <span class="hljs-number">256</span>,  <span class="hljs-attr">"hidden_act"</span>: <span class="hljs-string">"gelu"</span>,  <span class="hljs-attr">"initializer_range"</span>: <span class="hljs-number">0.02</span>,  <span class="hljs-attr">"vocab_size"</span>: <span class="hljs-number">5981</span>,  <span class="hljs-attr">"hidden_dropout_prob"</span>: <span class="hljs-number">0.1</span>,  <span class="hljs-attr">"num_attention_heads"</span>: <span class="hljs-number">4</span>,  <span class="hljs-attr">"type_vocab_size"</span>: <span class="hljs-number">2</span>,  <span class="hljs-attr">"max_position_embeddings"</span>: <span class="hljs-number">256</span>,  <span class="hljs-attr">"num_hidden_layers"</span>: <span class="hljs-number">4</span>,  <span class="hljs-attr">"intermediate_size"</span>: <span class="hljs-number">1024</span>,  <span class="hljs-attr">"attention_probs_dropout_prob"</span>: <span class="hljs-number">0.1</span>&#125;</code></pre><p>由于我们的整体框架使用Pytorch，因此需要将最后一个检查点转换成Pytorch的权重。</p><pre><code class="hljs reasonml">def convert<span class="hljs-constructor">_tf_checkpoint_to_pytorch(<span class="hljs-params">tf_checkpoint_path</span>, <span class="hljs-params">bert_config_file</span>, <span class="hljs-params">pytorch_dump_path</span>)</span>:    # Initialise PyTorch model    config = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BertConfig</span>.</span></span>from<span class="hljs-constructor">_json_file(<span class="hljs-params">bert_config_file</span>)</span>    print(<span class="hljs-string">"Building PyTorch model from configuration: &#123;&#125;"</span>.format(str(config)))    model = <span class="hljs-constructor">BertForPreTraining(<span class="hljs-params">config</span>)</span>    # Load weights from tf checkpoint    load<span class="hljs-constructor">_tf_weights_in_bert(<span class="hljs-params">model</span>, <span class="hljs-params">config</span>, <span class="hljs-params">tf_checkpoint_path</span>)</span>    # Save pytorch-model    print(<span class="hljs-string">"Save PyTorch model to &#123;&#125;"</span>.format(pytorch_dump_path))    torch.save(model.state<span class="hljs-constructor">_dict()</span>, pytorch_dump_path)</code></pre><p>预训练消耗的资源较大，硬件条件不允许的情况下建议<strong>直接下载开源的模型</strong></p><h4 id="Bert-Finetune"><a href="#Bert-Finetune" class="headerlink" title="Bert Finetune"></a>Bert Finetune</h4><p><a href="https://camo.githubusercontent.com/6ee5331933f1637d5835522efb64f4951f6213ec/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313532363332362e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/6ee5331933f1637d5835522efb64f4951f6213ec/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313532363332362e706e67" srcset="/img/loading.gif" alt="experimental) Dynamic Quantization on BERT — PyTorch Tutorials 1.5 ..."></a></p><p>微调将最后一层的第一个token即[CLS]的隐藏向量作为句子的表示，然后输入到softmax层进行分类。</p><pre><code class="hljs nix">sequence_output, <span class="hljs-attr">pooled_output</span> = \    self.bert(<span class="hljs-attr">input_ids=input_ids,</span> <span class="hljs-attr">token_type_ids=token_type_ids)</span><span class="hljs-keyword">if</span> self.pooled:    <span class="hljs-attr">reps</span> = pooled_output<span class="hljs-keyword">else</span>:    <span class="hljs-attr">reps</span> = sequence_output[:, <span class="hljs-number">0</span>, :]  <span class="hljs-comment"># sen_num x 256</span><span class="hljs-keyword">if</span> self.training:    <span class="hljs-attr">reps</span> = self.dropout(reps)</code></pre><h3 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章介绍了Bert的原理和使用，具体包括pretrain和finetune两部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;赛题理解&quot;&gt;&lt;a href=&quot;#赛题理解&quot; class=&quot;headerlink&quot; title=&quot;赛题理解&quot;&gt;&lt;/a&gt;赛题理解&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;赛题名称：零基础入门NLP之新闻文本分类&lt;/li&gt;
&lt;li&gt;赛题任务：赛题以自然语言处理为背景，要求选手对新闻文
      
    
    </summary>
    
    
      <category term="自然语言处理" scheme="https://sulimin-nb.github.io/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="自然语言处理" scheme="https://sulimin-nb.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读2</title>
    <link href="https://sulimin-nb.github.io/article/1d82fc97.html"/>
    <id>https://sulimin-nb.github.io/article/1d82fc97.html</id>
    <published>2020-07-19T09:49:00.000Z</published>
    <updated>2020-07-20T16:12:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Prototypical-Networks-for-Few-shot-Learning"><a href="#1-Prototypical-Networks-for-Few-shot-Learning" class="headerlink" title="1.Prototypical Networks for Few-shot Learning"></a>1.Prototypical Networks for Few-shot Learning</h1><p><img src="/article/1d82fc97/image-20200719181649169.png" srcset="/img/loading.gif" alt="image-20200719181649169"></p><p><img src="/article/1d82fc97/image-20200719181614391.png" srcset="/img/loading.gif" alt="image-20200719181614391"></p><h1 id="2-Transferrable-Prototypical-Networks-for-Unsupervised-Domain-Adaptation"><a href="#2-Transferrable-Prototypical-Networks-for-Unsupervised-Domain-Adaptation" class="headerlink" title="2.Transferrable Prototypical Networks for Unsupervised Domain Adaptation"></a>2.Transferrable Prototypical Networks for Unsupervised Domain Adaptation</h1><p><img src="/article/1d82fc97/tempsnip.png" srcset="/img/loading.gif" alt="tempsnip"></p><p><strong>motivation:</strong></p><p><img src="/article/1d82fc97/image-20200720103101415.png" srcset="/img/loading.gif" alt="image-20200720103101415"></p><p><strong>design:</strong></p><p><img src="/article/1d82fc97/image-20200720103210812.png" srcset="/img/loading.gif" alt="image-20200720103210812"></p><p><img src="/article/1d82fc97/image-20200720103352834.png" srcset="/img/loading.gif" alt="image-20200720103352834"></p><p><img src="/article/1d82fc97/image-20200720103521702.png" srcset="/img/loading.gif" alt="image-20200720103521702"></p><p>相较于域级别而言，类级别的MMD更加地细粒度(fine-grained更细致)。</p><p><img src="/article/1d82fc97/image-20200720104021744.png" srcset="/img/loading.gif" alt="image-20200720104021744"></p><p><strong>motivation:</strong></p><p><img src="/article/1d82fc97/image-20200720104121465.png" srcset="/img/loading.gif" alt="image-20200720104121465"></p><p><strong>design:</strong></p><p><img src="/article/1d82fc97/image-20200720104403499.png" srcset="/img/loading.gif" alt="image-20200720104403499"></p><p><img src="/article/1d82fc97/image-20200720104647122.png" srcset="/img/loading.gif" alt="image-20200720104647122"></p><p>不同于单独匹配不同域之间的每个类的prototype，task-specific adaptation同时匹配所有类的prototypes。力求每个样本的类分布的score distributions相似.</p><p><img src="/article/1d82fc97/image-20200720105117126.png" srcset="/img/loading.gif" alt="image-20200720105117126"></p><p><strong>Optimization:</strong><br>源域上的监督学习</p><p><img src="/article/1d82fc97/image-20200720105431189.png" srcset="/img/loading.gif" alt="image-20200720105431189"></p><p><img src="/article/1d82fc97/image-20200720105531478.png" srcset="/img/loading.gif" alt="image-20200720105531478"></p><p><strong>Training Procedure:</strong></p><p><img src="/article/1d82fc97/image-20200720105706495.png" srcset="/img/loading.gif" alt="image-20200720105706495"></p><p><strong>推理阶段(测试阶段)：</strong></p><p><img src="/article/1d82fc97/image-20200720110755325.png" srcset="/img/loading.gif" alt="image-20200720110755325"></p><h1 id="3-Distant-Supervised-Centroid-Shift-A-Sample-and-Efficient-Approach-to-Visual-Domain-Adaptation"><a href="#3-Distant-Supervised-Centroid-Shift-A-Sample-and-Efficient-Approach-to-Visual-Domain-Adaptation" class="headerlink" title="3.Distant Supervised Centroid Shift: A Sample and Efficient Approach to Visual Domain Adaptation"></a>3.Distant Supervised Centroid Shift: A Sample and Efficient Approach to Visual Domain Adaptation</h1><p><strong>问题定义：</strong></p><p><img src="/article/1d82fc97/image-20200720140545581.png" srcset="/img/loading.gif" alt="image-20200720140545581"></p><p><strong>Method：</strong></p><p><img src="/article/1d82fc97/image-20200720141255925.png" srcset="/img/loading.gif" alt="image-20200720141255925"></p><p><strong>(1) 类内散度最小化(Source Domain)：</strong></p><p><img src="/article/1d82fc97/image-20200720141722664.png" srcset="/img/loading.gif" alt="image-20200720141722664"></p><p><img src="/article/1d82fc97/image-20200720142301426.png" srcset="/img/loading.gif" alt="image-20200720142301426"></p><p><strong>类内散度最小化(Target Domain)：</strong></p><p><img src="/article/1d82fc97/image-20200720142652395.png" srcset="/img/loading.gif" alt="image-20200720142652395"></p><p>目标域不存在标签，采用最近邻中心的分类器，同时force Target类中心和对应的Source类中心靠近。<br>就是把Source类中心加上一个偏移量视为Target类中心，同时最小化此偏移量。<br><strong>总体目标如下：</strong></p><p><img src="/article/1d82fc97/image-20200720143112960.png" srcset="/img/loading.gif" alt="image-20200720143112960"></p><p><img src="/article/1d82fc97/image-20200720145649943.png" srcset="/img/loading.gif" alt="image-20200720145649943"></p><p><strong>relaxed trace-ratio objective：</strong></p><p><img src="/article/1d82fc97/image-20200720150033777.png" srcset="/img/loading.gif" alt="image-20200720150033777"></p><p><img src="/article/1d82fc97/image-20200720171415765.png" srcset="/img/loading.gif" alt="image-20200720171415765"></p><p><strong>Optimization(具体流程)：</strong><br>利用GEVD求解：</p><p><img src="/article/1d82fc97/image-20200720173504331.png" srcset="/img/loading.gif" alt="image-20200720173504331"></p><p><span style="color:red">这里需要再看看</span></p><p><img src="/article/1d82fc97/tempsnip2.png" srcset="/img/loading.gif" alt="tempsnip2"></p><p><img src="/article/1d82fc97/image-20200720180603912.png" srcset="/img/loading.gif" alt="image-20200720180603912"></p><p><img src="/article/1d82fc97/image-20200720180940704.png" srcset="/img/loading.gif" alt="image-20200720180940704"></p><p><img src="/article/1d82fc97/image-20200720181003000.png" srcset="/img/loading.gif" alt="image-20200720181003000"></p><h1 id="4-Adaptive-Cross-Modal-Few-shot-Learning"><a href="#4-Adaptive-Cross-Modal-Few-shot-Learning" class="headerlink" title="4. Adaptive Cross-Modal Few-shot Learning"></a>4. Adaptive Cross-Modal Few-shot Learning</h1><p><strong>背景知识：</strong></p><p><img src="/article/1d82fc97/image-20200720235811934.png" srcset="/img/loading.gif" alt="image-20200720235811934"></p><p><a href="# 1.Prototypical Networks for Few-shot Learning">第一篇</a>写了，这里就不赘述了。</p><p><img src="/article/1d82fc97/image-20200720235846044.png" srcset="/img/loading.gif" alt="image-20200720235846044"></p><p><strong>motivation:</strong></p><p><img src="/article/1d82fc97/tempsnip3.png" srcset="/img/loading.gif" alt="tempsnip3"></p><p><img src="/article/1d82fc97/image-20200720235727709.png" srcset="/img/loading.gif" alt="image-20200720235727709"></p><p><strong>方法Formulation：</strong></p><p><img src="/article/1d82fc97/image-20200721001159311.png" srcset="/img/loading.gif" alt="image-20200721001159311"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Prototypical-Networks-for-Few-shot-Learning&quot;&gt;&lt;a href=&quot;#1-Prototypical-Networks-for-Few-shot-Learning&quot; class=&quot;headerlink&quot; title=&quot;1.
      
    
    </summary>
    
    
      <category term="linc实验室" scheme="https://sulimin-nb.github.io/categories/linc%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="论文阅读" scheme="https://sulimin-nb.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>leetcode200-岛屿数量</title>
    <link href="https://sulimin-nb.github.io/article/708439c3.html"/>
    <id>https://sulimin-nb.github.io/article/708439c3.html</id>
    <published>2020-07-19T07:21:17.000Z</published>
    <updated>2020-07-19T15:37:48.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/categories/leetcode/"/>
    
      <category term="深度优先搜索，广度优先搜索" scheme="https://sulimin-nb.github.io/categories/leetcode/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
