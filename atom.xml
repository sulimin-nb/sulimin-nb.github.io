<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>苏</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://sulimin-nb.github.io/"/>
  <updated>2020-08-24T03:08:16.218Z</updated>
  <id>https://sulimin-nb.github.io/</id>
  
  <author>
    <name>sulimin</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法-动态规划</title>
    <link href="https://sulimin-nb.github.io/article/e57c001c.html"/>
    <id>https://sulimin-nb.github.io/article/e57c001c.html</id>
    <published>2020-08-24T03:08:16.000Z</published>
    <updated>2020-08-24T03:08:16.218Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>动手学数据分析-2</title>
    <link href="https://sulimin-nb.github.io/article/dc948b2c.html"/>
    <id>https://sulimin-nb.github.io/article/dc948b2c.html</id>
    <published>2020-08-21T16:12:07.000Z</published>
    <updated>2020-08-21T16:12:16.653Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>动手学数据分析-1</title>
    <link href="https://sulimin-nb.github.io/article/459dda96.html"/>
    <id>https://sulimin-nb.github.io/article/459dda96.html</id>
    <published>2020-08-19T15:19:39.000Z</published>
    <updated>2020-08-19T16:09:46.930Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-数据载入及观察"><a href="#1-数据载入及观察" class="headerlink" title="1. 数据载入及观察"></a>1. 数据载入及观察</h2><p>在数据处理中，第一步通常都需要导入数据，并进行对数据的初步预览</p><ol><li><strong>导入库</strong> 导入所需数据库:import numpy as np; import pandas as pd</li><li><strong>载入数据</strong> pd.read_csv(‘filename’), csv为文件格式，可替换为其他格式：tsv;xlsx</li><li><strong>逐块读取</strong> 有时数据库过大，为了节约内存需要分批次读取：pd.read_csv(‘filename’, chunksize=int)</li><li><strong>修改column索引名称</strong> pd.read_csv(‘names=[‘a’,‘b’,…],index_col=‘乘客ID’,header=0)</li><li><strong>初步观察</strong> 前(n+1)个数据：head(n),后（n+1)个数据tail(n), 判断数据是否为空isnull()</li><li><strong>保存数据</strong> to_csv(‘filename’)</li></ol><h2 id="2-pandas基础"><a href="#2-pandas基础" class="headerlink" title="2. pandas基础"></a>2. pandas基础</h2><ol><li><strong>数据类型</strong> pandas中有两个数据类型DataFrame, Series; Series比较适合一个属性对应一个数据， DataFrame则适用于一个实例具有多种属性，很符合数据挖掘所需要的数据模式</li><li><strong>查看DataFrame数据的每列的项</strong> 根据数据的列索引可以很容易实现 data[‘Column_name’]</li><li><strong>将多余的列的删除</strong> del data[‘Column_name’]</li><li><strong>将某些列暂时隐藏</strong> data.drop([‘Columb_name’],axis=1)<br>若想完全删除 data.drop([‘Columb_name’]，axis=1, inplace = True)</li><li><strong>显示满足某条件的数据</strong><br>criteria = data[‘Column_name’]&gt; x<br>此时criteria所含元素数据类型皆为bool<br>显示满足条件的数据(bool=True): Desired = data[criteria]</li></ol><p>但此时index为old index, 若想得到此数据集某一行的值，需要重新设置index: Desird.reset_index(drop=True); drop=True将old index隐藏<br>\6. <strong>显示数据集中某行某列的值</strong> data.loc[[index_x,index_y, index_z…],[’Column_x‘,‘Columb_name_y’…]]</p><p>也可以都用索引值 函数：iloc<br>midage.iloc[[100,105,108],[2,3,4]]</p><h2 id="3-探索性数据分析"><a href="#3-探索性数据分析" class="headerlink" title="3. 探索性数据分析"></a>3. 探索性数据分析</h2><ol><li><strong>对数据值进行排序</strong> 一组数据DataFrame.sort_<strong>values</strong>(by=‘column_name’, ascending=False)<br>默认 ascending = True 升序， False 降序<br>两组数据排序(先对第一个排序)<br>DataFrame.sort_<strong>values</strong>(by=[‘column_name1’,‘column_name2’], ascending=False)</li><li><strong>索引排序</strong> 行索引升序排序：DataFrame.sort_<strong>index</strong>()<br>列索引升序排序 DataFrame.sort_<strong>index</strong>(axis = 1)</li><li><strong>算术计算</strong>两个DataFrame运算后，会返回一个新的DataFrame，对应的行和列的值会相加，没有对应的会变成空值NaN</li><li><strong>查看DataFrame数据信息</strong><br>函数：DataFrame.describe()<br>输出:<br>count : 样本数据大小<br>mean : 样本数据的平均值<br>std : 样本数据的标准差<br>min : 样本数据的最小值<br>25% : 样本数据25%的时候的值<br>50% : 样本数据50%的时候的值<br>75% : 样本数据75%的时候的值<br>max : 样本数据的最大值</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-数据载入及观察&quot;&gt;&lt;a href=&quot;#1-数据载入及观察&quot; class=&quot;headerlink&quot; title=&quot;1. 数据载入及观察&quot;&gt;&lt;/a&gt;1. 数据载入及观察&lt;/h2&gt;&lt;p&gt;在数据处理中，第一步通常都需要导入数据，并进行对数据的初步预览&lt;/p&gt;
&lt;ol&gt;
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>算法-分治</title>
    <link href="https://sulimin-nb.github.io/article/1768cd4c.html"/>
    <id>https://sulimin-nb.github.io/article/1768cd4c.html</id>
    <published>2020-08-19T10:32:09.000Z</published>
    <updated>2020-08-19T11:07:52.304Z</updated>
    
    <content type="html"><![CDATA[<h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>分治算法的主要思想是将原问题<strong>递归地分成</strong>若干个子问题，直到子问题<strong>满足边界条件</strong>，停止递归。将子问题逐个击破(一般是同种方法)，将已经解决的子问题合并，最后，算法会<strong>层层合并</strong>得到原问题的答案。</p><h3 id="分治算法的步骤"><a href="#分治算法的步骤" class="headerlink" title="分治算法的步骤"></a>分治算法的步骤</h3><ul><li>分：<strong>递归地</strong>将问题<strong>分解</strong>为各个的子<strong>问题</strong>(性质相同的、相互独立的子问题)；</li><li>治：将这些规模更小的子问题<strong>逐个击破</strong>；</li><li>合：将已解决的子问题<strong>逐层合并</strong>，最终得出原问题的解；</li></ul><p><img src="https://img-blog.csdnimg.cn/20200408204450701.png" srcset="/img/loading.gif" alt></p><h3 id="分治法适用的情况"><a href="#分治法适用的情况" class="headerlink" title="分治法适用的情况"></a>分治法适用的情况</h3><ul><li>原问题的<strong>计算复杂度</strong>随着问题的规模的增加而增加。</li><li>原问题<strong>能够被分解</strong>成更小的子问题。</li><li>子问题的<strong>结构和性质</strong>与原问题一样，并且<strong>相互独立</strong>，子问题之间<strong>不包含</strong>公共的子子问题。</li><li>原问题分解出的子问题的解<strong>可以合并</strong>为该问题的解。</li></ul><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">divide_conquer</span><span class="hljs-params">(problem, paraml, param2,...)</span>:</span>    <span class="hljs-comment"># 不断切分的终止条件</span>    <span class="hljs-keyword">if</span> problem <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        print_result        <span class="hljs-keyword">return</span>    <span class="hljs-comment"># 准备数据</span>    data=prepare_data(problem)    <span class="hljs-comment"># 将大问题拆分为小问题</span>    subproblems=split_problem(problem, data)    <span class="hljs-comment"># 处理小问题，得到子结果</span>    subresult1=self.divide_conquer(subproblems[<span class="hljs-number">0</span>],p1,..…)    subresult2=self.divide_conquer(subproblems[<span class="hljs-number">1</span>],p1,...)    subresult3=self.divide_conquer(subproblems[<span class="hljs-number">2</span>],p1,.…)    <span class="hljs-comment"># 对子结果进行合并 得到最终结果</span>    result=process_result(subresult1, subresult2, subresult3,...)</code></pre><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>​        通过应用举例分析理解分治算法的原理其实并不难，但是要想灵活应用并在编程中体现这种思想中却并不容易。所以，这里这里用分治算法应用在排序的时候的一个栗子，加深对分治算法的理解。</p><p>相关概念：</p><ul><li><strong>有序度</strong>：表示一组数据的有序程度</li><li><strong>逆序度</strong>：表示一组数据的无序程度</li></ul><p>一般通过<strong>计算有序对或者逆序对的个数</strong>，来表示数据的有序度或逆序度。</p><p>假设我们有 <code>n</code> 个数据，我们期望数据从小到大排列，那完全有序的数据的有序度就是 $n(n-1)/2$，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 $n(n-1)/2$。</p><p><strong>Q：如何编程求出一组数据的有序对个数或者逆序对个数呢？</strong></p><p>因为有序对个数和逆序对个数的求解方式是类似的，所以这里可以只思考逆序对（常接触的）个数的求解方法。</p><ul><li>方法1<ul><li>拿数组里的每个数字跟它后面的数字比较，看有几个比它小的。</li><li>把比它小的数字个数记作 <code>k</code>，通过这样的方式，把每个数字都考察一遍之后，然后对每个数字对应的 <code>k</code> 值求和</li><li>最后得到的总和就是逆序对个数。</li><li>这样操作的时间复杂度是$O(n^2)$（需要两层循环过滤）。那有没有更加高效的处理方法呢？这里尝试套用分治的思想来求数组 A 的逆序对个数。</li></ul></li><li>方法2<ul><li>首先将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2</li><li>然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</li><li>注意使用分治算法其中一个要求是，<strong>子问题合并的代价不能太大</strong>，否则就起不了降低时间复杂度的效果了。</li><li><strong>如何快速计算出两个子问题 A1 与 A2 之间的逆序对个数呢？这里就要借助归并排序算法了。（这里先回顾一下归并排序思想）</strong>如何借助归并排序算法来解决呢？归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。实际上，在这个合并的过程中，可以计算这两个小数组的逆序对个数了。每次合并操作，我们都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。</li></ul></li></ul><h3 id="算法应用"><a href="#算法应用" class="headerlink" title="算法应用"></a>算法应用</h3><h4 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169. 多数元素</a></h4><ul><li><p>题目描述</p><p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 [n/2] 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p><p>示例 1:</p><pre><code class="hljs python">输入: [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]输出: <span class="hljs-number">3</span></code></pre><p>示例 2:</p><pre><code class="hljs python">输入: [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]输出: <span class="hljs-number">2</span></code></pre></li><li><p>解题思路</p><ul><li><p>确定切分的终止条件</p><p>直到所有的子问题都是长度为 1 的数组，停止切分。</p></li><li><p>准备数据，将大问题切分为小问题</p><p>递归地将原数组二分为左区间与右区间，直到最终的数组只剩下一个元素，将其返回</p></li><li><p>处理子问题得到子结果，并合并</p><ul><li><p>长度为 1 的子数组中唯一的数显然是众数，直接返回即可。</p></li><li><p>如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。</p></li><li><p>如果他们的众数不同，比较两个众数在整个区间内出现的次数来决定该区间的众数</p></li></ul></li></ul></li><li><p>代码</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majorityElement2</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># 【不断切分的终止条件】</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]        <span class="hljs-comment"># 【准备数据，并将大问题拆分为小问题】</span>        left = self.majorityElement(nums[:len(nums)//<span class="hljs-number">2</span>])        right = self.majorityElement(nums[len(nums)//<span class="hljs-number">2</span>:])        <span class="hljs-comment"># 【处理子问题，得到子结果】</span>        <span class="hljs-comment"># 【对子结果进行合并 得到最终结果】</span>        <span class="hljs-keyword">if</span> left == right:            <span class="hljs-keyword">return</span> left        <span class="hljs-keyword">if</span> nums.count(left) &gt; nums.count(right):            <span class="hljs-keyword">return</span> left        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> right</code></pre></li></ul><h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h4><ul><li><p>题目描述</p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">4</span>],输出: <span class="hljs-number">6</span>解释: 连续子数组 [<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 的和最大为<span class="hljs-number">6</span>。</code></pre></li><li><p>解题思路</p></li><li><p><img src="/article/1768cd4c/image-20200819190726688.png" srcset="/img/loading.gif" alt="image-20200819190726688"></p></li><li><p>```python<br>from typing import List<br>class Solution:<br>  def maxSubArray(self, nums: List[int]) -&gt; int:</p><pre><code>    ans = nums[0]  pre=0    for x in nums:      pre = max(pre+x, x)        ans = max(ans, pre)      print(pre, ans)    return ans</code></pre><pre><code class="hljs python">  * **方法二：分治**  * 确定切分的终止条件    直到所有的子问题都是长度为 <span class="hljs-number">1</span> 的数组，停止切分。  * 准备数据，将大问题切分为小问题    递归地将原数组二分为左区间与右区间，直到最终的数组只剩下一个元素，将其返回  * 处理子问题得到子结果，并合并    - 将数组切分为左右区间      - 对与左区间：从右到左计算左边的最大子序和      - 对与右区间：从左到右计算右边的最大子序和    - 由于左右区间计算累加和的方向不一致，因此，左右区间直接合并相加之后就是整个区间的和    - 最终返回左区间的元素、右区间的元素、以及整个区间(相对子问题)和的最大值* 代码  ```python  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(self, nums)</span>:</span>          <span class="hljs-string">"""</span><span class="hljs-string">          :type nums: List[int]</span><span class="hljs-string">          :rtype: int</span><span class="hljs-string">          """</span>          <span class="hljs-comment"># 【确定不断切分的终止条件】</span>          n = len(nums)          <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:              <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]            <span class="hljs-comment"># 【准备数据，并将大问题拆分为小的问题】</span>          left = self.maxSubArray(nums[:len(nums)//<span class="hljs-number">2</span>])          right = self.maxSubArray(nums[len(nums)//<span class="hljs-number">2</span>:])            <span class="hljs-comment"># 【处理小问题，得到子结果】</span>          <span class="hljs-comment">#　从右到左计算左边的最大子序和</span>          max_l = nums[len(nums)//<span class="hljs-number">2</span> <span class="hljs-number">-1</span>] <span class="hljs-comment"># max_l为该数组的最右边的元素</span>          tmp = <span class="hljs-number">0</span> <span class="hljs-comment"># tmp用来记录连续子数组的和</span>                    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range( len(nums)//<span class="hljs-number">2</span><span class="hljs-number">-1</span> , <span class="hljs-number">-1</span> , <span class="hljs-number">-1</span> ):<span class="hljs-comment"># 从右到左遍历数组的元素</span>              tmp += nums[i]              max_l = max(tmp ,max_l)                        <span class="hljs-comment"># 从左到右计算右边的最大子序和</span>          max_r = nums[len(nums)//<span class="hljs-number">2</span>]          tmp = <span class="hljs-number">0</span>          <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)//<span class="hljs-number">2</span>,len(nums)):              tmp += nums[i]              max_r = max(tmp,max_r)                        <span class="hljs-comment"># 【对子结果进行合并 得到最终结果】</span>          <span class="hljs-comment"># 返回三个中的最大值</span>          <span class="hljs-keyword">return</span> max(left,right,max_l+ max_r)</code></pre></li></ul><h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h4><ul><li><p>题目描述</p><p>实现 <code>pow(x, n)</code>，即计算 <code>x</code> 的 <code>n</code> 次幂函数。</p><p>示例 1:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">2.00000</span>, <span class="hljs-number">10</span>输出: <span class="hljs-number">1024.00000</span></code></pre><p>示例 2:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">2.10000</span>, <span class="hljs-number">3</span>输出: <span class="hljs-number">9.26100</span></code></pre><p>示例 3:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">2.00000</span>, <span class="hljs-number">-2</span>输出: <span class="hljs-number">0.25000</span>解释: <span class="hljs-number">2</span><span class="hljs-number">-2</span> = <span class="hljs-number">1</span>/<span class="hljs-number">22</span> = <span class="hljs-number">1</span>/<span class="hljs-number">4</span> = <span class="hljs-number">0.25</span></code></pre><p>说明:</p><p><code>-100.0 &lt; x &lt; 100.0</code><br><code>n</code>是 32 位有符号整数，其数值范围是$[−2^{31}, 2^{31} − 1] $。</p></li><li><p>解题思路</p><ul><li><p>确定切分的终止条件</p><p>对<code>n</code>不断除以2，并更新<code>n</code>，直到为0，终止切分</p></li><li><p>准备数据，将大问题切分为小问题</p><p>对<code>n</code>不断除以2，更新</p></li><li><p>处理子问题得到子结果，并合并</p><ul><li><code>x</code>与自身相乘更新<code>x</code></li><li>如果<code>n%2 ==1</code><ul><li>将<code>p</code>乘以<code>x</code>之后赋值给<code>p</code>(初始值为1)，返回<code>p</code></li></ul></li></ul></li><li><p>最终返回<code>p</code></p></li></ul></li><li><p>代码</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: float</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: float</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># 处理n为负的情况</span>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> :            x = <span class="hljs-number">1</span>/x            n = -n        <span class="hljs-comment"># 【确定不断切分的终止条件】</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> :            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        <span class="hljs-comment"># 【准备数据，并将大问题拆分为小的问题】</span>        <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>:          <span class="hljs-comment"># 【处理小问题，得到子结果】</span>          p = x * self.myPow(x,n<span class="hljs-number">-1</span>)<span class="hljs-comment"># 【对子结果进行合并 得到最终结果】</span>          <span class="hljs-keyword">return</span> p        <span class="hljs-keyword">return</span> self.myPow(x*x,n/<span class="hljs-number">2</span>)</code></pre></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;主要思想&quot;&gt;&lt;a href=&quot;#主要思想&quot; class=&quot;headerlink&quot; title=&quot;主要思想&quot;&gt;&lt;/a&gt;主要思想&lt;/h3&gt;&lt;p&gt;分治算法的主要思想是将原问题&lt;strong&gt;递归地分成&lt;/strong&gt;若干个子问题，直到子问题&lt;strong&gt;满足边界条件
      
    
    </summary>
    
    
      <category term="算法" scheme="https://sulimin-nb.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://sulimin-nb.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>python06-字典、集合和序列</title>
    <link href="https://sulimin-nb.github.io/article/8b342fda.html"/>
    <id>https://sulimin-nb.github.io/article/8b342fda.html</id>
    <published>2020-07-31T15:55:35.000Z</published>
    <updated>2020-07-31T15:56:55.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="1-可变类型与不可变类型"><a href="#1-可变类型与不可变类型" class="headerlink" title="1. 可变类型与不可变类型"></a>1. 可变类型与不可变类型</h2><ul><li>序列是以连续的整数为索引，与此不同的是，字典以”关键字”为索引，关键字可以是任意不可变类型，通常用字符串或数值。</li><li>字典是 Python 唯一的一个 <u>映射类型</u>，字符串、元组、列表属于<u>序列类型</u>。</li></ul><p>那么如何快速判断一个数据类型 <code>X</code> 是不是可变类型的呢？两种方法：</p><ul><li>麻烦方法：用 <code>id(X)</code> 函数，对 X 进行某种操作，比较操作前后的 <code>id</code>，如果不一样，则 <code>X</code> 不可变，如果一样，则 <code>X</code> 可变。</li><li>便捷方法：用 <code>hash(X)</code>，只要不报错，证明 <code>X</code> 可被哈希，即不可变，反过来不可被哈希，即可变。</li></ul><pre><code class="hljs python">i = <span class="hljs-number">1</span>print(id(i))  <span class="hljs-comment"># 140732167000896</span>i = i + <span class="hljs-number">2</span>print(id(i))  <span class="hljs-comment"># 140732167000960</span>l = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]print(id(l))  <span class="hljs-comment"># 4300825160</span>l.append(<span class="hljs-string">'Python'</span>)print(id(l))  <span class="hljs-comment"># 4300825160</span></code></pre><ul><li>整数 <code>i</code> 在加 1 之后的 <code>id</code> 和之前不一样，因此加完之后的这个 <code>i</code> (虽然名字没变)，但不是加之前的那个 <code>i</code> 了，因此整数是不可变类型。</li><li>列表 <code>l</code> 在附加 <code>&#39;Python&#39;</code> 之后的 <code>id</code> 和之前一样，因此列表是可变类型。</li></ul><pre><code class="hljs python">print(hash(<span class="hljs-string">'Name'</span>))  <span class="hljs-comment"># -9215951442099718823</span>print(hash((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'Python'</span>)))  <span class="hljs-comment"># 823362308207799471</span>print(hash([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'Python'</span>]))<span class="hljs-comment"># TypeError: unhashable type: 'list'</span>print(hash(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;))<span class="hljs-comment"># TypeError: unhashable type: 'set'</span></code></pre><ul><li>数值、字符和元组 都能被哈希，因此它们是不可变类型。</li><li>列表、集合、字典不能被哈希，因此它是可变类型。</li></ul><h2 id="2-字典的定义"><a href="#2-字典的定义" class="headerlink" title="2. 字典的定义"></a>2. 字典的定义</h2><p>字典 是无序的 键:值（<code>key:value</code>）对集合，键必须是互不相同的（在同一个字典之内）。</p><ul><li><code>dict</code> 内部存放的顺序和 <code>key</code> 放入的顺序是没有关系的。</li><li><code>dict</code> 查找和插入的速度极快，不会随着 <code>key</code> 的增加而增加，但是需要占用大量的内存。</li></ul><p>字典 定义语法为 <code>{元素1, 元素2, ..., 元素n}</code></p><ul><li>其中每一个元素是一个「键值对」— 键:值 (<code>key:value</code>)</li><li>关键点是「大括号 {}」,「逗号 ,」和「冒号 :」</li><li>大括号 — 把所有元素绑在一起</li><li>逗号 — 将每个键值对分开</li><li>冒号 — 将键和值分开</li></ul><h2 id="3-创建和访问字典"><a href="#3-创建和访问字典" class="headerlink" title="3. 创建和访问字典"></a>3. 创建和访问字典</h2><p>【例子】</p><pre><code class="hljs python">brand = [<span class="hljs-string">'李宁'</span>, <span class="hljs-string">'耐克'</span>, <span class="hljs-string">'阿迪达斯'</span>]slogan = [<span class="hljs-string">'一切皆有可能'</span>, <span class="hljs-string">'Just do it'</span>, <span class="hljs-string">'Impossible is nothing'</span>]print(<span class="hljs-string">'耐克的口号是:'</span>, slogan[brand.index(<span class="hljs-string">'耐克'</span>)])  <span class="hljs-comment"># 耐克的口号是: Just do it</span>dic = &#123;<span class="hljs-string">'李宁'</span>: <span class="hljs-string">'一切皆有可能'</span>, <span class="hljs-string">'耐克'</span>: <span class="hljs-string">'Just do it'</span>, <span class="hljs-string">'阿迪达斯'</span>: <span class="hljs-string">'Impossible is nothing'</span>&#125;print(<span class="hljs-string">'耐克的口号是:'</span>, dic[<span class="hljs-string">'耐克'</span>])  <span class="hljs-comment"># 耐克的口号是: Just do it</span></code></pre><p>通过字符串或数值作为<code>key</code>来创建字典。</p><p>注意：如果我们取的键在字典中不存在，会直接报错<code>KeyError</code>。</p><p>【例子】</p><pre><code class="hljs python">dic1 = &#123;<span class="hljs-number">1</span>: <span class="hljs-string">'one'</span>, <span class="hljs-number">2</span>: <span class="hljs-string">'two'</span>, <span class="hljs-number">3</span>: <span class="hljs-string">'three'</span>&#125;print(dic1)  <span class="hljs-comment"># &#123;1: 'one', 2: 'two', 3: 'three'&#125;</span>print(dic1[<span class="hljs-number">1</span>])  <span class="hljs-comment"># one</span>print(dic1[<span class="hljs-number">4</span>])  <span class="hljs-comment"># KeyError: 4</span>dic2 = &#123;<span class="hljs-string">'rice'</span>: <span class="hljs-number">35</span>, <span class="hljs-string">'wheat'</span>: <span class="hljs-number">101</span>, <span class="hljs-string">'corn'</span>: <span class="hljs-number">67</span>&#125;print(dic2)  <span class="hljs-comment"># &#123;'wheat': 101, 'corn': 67, 'rice': 35&#125;</span>print(dic2[<span class="hljs-string">'rice'</span>])  <span class="hljs-comment"># 35</span></code></pre><p>【例子】通过元组作为<code>key</code>来创建字典，但一般不这样使用。</p><pre><code class="hljs python">dic = &#123;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>): <span class="hljs-string">"Tom"</span>, <span class="hljs-string">"Age"</span>: <span class="hljs-number">12</span>, <span class="hljs-number">3</span>: [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]&#125;print(dic)  <span class="hljs-comment"># &#123;(1, 2, 3): 'Tom', 'Age': 12, 3: [3, 5, 7]&#125;</span>print(type(dic))  <span class="hljs-comment"># &lt;class 'dict'&gt;</span></code></pre><p>通过构造函数<code>dict</code>来创建字典。</p><ul><li><code>dict()</code> -&gt; 创建一个空的字典。</li></ul><p>【例子】通过<code>key</code>直接把数据放入字典中，但一个<code>key</code>只能对应一个<code>value</code>，多次对一个<code>key</code>放入 <code>value</code>，后面的值会把前面的值冲掉。</p><pre><code class="hljs python">dic = dict()dic[<span class="hljs-string">'a'</span>] = <span class="hljs-number">1</span>dic[<span class="hljs-string">'b'</span>] = <span class="hljs-number">2</span>dic[<span class="hljs-string">'c'</span>] = <span class="hljs-number">3</span>print(dic)<span class="hljs-comment"># &#123;'a': 1, 'b': 2, 'c': 3&#125;</span>dic[<span class="hljs-string">'a'</span>] = <span class="hljs-number">11</span>print(dic)<span class="hljs-comment"># &#123;'a': 11, 'b': 2, 'c': 3&#125;</span>dic[<span class="hljs-string">'d'</span>] = <span class="hljs-number">4</span>print(dic)<span class="hljs-comment"># &#123;'a': 11, 'b': 2, 'c': 3, 'd': 4&#125;</span></code></pre><ul><li><code>dict(mapping)</code> -&gt; new dictionary initialized from a mapping object’s (key, value) pairs</li></ul><p>【例子】</p><pre><code class="hljs python">dic1 = dict([(<span class="hljs-string">'apple'</span>, <span class="hljs-number">4139</span>), (<span class="hljs-string">'peach'</span>, <span class="hljs-number">4127</span>), (<span class="hljs-string">'cherry'</span>, <span class="hljs-number">4098</span>)])print(dic1)  <span class="hljs-comment"># &#123;'cherry': 4098, 'apple': 4139, 'peach': 4127&#125;</span>dic2 = dict(((<span class="hljs-string">'apple'</span>, <span class="hljs-number">4139</span>), (<span class="hljs-string">'peach'</span>, <span class="hljs-number">4127</span>), (<span class="hljs-string">'cherry'</span>, <span class="hljs-number">4098</span>)))print(dic2)  <span class="hljs-comment"># &#123;'peach': 4127, 'cherry': 4098, 'apple': 4139&#125;</span></code></pre><ul><li><code>dict(**kwargs)</code> -&gt; new dictionary initialized with the name=value pairs in the keyword argument list.  For example:  dict(one=1, two=2)</li></ul><p>【例子】这种情况下，键只能为字符串类型，并且创建的时候字符串不能加引号，加上就会直接报语法错误。</p><pre><code class="hljs python">dic = dict(name=<span class="hljs-string">'Tom'</span>, age=<span class="hljs-number">10</span>)print(dic)  <span class="hljs-comment"># &#123;'name': 'Tom', 'age': 10&#125;</span>print(type(dic))  <span class="hljs-comment"># &lt;class 'dict'&gt;</span></code></pre><h2 id="4-字典的内置方法"><a href="#4-字典的内置方法" class="headerlink" title="4. 字典的内置方法"></a>4. 字典的内置方法</h2><ul><li><code>dict.fromkeys(seq[, value])</code> 用于创建一个新字典，以序列 <code>seq</code> 中元素做字典的键，<code>value</code> 为字典所有键对应的初始值。</li></ul><p>【例子】</p><pre><code class="hljs python">seq = (<span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>, <span class="hljs-string">'sex'</span>)dic1 = dict.fromkeys(seq)print(<span class="hljs-string">"新的字典为 : %s"</span> % str(dic1))  <span class="hljs-comment"># 新的字典为 : &#123;'name': None, 'age': None, 'sex': None&#125;</span>dic2 = dict.fromkeys(seq, <span class="hljs-number">10</span>)print(<span class="hljs-string">"新的字典为 : %s"</span> % str(dic2))  <span class="hljs-comment"># 新的字典为 : &#123;'name': 10, 'age': 10, 'sex': 10&#125;</span>dic3 = dict.fromkeys(seq, (<span class="hljs-string">'小马'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'男'</span>))print(<span class="hljs-string">"新的字典为 : %s"</span> % str(dic3))  <span class="hljs-comment"># 新的字典为 : &#123;'name': ('小马', '8', '男'), 'age': ('小马', '8', '男'), 'sex': ('小马', '8', '男')&#125;</span></code></pre><ul><li><code>dict.keys()</code>返回一个可迭代对象，可以使用 <code>list()</code> 来转换为列表，列表为字典中的所有键。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;print(dic.keys())  <span class="hljs-comment"># dict_keys(['Name', 'Age'])</span>lst = list(dic.keys())  <span class="hljs-comment"># 转换为列表</span>print(lst)  <span class="hljs-comment"># ['Name', 'Age']</span></code></pre><ul><li><code>dict.values()</code>返回一个迭代器，可以使用 <code>list()</code> 来转换为列表，列表为字典中的所有值。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Sex'</span>: <span class="hljs-string">'female'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>, <span class="hljs-string">'Name'</span>: <span class="hljs-string">'Zara'</span>&#125;print(<span class="hljs-string">"字典所有值为 : "</span>, list(dic.values()))  <span class="hljs-comment"># 字典所有值为 :  [7, 'female', 'Zara']</span></code></pre><ul><li><code>dict.items()</code>以列表返回可遍历的 (键, 值) 元组数组。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;print(<span class="hljs-string">"Value : %s"</span> % dic.items())  <span class="hljs-comment"># Value : dict_items([('Name', 'Lsgogroup'), ('Age', 7)])</span>print(tuple(dic.items()))  <span class="hljs-comment"># (('Name', 'Lsgogroup'), ('Age', 7))</span></code></pre><ul><li><code>dict.get(key, default=None)</code>返回指定键的值，如果值不在字典中返回默认值。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">27</span>&#125;print(<span class="hljs-string">"Age 值为 : %s"</span> % dic.get(<span class="hljs-string">'Age'</span>))  <span class="hljs-comment"># Age 值为 : 27</span>print(<span class="hljs-string">"Sex 值为 : %s"</span> % dic.get(<span class="hljs-string">'Sex'</span>, <span class="hljs-string">"NA"</span>))  <span class="hljs-comment"># Sex 值为 : NA</span></code></pre><ul><li><code>dict.setdefault(key, default=None)</code>和<code>get()</code>方法 类似, 如果键不存在于字典中，将会添加键并将值设为默认值。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;print(<span class="hljs-string">"Age 键的值为 : %s"</span> % dic.setdefault(<span class="hljs-string">'Age'</span>, <span class="hljs-literal">None</span>))  <span class="hljs-comment"># Age 键的值为 : 7</span>print(<span class="hljs-string">"Sex 键的值为 : %s"</span> % dic.setdefault(<span class="hljs-string">'Sex'</span>, <span class="hljs-literal">None</span>))  <span class="hljs-comment"># Sex 键的值为 : None</span>print(<span class="hljs-string">"新字典为："</span>, dic)  <span class="hljs-comment"># 新字典为： &#123;'Age': 7, 'Name': 'Lsgogroup', 'Sex': None&#125;</span></code></pre><ul><li><code>key in dict</code> <code>in</code> 操作符用于判断键是否存在于字典中，如果键在字典 dict 里返回<code>true</code>，否则返回<code>false</code>。而<code>not in</code>操作符刚好相反，如果键在字典 dict 里返回<code>false</code>，否则返回<code>true</code>。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;<span class="hljs-comment"># in 检测键 Age 是否存在</span><span class="hljs-keyword">if</span> <span class="hljs-string">'Age'</span> <span class="hljs-keyword">in</span> dic:    print(<span class="hljs-string">"键 Age 存在"</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"键 Age 不存在"</span>)<span class="hljs-comment"># 检测键 Sex 是否存在</span><span class="hljs-keyword">if</span> <span class="hljs-string">'Sex'</span> <span class="hljs-keyword">in</span> dic:    print(<span class="hljs-string">"键 Sex 存在"</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"键 Sex 不存在"</span>)<span class="hljs-comment"># not in 检测键 Age 是否存在</span><span class="hljs-keyword">if</span> <span class="hljs-string">'Age'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dic:    print(<span class="hljs-string">"键 Age 不存在"</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"键 Age 存在"</span>)<span class="hljs-comment"># 键 Age 存在</span><span class="hljs-comment"># 键 Sex 不存在</span><span class="hljs-comment"># 键 Age 存在</span></code></pre><ul><li><code>dict.pop(key[,default])</code>删除字典给定键 <code>key</code> 所对应的值，返回值为被删除的值。<code>key</code> 值必须给出。若<code>key</code>不存在，则返回 <code>default</code> 值。</li><li><code>del dict[key]</code> 删除字典给定键 <code>key</code> 所对应的值。</li></ul><p>【例子】</p><pre><code class="hljs python">dic1 = &#123;<span class="hljs-number">1</span>: <span class="hljs-string">"a"</span>, <span class="hljs-number">2</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]&#125;print(dic1.pop(<span class="hljs-number">1</span>), dic1)  <span class="hljs-comment"># a &#123;2: [1, 2]&#125;</span><span class="hljs-comment"># 设置默认值，必须添加，否则报错</span>print(dic1.pop(<span class="hljs-number">3</span>, <span class="hljs-string">"nokey"</span>), dic1)  <span class="hljs-comment"># nokey &#123;2: [1, 2]&#125;</span><span class="hljs-keyword">del</span> dic1[<span class="hljs-number">2</span>]print(dic1)  <span class="hljs-comment"># &#123;&#125;</span></code></pre><ul><li><code>dict.popitem()</code>随机返回并删除字典中的一对键和值，如果字典已经为空，却调用了此方法，就报出KeyError异常。</li></ul><p>【例子】</p><pre><code class="hljs python">dic1 = &#123;<span class="hljs-number">1</span>: <span class="hljs-string">"a"</span>, <span class="hljs-number">2</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]&#125;print(dic1.popitem())  <span class="hljs-comment"># (1, 'a')</span>print(dic1)  <span class="hljs-comment"># &#123;2: [1, 2]&#125;</span></code></pre><ul><li><code>dict.clear()</code>用于删除字典内所有元素。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Zara'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;print(<span class="hljs-string">"字典长度 : %d"</span> % len(dic))  <span class="hljs-comment"># 字典长度 : 2</span>dict.clear()print(<span class="hljs-string">"字典删除后长度 : %d"</span> % len(dic))  <span class="hljs-comment"># 字典删除后长度 : 0</span></code></pre><ul><li><code>dict.copy()</code>返回一个字典的浅复制。</li></ul><p>【例子】</p><pre><code class="hljs python">dic1 = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>, <span class="hljs-string">'Class'</span>: <span class="hljs-string">'First'</span>&#125;dic2 = dic1.copy()print(<span class="hljs-string">"新复制的字典为 : "</span>, dic2)  <span class="hljs-comment"># 新复制的字典为 :  &#123;'Age': 7, 'Name': 'Lsgogroup', 'Class': 'First'&#125;</span></code></pre><p>【例子】直接赋值和 copy 的区别</p><pre><code class="hljs python">dic1 = &#123;<span class="hljs-string">'user'</span>: <span class="hljs-string">'lsgogroup'</span>, <span class="hljs-string">'num'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;<span class="hljs-comment"># 引用对象</span>dic2 = dic1  <span class="hljs-comment"># 深拷贝父对象（一级目录），子对象（二级目录）不拷贝，还是引用</span>dic3 = dic1.copy()  print(id(dic1))  <span class="hljs-comment"># 148635574728</span>print(id(dic2))  <span class="hljs-comment"># 148635574728</span>print(id(dic3))  <span class="hljs-comment"># 148635574344</span><span class="hljs-comment"># 修改 data 数据</span>dic1[<span class="hljs-string">'user'</span>] = <span class="hljs-string">'root'</span>dic1[<span class="hljs-string">'num'</span>].remove(<span class="hljs-number">1</span>)<span class="hljs-comment"># 输出结果</span>print(dic1)  <span class="hljs-comment"># &#123;'user': 'root', 'num': [2, 3]&#125;</span>print(dic2)  <span class="hljs-comment"># &#123;'user': 'root', 'num': [2, 3]&#125;</span>print(dic3)  <span class="hljs-comment"># &#123;'user': 'runoob', 'num': [2, 3]&#125;</span></code></pre><ul><li><code>dict.update(dict2)</code>把字典参数 <code>dict2</code> 的 <code>key:value</code>对 更新到字典 <code>dict</code> 里。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;dic2 = &#123;<span class="hljs-string">'Sex'</span>: <span class="hljs-string">'female'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">8</span>&#125;dic.update(dic2)print(<span class="hljs-string">"更新字典 dict : "</span>, dic)  <span class="hljs-comment"># 更新字典 dict :  &#123;'Sex': 'female', 'Age': 8, 'Name': 'Lsgogroup'&#125;</span></code></pre><hr><p><strong>练习题</strong>：</p><p>1、字典基本操作</p><p>字典内容如下:</p><pre><code class="hljs python">dic = &#123;    <span class="hljs-string">'python'</span>: <span class="hljs-number">95</span>,    <span class="hljs-string">'java'</span>: <span class="hljs-number">99</span>,    <span class="hljs-string">'c'</span>: <span class="hljs-number">100</span>    &#125;</code></pre><p>用程序解答下面的题目</p><ul><li>字典的长度是多少</li><li>请修改’java’ 这个key对应的value值为98</li><li>删除 c 这个key</li><li>增加一个key-value对，key值为 php, value是90</li><li>获取所有的key值，存储在列表里</li><li>获取所有的value值，存储在列表里</li><li>判断 javascript 是否在字典中</li><li>获得字典里所有value 的和</li><li>获取字典里最大的value</li><li>获取字典里最小的value</li><li>字典 dic1 = {‘php’: 97}， 将dic1的数据更新到dic中</li></ul><p>2、字典中的value</p><p>有一个字典，保存的是学生各个编程语言的成绩，内容如下</p><pre><code class="hljs prolog">data = &#123;        <span class="hljs-string">'python'</span>: &#123;<span class="hljs-string">'上学期'</span>: <span class="hljs-string">'90'</span>, <span class="hljs-string">'下学期'</span>: <span class="hljs-string">'95'</span>&#125;,        <span class="hljs-string">'c++'</span>: [<span class="hljs-string">'95'</span>, <span class="hljs-string">'96'</span>, <span class="hljs-string">'97'</span>],        <span class="hljs-string">'java'</span>: [&#123;<span class="hljs-string">'月考'</span>:<span class="hljs-string">'90'</span>, <span class="hljs-string">'期中考试'</span>: <span class="hljs-string">'94'</span>, <span class="hljs-string">'期末考试'</span>: <span class="hljs-string">'98'</span>&#125;]        &#125;</code></pre><p>各门课程的考试成绩存储方式并不相同，有的用字典，有的用列表，但是分数都是字符串类型，请实现函数<code>transfer_score(score_dict)</code>，将分数修改成int类型</p><pre><code class="hljs python">   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transfer_score</span><span class="hljs-params">(data)</span>:</span>    <span class="hljs-comment"># your code here</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字典&quot;&gt;&lt;a href=&quot;#字典&quot; class=&quot;headerlink&quot; title=&quot;字典&quot;&gt;&lt;/a&gt;字典&lt;/h1&gt;&lt;h2 id=&quot;1-可变类型与不可变类型&quot;&gt;&lt;a href=&quot;#1-可变类型与不可变类型&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python05-列表、字典和字符串</title>
    <link href="https://sulimin-nb.github.io/article/a112c8e7.html"/>
    <id>https://sulimin-nb.github.io/article/a112c8e7.html</id>
    <published>2020-07-28T16:14:42.000Z</published>
    <updated>2020-07-28T16:17:21.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>简单数据类型</p><ul><li>整型<code>&lt;class &#39;int&#39;&gt;</code></li><li>浮点型<code>&lt;class &#39;float&#39;&gt;</code></li><li>布尔型<code>&lt;class &#39;bool&#39;&gt;</code></li></ul><p>容器数据类型</p><ul><li>列表<code>&lt;class &#39;list&#39;&gt;</code></li><li>元组<code>&lt;class &#39;tuple&#39;&gt;</code></li><li>字典<code>&lt;class &#39;dict&#39;&gt;</code></li><li>集合<code>&lt;class &#39;set&#39;&gt;</code></li><li>字符串<code>&lt;class &#39;str&#39;&gt;</code></li></ul><h2 id="1-列表的定义"><a href="#1-列表的定义" class="headerlink" title="1. 列表的定义"></a>1. 列表的定义</h2><p>列表是有序集合，没有固定大小，能够保存任意数量任意类型的 Python 对象，语法为 <code>[元素1, 元素2, ..., 元素n]</code>。</p><ul><li>关键点是「中括号 []」和「逗号 ,」</li><li>中括号 把所有元素绑在一起</li><li>逗号 将每个元素一一分开</li></ul><h2 id="2-列表的创建"><a href="#2-列表的创建" class="headerlink" title="2. 列表的创建"></a>2. 列表的创建</h2><ul><li>创建一个普通列表</li></ul><p>【例子】 </p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(x, type(x))<span class="hljs-comment"># ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'] &lt;class 'list'&gt;</span>x = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]print(x, type(x))<span class="hljs-comment"># [2, 3, 4, 5, 6, 7] &lt;class 'list'&gt;</span></code></pre><ul><li>利用<code>range()</code>创建列表</li></ul><p>【例子】 </p><pre><code class="hljs python">x = list(range(<span class="hljs-number">10</span>))print(x, type(x))<span class="hljs-comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class 'list'&gt;</span>x = list(range(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">2</span>))print(x, type(x))<span class="hljs-comment"># [1, 3, 5, 7, 9] &lt;class 'list'&gt;</span>x = list(range(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-2</span>))print(x, type(x))<span class="hljs-comment"># [10, 8, 6, 4, 2] &lt;class 'list'&gt;</span></code></pre><ul><li>利用推导式创建列表</li></ul><p>【例子】 </p><pre><code class="hljs python">x = [<span class="hljs-number">0</span>] * <span class="hljs-number">5</span>print(x, type(x))<span class="hljs-comment"># [0, 0, 0, 0, 0] &lt;class 'list'&gt;</span>x = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]print(x, type(x))<span class="hljs-comment"># [0, 0, 0, 0, 0] &lt;class 'list'&gt;</span>x = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)]print(x, type(x))<span class="hljs-comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class 'list'&gt;</span>x = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>)]print(x, type(x))<span class="hljs-comment"># [1, 3, 5, 7, 9] &lt;class 'list'&gt;</span>x = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-2</span>)]print(x, type(x))<span class="hljs-comment"># [10, 8, 6, 4, 2] &lt;class 'list'&gt;</span>x = [i ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)]print(x, type(x))<span class="hljs-comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81] &lt;class 'list'&gt;</span>x = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>) <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> (i % <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>]print(x, type(x))<span class="hljs-comment"># [3, 9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99] &lt;class 'list'&gt;</span></code></pre><ul><li>创建一个 4×3的二维数组</li></ul><p>【例子】</p><pre><code class="hljs python">x = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]print(x, type(x))<span class="hljs-comment"># [[1, 2, 3], [4, 5, 6], [7, 8, 9], [0, 0, 0]] &lt;class 'list'&gt;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x:    print(i, type(i))<span class="hljs-comment"># [1, 2, 3] &lt;class 'list'&gt;</span><span class="hljs-comment"># [4, 5, 6] &lt;class 'list'&gt;</span><span class="hljs-comment"># [7, 8, 9] &lt;class 'list'&gt;</span><span class="hljs-comment"># [0, 0, 0] &lt;class 'list'&gt;</span>x = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>)]print(x, type(x))<span class="hljs-comment"># [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span>x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>print(x, type(x))<span class="hljs-comment"># [[1, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span>x = [[<span class="hljs-number">0</span>] * <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>)]print(x, type(x))<span class="hljs-comment"># [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span>x[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>print(x, type(x))<span class="hljs-comment"># [[0, 0, 0], [0, 1, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span></code></pre><p>注意：</p><p>由于list的元素可以是任何对象，因此列表中所保存的是对象的指针。即使保存一个简单的<code>[1,2,3]</code>，也有3个指针和3个整数对象。</p><p><code>x = [a] * 4</code>操作中，只是创建4个指向list的引用，所以一旦<code>a</code>改变，<code>x</code>中4个<code>a</code>也会随之改变。</p><p>【例子】</p><pre><code class="hljs python">x = [[<span class="hljs-number">0</span>] * <span class="hljs-number">3</span>] * <span class="hljs-number">4</span>print(x, type(x))<span class="hljs-comment"># [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span>x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>print(x, type(x))<span class="hljs-comment"># [[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class 'list'&gt;</span>a = [<span class="hljs-number">0</span>] * <span class="hljs-number">3</span>x = [a] * <span class="hljs-number">4</span>print(x, type(x))<span class="hljs-comment"># [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span>x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>print(x, type(x))<span class="hljs-comment"># [[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class 'list'&gt;</span></code></pre><ul><li>创建一个混合列表</li></ul><p>【例子】 </p><pre><code class="hljs python">mix = [<span class="hljs-number">1</span>, <span class="hljs-string">'lsgo'</span>, <span class="hljs-number">3.14</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]]print(mix)  <span class="hljs-comment"># [1, 'lsgo', 3.14, [1, 2, 3]]</span></code></pre><ul><li>创建一个空列表</li></ul><p>【例子】 </p><pre><code class="hljs python">empty = []print(empty)  <span class="hljs-comment"># []</span></code></pre><p>列表不像元组，列表内容可更改 (mutable)，因此附加 (<code>append</code>, <code>extend</code>)、插入 (<code>insert</code>)、删除 (<code>remove</code>, <code>pop</code>) 这些操作都可以用在它身上。</p><h2 id="3-向列表中添加元素"><a href="#3-向列表中添加元素" class="headerlink" title="3. 向列表中添加元素"></a>3. 向列表中添加元素</h2><ul><li><code>list.append(obj)</code> 在列表末尾添加新的对象，只接受一个参数，参数可以是任何数据类型，被追加的元素在 list 中保持着原结构类型。</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]x.append(<span class="hljs-string">'Thursday'</span>)print(x)  <span class="hljs-comment"># ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Thursday']</span>print(len(x))  <span class="hljs-comment"># 6</span></code></pre><p>此元素如果是一个 list，那么这个 list 将作为一个整体进行追加，注意<code>append()</code>和<code>extend()</code>的区别。</p><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]x.append([<span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Sunday'</span>])print(x)  <span class="hljs-comment"># ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', ['Thursday', 'Sunday']]</span>print(len(x))  <span class="hljs-comment"># 6</span></code></pre><ul><li><code>list.extend(seq)</code> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]x.extend([<span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Sunday'</span>])print(x)  <span class="hljs-comment"># ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Thursday', 'Sunday']</span>print(len(x))  <span class="hljs-comment"># 7</span></code></pre><p>严格来说 <code>append</code> 是追加，把一个东西整体添加在列表后，而 <code>extend</code> 是扩展，把一个东西里的所有元素添加在列表后。</p><ul><li><code>list.insert(index, obj)</code> 在编号 <code>index</code> 位置前插入 <code>obj</code>。</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]x.insert(<span class="hljs-number">2</span>, <span class="hljs-string">'Sunday'</span>)print(x)<span class="hljs-comment"># ['Monday', 'Tuesday', 'Sunday', 'Wednesday', 'Thursday', 'Friday']</span>print(len(x))  <span class="hljs-comment"># 6</span></code></pre><h2 id="4-删除列表中的元素"><a href="#4-删除列表中的元素" class="headerlink" title="4. 删除列表中的元素"></a>4. 删除列表中的元素</h2><ul><li><code>list.remove(obj)</code> 移除列表中某个值的第一个匹配项</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]x.remove(<span class="hljs-string">'Monday'</span>)print(x)  <span class="hljs-comment"># ['Tuesday', 'Wednesday', 'Thursday', 'Friday']</span></code></pre><ul><li><code>list.pop([index=-1])</code> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]y = x.pop()print(y)  <span class="hljs-comment"># Friday</span>y = x.pop(<span class="hljs-number">0</span>)print(y)  <span class="hljs-comment"># Monday</span>y = x.pop(<span class="hljs-number">-2</span>)print(y)  <span class="hljs-comment"># Wednesday</span>print(x)  <span class="hljs-comment"># ['Tuesday', 'Thursday']</span></code></pre><p><code>remove</code> 和 <code>pop</code> 都可以删除元素，前者是指定具体要删除的元素，后者是指定一个索引。</p><ul><li><code>del var1[, var2 ……]</code> 删除单个或多个对象。</li></ul><p>【例子】</p><p>如果知道要删除的元素在列表中的位置，可使用<code>del</code>语句。</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]<span class="hljs-keyword">del</span> x[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]print(x)  <span class="hljs-comment"># ['Wednesday', 'Thursday', 'Friday']</span></code></pre><p>如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用<code>del</code>语句；如果你要在删除元素后还能继续使用它，就使用方法<code>pop()</code>。</p><h2 id="5-获取列表中的元素"><a href="#5-获取列表中的元素" class="headerlink" title="5. 获取列表中的元素"></a>5. 获取列表中的元素</h2><ul><li>通过元素的索引值，从列表获取单个元素，注意，列表索引值是从0开始的。</li><li>通过将索引指定为-1，可让Python返回最后一个列表元素，索引 -2 返回倒数第二个列表元素，以此类推。</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(x[<span class="hljs-number">0</span>], type(x[<span class="hljs-number">0</span>]))  <span class="hljs-comment"># Monday &lt;class 'str'&gt;</span>print(x[<span class="hljs-number">-1</span>], type(x[<span class="hljs-number">-1</span>]))  <span class="hljs-comment"># Friday &lt;class 'str'&gt;</span>print(x[<span class="hljs-number">-2</span>], type(x[<span class="hljs-number">-2</span>]))  <span class="hljs-comment"># Thursday &lt;class 'str'&gt;</span></code></pre><p>切片的通用写法是 <code>start : stop : step</code></p><ul><li>情况 1 - “start :” </li><li>以 <code>step</code> 为 1 (默认) 从编号 <code>start</code> 往列表尾部切片。</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(x[<span class="hljs-number">3</span>:])  <span class="hljs-comment"># ['Thursday', 'Friday']</span>print(x[<span class="hljs-number">-3</span>:])  <span class="hljs-comment"># ['Wednesday', 'Thursday', 'Friday']</span></code></pre><ul><li>情况 2 - “: stop”</li><li>以 <code>step</code> 为 1 (默认) 从列表头部往编号 <code>stop</code> 切片。</li></ul><p>【例子】</p><pre><code class="hljs python">week = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(week[:<span class="hljs-number">3</span>])  <span class="hljs-comment"># ['Monday', 'Tuesday', 'Wednesday']</span>print(week[:<span class="hljs-number">-3</span>])  <span class="hljs-comment"># ['Monday', 'Tuesday']</span></code></pre><ul><li>情况 3 - “start : stop”</li><li>以 <code>step</code> 为 1 (默认) 从编号 <code>start</code> 往编号 <code>stop</code> 切片。</li></ul><p>【例子】</p><pre><code class="hljs python">week = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(week[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])  <span class="hljs-comment"># ['Tuesday', 'Wednesday']</span>print(week[<span class="hljs-number">-3</span>:<span class="hljs-number">-1</span>])  <span class="hljs-comment"># ['Wednesday', 'Thursday']</span></code></pre><ul><li>情况 4 - “start : stop : step”</li><li>以具体的 <code>step</code> 从编号 <code>start</code> 往编号 <code>stop</code> 切片。注意最后把 <code>step</code> 设为 -1，相当于将列表反向排列。</li></ul><p>【例子】</p><pre><code class="hljs python">week = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(week[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>])  <span class="hljs-comment"># ['Tuesday', 'Thursday']</span>print(week[:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>])  <span class="hljs-comment"># ['Monday', 'Wednesday']</span>print(week[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>])  <span class="hljs-comment"># ['Tuesday', 'Thursday']</span>print(week[::<span class="hljs-number">-1</span>])  <span class="hljs-comment"># ['Friday', 'Thursday', 'Wednesday', 'Tuesday', 'Monday']</span></code></pre><ul><li>情况 5 - “ : “</li><li>复制列表中的所有元素（浅拷贝）。</li></ul><p>【例子】</p><pre><code class="hljs python">week = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(week[:])  <span class="hljs-comment"># week的拷贝 ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']</span>list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-number">789</span>, <span class="hljs-number">213</span>]list2 = list1list3 = list1[:]print(list2)  <span class="hljs-comment"># [123, 456, 789, 213]</span>print(list3)  <span class="hljs-comment"># [123, 456, 789, 213]</span>list1.sort()print(list2)  <span class="hljs-comment"># [123, 213, 456, 789] </span>print(list3)  <span class="hljs-comment"># [123, 456, 789, 213]</span>list1 = [[<span class="hljs-number">123</span>, <span class="hljs-number">456</span>], [<span class="hljs-number">789</span>, <span class="hljs-number">213</span>]]list2 = list1list3 = list1[:]print(list2)  <span class="hljs-comment"># [[123, 456], [789, 213]]</span>print(list3)  <span class="hljs-comment"># [[123, 456], [789, 213]]</span>list1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">111</span>print(list2)  <span class="hljs-comment"># [[111, 456], [789, 213]]</span>print(list3)  <span class="hljs-comment"># [[111, 456], [789, 213]]</span></code></pre><h2 id="6-列表的常用操作符"><a href="#6-列表的常用操作符" class="headerlink" title="6. 列表的常用操作符"></a>6. 列表的常用操作符</h2><ul><li>等号操作符：<code>==</code></li><li>连接操作符 <code>+</code></li><li>重复操作符 <code>*</code></li><li>成员关系操作符 <code>in</code>、<code>not in</code></li></ul><p>「等号 ==」，只有成员、成员位置都相同时才返回True。</p><p>和元组拼接一样， 列表拼接也有两种方式，用「加号 +」和「乘号 *」，前者首尾拼接，后者复制拼接。</p><p>【例子】</p><pre><code class="hljs Python">list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>]list2 = [<span class="hljs-number">456</span>, <span class="hljs-number">123</span>]list3 = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>]print(list1 == list2)  <span class="hljs-comment"># False</span>print(list1 == list3)  <span class="hljs-comment"># True</span>list4 = list1 + list2  <span class="hljs-comment"># extend()</span>print(list4)  <span class="hljs-comment"># [123, 456, 456, 123]</span>list5 = list3 * <span class="hljs-number">3</span>print(list5)  <span class="hljs-comment"># [123, 456, 123, 456, 123, 456]</span>list3 *= <span class="hljs-number">3</span>print(list3)  <span class="hljs-comment"># [123, 456, 123, 456, 123, 456]</span>print(<span class="hljs-number">123</span> <span class="hljs-keyword">in</span> list3)  <span class="hljs-comment"># True</span>print(<span class="hljs-number">456</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> list3)  <span class="hljs-comment"># False</span></code></pre><p>前面三种方法（<code>append</code>, <code>extend</code>, <code>insert</code>）可对列表增加元素，它们没有返回值，是直接修改了原数据对象。<br>将两个list相加，需要创建新的 list 对象，从而需要消耗额外的内存，特别是当 list 较大时，尽量不要使用 “+” 来添加list。</p><h2 id="7-列表的其它方法"><a href="#7-列表的其它方法" class="headerlink" title="7. 列表的其它方法"></a>7. 列表的其它方法</h2><p><code>list.count(obj)</code> 统计某个元素在列表中出现的次数</p><p>【例子】</p><pre><code class="hljs python">list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>] * <span class="hljs-number">3</span>print(list1)  <span class="hljs-comment"># [123, 456, 123, 456, 123, 456]</span>num = list1.count(<span class="hljs-number">123</span>)print(num)  <span class="hljs-comment"># 3</span></code></pre><p><code>list.index(x[, start[, end]])</code> 从列表中找出某个值第一个匹配项的索引位置</p><p>【例子】</p><pre><code class="hljs python">list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>] * <span class="hljs-number">5</span>print(list1.index(<span class="hljs-number">123</span>))  <span class="hljs-comment"># 0</span>print(list1.index(<span class="hljs-number">123</span>, <span class="hljs-number">1</span>))  <span class="hljs-comment"># 2</span>print(list1.index(<span class="hljs-number">123</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>))  <span class="hljs-comment"># 4</span></code></pre><p><code>list.reverse()</code> 反向列表中元素</p><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-number">789</span>]x.reverse()print(x)  <span class="hljs-comment"># [789, 456, 123]</span></code></pre><p><code>list.sort(key=None, reverse=False)</code> 对原列表进行排序。</p><ul><li><code>key</code> — 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li><code>reverse</code> — 排序规则，<code>reverse = True</code> 降序， <code>reverse = False</code> 升序（默认）。</li><li>该方法没有返回值，但是会对列表的对象进行排序。</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-number">789</span>, <span class="hljs-number">213</span>]x.sort()print(x)<span class="hljs-comment"># [123, 213, 456, 789]</span>x.sort(reverse=<span class="hljs-literal">True</span>)print(x)<span class="hljs-comment"># [789, 456, 213, 123]</span><span class="hljs-comment"># 获取列表的第二个元素</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takeSecond</span><span class="hljs-params">(elem)</span>:</span>    <span class="hljs-keyword">return</span> elem[<span class="hljs-number">1</span>]x = [(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)]x.sort(key=takeSecond)print(x)<span class="hljs-comment"># [(4, 1), (2, 2), (1, 3), (3, 4)]</span>x.sort(key=<span class="hljs-keyword">lambda</span> a: a[<span class="hljs-number">0</span>])print(x)<span class="hljs-comment"># [(1, 3), (2, 2), (3, 4), (4, 1)]</span></code></pre><hr><p><strong>参考文献</strong>：</p><ul><li><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-tutorial.html</a></li><li><a href="https://www.bilibili.com/video/av4050443" target="_blank" rel="noopener">https://www.bilibili.com/video/av4050443</a></li><li><a href="https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ</a></li></ul><hr><p><strong>练习题</strong>：</p><p>1、列表操作练习</p><p>列表lst 内容如下</p><p>lst = [2, 5, 6, 7, 8, 9, 2, 9, 9]</p><p>请写程序完成下列操作：</p><ol><li>在列表的末尾增加元素15</li><li>在列表的中间位置插入元素20</li><li>将列表[2, 5, 6]合并到lst中</li><li>移除列表中索引为3的元素</li><li>翻转列表里的所有元素</li><li>对列表里的元素进行排序，从小到大一次，从大到小一次</li></ol><p>2、修改列表</p><p>问题描述：</p><p>lst = [1, [4, 6], True]</p><p>请将列表里所有数字修改成原来的两倍</p><p>3、leetcode 852题 山脉数组的峰顶索引</p><p>如果一个数组k符合下面两个属性，则称之为山脉数组</p><p>数组的长度大于等于3</p><p>存在$i$，$i$ &gt;0 且$i&lt;\operatorname{len}(k)-1$， 使得<script type="math/tex">\mathrm{k}[0]<\mathrm{k}[1]<\ldots<\mathrm{k}[\mathrm{i}-1]<\mathrm{k}[\mathrm{j}]>\mathrm{k}[\mathrm{i}+1] \ldots>\mathrm{k}[\operatorname{len}(\mathrm{k})-1]</script></p><p>这个$i$就是顶峰索引。</p><p>现在，给定一个山脉数组，求顶峰索引。</p><p>示例:</p><p>输入：[1, 3, 4, 5, 3]</p><p>输出：True</p><p>输入：[1, 2, 4, 6, 4, 5]</p><p>输出：False</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">peakIndexInMountainArray</span><span class="hljs-params">(self, A: List[int])</span> -&gt; int:</span>           <span class="hljs-comment"># your code here</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;列表&quot;&gt;&lt;a href=&quot;#列表&quot; class=&quot;headerlink&quot; title=&quot;列表&quot;&gt;&lt;/a&gt;列表&lt;/h1&gt;&lt;p&gt;简单数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;整型&lt;code&gt;&amp;lt;class &amp;#39;int&amp;#39;&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python04-异常处理</title>
    <link href="https://sulimin-nb.github.io/article/60fd2cd8.html"/>
    <id>https://sulimin-nb.github.io/article/60fd2cd8.html</id>
    <published>2020-07-25T15:38:18.000Z</published>
    <updated>2020-07-25T15:38:51.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常就是运行期检测到的错误。计算机语言针对可能出现的错误定义了异常类型，某种错误引发对应的异常时，异常处理程序将被启动，从而恢复程序的正常运行。</p><h2 id="1-Python-标准异常总结"><a href="#1-Python-标准异常总结" class="headerlink" title="1. Python 标准异常总结"></a>1. Python 标准异常总结</h2><ul><li>BaseException：所有异常的 <strong>基类</strong></li><li>Exception：常规异常的 <strong>基类</strong></li><li>StandardError：所有的内建标准异常的基类</li><li>ArithmeticError：所有数值计算异常的基类</li><li>FloatingPointError：浮点计算异常</li><li><u>OverflowError</u>：数值运算超出最大限制</li><li><u>ZeroDivisionError</u>：除数为零</li><li><u>AssertionError</u>：断言语句（assert）失败</li><li><u>AttributeError</u>：尝试访问未知的对象属性</li><li>EOFError：没有内建输入，到达EOF标记</li><li>EnvironmentError：操作系统异常的基类</li><li>IOError：输入/输出操作失败</li><li><u>OSError</u>：操作系统产生的异常（例如打开一个不存在的文件）</li><li>WindowsError：系统调用失败</li><li><u>ImportError</u>：导入模块失败的时候</li><li>KeyboardInterrupt：用户中断执行</li><li>LookupError：无效数据查询的基类</li><li><u>IndexError</u>：索引超出序列的范围</li><li><u>KeyError</u>：字典中查找一个不存在的关键字</li><li><u>MemoryError</u>：内存溢出（可通过删除对象释放内存）</li><li><u>NameError</u>：尝试访问一个不存在的变量</li><li>UnboundLocalError：访问未初始化的本地变量</li><li>ReferenceError：弱引用试图访问已经垃圾回收了的对象</li><li>RuntimeError：一般的运行时异常</li><li>NotImplementedError：尚未实现的方法</li><li><u>SyntaxError</u>：语法错误导致的异常</li><li>IndentationError：缩进错误导致的异常</li><li>TabError：Tab和空格混用</li><li>SystemError：一般的解释器系统异常</li><li><u>TypeError</u>：不同类型间的无效操作</li><li><u>ValueError</u>：传入无效的参数</li><li>UnicodeError：Unicode相关的异常</li><li>UnicodeDecodeError：Unicode解码时的异常</li><li>UnicodeEncodeError：Unicode编码错误导致的异常</li><li>UnicodeTranslateError：Unicode转换错误导致的异常</li></ul><p>异常体系内部有层次关系，Python异常体系中的部分关系如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20200710131404548.png" srcset="/img/loading.gif" alt></p><hr><h2 id="2-Python标准警告总结"><a href="#2-Python标准警告总结" class="headerlink" title="2. Python标准警告总结"></a>2. Python标准警告总结</h2><ul><li>Warning：警告的基类</li><li>DeprecationWarning：关于被弃用的特征的警告</li><li>FutureWarning：关于构造将来语义会有改变的警告</li><li>UserWarning：用户代码生成的警告</li><li>PendingDeprecationWarning：关于特性将会被废弃的警告</li><li>RuntimeWarning：可疑的运行时行为(runtime behavior)的警告</li><li>SyntaxWarning：可疑语法的警告</li><li>ImportWarning：用于在导入模块过程中触发的警告</li><li>UnicodeWarning：与Unicode相关的警告</li><li>BytesWarning：与字节或字节码相关的警告</li><li>ResourceWarning：与资源使用相关的警告</li></ul><hr><h2 id="3-try-except-语句"><a href="#3-try-except-语句" class="headerlink" title="3. try - except 语句"></a>3. try - except 语句</h2><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    检测范围<span class="hljs-keyword">except</span> Exception[<span class="hljs-keyword">as</span> reason]:    出现异常后的处理代码</code></pre><p>try 语句按照如下方式工作：</p><ul><li>首先，执行<code>try</code>子句（在关键字<code>try</code>和关键字<code>except</code>之间的语句）</li><li>如果没有异常发生，忽略<code>except</code>子句，<code>try</code>子句执行后结束。</li><li>如果在执行<code>try</code>子句的过程中发生了异常，那么<code>try</code>子句余下的部分将被忽略。如果异常的类型和<code>except</code>之后的名称相符，那么对应的<code>except</code>子句将被执行。最后执行<code>try</code>语句之后的代码。</li><li>如果一个异常没有与任何的<code>except</code>匹配，那么这个异常将会传递给上层的<code>try</code>中。</li></ul><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    f = open(<span class="hljs-string">'test.txt'</span>)    print(f.read())    f.close()<span class="hljs-keyword">except</span> OSError:    print(<span class="hljs-string">'打开文件出错'</span>)<span class="hljs-comment"># 打开文件出错</span></code></pre><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    f = open(<span class="hljs-string">'test.txt'</span>)    print(f.read())    f.close()<span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> error:    print(<span class="hljs-string">'打开文件出错\n原因是：'</span> + str(error))<span class="hljs-comment"># 打开文件出错</span><span class="hljs-comment"># 原因是：[Errno 2] No such file or directory: 'test.txt'</span></code></pre><p>一个<code>try</code>语句可能包含多个<code>except</code>子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    int(<span class="hljs-string">"abc"</span>)    s = <span class="hljs-number">1</span> + <span class="hljs-string">'1'</span>    f = open(<span class="hljs-string">'test.txt'</span>)    print(f.read())    f.close()<span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> error:    print(<span class="hljs-string">'打开文件出错\n原因是：'</span> + str(error))<span class="hljs-keyword">except</span> TypeError <span class="hljs-keyword">as</span> error:    print(<span class="hljs-string">'类型出错\n原因是：'</span> + str(error))<span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> error:    print(<span class="hljs-string">'数值出错\n原因是：'</span> + str(error))<span class="hljs-comment"># 数值出错</span><span class="hljs-comment"># 原因是：invalid literal for int() with base 10: 'abc'</span></code></pre><p>【例子】</p><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'v'</span>: <span class="hljs-number">22</span>&#125;<span class="hljs-keyword">try</span>:    x = dict1[<span class="hljs-string">'y'</span>]<span class="hljs-keyword">except</span> LookupError:    print(<span class="hljs-string">'查询错误'</span>)<span class="hljs-keyword">except</span> KeyError:    print(<span class="hljs-string">'键错误'</span>)<span class="hljs-keyword">else</span>:    print(x)<span class="hljs-comment"># 查询错误</span></code></pre><p><code>try-except-else</code>语句尝试查询不在<code>dict</code>中的键值对，从而引发了异常。这一异常准确地说应属于<code>KeyError</code>，但由于<code>KeyError</code>是<code>LookupError</code>的子类，且将<code>LookupError</code>置于<code>KeyError</code>之前，因此程序优先执行该<code>except</code>代码块。所以，使用多个<code>except</code>代码块时，必须坚持对其规范排序，要从最具针对性的异常到最通用的异常。</p><p>【例子】</p><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'v'</span>: <span class="hljs-number">22</span>&#125;<span class="hljs-keyword">try</span>:    x = dict1[<span class="hljs-string">'y'</span>]<span class="hljs-keyword">except</span> KeyError:    print(<span class="hljs-string">'键错误'</span>)<span class="hljs-keyword">except</span> LookupError:    print(<span class="hljs-string">'查询错误'</span>)<span class="hljs-keyword">else</span>:    print(x)<span class="hljs-comment"># 键错误</span></code></pre><p>【例子】一个 <code>except</code> 子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    s = <span class="hljs-number">1</span> + <span class="hljs-string">'1'</span>    int(<span class="hljs-string">"abc"</span>)    f = open(<span class="hljs-string">'test.txt'</span>)    print(f.read())    f.close()<span class="hljs-keyword">except</span> (OSError, TypeError, ValueError) <span class="hljs-keyword">as</span> error:    print(<span class="hljs-string">'出错了！\n原因是：'</span> + str(error))<span class="hljs-comment"># 出错了！</span><span class="hljs-comment"># 原因是：unsupported operand type(s) for +: 'int' and 'str'</span></code></pre><hr><h2 id="4-try-except-finally-语句"><a href="#4-try-except-finally-语句" class="headerlink" title="4. try - except - finally 语句"></a>4. try - except - finally 语句</h2><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    检测范围<span class="hljs-keyword">except</span> Exception[<span class="hljs-keyword">as</span> reason]:    出现异常后的处理代码<span class="hljs-keyword">finally</span>:    无论如何都会被执行的代码</code></pre><p>不管<code>try</code>子句里面有没有发生异常，<code>finally</code>子句都会执行。</p><p>如果一个异常在<code>try</code>子句里被抛出，而又没有任何的<code>except</code>把它截住，那么这个异常会在<code>finally</code>子句执行后被抛出。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">divide</span><span class="hljs-params">(x, y)</span>:</span>    <span class="hljs-keyword">try</span>:        result = x / y        print(<span class="hljs-string">"result is"</span>, result)    <span class="hljs-keyword">except</span> ZeroDivisionError:        print(<span class="hljs-string">"division by zero!"</span>)    <span class="hljs-keyword">finally</span>:        print(<span class="hljs-string">"executing finally clause"</span>)divide(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<span class="hljs-comment"># result is 2.0</span><span class="hljs-comment"># executing finally clause</span>divide(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)<span class="hljs-comment"># division by zero!</span><span class="hljs-comment"># executing finally clause</span>divide(<span class="hljs-string">"2"</span>, <span class="hljs-string">"1"</span>)<span class="hljs-comment"># executing finally clause</span><span class="hljs-comment"># TypeError: unsupported operand type(s) for /: 'str' and 'str'</span></code></pre><hr><h2 id="5-try-except-else-语句"><a href="#5-try-except-else-语句" class="headerlink" title="5. try - except - else 语句"></a>5. try - except - else 语句</h2><p>如果在<code>try</code>子句执行时没有发生异常，Python将执行<code>else</code>语句后的语句。</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    检测范围<span class="hljs-keyword">except</span>:    出现异常后的处理代码<span class="hljs-keyword">else</span>:    如果没有异常执行这块代码</code></pre><p>使用<code>except</code>而不带任何异常类型，这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息，因为它捕获所有的异常。</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    检测范围<span class="hljs-keyword">except</span>(Exception1[, Exception2[,...ExceptionN]]]):   发生以上多个异常中的一个，执行这块代码<span class="hljs-keyword">else</span>:    如果没有异常执行这块代码</code></pre><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    fh = open(<span class="hljs-string">"testfile"</span>, <span class="hljs-string">"w"</span>)    fh.write(<span class="hljs-string">"这是一个测试文件，用于测试异常!!"</span>)<span class="hljs-keyword">except</span> IOError:    print(<span class="hljs-string">"Error: 没有找到文件或读取文件失败"</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"内容写入文件成功"</span>)    fh.close()<span class="hljs-comment"># 内容写入文件成功</span></code></pre><p>注意：<code>else</code>语句的存在必须以<code>except</code>语句的存在为前提，在没有<code>except</code>语句的<code>try</code>语句中使用<code>else</code>语句，会引发语法错误。</p><hr><h2 id="6-raise语句"><a href="#6-raise语句" class="headerlink" title="6. raise语句"></a>6. raise语句</h2><p>Python 使用<code>raise</code>语句抛出一个指定的异常。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    <span class="hljs-keyword">raise</span> NameError(<span class="hljs-string">'HiThere'</span>)<span class="hljs-keyword">except</span> NameError:    print(<span class="hljs-string">'An exception flew by!'</span>)    <span class="hljs-comment"># An exception flew by!</span></code></pre><hr><p><strong>练习题</strong>：</p><p>1、猜数字游戏</p><p>题目描述:</p><p>电脑产生一个零到100之间的随机数字，然后让用户来猜，如果用户猜的数字比这个数字大，提示太大，否则提示太小，当用户正好猜中电脑会提示，”恭喜你猜到了这个数是……”。在用户每次猜测之前程序会输出用户是第几次猜测，如果用户输入的根本不是一个数字，程序会告诉用户”输入无效”。</p><p>(尝试使用try catch异常处理结构对输入情况进行处理)</p><p>获取随机数采用random模块。</p><p><img src="https://img-blog.csdnimg.cn/20200714230819193.png" srcset="/img/loading.gif" alt></p><pre><code class="hljs python"><span class="hljs-comment"># your code here</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;异常处理&quot;&gt;&lt;a href=&quot;#异常处理&quot; class=&quot;headerlink&quot; title=&quot;异常处理&quot;&gt;&lt;/a&gt;异常处理&lt;/h1&gt;&lt;p&gt;异常就是运行期检测到的错误。计算机语言针对可能出现的错误定义了异常类型，某种错误引发对应的异常时，异常处理程序将被启动，从而
      
    
    </summary>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python03-条件语句</title>
    <link href="https://sulimin-nb.github.io/article/22d0bd28.html"/>
    <id>https://sulimin-nb.github.io/article/22d0bd28.html</id>
    <published>2020-07-23T15:14:44.000Z</published>
    <updated>2020-07-24T05:11:00.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="1-if-语句"><a href="#1-if-语句" class="headerlink" title="1. if 语句"></a>1. if 语句</h2><pre><code class="hljs python"><span class="hljs-keyword">if</span> expression:    expr_true_suite</code></pre><ul><li>if 语句的 <code>expr_true_suite</code> 代码块只有当条件表达式 <code>expression</code> 结果为真时才执行，否则将继续执行紧跟在该代码块后面的语句。</li><li>单个 if 语句中的 <code>expression</code> 条件表达式可以通过布尔操作符 <code>and</code>，<code>or</code>和<code>not</code> 实现多重条件判断。</li></ul><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-number">2</span> &gt; <span class="hljs-number">3</span>:    print(<span class="hljs-string">'Correct Judgement!'</span>)<span class="hljs-comment"># Correct Judgement!</span></code></pre><h2 id="2-if-else-语句"><a href="#2-if-else-语句" class="headerlink" title="2. if - else 语句"></a>2. if - else 语句</h2><pre><code class="hljs python"><span class="hljs-keyword">if</span> expression:    expr_true_suite<span class="hljs-keyword">else</span>:    expr_false_suite</code></pre><ul><li>Python 提供与 if 搭配使用的 else，如果 if 语句的条件表达式结果布尔值为假，那么程序将执行 else 语句后的代码。</li></ul><p>【例子】</p><pre><code class="hljs python">temp = input(<span class="hljs-string">"猜一猜小姐姐想的是哪个数字？"</span>)guess = int(temp) <span class="hljs-comment"># input 函数将接收的任何数据类型都默认为 str。</span><span class="hljs-keyword">if</span> guess == <span class="hljs-number">666</span>:    print(<span class="hljs-string">"你太了解小姐姐的心思了！"</span>)    print(<span class="hljs-string">"哼，猜对也没有奖励！"</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"猜错了，小姐姐现在心里想的是666！"</span>)print(<span class="hljs-string">"游戏结束，不玩儿啦！"</span>)</code></pre><p><code>if</code>语句支持嵌套，即在一个<code>if</code>语句中嵌入另一个<code>if</code>语句，从而构成不同层次的选择结构。<strong>Python 使用缩进而不是大括号来标记代码块边界</strong>，因此要特别注意<code>else</code>的悬挂问题。</p><p>【例子】</p><pre><code class="hljs python">hi = <span class="hljs-number">6</span><span class="hljs-keyword">if</span> hi &gt; <span class="hljs-number">2</span>:    <span class="hljs-keyword">if</span> hi &gt; <span class="hljs-number">7</span>:        print(<span class="hljs-string">'好棒!好棒!'</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'切~'</span>)</code></pre><p>【例子】</p><pre><code class="hljs python">temp = input(<span class="hljs-string">"不妨猜一下小哥哥现在心里想的是那个数字："</span>)guess = int(temp)<span class="hljs-keyword">if</span> guess &gt; <span class="hljs-number">8</span>:    print(<span class="hljs-string">"大了，大了"</span>)<span class="hljs-keyword">else</span>:    <span class="hljs-keyword">if</span> guess == <span class="hljs-number">8</span>:        print(<span class="hljs-string">"你这么懂小哥哥的心思吗？"</span>)        print(<span class="hljs-string">"哼，猜对也没有奖励！"</span>)    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">"小了，小了"</span>)print(<span class="hljs-string">"游戏结束，不玩儿啦！"</span>)</code></pre><h2 id="3-if-elif-else-语句"><a href="#3-if-elif-else-语句" class="headerlink" title="3. if - elif - else 语句"></a>3. if - elif - else 语句</h2><pre><code class="hljs python"><span class="hljs-keyword">if</span> expression1:    expr1_true_suite<span class="hljs-keyword">elif</span> expression2:    expr2_true_suite    .    .<span class="hljs-keyword">elif</span> expressionN:    exprN_true_suite<span class="hljs-keyword">else</span>:    expr_false_suite</code></pre><ul><li>elif 语句即为 else if，用来检查多个表达式是否为真，并在为真时执行特定代码块中的代码。</li></ul><p>【例子】</p><pre><code class="hljs python">temp = input(<span class="hljs-string">'请输入成绩:'</span>)source = int(temp)<span class="hljs-keyword">if</span> <span class="hljs-number">100</span> &gt;= source &gt;= <span class="hljs-number">90</span>:    print(<span class="hljs-string">'A'</span>)<span class="hljs-keyword">elif</span> <span class="hljs-number">90</span> &gt; source &gt;= <span class="hljs-number">80</span>:    print(<span class="hljs-string">'B'</span>)<span class="hljs-keyword">elif</span> <span class="hljs-number">80</span> &gt; source &gt;= <span class="hljs-number">60</span>:    print(<span class="hljs-string">'C'</span>)<span class="hljs-keyword">elif</span> <span class="hljs-number">60</span> &gt; source &gt;= <span class="hljs-number">0</span>:    print(<span class="hljs-string">'D'</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'输入错误！'</span>)</code></pre><h2 id="4-assert-关键词"><a href="#4-assert-关键词" class="headerlink" title="4. assert 关键词"></a>4. assert 关键词</h2><ul><li><code>assert</code>这个关键词我们称之为“断言”，当这个关键词后边的条件为 False 时，程序自动崩溃并抛出<code>AssertionError</code>的异常。</li></ul><p>【例子】</p><pre><code class="hljs python">my_list = [<span class="hljs-string">'lsgogroup'</span>]my_list.pop(<span class="hljs-number">0</span>)<span class="hljs-keyword">assert</span> len(my_list) &gt; <span class="hljs-number">0</span><span class="hljs-comment"># AssertionError</span></code></pre><ul><li>在进行单元测试时，可以用来在程序中置入检查点，只有条件为 True 才能让程序正常工作。</li></ul><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">assert</span> <span class="hljs-number">3</span> &gt; <span class="hljs-number">7</span><span class="hljs-comment"># AssertionError</span></code></pre><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="1-while-循环"><a href="#1-while-循环" class="headerlink" title="1. while 循环"></a>1. while 循环</h2><p><code>while</code>语句最基本的形式包括一个位于顶部的布尔表达式，一个或多个属于<code>while</code>代码块的缩进语句。</p><pre><code class="hljs python"><span class="hljs-keyword">while</span> 布尔表达式:    代码块</code></pre><p><code>while</code>循环的代码块会一直循环执行，直到布尔表达式的值为布尔假。</p><p>如果布尔表达式不带有<code>&lt;、&gt;、==、！=、in、not in</code>等运算符，仅仅给出数值之类的条件，也是可以的。当<code>while</code>后写入一个非零整数时，视为真值，执行循环体；写入<code>0</code>时，视为假值，不执行循环体。也可以写入<code>str、list</code>或任何序列，长度非零则视为真值，执行循环体；否则视为假值，不执行循环体。</p><p>【例子】</p><pre><code class="hljs python">count = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">3</span>:    temp = input(<span class="hljs-string">"不妨猜一下小哥哥现在心里想的是那个数字："</span>)    guess = int(temp)    <span class="hljs-keyword">if</span> guess &gt; <span class="hljs-number">8</span>:        print(<span class="hljs-string">"大了，大了"</span>)    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">if</span> guess == <span class="hljs-number">8</span>:            print(<span class="hljs-string">"你是小哥哥心里的蛔虫吗？"</span>)            print(<span class="hljs-string">"哼，猜对也没有奖励！"</span>)            count = <span class="hljs-number">3</span>        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">"小了，小了"</span>)    count = count + <span class="hljs-number">1</span>print(<span class="hljs-string">"游戏结束，不玩儿啦！"</span>)</code></pre><p>【例子】布尔表达式返回0，循环终止。</p><pre><code class="hljs python">string = <span class="hljs-string">'abcd'</span><span class="hljs-keyword">while</span> string:    print(string)    string = string[<span class="hljs-number">1</span>:]<span class="hljs-comment"># abcd</span><span class="hljs-comment"># bcd</span><span class="hljs-comment"># cd</span><span class="hljs-comment"># d</span></code></pre><hr><h2 id="2-while-else-循环"><a href="#2-while-else-循环" class="headerlink" title="2. while - else 循环"></a>2. while - else 循环</h2><pre><code class="hljs python"><span class="hljs-keyword">while</span> 布尔表达式:    代码块<span class="hljs-keyword">else</span>:    代码块</code></pre><p><strong>当<code>while</code>循环正常执行完的情况下，执行<code>else</code>输出，如果<code>while</code>循环中执行了跳出循环的语句，比如 <code>break</code>，将不执行<code>else</code>代码块的内容。</strong>    </p><p>【例子】</p><pre><code class="hljs python">count = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">5</span>:    print(<span class="hljs-string">"%d is  less than 5"</span> % count)    count = count + <span class="hljs-number">1</span><span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"%d is not less than 5"</span> % count)    <span class="hljs-comment"># 0 is  less than 5</span><span class="hljs-comment"># 1 is  less than 5</span><span class="hljs-comment"># 2 is  less than 5</span><span class="hljs-comment"># 3 is  less than 5</span><span class="hljs-comment"># 4 is  less than 5</span><span class="hljs-comment"># 5 is not less than 5</span></code></pre><p>【例子】</p><pre><code class="hljs python">count = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">5</span>:    print(<span class="hljs-string">"%d is  less than 5"</span> % count)    count = <span class="hljs-number">6</span>    <span class="hljs-keyword">break</span><span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"%d is not less than 5"</span> % count)<span class="hljs-comment"># 0 is  less than 5</span></code></pre><hr><h2 id="3-for-循环"><a href="#3-for-循环" class="headerlink" title="3. for 循环"></a>3. for 循环</h2><p><code>for</code>循环是迭代循环，在Python中相当于一个通用的序列迭代器，可以遍历任何有序序列，如<code>str、list、tuple</code>等，也可以遍历任何可迭代对象，如<code>dict</code>。</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> 迭代变量 <span class="hljs-keyword">in</span> 可迭代对象:    代码块</code></pre><p>每次循环，迭代变量被设置为可迭代对象的当前元素，提供给代码块使用。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">'ILoveLSGO'</span>:    print(i, end=<span class="hljs-string">' '</span>)  <span class="hljs-comment"># 不换行输出</span><span class="hljs-comment"># I L o v e L S G O</span></code></pre><p>【例子】</p><pre><code class="hljs python">member = [<span class="hljs-string">'张三'</span>, <span class="hljs-string">'李四'</span>, <span class="hljs-string">'刘德华'</span>, <span class="hljs-string">'刘六'</span>, <span class="hljs-string">'周润发'</span>]<span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> member:    print(each)<span class="hljs-comment"># 张三</span><span class="hljs-comment"># 李四</span><span class="hljs-comment"># 刘德华</span><span class="hljs-comment"># 刘六</span><span class="hljs-comment"># 周润发</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(member)):    print(member[i])<span class="hljs-comment"># 张三</span><span class="hljs-comment"># 李四</span><span class="hljs-comment"># 刘德华</span><span class="hljs-comment"># 刘六</span><span class="hljs-comment"># 周润发</span></code></pre><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">4</span>&#125;<span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> dic.items():    print(key, value, sep=<span class="hljs-string">':'</span>, end=<span class="hljs-string">' '</span>)    <span class="hljs-comment"># a:1 b:2 c:3 d:4</span></code></pre><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">4</span>&#125;<span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dic.keys():    print(key, end=<span class="hljs-string">' '</span>)    <span class="hljs-comment"># a b c d</span></code></pre><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">4</span>&#125;<span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> dic.values():    print(value, end=<span class="hljs-string">' '</span>)    <span class="hljs-comment"># 1 2 3 4</span></code></pre><hr><h2 id="4-for-else-循环"><a href="#4-for-else-循环" class="headerlink" title="4. for - else 循环"></a>4. for - else 循环</h2><pre><code class="hljs python"><span class="hljs-keyword">for</span> 迭代变量 <span class="hljs-keyword">in</span> 可迭代对象:    代码块<span class="hljs-keyword">else</span>:    代码块</code></pre><p>当<code>for</code>循环正常执行完的情况下，执行<code>else</code>输出，如果<code>for</code>循环中执行了跳出循环的语句，比如 <code>break</code>，将不执行<code>else</code>代码块的内容，与<code>while - else</code>语句一样。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>):  <span class="hljs-comment"># 迭代 10 到 20 之间的数字</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, num):  <span class="hljs-comment"># 根据因子迭代</span>        <span class="hljs-keyword">if</span> num % i == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 确定第一个因子</span>            j = num / i  <span class="hljs-comment"># 计算第二个因子</span>            print(<span class="hljs-string">'%d 等于 %d * %d'</span> % (num, i, j))            <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 跳出当前循环</span>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 循环的 else 部分</span>        print(num, <span class="hljs-string">'是一个质数'</span>)<span class="hljs-comment"># 10 等于 2 * 5</span><span class="hljs-comment"># 11 是一个质数</span><span class="hljs-comment"># 12 等于 2 * 6</span><span class="hljs-comment"># 13 是一个质数</span><span class="hljs-comment"># 14 等于 2 * 7</span><span class="hljs-comment"># 15 等于 3 * 5</span><span class="hljs-comment"># 16 等于 2 * 8</span><span class="hljs-comment"># 17 是一个质数</span><span class="hljs-comment"># 18 等于 2 * 9</span><span class="hljs-comment"># 19 是一个质数</span></code></pre><hr><h2 id="5-range-函数"><a href="#5-range-函数" class="headerlink" title="5. range() 函数"></a>5. range() 函数</h2><pre><code class="hljs python">range([start,] stop[, step=<span class="hljs-number">1</span>])</code></pre><ul><li>这个BIF（Built-in functions内置函数）有三个参数，其中用中括号括起来的两个表示这两个参数是可选的。</li><li><code>step=1</code> 表示第三个参数的默认值是1。</li><li><code>range</code> 这个BIF的作用是生成一个从<code>start</code>参数的值开始到<code>stop</code>参数的值结束的数字序列，该序列包含<code>start</code>的值但不包含<code>stop</code>的值。</li></ul><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>):  <span class="hljs-comment"># 不包含9</span>    print(i)<span class="hljs-comment"># 2</span><span class="hljs-comment"># 3</span><span class="hljs-comment"># 4</span><span class="hljs-comment"># 5</span><span class="hljs-comment"># 6</span><span class="hljs-comment"># 7</span><span class="hljs-comment"># 8</span></code></pre><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>):    print(i)<span class="hljs-comment"># 1</span><span class="hljs-comment"># 3</span><span class="hljs-comment"># 5</span><span class="hljs-comment"># 7</span><span class="hljs-comment"># 9</span></code></pre><hr><h2 id="6-enumerate-函数"><a href="#6-enumerate-函数" class="headerlink" title="6. enumerate()函数"></a>6. enumerate()函数</h2><pre><code class="hljs python">enumerate(sequence, [start=<span class="hljs-number">0</span>])</code></pre><ul><li>sequence — 一个序列、迭代器或其他支持迭代对象。</li><li>start — 下标起始位置。</li><li>返回 enumerate(枚举) 对象</li></ul><p>【例子】</p><pre><code class="hljs python">seasons = [<span class="hljs-string">'Spring'</span>, <span class="hljs-string">'Summer'</span>, <span class="hljs-string">'Fall'</span>, <span class="hljs-string">'Winter'</span>]lst = list(enumerate(seasons))print(lst)<span class="hljs-comment"># [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]</span>lst = list(enumerate(seasons, start=<span class="hljs-number">1</span>))  <span class="hljs-comment"># 下标从 1 开始</span>print(lst)<span class="hljs-comment"># [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]</span></code></pre><p><code>enumerate()</code>与 for 循环的结合使用</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i, a <span class="hljs-keyword">in</span> enumerate(A)    do something <span class="hljs-keyword">with</span> a</code></pre><p>用 <code>enumerate(A)</code> 不仅返回了 <code>A</code> 中的元素，还顺便给该元素一个索引值 (默认从 0 开始)。此外，用 <code>enumerate(A, j)</code> 还可以确定索引起始值为 <code>j</code>。</p><p>【例子】</p><pre><code class="hljs python">languages = [<span class="hljs-string">'Python'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'Matlab'</span>, <span class="hljs-string">'C++'</span>]<span class="hljs-keyword">for</span> language <span class="hljs-keyword">in</span> languages:    print(<span class="hljs-string">'I love'</span>, language)print(<span class="hljs-string">'Done!'</span>)<span class="hljs-string">'''</span><span class="hljs-string">I love Python</span><span class="hljs-string">I love R</span><span class="hljs-string">I love Matlab</span><span class="hljs-string">I love C++</span><span class="hljs-string">Done!</span><span class="hljs-string">'''</span><span class="hljs-keyword">for</span> i, language <span class="hljs-keyword">in</span> enumerate(languages, <span class="hljs-number">2</span>):    print(i, <span class="hljs-string">'I love'</span>, language)print(<span class="hljs-string">'Done!'</span>)<span class="hljs-string">'''</span><span class="hljs-string">2 I love Python</span><span class="hljs-string">3 I love R</span><span class="hljs-string">4 I love Matlab</span><span class="hljs-string">5 I love C++</span><span class="hljs-string">Done!</span><span class="hljs-string">'''</span></code></pre><hr><h2 id="7-break-语句"><a href="#7-break-语句" class="headerlink" title="7. break 语句"></a>7. break 语句</h2><p><code>break</code>语句可以跳出当前所在层的循环。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> randomsecret = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">#[1,10]之间的随机数</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    temp = input(<span class="hljs-string">"不妨猜一下小哥哥现在心里想的是那个数字："</span>)    guess = int(temp)    <span class="hljs-keyword">if</span> guess &gt; secret:        print(<span class="hljs-string">"大了，大了"</span>)    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">if</span> guess == secret:            print(<span class="hljs-string">"你这样懂小哥哥的心思啊？"</span>)            print(<span class="hljs-string">"哼，猜对也没有奖励！"</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">"小了，小了"</span>)print(<span class="hljs-string">"游戏结束，不玩儿啦！"</span>)</code></pre><hr><h2 id="8-continue-语句"><a href="#8-continue-语句" class="headerlink" title="8. continue 语句"></a>8. continue 语句</h2><p><code>continue</code>终止本轮循环并开始下一轮循环。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):    <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:        print(i)        <span class="hljs-keyword">continue</span>    i += <span class="hljs-number">2</span>    print(i)<span class="hljs-comment"># 2</span><span class="hljs-comment"># 1</span><span class="hljs-comment"># 4</span><span class="hljs-comment"># 3</span><span class="hljs-comment"># 6</span><span class="hljs-comment"># 5</span><span class="hljs-comment"># 8</span><span class="hljs-comment"># 7</span><span class="hljs-comment"># 10</span><span class="hljs-comment"># 9</span></code></pre><hr><h2 id="9-pass-语句"><a href="#9-pass-语句" class="headerlink" title="9. pass 语句"></a>9. pass 语句</h2><p><code>pass</code> 语句的意思是“不做任何事”，如果你在需要有语句的地方不写任何语句，那么解释器会提示出错，而 <code>pass</code> 语句就是用来解决这些问题的。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a_func</span><span class="hljs-params">()</span>:</span><span class="hljs-comment"># SyntaxError: unexpected EOF while parsing</span></code></pre><p>【例子】</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a_func</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">pass</span></code></pre><p><code>pass</code>是空语句，不做任何操作，只起到占位的作用，其作用是为了保持程序结构的完整性。尽管<code>pass</code>语句不做任何操作，但如果暂时不确定要在一个位置放上什么样的代码，可以先放置一个<code>pass</code>语句，让代码可以正常运行。</p><hr><h2 id="10-推导式"><a href="#10-推导式" class="headerlink" title="10. 推导式"></a>10. 推导式</h2><p><strong>列表推导式</strong></p><pre><code class="hljs python">[ expr <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> collection [<span class="hljs-keyword">if</span> condition] ]</code></pre><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-number">-4</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]y = [a * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> x]print(y)<span class="hljs-comment"># [-8, -4, 0, 4, 8]</span></code></pre><p>【例子】</p><pre><code class="hljs python">x = [i ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)]print(x)<span class="hljs-comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></code></pre><p>【例子】</p><pre><code class="hljs python">x = [(i, i ** <span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">6</span>)]print(x)<span class="hljs-comment"># [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]</span></code></pre><p>【例子】</p><pre><code class="hljs python">x = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>) <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> (i % <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>]print(x)<span class="hljs-comment"># [3, 9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99]</span></code></pre><p>【例子】</p><pre><code class="hljs python">a = [(i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)]print(a)<span class="hljs-comment"># [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]</span></code></pre><p>【例子】</p><pre><code class="hljs python">x = [[i, j] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)]print(x)<span class="hljs-comment"># [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]</span>x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>print(x)<span class="hljs-comment"># [[10, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]</span></code></pre><p>【例子】</p><pre><code class="hljs python">a = [(i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">if</span> j &gt; <span class="hljs-number">1</span>]print(a)<span class="hljs-comment"># [(0, 2)]</span></code></pre><p><strong>元组推导式</strong></p><pre><code class="hljs python">( expr <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> collection [<span class="hljs-keyword">if</span> condition] )</code></pre><p>【例子】</p><pre><code class="hljs python">a = (x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>))print(a)<span class="hljs-comment"># &lt;generator object &lt;genexpr&gt; at 0x0000025BE511CC48&gt;</span>print(tuple(a))<span class="hljs-comment"># (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)</span></code></pre><p><strong>字典推导式</strong></p><pre><code class="hljs python">&#123; key_expr: value_expr <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> collection [<span class="hljs-keyword">if</span> condition] &#125;</code></pre><p>【例子】</p><pre><code class="hljs python">b = &#123;i: i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>&#125;print(b)<span class="hljs-comment"># &#123;0: True, 3: False, 6: True, 9: False&#125;</span></code></pre><p><strong>集合推导式</strong></p><pre><code class="hljs clojure">&#123; expr for value in collection [if condition] &#125;</code></pre><p>【例子】</p><pre><code class="hljs python">c = &#123;i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]&#125;print(c)<span class="hljs-comment"># &#123;1, 2, 3, 4, 5, 6&#125;</span></code></pre><p><strong>其它</strong></p><pre><code class="hljs python">d = <span class="hljs-string">'i for i in "I Love Lsgogroup"'</span>print(d)<span class="hljs-comment"># i for i in "I Love Lsgogroup"</span>e = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>))print(e)<span class="hljs-comment"># &lt;generator object &lt;genexpr&gt; at 0x0000007A0B8D01B0&gt;</span>print(next(e))  <span class="hljs-comment"># 0</span>print(next(e))  <span class="hljs-comment"># 1</span><span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> e:    print(each, end=<span class="hljs-string">' '</span>)<span class="hljs-comment"># 2 3 4 5 6 7 8 9</span>s = sum([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">101</span>)])print(s)  <span class="hljs-comment"># 5050</span>s = sum((i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">101</span>)))print(s)  <span class="hljs-comment"># 5050</span></code></pre><hr><h2 id="11-综合例子"><a href="#11-综合例子" class="headerlink" title="11. 综合例子"></a>11. 综合例子</h2><pre><code class="hljs python">passwdList = [<span class="hljs-string">'123'</span>, <span class="hljs-string">'345'</span>, <span class="hljs-string">'890'</span>]valid = <span class="hljs-literal">False</span>count = <span class="hljs-number">3</span><span class="hljs-keyword">while</span> count &gt; <span class="hljs-number">0</span>:    password = input(<span class="hljs-string">'enter password:'</span>)    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> passwdList:        <span class="hljs-keyword">if</span> password == item:            valid = <span class="hljs-literal">True</span>            <span class="hljs-keyword">break</span>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> valid:        print(<span class="hljs-string">'invalid input'</span>)        count -= <span class="hljs-number">1</span>        <span class="hljs-keyword">continue</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">break</span></code></pre><hr><p><strong>参考文献</strong>：</p><ul><li><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-tutorial.html</a></li><li><a href="https://www.bilibili.com/video/av4050443" target="_blank" rel="noopener">https://www.bilibili.com/video/av4050443</a></li><li><a href="https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ</a></li></ul><hr><p><strong>练习题</strong>：</p><p>1、编写一个Python程序来查找那些可以被7除以5的整数的数字，介于1500和2700之间。</p><pre><code class="hljs python"><span class="hljs-comment"># your code here</span></code></pre><p>2、龟兔赛跑游戏</p><p>题目描述：</p><p>话说这个世界上有各种各样的兔子和乌龟，但是研究发现，所有的兔子和乌龟都有一个共同的特点——喜欢赛跑。于是世界上各个角落都不断在发生着乌龟和兔子的比赛，小华对此很感兴趣，于是决定研究不同兔  子和乌龟的赛跑。他发现，兔子虽然跑比乌龟快，但它们有众所周知的毛病——骄傲且懒惰，于是在与乌龟的比赛中，一旦任一秒结束后兔子发现自己领先t米或以  上，它们就会停下来休息s秒。对于不同的兔子，t，s的数值是不同的，但是所有的乌龟却是一致——它们不到终点决不停止。 </p><p>然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子和乌龟的数据——兔子的速度v1（表示每秒兔子能跑v1  米），乌龟的速度v2，以及兔子对应的t，s值，以及赛道的长度l——就能预测出比赛的结果。但是小华很懒，不想通过手工计算推测出比赛的结果，于是他找 到了你——清华大学计算机系的高才生——请求帮助，请你写一个程序，对于输入的一场比赛的数据v1，v2，t，s，l，预测该场比赛的结果。</p><p>输入:</p><p>输入只有一行，包含用空格隔开的五个正整数v1，v2，t，s，l，其中(v1,v2&lt; =100;t&lt; =300;s&lt; =10;l&lt; =10000且为v1,v2的公倍数) </p><p>输出:</p><p>输出包含两行，第一行输出比赛结果——一个大写字母“T”或“R”或“D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点。 </p><p>第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）。 </p><hr><p>样例输入：</p><p>10  5  5  2  20 </p><p>样例输出</p><p>D<br><br>4</p><pre><code class="hljs python"><span class="hljs-comment"># your code here</span></code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;条件语句&quot;&gt;&lt;a href=&quot;#条件语句&quot; class=&quot;headerlink&quot; title=&quot;条件语句&quot;&gt;&lt;/a&gt;条件语句&lt;/h1&gt;&lt;h2 id=&quot;1-if-语句&quot;&gt;&lt;a href=&quot;#1-if-语句&quot; class=&quot;headerlink&quot; title=&quot;1. 
      
    
    </summary>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python02-位运算</title>
    <link href="https://sulimin-nb.github.io/article/392be851.html"/>
    <id>https://sulimin-nb.github.io/article/392be851.html</id>
    <published>2020-07-23T15:09:34.000Z</published>
    <updated>2020-07-24T00:37:51.049Z</updated>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="1-原码、反码和补码"><a href="#1-原码、反码和补码" class="headerlink" title="1. 原码、反码和补码"></a>1. 原码、反码和补码</h2><p>二进制有三种不同的表示形式：原码、反码和补码，<u>计算机内部使用补码来表示</u>。</p><p><strong>原码</strong>：就是其二进制表示（注意，有一位符号位）。</p><pre><code class="hljs python">00 00 00 11 -&gt; 310 00 00 11 -&gt; -3</code></pre><p><strong>反码</strong>：正数的反码就是原码，负数的反码是符号位不变，其余位取反（对应正数按位取反）。</p><pre><code class="hljs python">00 00 00 11 -&gt; 311 11 11 00 -&gt; -3</code></pre><p><strong>补码</strong>：正数的补码就是原码，负数的补码是反码+1。</p><pre><code class="hljs python">00 00 00 11 -&gt; 311 11 11 01 -&gt; -3</code></pre><p><strong>符号位</strong>：最高位为符号位，0表示正数，1表示负数。在位运算中符号位也参与运算。</p><h2 id="2-按位非操作"><a href="#2-按位非操作" class="headerlink" title="2. 按位非操作 ~"></a>2. 按位非操作 ~</h2><pre><code class="hljs python">~ <span class="hljs-number">1</span> = <span class="hljs-number">0</span>~ <span class="hljs-number">0</span> = <span class="hljs-number">1</span></code></pre><p><code>~</code> 把<code>num</code>的补码中的 0 和 1 全部取反（0 变为 1，1 变为 0）有符号整数的符号位在 <code>~</code> 运算中同样会取反。</p><pre><code class="hljs python">00 00 01 01 -&gt; 5~---11 11 10 10 -&gt; -611 11 10 11 -&gt; -5~---00 00 01 00 -&gt; 4</code></pre><h2 id="3-按位与操作-amp"><a href="#3-按位与操作-amp" class="headerlink" title="3. 按位与操作 &amp;"></a>3. 按位与操作 &amp;</h2><pre><code class="hljs python"><span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span> = <span class="hljs-number">1</span><span class="hljs-number">1</span> &amp; <span class="hljs-number">0</span> = <span class="hljs-number">0</span><span class="hljs-number">0</span> &amp; <span class="hljs-number">1</span> = <span class="hljs-number">0</span><span class="hljs-number">0</span> &amp; <span class="hljs-number">0</span> = <span class="hljs-number">0</span></code></pre><p>只有两个对应位都为 1 时才为 1</p><pre><code class="hljs python">00 00 01 01 -&gt; 5&amp;00 00 01 10 -&gt; 6---00 00 01 00 -&gt; 4</code></pre><h2 id="4-按位或操作"><a href="#4-按位或操作" class="headerlink" title="4. 按位或操作 |"></a>4. 按位或操作 |</h2><pre><code class="hljs python"><span class="hljs-number">1</span> | <span class="hljs-number">1</span> = <span class="hljs-number">1</span><span class="hljs-number">1</span> | <span class="hljs-number">0</span> = <span class="hljs-number">1</span><span class="hljs-number">0</span> | <span class="hljs-number">1</span> = <span class="hljs-number">1</span><span class="hljs-number">0</span> | <span class="hljs-number">0</span> = <span class="hljs-number">0</span></code></pre><p>只要两个对应位中有一个 1 时就为 1</p><pre><code class="hljs python">00 00 01 01 -&gt; 5|00 00 01 10 -&gt; 6---00 00 01 11 -&gt; 7</code></pre><h2 id="5-按位异或操作"><a href="#5-按位异或操作" class="headerlink" title="5. 按位异或操作 ^"></a>5. 按位异或操作 ^</h2><pre><code class="hljs python"><span class="hljs-number">1</span> ^ <span class="hljs-number">1</span> = <span class="hljs-number">0</span><span class="hljs-number">1</span> ^ <span class="hljs-number">0</span> = <span class="hljs-number">1</span><span class="hljs-number">0</span> ^ <span class="hljs-number">1</span> = <span class="hljs-number">1</span><span class="hljs-number">0</span> ^ <span class="hljs-number">0</span> = <span class="hljs-number">0</span></code></pre><p>只有两个对应位不同时才为 1</p><pre><code class="hljs python">00 00 01 01 -&gt; 5^00 00 01 10 -&gt; 6---00 00 00 11 -&gt; 3</code></pre><p>异或操作的性质：满足交换律和结合律</p><pre><code class="hljs python">A: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span>B: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">11</span>A^B: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>B^A: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>A^A: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>A^<span class="hljs-number">0</span>: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span>A^B^A: = A^A^B = <span class="hljs-number">0</span>^B = <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">11</span></code></pre><h2 id="6-按位左移操作-lt-lt"><a href="#6-按位左移操作-lt-lt" class="headerlink" title="6. 按位左移操作 &lt;&lt;"></a>6. 按位左移操作 &lt;&lt;</h2><p><code>num &lt;&lt; i</code> 将<code>num</code>的二进制表示向左移动<code>i</code>位所得的值。</p><pre><code class="hljs python">00 00 10 11 -&gt; 11<span class="hljs-number">11</span> &lt;&lt; <span class="hljs-number">3</span>---01 01 10 00 -&gt; 88 = 11 x 8</code></pre><h2 id="7-按位右移操作-gt-gt"><a href="#7-按位右移操作-gt-gt" class="headerlink" title="7. 按位右移操作 &gt;&gt;"></a>7. 按位右移操作 &gt;&gt;</h2><p><code>num &gt;&gt; i</code> 将<code>num</code>的二进制表示向右移动<code>i</code>位所得的值。</p><pre><code class="hljs python">00 00 10 11 -&gt; 11<span class="hljs-number">11</span> &gt;&gt; <span class="hljs-number">2</span>---00 00 00 10 -&gt; 2 = 11 // 4</code></pre><h2 id="8-利用位运算实现快速计算"><a href="#8-利用位运算实现快速计算" class="headerlink" title="8. 利用位运算实现快速计算"></a>8. 利用位运算实现快速计算</h2><p>通过 <code>&lt;&lt;</code>，<code>&gt;&gt;</code> 快速计算2的倍数问题。</p><pre><code class="hljs excel"><span class="hljs-built_in">n</span> &lt;&lt; <span class="hljs-number">1</span> -&gt; 计算 <span class="hljs-built_in">n</span>*<span class="hljs-number">2</span><span class="hljs-built_in">n</span> &gt;&gt; <span class="hljs-number">1</span> -&gt; 计算 <span class="hljs-built_in">n</span>//<span class="hljs-number">2</span>，负奇数的运算不可用<span class="hljs-built_in">n</span> &lt;&lt; m -&gt; 计算 <span class="hljs-built_in">n</span>*(<span class="hljs-number">2</span>^m)，即乘以 <span class="hljs-number">2</span> 的 m 次方<span class="hljs-built_in">n</span> &gt;&gt; m -&gt; 计算 <span class="hljs-built_in">n</span>//(<span class="hljs-number">2</span>^m)，即除以 <span class="hljs-number">2</span> 的 m 次方<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">n</span> -&gt; <span class="hljs-number">2</span>^<span class="hljs-built_in">n</span></code></pre><p>通过 <code>^</code> 快速交换两个整数。</p><pre><code class="hljs c">a ^= bb ^= aa ^= b</code></pre><p>通过 <code>a &amp; (-a)</code> 快速获取<code>a</code>的最后为 1 位置的整数。</p><p><span style="color:blue">(-a) = a的补码+1，最后一个1之后的0全变为1，+1后为0，进一000位后，原先的最后一个1保持不变。</span></p><pre><code class="hljs c"><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span> -&gt; <span class="hljs-number">5</span>&amp;<span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> -&gt; <span class="hljs-number">-5</span>---<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> -&gt; <span class="hljs-number">1</span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">11</span> <span class="hljs-number">10</span> -&gt; <span class="hljs-number">14</span>&amp;<span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> -&gt; <span class="hljs-number">-14</span>---<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> -&gt; <span class="hljs-number">2</span></code></pre><h2 id="9-利用位运算实现整数集合"><a href="#9-利用位运算实现整数集合" class="headerlink" title="9. 利用位运算实现整数集合"></a>9. 利用位运算实现整数集合</h2><p>一个数的二进制表示可以看作是一个集合（0 表示不在集合中，1 表示在集合中）。</p><p>比如集合 <code>{1, 3, 4, 8}</code>，可以表示成 <code>01 00 01 10 10(876543210,1表示在集合中,0表示不在集合中)</code> 而对应的位运算也就可以看作是对集合进行的操作。</p><p>元素与集合的操作：</p><pre><code class="hljs livescript">a | <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>&lt;&lt;i)</span>  -&gt;</span> 把 i 插入到集合中a &amp; ~<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>&lt;&lt;i)</span> -&gt;</span> 把 i 从集合中删除a &amp; <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>&lt;&lt;i)</span>  -&gt;</span> 判断 i 是否属于该集合（<span class="hljs-number">0</span>:不属于，<span class="hljs-number">1</span>:属于）</code></pre><p>集合之间的操作：</p><pre><code class="hljs c">a 补   -&gt; ~aa 交 b -&gt; a &amp; ba 并 b -&gt; a | ba 差 b -&gt; a &amp; (~b)</code></pre><p>注意：整数在内存中是以补码的形式存在的，输出自然也是按照补码输出。</p><p>【例子】C#语言输出负数。</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span><span class="hljs-params">(<span class="hljs-built_in">string</span>[] args)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">string</span> s1 = Convert.ToString(<span class="hljs-number">-3</span>, <span class="hljs-number">2</span>);        <span class="hljs-built_in">Console</span>.WriteLine(s1);         <span class="hljs-comment">// 11111111111111111111111111111101</span>                <span class="hljs-built_in">string</span> s2 = Convert.ToString(<span class="hljs-number">-3</span>, <span class="hljs-number">16</span>);        <span class="hljs-built_in">Console</span>.WriteLine(s2);         <span class="hljs-comment">// fffffffd</span>    &#125;&#125;</code></pre><p>【例子】 Python 的<code>bin()</code> 输出。</p><pre><code class="hljs python">print(bin(<span class="hljs-number">3</span>))  <span class="hljs-comment"># 0b11</span>print(bin(<span class="hljs-number">-3</span>))  <span class="hljs-comment"># -0b11</span>print(bin(<span class="hljs-number">-3</span> &amp; <span class="hljs-number">0xffffffff</span>))  <span class="hljs-comment"># 0b11111111111111111111111111111101</span>print(bin(<span class="hljs-number">0xfffffffd</span>))       <span class="hljs-comment"># 0b11111111111111111111111111111101</span>print(<span class="hljs-number">0xfffffffd</span>)  <span class="hljs-comment"># 4294967293</span></code></pre><p>是不是很颠覆认知，我们从结果可以看出：</p><ul><li>Python中<code>bin</code>一个负数（十进制表示），输出的是它的原码的二进制表示加上个负号，巨坑。</li><li>Python中的整型是补码形式存储的。</li><li>Python中整型是不限制长度的不会超范围溢出。</li></ul><p>所以为了获得负数（十进制表示）的补码，需要手动将其和十六进制数<code>0xffffffff</code>进行按位与操作，再交给<code>bin()</code>进行输出，得到的才是负数的补码表示。</p><hr><p><strong>练习题</strong>：</p><p>leetcode 习题 136. 只出现一次的数字</p><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>尝试使用位运算解决此题。</p><p>题目说明:</p><pre><code class="hljs python"><span class="hljs-string">"""</span><span class="hljs-string">Input file</span><span class="hljs-string">example1: [2,2,1]</span><span class="hljs-string">example2: [4,1,2,1,2]</span><span class="hljs-string"></span><span class="hljs-string">Output file</span><span class="hljs-string">result1: 1</span><span class="hljs-string">result2: 4</span><span class="hljs-string">"""</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(self, nums: List[int])</span> -&gt; int:</span>        <span class="hljs-comment"># your code here</span>        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x,y: x^y, nums)</code></pre><p>思路：</p><p>$a \bigoplus a = 0$, $0 \bigoplus a=a$,$0 \bigoplus 0=0$,所以把所有数字做异或操作，得到$(a_1 \bigoplus a_1) \bigoplus (a_2 \bigoplus a_2) \bigoplus \ldots (a_n) = a_n$</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;位运算&quot;&gt;&lt;a href=&quot;#位运算&quot; class=&quot;headerlink&quot; title=&quot;位运算&quot;&gt;&lt;/a&gt;位运算&lt;/h1&gt;&lt;h2 id=&quot;1-原码、反码和补码&quot;&gt;&lt;a href=&quot;#1-原码、反码和补码&quot; class=&quot;headerlink&quot; title=&quot;1
      
    
    </summary>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python01-变量、运算符与数据类型</title>
    <link href="https://sulimin-nb.github.io/article/fcab5e80.html"/>
    <id>https://sulimin-nb.github.io/article/fcab5e80.html</id>
    <published>2020-07-22T15:26:59.000Z</published>
    <updated>2020-07-24T04:32:39.061Z</updated>
    
    <content type="html"><![CDATA[<h1 id="变量、运算符与数据类型"><a href="#变量、运算符与数据类型" class="headerlink" title="变量、运算符与数据类型"></a>变量、运算符与数据类型</h1><h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h2><ul><li>在 Python 中，<code>#</code> 表示注释，作用于整行。</li></ul><p>【例子】单行注释</p><pre><code class="hljs python"><span class="hljs-comment"># 这是一个注释</span>print(<span class="hljs-string">"Hello world"</span>)<span class="hljs-comment"># Hello world</span></code></pre><ul><li><code>&#39;&#39;&#39; &#39;&#39;&#39;</code> 或者 <code>&quot;&quot;&quot; &quot;&quot;&quot;</code> 表示区间注释，在三引号之间的所有内容被注释</li></ul><p>【例子】多行注释</p><pre><code class="hljs python"><span class="hljs-string">'''</span><span class="hljs-string">这是多行注释，用三个单引号</span><span class="hljs-string">这是多行注释，用三个单引号</span><span class="hljs-string">这是多行注释，用三个单引号</span><span class="hljs-string">'''</span>print(<span class="hljs-string">"Hello china"</span>) <span class="hljs-comment"># Hello china</span><span class="hljs-string">"""</span><span class="hljs-string">这是多行注释，用三个双引号</span><span class="hljs-string">这是多行注释，用三个双引号 </span><span class="hljs-string">这是多行注释，用三个双引号</span><span class="hljs-string">"""</span>print(<span class="hljs-string">"hello china"</span>) <span class="hljs-comment"># hello china</span></code></pre><h2 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h2><p><b>算术运算符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>+</code></td><td style="text-align:center">加</td><td style="text-align:center"><code>1 + 1</code></td></tr><tr><td style="text-align:center"><code>-</code></td><td style="text-align:center">减</td><td style="text-align:center"><code>2 - 1</code></td></tr><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center">乘</td><td style="text-align:center"><code>3 * 4</code></td></tr><tr><td style="text-align:center"><code>/</code></td><td style="text-align:center">除</td><td style="text-align:center"><code>3 / 4</code></td></tr><tr><td style="text-align:center"><code>//</code></td><td style="text-align:center">整除（地板除）</td><td style="text-align:center"><code>3 // 4</code></td></tr><tr><td style="text-align:center"><code>%</code></td><td style="text-align:center">取余</td><td style="text-align:center"><code>3 % 4</code></td></tr><tr><td style="text-align:center"><code>**</code></td><td style="text-align:center">幂</td><td style="text-align:center"><code>2 ** 3</code></td></tr></tbody></table></div><p>【例子】</p><pre><code class="hljs python">print(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 2</span>print(<span class="hljs-number">2</span> - <span class="hljs-number">1</span>)  <span class="hljs-comment"># 1</span>print(<span class="hljs-number">3</span> * <span class="hljs-number">4</span>)  <span class="hljs-comment"># 12</span>print(<span class="hljs-number">3</span> / <span class="hljs-number">4</span>)  <span class="hljs-comment"># 0.75</span>print(<span class="hljs-number">3</span> // <span class="hljs-number">4</span>)  <span class="hljs-comment"># 0</span>print(<span class="hljs-number">3</span> % <span class="hljs-number">4</span>)  <span class="hljs-comment"># 3</span>print(<span class="hljs-number">2</span> ** <span class="hljs-number">3</span>)  <span class="hljs-comment"># 8</span></code></pre><p><b>比较运算符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>&gt;</code></td><td style="text-align:center">大于</td><td style="text-align:center"><code>2 &gt; 1</code></td></tr><tr><td style="text-align:center"><code>&gt;=</code></td><td style="text-align:center">大于等于</td><td style="text-align:center"><code>2 &gt;= 4</code></td></tr><tr><td style="text-align:center"><code>&lt;</code></td><td style="text-align:center">小于</td><td style="text-align:center"><code>1 &lt; 2</code></td></tr><tr><td style="text-align:center"><code>&lt;=</code></td><td style="text-align:center">小于等于</td><td style="text-align:center"><code>5 &lt;= 2</code></td></tr><tr><td style="text-align:center"><code>==</code></td><td style="text-align:center">等于</td><td style="text-align:center"><code>3 == 4</code></td></tr><tr><td style="text-align:center"><code>!=</code></td><td style="text-align:center">不等于</td><td style="text-align:center"><code>3 != 5</code></td></tr></tbody></table></div><p>【例子】</p><pre><code class="hljs python">print(<span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span>)  <span class="hljs-comment"># True</span>print(<span class="hljs-number">2</span> &gt;= <span class="hljs-number">4</span>)  <span class="hljs-comment"># False</span>print(<span class="hljs-number">1</span> &lt; <span class="hljs-number">2</span>)  <span class="hljs-comment"># True</span>print(<span class="hljs-number">5</span> &lt;= <span class="hljs-number">2</span>)  <span class="hljs-comment"># False</span>print(<span class="hljs-number">3</span> == <span class="hljs-number">4</span>)  <span class="hljs-comment"># False</span>print(<span class="hljs-number">3</span> != <span class="hljs-number">5</span>)  <span class="hljs-comment"># True</span></code></pre><p><b>逻辑运算符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>and</code></td><td style="text-align:center">与</td><td style="text-align:center"><code>(3 &gt; 2) and (3 &lt; 5)</code></td></tr><tr><td style="text-align:center"><code>or</code></td><td style="text-align:center">或</td><td style="text-align:center"><code>(1 &gt; 3) or (9 &lt; 2)</code></td></tr><tr><td style="text-align:center"><code>not</code></td><td style="text-align:center">非</td><td style="text-align:center"><code>not (2 &gt; 1)</code></td></tr></tbody></table></div><p>【例子】</p><pre><code class="hljs python">print((<span class="hljs-number">3</span> &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">and</span> (<span class="hljs-number">3</span> &lt; <span class="hljs-number">5</span>))  <span class="hljs-comment"># True</span>print((<span class="hljs-number">1</span> &gt; <span class="hljs-number">3</span>) <span class="hljs-keyword">or</span> (<span class="hljs-number">9</span> &lt; <span class="hljs-number">2</span>))  <span class="hljs-comment"># False</span>print(<span class="hljs-keyword">not</span> (<span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span>))  <span class="hljs-comment"># False</span></code></pre><p><b>位运算符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>~</code></td><td style="text-align:center">按位取反</td><td style="text-align:center"><code>~4</code></td></tr><tr><td style="text-align:center"><code>&amp;</code></td><td style="text-align:center">按位与</td><td style="text-align:center"><code>4 &amp; 5</code></td></tr><tr><td style="text-align:center">`</td><td style="text-align:center">`</td><td style="text-align:center">按位或</td><td>`4</td><td>5`</td></tr><tr><td style="text-align:center"><code>^</code></td><td style="text-align:center">按位异或</td><td style="text-align:center"><code>4 ^ 5</code></td></tr><tr><td style="text-align:center"><code>&lt;&lt;</code></td><td style="text-align:center">左移</td><td style="text-align:center"><code>4 &lt;&lt; 2</code></td></tr><tr><td style="text-align:center"><code>&gt;&gt;</code></td><td style="text-align:center">右移</td><td style="text-align:center"><code>4 &gt;&gt; 2</code></td></tr></tbody></table></div><p>【例子】有关二进制的运算，参见“位运算”部分的讲解。</p><pre><code class="hljs python">print(bin(<span class="hljs-number">4</span>))  <span class="hljs-comment"># 0b100</span>print(bin(<span class="hljs-number">5</span>))  <span class="hljs-comment"># 0b101</span>print(bin(~<span class="hljs-number">4</span>), ~<span class="hljs-number">4</span>)  <span class="hljs-comment"># -0b101 -5</span>print(bin(<span class="hljs-number">4</span> &amp; <span class="hljs-number">5</span>), <span class="hljs-number">4</span> &amp; <span class="hljs-number">5</span>)  <span class="hljs-comment"># 0b100 4</span>print(bin(<span class="hljs-number">4</span> | <span class="hljs-number">5</span>), <span class="hljs-number">4</span> | <span class="hljs-number">5</span>)  <span class="hljs-comment"># 0b101 5</span>print(bin(<span class="hljs-number">4</span> ^ <span class="hljs-number">5</span>), <span class="hljs-number">4</span> ^ <span class="hljs-number">5</span>)  <span class="hljs-comment"># 0b1 1</span>print(bin(<span class="hljs-number">4</span> &lt;&lt; <span class="hljs-number">2</span>), <span class="hljs-number">4</span> &lt;&lt; <span class="hljs-number">2</span>)  <span class="hljs-comment"># 0b10000 16</span>print(bin(<span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">2</span>), <span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">2</span>)  <span class="hljs-comment"># 0b1 1</span></code></pre><p><b>三元运算符</b></p><p>【例子】</p><pre><code class="hljs python">x, y = <span class="hljs-number">4</span>, <span class="hljs-number">5</span><span class="hljs-keyword">if</span> x &lt; y:    small = x<span class="hljs-keyword">else</span>:    small = yprint(small)  <span class="hljs-comment"># 4</span></code></pre><p>有了这个三元操作符的条件表达式，你可以使用一条语句来完成以上的条件判断和赋值操作。</p><p>【例子】</p><pre><code class="hljs python">x, y = <span class="hljs-number">4</span>, <span class="hljs-number">5</span>small = x <span class="hljs-keyword">if</span> x &lt; y <span class="hljs-keyword">else</span> yprint(small)  <span class="hljs-comment"># 4</span></code></pre><p><b>其他运算符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>in</code></td><td style="text-align:center">存在</td><td style="text-align:center"><code>&#39;A&#39; in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></td></tr><tr><td style="text-align:center"><code>not in</code></td><td style="text-align:center">不存在</td><td style="text-align:center"><code>&#39;h&#39; not in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></td></tr><tr><td style="text-align:center"><code>is</code></td><td style="text-align:center">是</td><td style="text-align:center"><code>&quot;hello&quot; is &quot;hello&quot;</code></td></tr><tr><td style="text-align:center"><code>is not</code></td><td style="text-align:center">不是</td><td style="text-align:center"><code>&quot;hello&quot; is not &quot;hello&quot;</code></td></tr></tbody></table></div><p>【例子】</p><pre><code class="hljs python">letters = [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>]<span class="hljs-keyword">if</span> <span class="hljs-string">'A'</span> <span class="hljs-keyword">in</span> letters:    print(<span class="hljs-string">'A'</span> + <span class="hljs-string">' exists'</span>)<span class="hljs-keyword">if</span> <span class="hljs-string">'h'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> letters:    print(<span class="hljs-string">'h'</span> + <span class="hljs-string">' not exists'</span>)<span class="hljs-comment"># A exists</span><span class="hljs-comment"># h not exists</span></code></pre><p>【例子】比较的两个变量均指向不可变类型。</p><pre><code class="hljs python">a = <span class="hljs-string">"hello"</span>b = <span class="hljs-string">"hello"</span>print(a <span class="hljs-keyword">is</span> b, a == b)  <span class="hljs-comment"># True True</span>print(a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> b, a != b)  <span class="hljs-comment"># False False</span>print(id(a)) <span class="hljs-comment"># 2085367637744</span>print(id(b)) <span class="hljs-comment"># 2085367637744</span></code></pre><p>【例子】比较的两个变量均指向可变类型。</p><pre><code class="hljs python">a = [<span class="hljs-string">"hello"</span>]b = [<span class="hljs-string">"hello"</span>]print(a <span class="hljs-keyword">is</span> b, a == b)  <span class="hljs-comment"># False True</span>print(a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> b, a != b)  <span class="hljs-comment"># True False</span>print(id(a)) <span class="hljs-comment"># 2085336762952</span>print(id(b)) <span class="hljs-comment"># 2085340033544</span></code></pre><p>【例子】比较的两个变量均指向可变类型。</p><pre><code class="hljs python">e = dprint(e <span class="hljs-keyword">is</span> d, e == d) <span class="hljs-comment"># True True</span>print(e <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> d, e != d) <span class="hljs-comment"># False False</span></code></pre><p>注意：</p><ul><li>is, is not 对比的是两个变量的内存地址</li><li>==, != 对比的是两个变量的值</li><li>比较的两个变量，指向的都是地址不可变的类型（str等），那么is，is not 和 ==，！= 是完全等价的。<ul><li>通常，具有相同值的不可变对象在默认情况下具有相同的id。例如，数字-5到256在CPython中被保存，每个数字都存储在内存中单一且固定的位置，这为常用整数节省了内存。(可使用id()查看内存地址)</li></ul></li><li>对比的两个变量，指向的是地址可变的类型（list，dict，tuple等），则两者是有区别的。<ul><li>可变对象一般具有不同的id。除非是一个对象引用另一个对象，此时is的结果为True。</li></ul></li></ul><p><b>运算符的优先级</b></p><ul><li>一元运算符优于二元运算符。例如<code>3 ** -2</code>等价于<code>3 ** (-2)</code>。</li><li>先算术运算，后移位运算，最后位运算。例如 <code>1 &lt;&lt; 3 + 2 &amp; 7</code>等价于 <code>(1 &lt;&lt; (3 + 2)) &amp; 7</code>。</li><li>逻辑运算最后结合。例如<code>3 &lt; 4 and 4 &lt; 5</code>等价于<code>(3 &lt; 4) and (4 &lt; 5)</code>。</li></ul><p>【例子】</p><pre><code class="hljs python">print(<span class="hljs-number">-3</span> ** <span class="hljs-number">2</span>)  <span class="hljs-comment"># -9</span>print(<span class="hljs-number">3</span> ** <span class="hljs-number">-2</span>)  <span class="hljs-comment"># 0.1111111111111111</span>print(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span> + <span class="hljs-number">2</span> &amp; <span class="hljs-number">7</span>)  <span class="hljs-comment"># 0</span>print(<span class="hljs-number">-3</span> * <span class="hljs-number">2</span> + <span class="hljs-number">5</span> / <span class="hljs-number">-2</span> - <span class="hljs-number">4</span>)  <span class="hljs-comment"># -12.5</span>print(<span class="hljs-number">3</span> &lt; <span class="hljs-number">4</span> <span class="hljs-keyword">and</span> <span class="hljs-number">4</span> &lt; <span class="hljs-number">5</span>)  <span class="hljs-comment"># True</span></code></pre><h2 id="3-变量和赋值"><a href="#3-变量和赋值" class="headerlink" title="3. 变量和赋值"></a>3. 变量和赋值</h2><ul><li>在使用变量之前，需要对其先赋值。</li><li>变量名可以包括字母、数字、下划线、但变量名不能以数字开头。</li><li>Python 变量名是大小写敏感的，foo != Foo。</li></ul><p>【例子】</p><pre><code class="hljs python">teacher = <span class="hljs-string">"hey, bro"</span>print(teacher)  <span class="hljs-comment"># hey, bro</span></code></pre><p>【例子】</p><pre><code class="hljs python">first = <span class="hljs-number">2</span>second = <span class="hljs-number">3</span>third = first + secondprint(third)  <span class="hljs-comment"># 5</span></code></pre><p>【例子】</p><pre><code class="hljs python">myTeacher = <span class="hljs-string">"老马"</span>yourTeacher = <span class="hljs-string">"小马"</span>ourTeacher = myTeacher + <span class="hljs-string">','</span> + yourTeacherprint(ourTeacher)  <span class="hljs-comment"># 老马,小马</span></code></pre><h2 id="4-数据类型与转换"><a href="#4-数据类型与转换" class="headerlink" title="4. 数据类型与转换"></a>4. 数据类型与转换</h2><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">整型 <code>&lt;class &#39;int&#39;&gt;</code></td><td style="text-align:center"><code>-876, 10</code></td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">浮点型<code>&lt;class &#39;float&#39;&gt;</code></td><td style="text-align:center"><code>3.149, 11.11</code></td></tr><tr><td style="text-align:center">bool</td><td style="text-align:center">布尔型<code>&lt;class &#39;bool&#39;&gt;</code></td><td style="text-align:center"><code>True, False</code></td></tr></tbody></table></div><p><b>整型</b></p><p>【例子】通过 <code>print()</code> 可看出 <code>a</code> 的值，以及类 (class) 是<code>int</code>。</p><pre><code class="hljs python">a = <span class="hljs-number">1031</span>print(a, type(a))<span class="hljs-comment"># 1031 &lt;class 'int'&gt;</span></code></pre><p>Python 里面万物皆对象（object），整型也不例外，只要是对象，就有相应的属性 （attributes） 和方法（methods）。</p><p>【例子】</p><pre><code class="hljs python">b = dir(int)print(b)<span class="hljs-comment"># ['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__',</span><span class="hljs-comment"># '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__',</span><span class="hljs-comment"># '__float__', '__floor__', '__floordiv__', '__format__', '__ge__',</span><span class="hljs-comment"># '__getattribute__', '__getnewargs__', '__gt__', '__hash__',</span><span class="hljs-comment"># '__index__', '__init__', '__init_subclass__', '__int__', '__invert__',</span><span class="hljs-comment"># '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__',</span><span class="hljs-comment"># '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__',</span><span class="hljs-comment"># '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__',</span><span class="hljs-comment"># '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__',</span><span class="hljs-comment"># '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__',</span><span class="hljs-comment"># '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__',</span><span class="hljs-comment"># '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__',</span><span class="hljs-comment"># 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag',</span><span class="hljs-comment"># 'numerator', 'real', 'to_bytes']</span></code></pre><p>对它们有个大概印象就可以了，具体怎么用，需要哪些参数 （argument），还需要查文档。看个<code>bit_length()</code>的例子。</p><p>【例子】找到一个整数的二进制表示，再返回其长度。</p><pre><code class="hljs python">a = <span class="hljs-number">1031</span>print(bin(a))  <span class="hljs-comment"># 0b10000000111</span>print(a.bit_length())  <span class="hljs-comment"># 11</span></code></pre><p><b>浮点型</b></p><p>【例子】</p><pre><code class="hljs python">print(<span class="hljs-number">1</span>, type(<span class="hljs-number">1</span>))<span class="hljs-comment"># 1 &lt;class 'int'&gt;</span>print(<span class="hljs-number">1.</span>, type(<span class="hljs-number">1.</span>))<span class="hljs-comment"># 1.0 &lt;class 'float'&gt;</span>a = <span class="hljs-number">0.00000023</span>b = <span class="hljs-number">2.3e-7</span>print(a)  <span class="hljs-comment"># 2.3e-07</span>print(b)  <span class="hljs-comment"># 2.3e-07</span></code></pre><p>有时候我们想保留浮点型的小数点后 <code>n</code> 位。可以用 <code>decimal</code> 包里的 <code>Decimal</code> 对象和 <code>getcontext()</code> 方法来实现。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> decimal<span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal</code></pre><p>Python 里面有很多用途广泛的包 (package)，用什么你就引进 (import) 什么。包也是对象，也可以用上面提到的<code>dir(decimal)</code> 来看其属性和方法。</p><p>【例子】<code>getcontext()</code> 显示了 <code>Decimal</code> 对象的默认精度值是 28 位 (<code>prec=28</code>)。</p><pre><code class="hljs python">a = decimal.getcontext()print(a)<span class="hljs-comment"># Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span><span class="hljs-comment"># capitals=1, clamp=0, flags=[], </span><span class="hljs-comment"># traps=[InvalidOperation, DivisionByZero, Overflow])</span></code></pre><pre><code class="hljs python">b = Decimal(<span class="hljs-number">1</span>) / Decimal(<span class="hljs-number">3</span>)print(b)<span class="hljs-comment"># 0.3333333333333333333333333333</span></code></pre><p>【例子】使 1/3 保留 4 位，用 <code>getcontext().prec</code> 来调整精度。</p><pre><code class="hljs python">decimal.getcontext().prec = <span class="hljs-number">4</span>c = Decimal(<span class="hljs-number">1</span>) / Decimal(<span class="hljs-number">3</span>)print(c)<span class="hljs-comment"># 0.3333</span></code></pre><p><b>布尔型</b></p><p>布尔 (boolean) 型变量只能取两个值，<code>True</code> 和 <code>False</code>。当把布尔型变量用在数字运算中，用 <code>1</code> 和 <code>0</code> 代表 <code>True</code> 和 <code>False</code>。</p><p>【例子】</p><pre><code class="hljs python">print(<span class="hljs-literal">True</span> + <span class="hljs-literal">True</span>)  <span class="hljs-comment"># 2</span>print(<span class="hljs-literal">True</span> + <span class="hljs-literal">False</span>)  <span class="hljs-comment"># 1</span>print(<span class="hljs-literal">True</span> * <span class="hljs-literal">False</span>)  <span class="hljs-comment"># 0</span></code></pre><p>除了直接给变量赋值 <code>True</code> 和 <code>False</code>，还可以用 <code>bool(X)</code> 来创建变量，其中 <code>X</code> 可以是</p><ul><li>基本类型：整型、浮点型、布尔型</li><li>容器类型：字符串、元组、列表、字典和集合</li></ul><p>【例子】<code>bool</code> 作用在基本类型变量：<code>X</code> 只要不是整型 <code>0</code>、浮点型 <code>0.0</code>，<code>bool(X)</code> 就是 <code>True</code>，其余就是 <code>False</code>。</p><pre><code class="hljs python">print(type(<span class="hljs-number">0</span>), bool(<span class="hljs-number">0</span>), bool(<span class="hljs-number">1</span>))<span class="hljs-comment"># &lt;class 'int'&gt; False True</span>print(type(<span class="hljs-number">10.31</span>), bool(<span class="hljs-number">0.00</span>), bool(<span class="hljs-number">10.31</span>))<span class="hljs-comment"># &lt;class 'float'&gt; False True</span>print(type(<span class="hljs-literal">True</span>), bool(<span class="hljs-literal">False</span>), bool(<span class="hljs-literal">True</span>))<span class="hljs-comment"># &lt;class 'bool'&gt; False True</span></code></pre><p>【例子】<code>bool</code> 作用在容器类型变量：<code>X</code> 只要不是空的变量，<code>bool(X)</code> 就是 <code>True</code>，其余就是 <code>False</code>。</p><pre><code class="hljs python">print(type(<span class="hljs-string">''</span>), bool(<span class="hljs-string">''</span>), bool(<span class="hljs-string">'python'</span>))<span class="hljs-comment"># &lt;class 'str'&gt; False True</span>print(type(()), bool(()), bool((<span class="hljs-number">10</span>,)))<span class="hljs-comment"># &lt;class 'tuple'&gt; False True</span>print(type([]), bool([]), bool([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]))<span class="hljs-comment"># &lt;class 'list'&gt; False True</span>print(type(&#123;&#125;), bool(&#123;&#125;), bool(&#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>&#125;))<span class="hljs-comment"># &lt;class 'dict'&gt; False True</span>print(type(set()), bool(set()), bool(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;))<span class="hljs-comment"># &lt;class 'set'&gt; False True</span></code></pre><p>确定<code>bool(X)</code> 的值是 <code>True</code> 还是 <code>False</code>，就看 <code>X</code> 是不是空，空的话就是 <code>False</code>，不空的话就是 <code>True</code>。</p><ul><li>对于数值变量，<code>0</code>, <code>0.0</code> 都可认为是空的。</li><li>对于容器变量，里面没元素就是空的。</li></ul><p><b>获取类型信息</b></p><ul><li>获取类型信息 <code>type(object)</code></li></ul><p>【例子】</p><pre><code class="hljs python">print(type(<span class="hljs-number">1</span>))  <span class="hljs-comment"># &lt;class 'int'&gt;</span>print(type(<span class="hljs-number">5.2</span>))  <span class="hljs-comment"># &lt;class 'float'&gt;</span>print(type(<span class="hljs-literal">True</span>))  <span class="hljs-comment"># &lt;class 'bool'&gt;</span>print(type(<span class="hljs-string">'5.2'</span>))  <span class="hljs-comment"># &lt;class 'str'&gt;</span></code></pre><ul><li>获取类型信息 <code>isinstance(object, classinfo)</code></li></ul><p>【例子】</p><pre><code class="hljs python">print(isinstance(<span class="hljs-number">1</span>, int))  <span class="hljs-comment"># True</span>print(isinstance(<span class="hljs-number">5.2</span>, float))  <span class="hljs-comment"># True</span>print(isinstance(<span class="hljs-literal">True</span>, bool))  <span class="hljs-comment"># True</span>print(isinstance(<span class="hljs-string">'5.2'</span>, str))  <span class="hljs-comment"># True</span></code></pre><p>注：</p><ul><li><code>type()</code> 不会认为子类是一种父类类型，不考虑继承关系。</li><li><code>isinstance()</code> 会认为子类是一种父类类型，考虑继承关系。</li></ul><p>如果要判断两个类型是否相同推荐使用 <code>isinstance()</code>。</p><p><strong>类型转换</strong></p><ul><li>转换为整型 <code>int(x, base=10)</code></li><li>转换为字符串 <code>str(object=&#39;&#39;)</code></li><li>转换为浮点型 <code>float(x)</code></li><li>转换为布尔型 <code>bool(x)</code></li></ul><p>【例子】</p><pre><code class="hljs python">print(int(<span class="hljs-string">'520'</span>))  <span class="hljs-comment"># 520</span>print(int(<span class="hljs-number">520.52</span>))  <span class="hljs-comment"># 520</span>print(float(<span class="hljs-string">'520.52'</span>))  <span class="hljs-comment"># 520.52</span>print(float(<span class="hljs-number">520</span>))  <span class="hljs-comment"># 520.0</span>print(str(<span class="hljs-number">10</span> + <span class="hljs-number">10</span>))  <span class="hljs-comment"># 20</span>print(str(<span class="hljs-number">10.1</span> + <span class="hljs-number">5.2</span>))  <span class="hljs-comment"># 15.3</span>print(bool([])) <span class="hljs-comment"># False</span></code></pre><h2 id="5-print-函数"><a href="#5-print-函数" class="headerlink" title="5. print() 函数"></a>5. print() 函数</h2><pre><code class="hljs python">print(*objects, sep=<span class="hljs-string">' '</span>, end=<span class="hljs-string">'\n'</span>, file=sys.stdout, flush=<span class="hljs-literal">False</span>)</code></pre><ul><li>将对象以字符串表示的方式格式化输出到流文件对象file里。其中所有非关键字参数都按<code>str()</code>方式进行转换为字符串输出；</li><li>关键字参数<code>sep</code>是实现分隔符，比如多个参数输出时想要输出中间的分隔字符；</li><li>关键字参数<code>end</code>是输出结束时的字符，默认是换行符<code>\n</code>；</li><li>关键字参数<code>file</code>是定义流输出的文件，可以是标准的系统输出<code>sys.stdout</code>，也可以重定义为别的文件；</li><li>关键字参数<code>flush</code>是立即把内容输出到流文件，不作缓存。</li></ul><p>【例子】没有参数时，每次输出后都会换行。</p><pre><code class="hljs python">shoplist = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'mango'</span>, <span class="hljs-string">'carrot'</span>, <span class="hljs-string">'banana'</span>]print(<span class="hljs-string">"This is printed without 'end'and 'sep'."</span>)<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> shoplist:    print(item)<span class="hljs-comment"># This is printed without 'end'and 'sep'.</span><span class="hljs-comment"># apple</span><span class="hljs-comment"># mango</span><span class="hljs-comment"># carrot</span><span class="hljs-comment"># banana</span></code></pre><p>【例子】每次输出结束都用<code>end</code>设置的参数<code>&amp;</code>结尾，并没有默认换行。</p><pre><code class="hljs python">shoplist = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'mango'</span>, <span class="hljs-string">'carrot'</span>, <span class="hljs-string">'banana'</span>]print(<span class="hljs-string">"This is printed with 'end='&amp;''."</span>)<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> shoplist:    print(item, end=<span class="hljs-string">'&amp;'</span>)print(<span class="hljs-string">'hello world'</span>)<span class="hljs-comment"># This is printed with 'end='&amp;''.</span><span class="hljs-comment"># apple&amp;mango&amp;carrot&amp;banana&amp;hello world</span></code></pre><p>【例子】<code>item</code>值与<code>&#39;another string&#39;</code>两个值之间用<code>sep</code>设置的参数<code>&amp;</code>分割。由于<code>end</code>参数没有设置，因此默认是输出解释后换行，即<code>end</code>参数的默认值为<code>\n</code>。</p><pre><code class="hljs python">shoplist = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'mango'</span>, <span class="hljs-string">'carrot'</span>, <span class="hljs-string">'banana'</span>]print(<span class="hljs-string">"This is printed with 'sep='&amp;''."</span>)<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> shoplist:    print(item, <span class="hljs-string">'another string'</span>, sep=<span class="hljs-string">'&amp;'</span>)<span class="hljs-comment"># This is printed with 'sep='&amp;''.</span><span class="hljs-comment"># apple&amp;another string</span><span class="hljs-comment"># mango&amp;another string</span><span class="hljs-comment"># carrot&amp;another string</span><span class="hljs-comment"># banana&amp;another string</span></code></pre><hr><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li><p>怎样对python中的代码进行注释？</p><h1 id="：单行注释"><a href="#：单行注释" class="headerlink" title="：单行注释"></a>：单行注释</h1><p><code>&#39;&#39;&#39; &#39;&#39;&#39;</code> 或者 <code>&quot;&quot;&quot; &quot;&quot;&quot;</code> ：区间注释，在三引号之间的所有内容被注释</p></li><li><p>python有哪些运算符，这些运算符的优先级是怎样的？</p><p><b>运算符的优先级</b></p><ul><li>一元运算符优于二元运算符。</li><li>先算术运算，后移位运算，最后位运算。</li><li>逻辑运算最后结合。</li></ul></li><li><p>python 中 <code>is</code>, <code>is not</code> 与 <code>==</code>, <code>!=</code> 的区别是什么？</p><p><code>is</code>，<code>is not</code>对比的是两个变量的内存地址</p><p><code>==</code>，<code>！=</code>对比的是两个变量的值</p></li><li><p>python 中包含哪些数据类型？这些数据类型之间如何转换？</p><p>数据类型：整型，浮点型，字符型，布尔型</p><p><strong>类型转换</strong></p><ul><li>转换为整型 <code>int(x, base=10)</code></li><li>转换为字符串 <code>str(object=&#39;&#39;)</code></li><li>转换为浮点型 <code>float(x)</code></li><li>转换为布尔型 <code>bool(x)</code></li></ul></li></ol><hr><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://github.com/datawhalechina/team-learning-program/blob/master/Python-Language/01. 变量、运算符与数据类型.md" target="_blank" rel="noopener">datawhale-01.变量、运算符与数据类型</a></li><li><a href="https://zhuanlan.zhihu.com/p/105849984" target="_blank" rel="noopener">【译】Python中的 !=与is not不同</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;变量、运算符与数据类型&quot;&gt;&lt;a href=&quot;#变量、运算符与数据类型&quot; class=&quot;headerlink&quot; title=&quot;变量、运算符与数据类型&quot;&gt;&lt;/a&gt;变量、运算符与数据类型&lt;/h1&gt;&lt;h2 id=&quot;1-注释&quot;&gt;&lt;a href=&quot;#1-注释&quot; class=&quot;
      
    
    </summary>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://sulimin-nb.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>自然语言处理-新闻文本分类</title>
    <link href="https://sulimin-nb.github.io/article/1ddf0dd3.html"/>
    <id>https://sulimin-nb.github.io/article/1ddf0dd3.html</id>
    <published>2020-07-21T14:29:02.000Z</published>
    <updated>2020-08-05T01:50:47.256Z</updated>
    
    <content type="html"><![CDATA[<h2 id="赛题理解"><a href="#赛题理解" class="headerlink" title="赛题理解"></a>赛题理解</h2><ul><li>赛题名称：零基础入门NLP之新闻文本分类</li><li>赛题任务：赛题以自然语言处理为背景，要求选手对新闻文本进行分类，这是一个典型的字符识别问题。</li></ul><h3 id="赛题数据"><a href="#赛题数据" class="headerlink" title="赛题数据"></a>赛题数据</h3><p>赛题以匿名处理后的新闻数据为赛题数据，数据集报名后可见并可下载。赛题数据为新闻文本，并按照字符级别进行匿名处理。整合划分出14个候选分类类别：财经、彩票、房产、股票、家居、教育、科技、社会、时尚、时政、体育、星座、游戏、娱乐的文本数据。</p><p>赛题数据由以下几个部分构成：训练集20w条样本，测试集A包括5w条样本，测试集B包括5w条样本。为了预防选手人工标注测试集的情况，我们将比赛数据的文本按照字符级别进行了匿名处理。</p><h3 id="数据标签"><a href="#数据标签" class="headerlink" title="数据标签"></a>数据标签</h3><p>处理后的赛题训练数据如下：</p><div class="table-container"><table><thead><tr><th>label</th><th>text</th></tr></thead><tbody><tr><td>6</td><td>57 44 66 56 2 3 3 37 5 41 9 57 44 47 45 33 13 63 58 31 17 47 0 1 1 69 26 60 62 15 21 12 49 18 38 20 50 23 57 44 45 33 25 28 47 22 52 35 30 14 24 69 54 7 48 19 11 51 16 43 26 34 53 27 64 8 4 42 36 46 65 69 29 39 15 37 57 44 45 33 69 54 7 25 40 35 30 66 56 47 55 69 61 10 60 42 36 46 65 37 5 41 32 67 6 59 47 0 1 1 68</td></tr></tbody></table></div><p>在数据集中标签的对应的关系如下：{‘科技’: 0, ‘股票’: 1, ‘体育’: 2, ‘娱乐’: 3, ‘时政’: 4, ‘社会’: 5, ‘教育’: 6, ‘财经’: 7, ‘家居’: 8, ‘游戏’: 9, ‘房产’: 10, ‘时尚’: 11, ‘彩票’: 12, ‘星座’: 13}</p><h3 id="评测指标"><a href="#评测指标" class="headerlink" title="评测指标"></a>评测指标</h3><p>评价标准为类别<code>f1_score</code>的均值，选手提交结果与实际测试集的类别进行对比，结果越大越好。</p><h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><p>使用<code>Pandas</code>库完成数据读取操作，并对赛题数据进行分析。</p><h2 id="数据读取与数据分析"><a href="#数据读取与数据分析" class="headerlink" title="数据读取与数据分析"></a>数据读取与数据分析</h2><p>本章主要内容为数据读取和数据分析，具体使用<code>Pandas</code>库完成数据读取操作，并对赛题数据进行分析构成。</p><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>学习使用<code>Pandas</code>读取赛题数据</li><li>分析赛题数据的分布规律</li></ul><h3 id="数据读取-1"><a href="#数据读取-1" class="headerlink" title="数据读取"></a>数据读取</h3><p>赛题数据虽然是文本数据，每个新闻是不定长的，但任然使用csv格式进行存储。因此可以直接用<code>Pandas</code>完成数据读取的操作。</p><pre><code class="hljs reasonml">import pandas <span class="hljs-keyword">as</span> pdtrain_df = pd.read<span class="hljs-constructor">_csv('..<span class="hljs-operator">/</span><span class="hljs-params">input</span><span class="hljs-operator">/</span><span class="hljs-params">train_set</span>.<span class="hljs-params">csv</span>', <span class="hljs-params">sep</span>='\<span class="hljs-params">t</span>', <span class="hljs-params">nrows</span>=100)</span></code></pre><p>这里的<code>read_csv</code>由三部分构成：</p><ul><li>读取的文件路径，这里需要根据改成你本地的路径，可以使用相对路径或绝对路径；</li><li>分隔符<code>sep</code>，为每列分割的字符，设置为<code>\t</code>即可；</li><li>读取行数<code>nrows</code>，为此次读取文件的函数，是数值类型（由于数据集比较大，建议先设置为100）；</li></ul><p><a href="https://camo.githubusercontent.com/3cfb75e212d4e8259de4c4151e52b405dbe256de/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333733303733392e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/3cfb75e212d4e8259de4c4151e52b405dbe256de/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333733303733392e706e67" srcset="/img/loading.gif" alt="task2_train_head"></a></p><p>上图是读取好的数据，是表格的形式。第一列为新闻的类别，第二列为新闻的字符。</p><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><p>在读取完成数据集后，我们还可以对数据集进行数据分析的操作。虽然对于非结构数据并不需要做很多的数据分析，但通过数据分析还是可以找出一些规律的。</p><p>此步骤我们读取了所有的训练集数据，在此我们通过数据分析希望得出以下结论：</p><ul><li>赛题数据中，新闻文本的长度是多少？</li><li>赛题数据的类别分布是怎么样的，哪些类别比较多？</li><li>赛题数据中，字符分布是怎么样的？</li></ul><h4 id="句子长度分析"><a href="#句子长度分析" class="headerlink" title="句子长度分析"></a>句子长度分析</h4><p>在赛题数据中每行句子的字符使用空格进行隔开，所以可以直接统计单词的个数来得到每个句子的长度。统计并如下：</p><pre><code class="hljs sas"><span class="hljs-name">%pylab</span> inlinetrain_df[<span class="hljs-string">'text_len'</span>] = train_df[<span class="hljs-string">'text'</span>].apply(lambda <span class="hljs-meta">x</span>: l<span class="hljs-meta">en(</span><span class="hljs-meta">x</span>.split(<span class="hljs-string">' '</span>)))p<span class="hljs-meta">rint(</span>train_df[<span class="hljs-string">'text_len'</span>].<span class="hljs-meta">describe</span>())</code></pre><p>输出结果为：</p><pre><code class="hljs yaml"><span class="hljs-string">Populating</span> <span class="hljs-string">the</span> <span class="hljs-string">interactive</span> <span class="hljs-string">namespace</span> <span class="hljs-string">from</span> <span class="hljs-string">numpy</span> <span class="hljs-string">and</span> <span class="hljs-string">matplotlib</span><span class="hljs-string">count</span>    <span class="hljs-number">200000.000000</span><span class="hljs-string">mean</span>        <span class="hljs-number">907.207110</span><span class="hljs-string">std</span>         <span class="hljs-number">996.029036</span><span class="hljs-string">min</span>           <span class="hljs-number">2.000000</span><span class="hljs-number">25</span><span class="hljs-string">%</span>         <span class="hljs-number">374.000000</span><span class="hljs-number">50</span><span class="hljs-string">%</span>         <span class="hljs-number">676.000000</span><span class="hljs-number">75</span><span class="hljs-string">%</span>        <span class="hljs-number">1131.000000</span><span class="hljs-string">max</span>       <span class="hljs-number">57921.000000</span><span class="hljs-attr">Name:</span> <span class="hljs-string">text_len,</span> <span class="hljs-attr">dtype:</span> <span class="hljs-string">float64</span></code></pre><p>对新闻句子的统计可以得出，本次赛题给定的文本比较长，每个句子平均由907个字符构成，最短的句子长度为2，最长的句子长度为57921。</p><p>下图将句子长度绘制了直方图，可见大部分句子的长度都几种在2000以内。</p><pre><code class="hljs routeros">_ = plt.hist(train_df[<span class="hljs-string">'text_len'</span>], <span class="hljs-attribute">bins</span>=200)plt.xlabel(<span class="hljs-string">'Text char count'</span>)plt.title(<span class="hljs-string">"Histogram of char count"</span>)</code></pre><p><a href="https://camo.githubusercontent.com/656471f35c5df332c6ca027756cfd048324e5727/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333833363930352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/656471f35c5df332c6ca027756cfd048324e5727/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333833363930352e706e67" srcset="/img/loading.gif" alt="task2_char_hist"></a></p><h4 id="新闻类别分布"><a href="#新闻类别分布" class="headerlink" title="新闻类别分布"></a>新闻类别分布</h4><p>接下来可以对数据集的类别进行分布统计，具体统计每类新闻的样本个数。</p><pre><code class="hljs less"><span class="hljs-selector-tag">train_df</span><span class="hljs-selector-attr">['label']</span><span class="hljs-selector-class">.value_counts</span>()<span class="hljs-selector-class">.plot</span>(kind=<span class="hljs-string">'bar'</span>)<span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.title</span>(<span class="hljs-string">'News class count'</span>)<span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.xlabel</span>(<span class="hljs-string">"category"</span>)</code></pre><p><a href="https://camo.githubusercontent.com/ea8ab6a105f74fa197f29cb09e5dfd97ae6a573e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333932393239362e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ea8ab6a105f74fa197f29cb09e5dfd97ae6a573e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333932393239362e706e67" srcset="/img/loading.gif" alt="task2_class_hist"></a></p><p>在数据集中标签的对应的关系如下：{‘科技’: 0, ‘股票’: 1, ‘体育’: 2, ‘娱乐’: 3, ‘时政’: 4, ‘社会’: 5, ‘教育’: 6, ‘财经’: 7, ‘家居’: 8, ‘游戏’: 9, ‘房产’: 10, ‘时尚’: 11, ‘彩票’: 12, ‘星座’: 13}</p><p>从统计结果可以看出，赛题的数据集类别分布存在较为不均匀的情况。在训练集中科技类新闻最多，其次是股票类新闻，最少的新闻是星座新闻。</p><h4 id="字符分布统计"><a href="#字符分布统计" class="headerlink" title="字符分布统计"></a>字符分布统计</h4><p>接下来可以统计每个字符出现的次数，首先可以将训练集中所有的句子进行拼接进而划分为字符，并统计每个字符的个数。</p><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> collections import Counterall_lines = <span class="hljs-string">' '</span>.join(list(train_df[<span class="hljs-string">'text'</span>]))word_count = Counter(all_lines.split(<span class="hljs-string">" "</span>))word_count = sorted(word_count.items(), <span class="hljs-attribute">key</span>=lambda d:d[1], reverse = <span class="hljs-literal">True</span>)<span class="hljs-builtin-name">print</span>(len(word_count))<span class="hljs-comment"># 6869</span><span class="hljs-builtin-name">print</span>(word_count[0])<span class="hljs-comment"># ('3750', 7482224)</span><span class="hljs-builtin-name">print</span>(word_count[-1])<span class="hljs-comment"># ('3133', 1)</span></code></pre><p>从统计结果中可以看出，在训练集中总共包括6869个字，其中编号3750的字出现的次数最多，编号3133的字出现的次数最少。</p><p>这里还可以根据字在每个句子的出现情况，反推出标点符号。下面代码统计了不同字符在句子中出现的次数，其中字符3750，字符900和字符648在20w新闻的覆盖率接近99%，很有可能是标点符号。</p><pre><code class="hljs vim">train_df[<span class="hljs-string">'text_unique'</span>] = train_df[<span class="hljs-string">'text'</span>].apply(lambda <span class="hljs-keyword">x</span>: <span class="hljs-string">' '</span>.<span class="hljs-keyword">join</span>(<span class="hljs-keyword">list</span>(<span class="hljs-keyword">set</span>(<span class="hljs-keyword">x</span>.<span class="hljs-keyword">split</span>(<span class="hljs-string">' '</span>)))))all_lines = <span class="hljs-string">' '</span>.<span class="hljs-keyword">join</span>(<span class="hljs-keyword">list</span>(train_df[<span class="hljs-string">'text_unique'</span>]))word_count = Counter(all_lines.<span class="hljs-keyword">split</span>(<span class="hljs-string">" "</span>))word_count = sorted(word_count.<span class="hljs-built_in">items</span>(), key=lambda d:<span class="hljs-keyword">int</span>(d[<span class="hljs-number">1</span>]), <span class="hljs-built_in">reverse</span> = True)<span class="hljs-keyword">print</span>(word_count[<span class="hljs-number">0</span>])# (<span class="hljs-string">'3750'</span>, <span class="hljs-number">197997</span>)<span class="hljs-keyword">print</span>(word_count[<span class="hljs-number">1</span>])# (<span class="hljs-string">'900'</span>, <span class="hljs-number">197653</span>)<span class="hljs-keyword">print</span>(word_count[<span class="hljs-number">2</span>])# (<span class="hljs-string">'648'</span>, <span class="hljs-number">191975</span>)</code></pre><h3 id="数据分析的结论"><a href="#数据分析的结论" class="headerlink" title="数据分析的结论"></a>数据分析的结论</h3><p>通过上述分析我们可以得出以下结论：</p><ol><li>赛题中每个新闻包含的字符个数平均为1000个，还有一些新闻字符较长；</li><li>赛题中新闻类别分布不均匀，科技类新闻样本量接近4w，星座类新闻样本量不到1k；</li><li>赛题总共包括7000-8000个字符；</li></ol><p>通过数据分析，我们还可以得出以下结论：</p><ol><li>每个新闻平均字符个数较多，可能需要截断；</li><li>由于类别不均衡，会严重影响模型的精度；</li></ol><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章对赛题数据进行读取，并新闻句子长度、类别和字符进行了可视化分析。</p><h3 id="本章作业"><a href="#本章作业" class="headerlink" title="本章作业"></a>本章作业</h3><ol><li>假设字符3750，字符900和字符648是句子的标点符号，请分析赛题每篇新闻平均由多少个句子构成？</li><li>统计每类新闻中出现次数对多的字符</li></ol><h1 id="基于机器学习的文本分类"><a href="#基于机器学习的文本分类" class="headerlink" title="基于机器学习的文本分类"></a>基于机器学习的文本分类</h1><p>在上一章节，我们对赛题的数据进行了读取，并在末尾给出了两个小作业。如果你顺利完成了作业，那么你基本上对<code>Python</code>也比较熟悉了。在本章我们将使用传统机器学习算法来完成新闻分类的过程，将会结束到赛题的核心知识点。</p><h2 id="基于机器学习的文本分类-1"><a href="#基于机器学习的文本分类-1" class="headerlink" title="基于机器学习的文本分类"></a>基于机器学习的文本分类</h2><p>在本章我们将开始使用机器学习模型来解决文本分类。机器学习发展比较广，且包括多个分支，本章侧重使用传统机器学习，从下一章开始是基于深度学习的文本分类。</p><h3 id="学习目标-1"><a href="#学习目标-1" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>学会TF-IDF的原理和使用</li><li>使用sklearn的机器学习模型完成文本分类</li></ul><h3 id="机器学习模型"><a href="#机器学习模型" class="headerlink" title="机器学习模型"></a>机器学习模型</h3><p>机器学习是对能通过经验自动改进的计算机算法的研究。机器学习通过历史数据<strong>训练</strong>出<strong>模型</strong>对应于人类对经验进行<strong>归纳</strong>的过程，机器学习利用<strong>模型</strong>对新数据进行<strong>预测</strong>对应于人类利用总结的<strong>规律</strong>对新问题进行<strong>预测</strong>的过程。</p><p>机器学习有很多种分支，对于学习者来说应该优先掌握机器学习算法的分类，然后再其中一种机器学习算法进行学习。由于机器学习算法的分支和细节实在是太多，所以如果你一开始就被细节迷住了眼，你就很难知道全局是什么情况的。</p><p>如果你是机器学习初学者，你应该知道如下的事情：</p><ol><li>机器学习能解决一定的问题，但不能奢求机器学习是万能的；</li><li>机器学习算法有很多种，看具体问题需要什么，再来进行选择；</li><li>每种机器学习算法有一定的偏好，需要具体问题具体分析；</li></ol><p><a href="https://camo.githubusercontent.com/d8e9a12417a2a2a754a874af0ae163bb1bddbb0b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333232333235332e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d8e9a12417a2a2a754a874af0ae163bb1bddbb0b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333232333235332e6a7067" srcset="/img/loading.gif" alt="machine_learning_overview"></a></p><h3 id="文本表示方法-Part1"><a href="#文本表示方法-Part1" class="headerlink" title="文本表示方法 Part1"></a>文本表示方法 Part1</h3><p>在机器学习算法的训练过程中，假设给定$N$个样本，每个样本有$M$个特征，这样组成了$N×M$的样本矩阵，然后完成算法的训练和预测。同样的在计算机视觉中可以将图片的像素看作特征，每张图片看作hight×width×3的特征图，一个三维的矩阵来进入计算机进行计算。</p><p>但是在自然语言领域，上述方法却不可行：文本是不定长度的。文本表示成计算机能够运算的数字或向量的方法一般称为词嵌入（Word Embedding）方法。词嵌入将不定长的文本转换到定长的空间内，是文本分类的第一步。</p><h4 id="One-hot"><a href="#One-hot" class="headerlink" title="One-hot"></a>One-hot</h4><p>这里的One-hot与数据挖掘任务中的操作是一致的，即将每一个单词使用一个离散的向量表示。具体将每个字/词编码一个索引，然后根据索引进行赋值。</p><p>One-hot表示方法的例子如下：</p><pre><code class="hljs angelscript">句子<span class="hljs-number">1</span>：我 爱 北 京 天 安 门句子<span class="hljs-number">2</span>：我 喜 欢 上 海</code></pre><p>首先对所有句子的字进行索引，即将每个字确定一个编号：</p><pre><code class="hljs 1c">&#123;'我': <span class="hljs-number">1</span>, '爱': <span class="hljs-number">2</span>, '北': <span class="hljs-number">3</span>, '京': <span class="hljs-number">4</span>, '天': <span class="hljs-number">5</span>,  '安': <span class="hljs-number">6</span>, '门': <span class="hljs-number">7</span>, '喜': <span class="hljs-number">8</span>, '欢': <span class="hljs-number">9</span>, '上': <span class="hljs-number">10</span>, '海': <span class="hljs-number">11</span>&#125;</code></pre><p>在这里共包括11个字，因此每个字可以转换为一个11维度稀疏向量：</p><pre><code class="hljs angelscript">我：[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]爱：[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]...海：[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</code></pre><h4 id="Bag-of-Words"><a href="#Bag-of-Words" class="headerlink" title="Bag of Words"></a>Bag of Words</h4><p>Bag of Words（词袋表示），也称为Count Vectors，每个文档的字/词可以使用其出现次数来进行表示。</p><pre><code class="hljs angelscript">句子<span class="hljs-number">1</span>：我 爱 北 京 天 安 门句子<span class="hljs-number">2</span>：我 喜 欢 上 海</code></pre><p>直接统计每个字出现的次数，并进行赋值：</p><pre><code class="hljs angelscript">句子<span class="hljs-number">1</span>：我 爱 北 京 天 安 门转换为 [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]句子<span class="hljs-number">2</span>：我 喜 欢 上 海转换为 [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]</code></pre><p>在sklearn中可以直接<code>CountVectorizer</code>来实现这一步骤：</p><pre><code class="hljs vbnet"><span class="hljs-keyword">from</span> sklearn.feature_extraction.<span class="hljs-keyword">text</span> import CountVectorizercorpus = [    <span class="hljs-comment">'This is the first document.',</span>    <span class="hljs-comment">'This document is the second document.',</span>    <span class="hljs-comment">'And this is the third one.',</span>    <span class="hljs-comment">'Is this the first document?',</span>]vectorizer = CountVectorizer()vectorizer.fit_transform(corpus).toarray()</code></pre><h4 id="N-gram"><a href="#N-gram" class="headerlink" title="N-gram"></a>N-gram</h4><p>N-gram与Count Vectors类似，不过加入了相邻单词组合成为新的单词，并进行计数。</p><p>如果N取值为2，则句子1和句子2就变为：</p><pre><code class="hljs angelscript">句子<span class="hljs-number">1</span>：我爱 爱北 北京 京天 天安 安门句子<span class="hljs-number">2</span>：我喜 喜欢 欢上 上海</code></pre><h4 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h4><p>TF-IDF 分数由两部分组成：第一部分是<strong>词语频率</strong>（Term Frequency），第二部分是<strong>逆文档频率</strong>（Inverse Document Frequency）。其中计算语料库中文档总数除以含有该词语的文档数量，然后再取对数就是逆文档频率。</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">TF</span><span class="hljs-params">(t)</span></span>= 该词语在当前文档出现的次数 / 当前文档中词语的总数<span class="hljs-function"><span class="hljs-title">IDF</span><span class="hljs-params">(t)</span></span>= log_e（文档总数 / 出现该词语的文档总数）</code></pre><h3 id="基于机器学习的文本分类-2"><a href="#基于机器学习的文本分类-2" class="headerlink" title="基于机器学习的文本分类"></a>基于机器学习的文本分类</h3><p>接下来我们将对比不同文本表示算法的精度，通过本地构建验证集计算F1得分。</p><h4 id="Count-Vectors-RidgeClassifier"><a href="#Count-Vectors-RidgeClassifier" class="headerlink" title="Count Vectors + RidgeClassifier"></a>Count Vectors + RidgeClassifier</h4><pre><code class="hljs reasonml">import pandas <span class="hljs-keyword">as</span> pdfrom sklearn.feature_extraction.text import CountVectorizerfrom sklearn.linear_model import RidgeClassifierfrom sklearn.metrics import f1_scoretrain_df = pd.read<span class="hljs-constructor">_csv('..<span class="hljs-operator">/</span><span class="hljs-params">input</span><span class="hljs-operator">/</span><span class="hljs-params">train_set</span>.<span class="hljs-params">csv</span>', <span class="hljs-params">sep</span>='\<span class="hljs-params">t</span>', <span class="hljs-params">nrows</span>=15000)</span>vectorizer = <span class="hljs-constructor">CountVectorizer(<span class="hljs-params">max_features</span>=3000)</span>train_test = vectorizer.fit<span class="hljs-constructor">_transform(<span class="hljs-params">train_df</span>['<span class="hljs-params">text</span>'])</span>clf = <span class="hljs-constructor">RidgeClassifier()</span>clf.fit(train_test<span class="hljs-literal">[:<span class="hljs-number">10000</span>]</span>, train_df<span class="hljs-literal">['<span class="hljs-identifier">label</span>']</span>.values<span class="hljs-literal">[:<span class="hljs-number">10000</span>]</span>)val_pred = clf.predict(train_test<span class="hljs-literal">[<span class="hljs-number">10000</span>:]</span>)print(f1<span class="hljs-constructor">_score(<span class="hljs-params">train_df</span>['<span class="hljs-params">label</span>'].<span class="hljs-params">values</span>[10000:], <span class="hljs-params">val_pred</span>, <span class="hljs-params">average</span>='<span class="hljs-params">macro</span>')</span>)# <span class="hljs-number">0.74</span></code></pre><h4 id="TF-IDF-RidgeClassifier"><a href="#TF-IDF-RidgeClassifier" class="headerlink" title="TF-IDF + RidgeClassifier"></a>TF-IDF + RidgeClassifier</h4><pre><code class="hljs reasonml">import pandas <span class="hljs-keyword">as</span> pdfrom sklearn.feature_extraction.text import TfidfVectorizerfrom sklearn.linear_model import RidgeClassifierfrom sklearn.metrics import f1_scoretrain_df = pd.read<span class="hljs-constructor">_csv('..<span class="hljs-operator">/</span><span class="hljs-params">input</span><span class="hljs-operator">/</span><span class="hljs-params">train_set</span>.<span class="hljs-params">csv</span>', <span class="hljs-params">sep</span>='\<span class="hljs-params">t</span>', <span class="hljs-params">nrows</span>=15000)</span>tfidf = <span class="hljs-constructor">TfidfVectorizer(<span class="hljs-params">ngram_range</span>=(1,3)</span>, max_features=<span class="hljs-number">3000</span>)train_test = tfidf.fit<span class="hljs-constructor">_transform(<span class="hljs-params">train_df</span>['<span class="hljs-params">text</span>'])</span>clf = <span class="hljs-constructor">RidgeClassifier()</span>clf.fit(train_test<span class="hljs-literal">[:<span class="hljs-number">10000</span>]</span>, train_df<span class="hljs-literal">['<span class="hljs-identifier">label</span>']</span>.values<span class="hljs-literal">[:<span class="hljs-number">10000</span>]</span>)val_pred = clf.predict(train_test<span class="hljs-literal">[<span class="hljs-number">10000</span>:]</span>)print(f1<span class="hljs-constructor">_score(<span class="hljs-params">train_df</span>['<span class="hljs-params">label</span>'].<span class="hljs-params">values</span>[10000:], <span class="hljs-params">val_pred</span>, <span class="hljs-params">average</span>='<span class="hljs-params">macro</span>')</span>)# <span class="hljs-number">0.87</span></code></pre><h2 id="基于深度学习的文本分类"><a href="#基于深度学习的文本分类" class="headerlink" title="基于深度学习的文本分类"></a>基于深度学习的文本分类</h2><p>与传统机器学习不同，深度学习既提供特征提取功能，也可以完成分类的功能。从本章开始我们将学习如何使用深度学习来完成文本表示。</p><h3 id="学习目标-2"><a href="#学习目标-2" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>学习FastText的使用和基础原理</li><li>学会使用验证集进行调参</li></ul><h3 id="文本表示方法-Part2"><a href="#文本表示方法-Part2" class="headerlink" title="文本表示方法 Part2"></a>文本表示方法 Part2</h3><h4 id="现有文本表示方法的缺陷"><a href="#现有文本表示方法的缺陷" class="headerlink" title="现有文本表示方法的缺陷"></a>现有文本表示方法的缺陷</h4><p>在上一章节，我们介绍几种文本表示方法：</p><ul><li>One-hot</li><li>Bag of Words</li><li>N-gram</li><li>TF-IDF</li></ul><p>也通过sklean进行了相应的实践，相信你也有了初步的认知。但上述方法都或多或少存在一定的问题：转换得到的向量维度很高，需要较长的训练实践；没有考虑单词与单词之间的关系，只是进行了统计。</p><p>与这些表示方法不同，深度学习也可以用于文本表示，还可以将其映射到一个低纬空间。其中比较典型的例子有：FastText、Word2Vec和Bert。在本章我们将介绍FastText，将在后面的内容介绍Word2Vec和Bert。</p><h4 id="FastText"><a href="#FastText" class="headerlink" title="FastText"></a>FastText</h4><p>FastText是一种典型的深度学习词向量的表示方法，它非常简单通过Embedding层将单词映射到稠密空间，然后将句子中所有的单词在Embedding空间中进行平均，进而完成分类操作。</p><p>所以FastText是一个三层的神经网络，输入层、隐含层和输出层。</p><p><a href="https://camo.githubusercontent.com/4e01004146c81db5ee15df1b373374b3ff145bfa/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343835363538392e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/4e01004146c81db5ee15df1b373374b3ff145bfa/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343835363538392e706e67" srcset="/img/loading.gif" alt="fast_text"></a></p><p>下图是使用keras实现的FastText网络结构：</p><p><a href="https://camo.githubusercontent.com/d4f33365b75bdddd0c80a857dc1a9e99789f1600/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343234393436332e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d4f33365b75bdddd0c80a857dc1a9e99789f1600/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343234393436332e6a7067" srcset="/img/loading.gif" alt="keras_fasttext"></a></p><p>FastText在文本分类任务上，是优于TF-IDF的：</p><ul><li>FastText用单词的Embedding叠加获得的文档向量，将相似的句子分为一类</li><li>FastText学习到的Embedding空间维度比较低，可以快速进行训练</li></ul><p>如果想深度学习，可以参考论文：</p><p>Bag of Tricks for Efficient Text Classification, <a href="https://arxiv.org/abs/1607.01759" target="_blank" rel="noopener">https://arxiv.org/abs/1607.01759</a></p><h3 id="基于FastText的文本分类"><a href="#基于FastText的文本分类" class="headerlink" title="基于FastText的文本分类"></a>基于FastText的文本分类</h3><p>FastText可以快速的在CPU上进行训练，最好的实践方法就是官方开源的版本： <a href="https://github.com/facebookresearch/fastText/tree/master/python" target="_blank" rel="noopener">https://github.com/facebookresearch/fastText/tree/master/python</a></p><ul><li>pip安装</li></ul><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> fasttext</code></pre><ul><li>源码安装</li></ul><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/facebookresearch/fastText.gitcd fastTextsudo pip install .</code></pre><p>两种安装方法都可以安装，如果你是初学者可以优先考虑使用pip安装。</p><ul><li>分类模型</li></ul><pre><code class="hljs routeros">import pandas as pd<span class="hljs-keyword">from</span> sklearn.metrics import f1_score<span class="hljs-comment"># 转换为FastText需要的格式</span>train_df = pd.read_csv(<span class="hljs-string">'../input/train_set.csv'</span>, <span class="hljs-attribute">sep</span>=<span class="hljs-string">'\t'</span>, <span class="hljs-attribute">nrows</span>=15000)train_df[<span class="hljs-string">'label_ft'</span>] = <span class="hljs-string">'__label__'</span> + train_df[<span class="hljs-string">'label'</span>].astype(str)train_df[[<span class="hljs-string">'text'</span>,<span class="hljs-string">'label_ft'</span>]].iloc[:-5000].to_csv(<span class="hljs-string">'train.csv'</span>, <span class="hljs-attribute">index</span>=None, <span class="hljs-attribute">header</span>=None, <span class="hljs-attribute">sep</span>=<span class="hljs-string">'\t'</span>)import fasttextmodel = fasttext.train_supervised(<span class="hljs-string">'train.csv'</span>, <span class="hljs-attribute">lr</span>=1.0, <span class="hljs-attribute">wordNgrams</span>=2,                                   <span class="hljs-attribute">verbose</span>=2, <span class="hljs-attribute">minCount</span>=1, <span class="hljs-attribute">epoch</span>=25, <span class="hljs-attribute">loss</span>=<span class="hljs-string">"hs"</span>)val_pred = [model.predict(x)[0][0].split(<span class="hljs-string">'__'</span>)[-1] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> train_df.iloc[-5000:][<span class="hljs-string">'text'</span>]]<span class="hljs-builtin-name">print</span>(f1_score(train_df[<span class="hljs-string">'label'</span>].values[-5000:].astype(str), val_pred, <span class="hljs-attribute">average</span>=<span class="hljs-string">'macro'</span>))<span class="hljs-comment"># 0.82</span></code></pre><p>此时数据量比较小得分为0.82，当不断增加训练集数量时，FastText的精度也会不断增加5w条训练样本时，验证集得分可以到0.89-0.90左右。</p><h3 id="如何使用验证集调参"><a href="#如何使用验证集调参" class="headerlink" title="如何使用验证集调参"></a>如何使用验证集调参</h3><p>在使用TF-IDF和FastText中，有一些模型的参数需要选择，这些参数会在一定程度上影响模型的精度，那么如何选择这些参数呢？</p><ul><li>通过阅读文档，要弄清楚这些参数的大致含义，那些参数会增加模型的复杂度</li><li>通过在验证集上进行验证模型精度，找到模型在是否过拟合还是欠拟合</li></ul><p><a href="https://camo.githubusercontent.com/3c19cda9d91954875be0b59abe99fad024552d29/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343430333834342e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/3c19cda9d91954875be0b59abe99fad024552d29/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343430333834342e706e67" srcset="/img/loading.gif" alt="train_val"></a></p><p>这里我们使用10折交叉验证，每折使用9/10的数据进行训练，剩余1/10作为验证集检验模型的效果。这里需要注意每折的划分必须保证标签的分布与整个数据集的分布一致。</p><pre><code class="hljs dockerfile">label2id = &#123;&#125;for i in range(total):    <span class="hljs-keyword">label</span><span class="bash"> = str(all_labels[i])</span>    if <span class="hljs-keyword">label</span><span class="bash"> not <span class="hljs-keyword">in</span> label2id:</span>        label2id[<span class="hljs-keyword">label</span><span class="bash">] = [i]</span>    else:        label2id[<span class="hljs-keyword">label</span><span class="bash">].append(i)</span></code></pre><p>通过10折划分，我们一共得到了10份分布一致的数据，索引分别为0到9，每次通过将一份数据作为验证集，剩余数据作为训练集，获得了所有数据的10种分割。不失一般性，我们选择最后一份完成剩余的实验，即索引为9的一份做为验证集，索引为1-8的作为训练集，然后基于验证集的结果调整超参数，使得模型性能更优。</p><h3 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章介绍了FastText的原理和基础使用，并进行相应的实践。然后介绍了通过10折交叉验证划分数据集。</p><h3 id="本章作业-1"><a href="#本章作业-1" class="headerlink" title="本章作业"></a>本章作业</h3><ul><li>阅读FastText的文档，尝试修改参数，得到更好的分数</li><li>基于验证集的结果调整超参数，使得模型性能更优</li></ul><h2 id="基于深度学习的文本分类-1"><a href="#基于深度学习的文本分类-1" class="headerlink" title="基于深度学习的文本分类"></a>基于深度学习的文本分类</h2><h3 id="学习目标-3"><a href="#学习目标-3" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>了解Transformer的原理和基于预训练语言模型（Bert）的词表示</li><li>学会Bert的使用，具体包括pretrain和finetune</li></ul><h3 id="文本表示方法Part4"><a href="#文本表示方法Part4" class="headerlink" title="文本表示方法Part4"></a>文本表示方法Part4</h3><h4 id="Transformer原理"><a href="#Transformer原理" class="headerlink" title="Transformer原理"></a>Transformer原理</h4><p>Transformer是在”<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Attention is All You Need</a>“中提出的，模型的编码部分是一组编码器的堆叠（论文中依次堆叠六个编码器），模型的解码部分是由相同数量的解码器的堆叠。</p><p><a href="https://camo.githubusercontent.com/1da32c07cd7d544113673ba47624f0a47af51ba6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313034363636382e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1da32c07cd7d544113673ba47624f0a47af51ba6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313034363636382e706e67" srcset="/img/loading.gif" alt="img"></a></p><p>我们重点关注编码部分。他们结构完全相同，但是并不共享参数，每一个编码器都可以拆解成两部分。在对输入序列做词的向量化之后，它们首先流过一个self-attention层，该层帮助编码器在它编码单词的时候能够看到输入序列中的其他单词。self-attention的输出流向一个前向网络（Feed Forward Neural Network），每个输入位置对应的前向网络是独立互不干扰的。最后将输出传入下一个编码器。</p><p><a href="https://camo.githubusercontent.com/70959c74cbf7ac3c3dae3fd0eceddf180715cb39/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313131353934352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/70959c74cbf7ac3c3dae3fd0eceddf180715cb39/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313131353934352e706e67" srcset="/img/loading.gif" alt="img"></a></p><p>这里能看到Transformer的一个关键特性，每个位置的词仅仅流过它自己的编码器路径。在self-attention层中，这些路径两两之间是相互依赖的。<strong>前向网络层则没有这些依赖性</strong>，但这些路径在流经前向网络时可以并行执行。</p><p>Self-Attention中使用多头机制，使得不同的attention heads所关注的的部分不同。</p><p><a href="https://camo.githubusercontent.com/1173d083304d3e60a81342717cd52d3f1a5124e1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313135333638372e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1173d083304d3e60a81342717cd52d3f1a5124e1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313135333638372e706e67" srcset="/img/loading.gif" alt="img"></a></p><p>编码”it”时，一个attention head集中于”the animal”，另一个head集中于“tired”，某种意义上讲，模型对“it”的表达合成了的“animal”和“tired”两者。</p><p>对于自注意力的详细计算，欢迎大家参考<a href="https://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">Jay Alammar</a>关于Transformer的博客，这里不再展开。</p><p>除此之外，为了使模型保持单词的语序，模型中添加了位置编码向量。如下图所示，每行对应一个向量的位置编码。因此，第一行将是我们要添加到输入序列中第一个单词的嵌入的向量。每行包含512个值—每个值都在1到-1之间。因为左侧是用sine函数生成，右侧是用cosine生成，所以可以观察到中间显著的分隔。</p><p><a href="https://camo.githubusercontent.com/1598ac84eeeca72eb271d7bc4696d36f564bc759/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313233323731362e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1598ac84eeeca72eb271d7bc4696d36f564bc759/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313233323731362e706e67" srcset="/img/loading.gif" alt="img"></a></p><p>编码器结构中值得提出注意的一个细节是，在每个子层中（Self-attention, FFNN），都有残差连接，并且紧跟着<a href="https://arxiv.org/abs/1607.06450" target="_blank" rel="noopener">layer-normalization</a>。如果我们可视化向量和LayerNorm操作，将如下所示：</p><p><a href="https://camo.githubusercontent.com/09ac8f9634bff9681b191c398e4b943d34f972c3/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313935353731332e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/09ac8f9634bff9681b191c398e4b943d34f972c3/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313935353731332e706e67" srcset="/img/loading.gif" alt="img"></a></p><h4 id="基于预训练语言模型的词表示"><a href="#基于预训练语言模型的词表示" class="headerlink" title="基于预训练语言模型的词表示"></a>基于预训练语言模型的词表示</h4><p>基于预训练语言模型的词表示由于可以建模上下文信息，进而解决传统静态词向量不能建模“一词多义”语言现象的问题。最早提出的ELMo基于两个单向LSTM，将从左到右和从右到左两个方向的隐藏层向量表示拼接学习上下文词嵌入。而GPT用Transformer代替LSTM作为编码器，首先进行了语言模型预训练，然后在下游任务微调模型参数。但GPT由于仅使用了单向语言模型，因此难以建模上下文信息。为了解决以上问题，研究者们提出了BERT，BERT模型结构如下图所示，它是一个基于Transformer的多层Encoder，通过执行一系列预训练，进而得到深层的上下文表示。</p><p><a href="https://camo.githubusercontent.com/f5297c1c8c1e71180cb62aca463503d21122e911/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313331363136372e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/f5297c1c8c1e71180cb62aca463503d21122e911/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313331363136372e706e67" srcset="/img/loading.gif" alt="bert_elmo"></a></p><p>ELMo论文题目中Deep是指双向双层LSTM，而更关键的在于context。传统方法生成的单词映射表的形式，即先为每个单词生成一个静态的词向量，之后这个单词的表示就被固定住了，不会跟着上下文的变化而做出改变。事实上，由于一词多义的语言现象，静态词向量是有很大的弊端的。以bank为例，如果训练语料的足够大，事先学好的词向量中混杂着所有的语义。而当下游应用时，即使在新句子中，bank的上下文里包含money等词，我们基本可以确定bank是“银行”的语义而不是在其他上下文中的“河床”的语义，但是由于静态词向量不能跟随上下文而进行变化，所以bank的表示中还是混杂着多种语义。为了解决这一问题，ELMo首先进行了语言模型预训练，然后在下游任务中动态调整Word Embedding，因此最后输出的词表示能够充分表达单词在上下文中的特定语义，进而解决一词多义的问题。</p><p>GPT来自于openai，是一种生成式预训练模型。GPT 除了将ELMo中的LSTM替换为Transformer 的Encoder外，更开创了NLP界基于预训练-微调的新范式。尽管GPT采用的也是和ELMo相同的两阶段模式，但GPT在第一个阶段并没有采取ELMo中使用两个单向双层LSTM拼接的结构，而是采用基于自回归式的单向语言模型。</p><p>Google在NAACL 2018发表的论文中提出了BERT，与GPT相同，BERT也采用了预训练-微调这一两阶段模式。但在模型结构方面，BERT采用了ELMO的范式，即使用双向语言模型代替GPT中的单向语言模型，但是BERT的作者认为ELMo使用两个单向语言模型拼接的方式太粗暴，因此在第一阶段的预训练过程中，BERT提出掩码语言模型，即类似完形填空的方式，通过上下文来预测单词本身，而不是从右到左或从左到右建模，这允许模型能够自由地编码每个层中来自两个方向的信息。而为了学习句子的词序关系，BERT将Transformer中的三角函数位置表示替换为可学习的参数，其次为了区别单句和双句输入，BERT还引入了句子类型表征。BERT的输入如图所示。此外，为了充分学习句子间的关系，BERT提出了下一个句子预测任务。具体来说，在训练时，句子对中的第二个句子有50％来自与原有的连续句子，而其余50%的句子则是通过在其他句子中随机采样。同时，消融实验也证明，这一预训练任务对句间关系判断任务具有很大的贡献。除了模型结构不同之外，BERT在预训练时使用的无标签数据规模要比GPT大的多。</p><p><a href="https://camo.githubusercontent.com/1fa48883f724ed604556d3bb9d241511012d1972/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313334383435362e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1fa48883f724ed604556d3bb9d241511012d1972/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313334383435362e706e67" srcset="/img/loading.gif" alt="bert_input"></a></p><p>在第二阶段，与GPT相同，BERT也使用Fine-Tuning模式来微调下游任务。如下图所示，BERT与GPT不同，它极大的减少了改造下游任务的要求，只需在BERT模型的基础上，通过额外添加Linear分类器，就可以完成下游任务。具体来说，对于句间关系判断任务，与GPT类似，只需在句子之间加个分隔符，然后在两端分别加上起始和终止符号。在进行输出时，只需把句子的起始符号[CLS]在BERT最后一层中对应的位置接一个Softmax+Linear分类层即可；对于单句分类问题，也与GPT类似，只需要在句子两段分别增加起始和终止符号，输出部分和句间关系判断任务保持一致即可；对于问答任务，由于需要输出答案在给定段落的起始和终止位置，因此需要先将问题和段落按照句间关系判断任务构造输入，输出只需要在BERT最后一层中第二个句子，即段落的每个单词对应的位置上分别接判断起始和终止位置的分类器；最后，对于NLP中的序列标注问题，输入与单句分类任务一致，不同的是在BERT最后一层中每个单词对应的位置上接分类器即可。</p><p><a href="https://camo.githubusercontent.com/265b6f273c9731886f63f66b7beb2805226cee73/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313430393538322e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/265b6f273c9731886f63f66b7beb2805226cee73/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313430393538322e706e67" srcset="/img/loading.gif" alt="bert_task"></a></p><p>更重要的是，BERT开启了NLP领域“预训练-微调”这种两阶段的全新范式。在第一阶段首先在海量无标注文本上预训练一个双向语言模型，这里特别值得注意的是，将Transformer作为特征提取器在解决并行性和长距离依赖问题上都要领先于传统的RNN或者CNN，通过预训练的方式，可以将训练数据中的词法、句法、语法知识以网络参数的形式提炼到模型当中，在第二阶段使用下游任务的数据Fine-tuning不同层数的BERT模型参数，或者把BERT当作特征提取器生成BERT Embedding，作为新特征引入下游任务。这种两阶段的全新范式尽管是来自于计算机视觉领域，但是在自然语言处理领域一直没有得到很好的运用，而BERT作为近些年NLP突破性进展的集大成者，最大的亮点可以说不仅在于模型性能好，并且几乎所有NLP任务都可以很方便地基于BERT进行改造，进而将预训练学到的语言学知识引入下游任务，进一步提升模型的性能。</p><h3 id="基于Bert的文本分类"><a href="#基于Bert的文本分类" class="headerlink" title="基于Bert的文本分类"></a>基于Bert的文本分类</h3><h4 id="Bert-Pretrain"><a href="#Bert-Pretrain" class="headerlink" title="Bert Pretrain"></a>Bert Pretrain</h4><p>预训练过程使用了Google基于Tensorflow发布的BERT源代码。首先从原始文本中创建训练数据，由于本次比赛的数据都是ID，这里重新建立了词表，并且建立了基于空格的分词器。</p><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WhitespaceTokenizer</span>(<span class="hljs-title">object</span>):</span>    <span class="hljs-string">""</span><span class="hljs-string">"WhitespaceTokenizer with vocab."</span><span class="hljs-string">""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, vocab_file)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">self</span>.vocab = load_vocab(vocab_file)        <span class="hljs-keyword">self</span>.inv_vocab = &#123;<span class="hljs-symbol">v:</span> k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.vocab.items()&#125;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tokenize</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, text)</span></span><span class="hljs-symbol">:</span>        split_tokens = whitespace_tokenize(text)        output_tokens = []        <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> <span class="hljs-symbol">split_tokens:</span>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">vocab:</span>                output_tokens.append(token)            <span class="hljs-symbol">else:</span>                output_tokens.append(<span class="hljs-string">"[UNK]"</span>)        <span class="hljs-keyword">return</span> output_tokens    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert_tokens_to_ids</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, tokens)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">return</span> convert_by_vocab(<span class="hljs-keyword">self</span>.vocab, tokens)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert_ids_to_tokens</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, ids)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">return</span> convert_by_vocab(<span class="hljs-keyword">self</span>.inv_vocab, ids)</code></pre><p>预训练由于去除了NSP预训练任务，因此将文档处理多个最大长度为256的段，如果最后一个段的长度小于256/2则丢弃。每一个段执行按照BERT原文中执行掩码语言模型，然后处理成tfrecord格式。</p><pre><code class="hljs vim">def create_segments_from_document(document, max_segment_length):    <span class="hljs-string">""</span><span class="hljs-string">"Split single document to segments according to max_segment_length."</span><span class="hljs-string">""</span>    assert <span class="hljs-built_in">len</span>(document) == <span class="hljs-number">1</span>    document = document[<span class="hljs-number">0</span>]    document_len = <span class="hljs-built_in">len</span>(document)    <span class="hljs-built_in">index</span> = <span class="hljs-keyword">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, document_len, max_segment_length))    other_len = document_len % max_segment_length    <span class="hljs-keyword">if</span> other_len &gt; max_segment_length / <span class="hljs-number">2</span>:        <span class="hljs-built_in">index</span>.<span class="hljs-keyword">append</span>(document_len)    segments = []    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">index</span>) - <span class="hljs-number">1</span>):        segment = document[<span class="hljs-built_in">index</span>[i]: <span class="hljs-built_in">index</span>[i+<span class="hljs-number">1</span>]]        segments.<span class="hljs-keyword">append</span>(segment)    <span class="hljs-keyword">return</span> segments</code></pre><p>在预训练过程中，也只执行掩码语言模型任务，因此不再计算下一句预测任务的loss。</p><pre><code class="hljs lisp">(<span class="hljs-name">masked_lm_loss</span>, masked_lm_example_loss, masked_lm_log_probs) = get_masked_lm_output(    bert_config, model.get_sequence_output(), model.get_embedding_table(),    masked_lm_positions, masked_lm_ids, masked_lm_weights)total_loss = masked_lm_loss</code></pre><p>为了适配句子的长度，以及减小模型的训练时间，我们采取了BERT-mini模型，详细配置如下。</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"hidden_size"</span>: <span class="hljs-number">256</span>,  <span class="hljs-attr">"hidden_act"</span>: <span class="hljs-string">"gelu"</span>,  <span class="hljs-attr">"initializer_range"</span>: <span class="hljs-number">0.02</span>,  <span class="hljs-attr">"vocab_size"</span>: <span class="hljs-number">5981</span>,  <span class="hljs-attr">"hidden_dropout_prob"</span>: <span class="hljs-number">0.1</span>,  <span class="hljs-attr">"num_attention_heads"</span>: <span class="hljs-number">4</span>,  <span class="hljs-attr">"type_vocab_size"</span>: <span class="hljs-number">2</span>,  <span class="hljs-attr">"max_position_embeddings"</span>: <span class="hljs-number">256</span>,  <span class="hljs-attr">"num_hidden_layers"</span>: <span class="hljs-number">4</span>,  <span class="hljs-attr">"intermediate_size"</span>: <span class="hljs-number">1024</span>,  <span class="hljs-attr">"attention_probs_dropout_prob"</span>: <span class="hljs-number">0.1</span>&#125;</code></pre><p>由于我们的整体框架使用Pytorch，因此需要将最后一个检查点转换成Pytorch的权重。</p><pre><code class="hljs reasonml">def convert<span class="hljs-constructor">_tf_checkpoint_to_pytorch(<span class="hljs-params">tf_checkpoint_path</span>, <span class="hljs-params">bert_config_file</span>, <span class="hljs-params">pytorch_dump_path</span>)</span>:    # Initialise PyTorch model    config = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BertConfig</span>.</span></span>from<span class="hljs-constructor">_json_file(<span class="hljs-params">bert_config_file</span>)</span>    print(<span class="hljs-string">"Building PyTorch model from configuration: &#123;&#125;"</span>.format(str(config)))    model = <span class="hljs-constructor">BertForPreTraining(<span class="hljs-params">config</span>)</span>    # Load weights from tf checkpoint    load<span class="hljs-constructor">_tf_weights_in_bert(<span class="hljs-params">model</span>, <span class="hljs-params">config</span>, <span class="hljs-params">tf_checkpoint_path</span>)</span>    # Save pytorch-model    print(<span class="hljs-string">"Save PyTorch model to &#123;&#125;"</span>.format(pytorch_dump_path))    torch.save(model.state<span class="hljs-constructor">_dict()</span>, pytorch_dump_path)</code></pre><p>预训练消耗的资源较大，硬件条件不允许的情况下建议<strong>直接下载开源的模型</strong></p><h4 id="Bert-Finetune"><a href="#Bert-Finetune" class="headerlink" title="Bert Finetune"></a>Bert Finetune</h4><p><a href="https://camo.githubusercontent.com/6ee5331933f1637d5835522efb64f4951f6213ec/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313532363332362e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/6ee5331933f1637d5835522efb64f4951f6213ec/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313532363332362e706e67" srcset="/img/loading.gif" alt="experimental) Dynamic Quantization on BERT — PyTorch Tutorials 1.5 ..."></a></p><p>微调将最后一层的第一个token即[CLS]的隐藏向量作为句子的表示，然后输入到softmax层进行分类。</p><pre><code class="hljs nix">sequence_output, <span class="hljs-attr">pooled_output</span> = \    self.bert(<span class="hljs-attr">input_ids=input_ids,</span> <span class="hljs-attr">token_type_ids=token_type_ids)</span><span class="hljs-keyword">if</span> self.pooled:    <span class="hljs-attr">reps</span> = pooled_output<span class="hljs-keyword">else</span>:    <span class="hljs-attr">reps</span> = sequence_output[:, <span class="hljs-number">0</span>, :]  <span class="hljs-comment"># sen_num x 256</span><span class="hljs-keyword">if</span> self.training:    <span class="hljs-attr">reps</span> = self.dropout(reps)</code></pre><h3 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章介绍了Bert的原理和使用，具体包括pretrain和finetune两部分。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;赛题理解&quot;&gt;&lt;a href=&quot;#赛题理解&quot; class=&quot;headerlink&quot; title=&quot;赛题理解&quot;&gt;&lt;/a&gt;赛题理解&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;赛题名称：零基础入门NLP之新闻文本分类&lt;/li&gt;
&lt;li&gt;赛题任务：赛题以自然语言处理为背景，要求选手对新闻文
      
    
    </summary>
    
    
      <category term="自然语言处理" scheme="https://sulimin-nb.github.io/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="自然语言处理" scheme="https://sulimin-nb.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>论文阅读2</title>
    <link href="https://sulimin-nb.github.io/article/1d82fc97.html"/>
    <id>https://sulimin-nb.github.io/article/1d82fc97.html</id>
    <published>2020-07-19T09:49:00.000Z</published>
    <updated>2020-07-20T16:12:02.821Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Prototypical-Networks-for-Few-shot-Learning"><a href="#1-Prototypical-Networks-for-Few-shot-Learning" class="headerlink" title="1.Prototypical Networks for Few-shot Learning"></a>1.Prototypical Networks for Few-shot Learning</h1><p><img src="/article/1d82fc97/image-20200719181649169.png" srcset="/img/loading.gif" alt="image-20200719181649169"></p><p><img src="/article/1d82fc97/image-20200719181614391.png" srcset="/img/loading.gif" alt="image-20200719181614391"></p><h1 id="2-Transferrable-Prototypical-Networks-for-Unsupervised-Domain-Adaptation"><a href="#2-Transferrable-Prototypical-Networks-for-Unsupervised-Domain-Adaptation" class="headerlink" title="2.Transferrable Prototypical Networks for Unsupervised Domain Adaptation"></a>2.Transferrable Prototypical Networks for Unsupervised Domain Adaptation</h1><p><img src="/article/1d82fc97/tempsnip.png" srcset="/img/loading.gif" alt="tempsnip"></p><p><strong>motivation:</strong></p><p><img src="/article/1d82fc97/image-20200720103101415.png" srcset="/img/loading.gif" alt="image-20200720103101415"></p><p><strong>design:</strong></p><p><img src="/article/1d82fc97/image-20200720103210812.png" srcset="/img/loading.gif" alt="image-20200720103210812"></p><p><img src="/article/1d82fc97/image-20200720103352834.png" srcset="/img/loading.gif" alt="image-20200720103352834"></p><p><img src="/article/1d82fc97/image-20200720103521702.png" srcset="/img/loading.gif" alt="image-20200720103521702"></p><p>相较于域级别而言，类级别的MMD更加地细粒度(fine-grained更细致)。</p><p><img src="/article/1d82fc97/image-20200720104021744.png" srcset="/img/loading.gif" alt="image-20200720104021744"></p><p><strong>motivation:</strong></p><p><img src="/article/1d82fc97/image-20200720104121465.png" srcset="/img/loading.gif" alt="image-20200720104121465"></p><p><strong>design:</strong></p><p><img src="/article/1d82fc97/image-20200720104403499.png" srcset="/img/loading.gif" alt="image-20200720104403499"></p><p><img src="/article/1d82fc97/image-20200720104647122.png" srcset="/img/loading.gif" alt="image-20200720104647122"></p><p>不同于单独匹配不同域之间的每个类的prototype，task-specific adaptation同时匹配所有类的prototypes。力求每个样本的类分布的score distributions相似.</p><p><img src="/article/1d82fc97/image-20200720105117126.png" srcset="/img/loading.gif" alt="image-20200720105117126"></p><p><strong>Optimization:</strong><br>源域上的监督学习</p><p><img src="/article/1d82fc97/image-20200720105431189.png" srcset="/img/loading.gif" alt="image-20200720105431189"></p><p><img src="/article/1d82fc97/image-20200720105531478.png" srcset="/img/loading.gif" alt="image-20200720105531478"></p><p><strong>Training Procedure:</strong></p><p><img src="/article/1d82fc97/image-20200720105706495.png" srcset="/img/loading.gif" alt="image-20200720105706495"></p><p><strong>推理阶段(测试阶段)：</strong></p><p><img src="/article/1d82fc97/image-20200720110755325.png" srcset="/img/loading.gif" alt="image-20200720110755325"></p><h1 id="3-Distant-Supervised-Centroid-Shift-A-Sample-and-Efficient-Approach-to-Visual-Domain-Adaptation"><a href="#3-Distant-Supervised-Centroid-Shift-A-Sample-and-Efficient-Approach-to-Visual-Domain-Adaptation" class="headerlink" title="3.Distant Supervised Centroid Shift: A Sample and Efficient Approach to Visual Domain Adaptation"></a>3.Distant Supervised Centroid Shift: A Sample and Efficient Approach to Visual Domain Adaptation</h1><p><strong>问题定义：</strong></p><p><img src="/article/1d82fc97/image-20200720140545581.png" srcset="/img/loading.gif" alt="image-20200720140545581"></p><p><strong>Method：</strong></p><p><img src="/article/1d82fc97/image-20200720141255925.png" srcset="/img/loading.gif" alt="image-20200720141255925"></p><p><strong>(1) 类内散度最小化(Source Domain)：</strong></p><p><img src="/article/1d82fc97/image-20200720141722664.png" srcset="/img/loading.gif" alt="image-20200720141722664"></p><p><img src="/article/1d82fc97/image-20200720142301426.png" srcset="/img/loading.gif" alt="image-20200720142301426"></p><p><strong>类内散度最小化(Target Domain)：</strong></p><p><img src="/article/1d82fc97/image-20200720142652395.png" srcset="/img/loading.gif" alt="image-20200720142652395"></p><p>目标域不存在标签，采用最近邻中心的分类器，同时force Target类中心和对应的Source类中心靠近。<br>就是把Source类中心加上一个偏移量视为Target类中心，同时最小化此偏移量。<br><strong>总体目标如下：</strong></p><p><img src="/article/1d82fc97/image-20200720143112960.png" srcset="/img/loading.gif" alt="image-20200720143112960"></p><p><img src="/article/1d82fc97/image-20200720145649943.png" srcset="/img/loading.gif" alt="image-20200720145649943"></p><p><strong>relaxed trace-ratio objective：</strong></p><p><img src="/article/1d82fc97/image-20200720150033777.png" srcset="/img/loading.gif" alt="image-20200720150033777"></p><p><img src="/article/1d82fc97/image-20200720171415765.png" srcset="/img/loading.gif" alt="image-20200720171415765"></p><p><strong>Optimization(具体流程)：</strong><br>利用GEVD求解：</p><p><img src="/article/1d82fc97/image-20200720173504331.png" srcset="/img/loading.gif" alt="image-20200720173504331"></p><p><span style="color:red">这里需要再看看</span></p><p><img src="/article/1d82fc97/tempsnip2.png" srcset="/img/loading.gif" alt="tempsnip2"></p><p><img src="/article/1d82fc97/image-20200720180603912.png" srcset="/img/loading.gif" alt="image-20200720180603912"></p><p><img src="/article/1d82fc97/image-20200720180940704.png" srcset="/img/loading.gif" alt="image-20200720180940704"></p><p><img src="/article/1d82fc97/image-20200720181003000.png" srcset="/img/loading.gif" alt="image-20200720181003000"></p><h1 id="4-Adaptive-Cross-Modal-Few-shot-Learning"><a href="#4-Adaptive-Cross-Modal-Few-shot-Learning" class="headerlink" title="4. Adaptive Cross-Modal Few-shot Learning"></a>4. Adaptive Cross-Modal Few-shot Learning</h1><p><strong>背景知识：</strong></p><p><img src="/article/1d82fc97/image-20200720235811934.png" srcset="/img/loading.gif" alt="image-20200720235811934"></p><p><a href="# 1.Prototypical Networks for Few-shot Learning">第一篇</a>写了，这里就不赘述了。</p><p><img src="/article/1d82fc97/image-20200720235846044.png" srcset="/img/loading.gif" alt="image-20200720235846044"></p><p><strong>motivation:</strong></p><p><img src="/article/1d82fc97/tempsnip3.png" srcset="/img/loading.gif" alt="tempsnip3"></p><p><img src="/article/1d82fc97/image-20200720235727709.png" srcset="/img/loading.gif" alt="image-20200720235727709"></p><p><strong>方法Formulation：</strong></p><p><img src="/article/1d82fc97/image-20200721001159311.png" srcset="/img/loading.gif" alt="image-20200721001159311"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-Prototypical-Networks-for-Few-shot-Learning&quot;&gt;&lt;a href=&quot;#1-Prototypical-Networks-for-Few-shot-Learning&quot; class=&quot;headerlink&quot; title=&quot;1.
      
    
    </summary>
    
    
      <category term="linc实验室" scheme="https://sulimin-nb.github.io/categories/linc%E5%AE%9E%E9%AA%8C%E5%AE%A4/"/>
    
    
      <category term="论文阅读" scheme="https://sulimin-nb.github.io/tags/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>leetcode200-岛屿数量</title>
    <link href="https://sulimin-nb.github.io/article/708439c3.html"/>
    <id>https://sulimin-nb.github.io/article/708439c3.html</id>
    <published>2020-07-19T07:21:17.000Z</published>
    <updated>2020-07-19T15:37:46.505Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/categories/leetcode/"/>
    
      <category term="深度优先搜索，广度优先搜索" scheme="https://sulimin-nb.github.io/categories/leetcode/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode127-单词接龙</title>
    <link href="https://sulimin-nb.github.io/article/1c7950e9.html"/>
    <id>https://sulimin-nb.github.io/article/1c7950e9.html</id>
    <published>2020-07-19T07:20:13.000Z</published>
    <updated>2020-07-19T15:37:43.921Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/categories/leetcode/"/>
    
      <category term="深度优先搜索，广度优先搜索" scheme="https://sulimin-nb.github.io/categories/leetcode/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode126-单词接龙II</title>
    <link href="https://sulimin-nb.github.io/article/25dd8b3e.html"/>
    <id>https://sulimin-nb.github.io/article/25dd8b3e.html</id>
    <published>2020-07-19T07:19:28.000Z</published>
    <updated>2020-07-19T15:37:41.543Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/categories/leetcode/"/>
    
      <category term="深度优先搜索，广度优先搜索" scheme="https://sulimin-nb.github.io/categories/leetcode/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode22-括号生成</title>
    <link href="https://sulimin-nb.github.io/article/68fd8ba2.html"/>
    <id>https://sulimin-nb.github.io/article/68fd8ba2.html</id>
    <published>2020-07-19T06:34:03.000Z</published>
    <updated>2020-07-19T15:37:38.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="leetcode20-括号生成"><a href="#leetcode20-括号生成" class="headerlink" title="leetcode20.括号生成"></a>leetcode20.括号生成</h1><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例：</strong></p><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span>输出：[       <span class="hljs-string">"((()))"</span>,       <span class="hljs-string">"(()())"</span>,       <span class="hljs-string">"(())()"</span>,       <span class="hljs-string">"()(())"</span>,       <span class="hljs-string">"()()()"</span>     ]</code></pre><h2 id="一：暴力法"><a href="#一：暴力法" class="headerlink" title="一：暴力法"></a>一：暴力法</h2><p><strong>思路</strong></p><p>我们可以生成所有 $2^{2n}$ 个 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 字符构成的序列，然后我们检查每一个是否有效即可。</p><p><strong>算法</strong></p><p>为了生成所有序列，我们可以使用递归。长度为 <code>n</code> 的序列就是在长度为 <code>n-1</code> 的序列前加一个 <code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code>。</p><p>为了检查序列是否有效，我们遍历这个序列，并使用一个变量 <code>balance</code> 表示左括号的数量减去右括号的数量。如果在遍历过程中 <code>balance</code> 的值小于零，或者结束时 <code>balance</code> 的值不为零，那么该序列就是无效的，否则它是有效的。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(self, n: int)</span> -&gt; List[str]:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate</span><span class="hljs-params">(A)</span>:</span>            <span class="hljs-keyword">if</span> len(A) == <span class="hljs-number">2</span>*n:                <span class="hljs-keyword">if</span> valid(A):                    ans.append(<span class="hljs-string">""</span>.join(A))            <span class="hljs-keyword">else</span>:                A.append(<span class="hljs-string">'('</span>)                generate(A)                A.pop()                A.append(<span class="hljs-string">')'</span>)                generate(A)                A.pop()        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valid</span><span class="hljs-params">(A)</span>:</span>            bal = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> A:                <span class="hljs-keyword">if</span> c == <span class="hljs-string">'('</span>: bal += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>: bal -= <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> bal &lt; <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">return</span> bal == <span class="hljs-number">0</span>        ans = []        generate([])        <span class="hljs-keyword">return</span> ans</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(2^{2n}n)$，对于 $2^{2n}$ 个序列中的每一个，我们用于建立和验证该序列的复杂度为 $O(n)$。</li></ul><p>空间复杂度：$O(n)$，除了答案数组之外，我们所需要的空间取决于递归栈的深度，每一层递归函数需要 $O(1)$ 的空间，最多递归 $2n$ 层，因此空间复杂度为 $O(n)$。</p><h2 id="方法二：回溯法"><a href="#方法二：回溯法" class="headerlink" title="方法二：回溯法"></a>方法二：回溯法</h2><p><strong>思路和算法</strong></p><p>方法一还有改进的余地，可以只在序列仍然保持有效时添加 <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>，而不是像 <a href="#方法一：暴力法">方法一</a> 那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点。<br>如果左括号数量不大于 $n$，可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(self, n)</span>:</span>        ans = []        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(S, left, right)</span>:</span>            <span class="hljs-keyword">if</span> len(S) == <span class="hljs-number">2</span> * n:                ans.append(<span class="hljs-string">''</span>.join(S))                <span class="hljs-keyword">return</span>            <span class="hljs-keyword">if</span> left &lt; n:                S.append(<span class="hljs-string">'('</span>)                backtrack(S, left+<span class="hljs-number">1</span>, right)                S.pop()            <span class="hljs-keyword">if</span> right &lt; left:                S.append(<span class="hljs-string">')'</span>)                backtrack(S, left, right+<span class="hljs-number">1</span>)                S.pop()        backtrack([], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> ans</code></pre><p><strong>复杂度分析</strong></p><p>复杂度分析依赖于理解 <code>generateParenthesis(n)</code> 中有多少个元素。事实证明这是第 $n$ 个卡特兰数 $\dfrac{1}{n+1}\dbinom{2n}{n}$ ，这是由 $\dfrac{4^n}{n\sqrt{n}}$ 渐近界定的。</p><ul><li>时间复杂度：时间复杂度：$O(\dfrac{4^n}{\sqrt{n}})$，在回溯过程中，每个答案需要 $O(n)$ 的时间复制到答案数组中。</li><li>空间复杂度：$O(n)$，除了答案数组之外，我们所需要的空间取决于递归栈的深度，每一层递归函数需要 $O(1)$ 的空间，最多递归 $2n$ 层，因此空间复杂度为 $O(n)$。</li></ul><h2 id="方法三：按括号序列的长度递归"><a href="#方法三：按括号序列的长度递归" class="headerlink" title="方法三：按括号序列的长度递归"></a>方法三：按括号序列的长度递归</h2><p><strong>思路与算法</strong></p><p>任何一个括号序列都一定是由 <code>(</code> 开头，并且第一个 <code>(</code> 一定有一个唯一与之对应的 <code>)</code>。这样一来，每一个括号序列可以用 <code>(a)b</code> 来表示，其中 <code>a</code> 与 <code>b</code> 分别是一个合法的括号序列（可以为空）。</p><p>那么，要生成所有长度为 <code>2 * n</code> 的括号序列，我们定义一个函数 <code>generate(n)</code> 来返回所有可能的括号序列。那么在函数 <code>generate(n)</code> 的过程中：</p><p>我们需要枚举与第一个 <code>(</code> 对应的 ) 的位置 <code>2 * i + 1</code>；<br>递归调用 <code>generate(i)</code> 即可计算 a 的所有可能性；<br>递归调用 <code>generate(n - i - 1)</code> 即可计算 b 的所有可能性；<br>遍历 <code>a</code> 与 <code>b</code> 的所有可能性并拼接，即可得到所有长度为 <code>2 * n</code> 的括号序列。<br>为了节省计算时间，我们在每次 <code>generate(i)</code> 函数返回之前，把返回值存储起来，下次再调用 <code>generate(i)</code> 时可以直接返回，不需要再递归计算。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-meta">    @lru_cache(None)</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(self, n: int)</span> -&gt; List[str]:</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> [<span class="hljs-string">''</span>]        ans = []        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(n):            <span class="hljs-keyword">for</span> left <span class="hljs-keyword">in</span> self.generateParenthesis(c):                <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> self.generateParenthesis(n<span class="hljs-number">-1</span>-c):                    ans.append(<span class="hljs-string">'(&#123;&#125;)&#123;&#125;'</span>.format(left, right))        <span class="hljs-keyword">return</span> ans</code></pre><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：$O(\dfrac{4^n}{\sqrt{n}})$，该分析与 方法二 类似。</p></li><li><p>空间复杂度：$O(\dfrac{4^n}{\sqrt{n}})$，此方法除答案数组外，中间过程中会存储与答案数组同样数量级的临时数组，是我们所需要的空间复杂度。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;leetcode20-括号生成&quot;&gt;&lt;a href=&quot;#leetcode20-括号生成&quot; class=&quot;headerlink&quot; title=&quot;leetcode20.括号生成&quot;&gt;&lt;/a&gt;leetcode20.括号生成&lt;/h1&gt;&lt;p&gt;数字 n 代表生成括号的对数，请你设
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/categories/leetcode/"/>
    
      <category term="深度优先搜索，广度优先搜索" scheme="https://sulimin-nb.github.io/categories/leetcode/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>leetcode433-最小基因变化</title>
    <link href="https://sulimin-nb.github.io/article/e3f6d653.html"/>
    <id>https://sulimin-nb.github.io/article/e3f6d653.html</id>
    <published>2020-07-19T05:21:24.000Z</published>
    <updated>2020-07-19T15:37:35.284Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/categories/leetcode/"/>
    
      <category term="深度优先搜索，广度优先搜索" scheme="https://sulimin-nb.github.io/categories/leetcode/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>nlp</title>
    <link href="https://sulimin-nb.github.io/article/6b3bc2e7.html"/>
    <id>https://sulimin-nb.github.io/article/6b3bc2e7.html</id>
    <published>2020-07-17T08:14:00.000Z</published>
    <updated>2020-07-19T15:37:26.589Z</updated>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">You must enter the password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="80f20397b22cf838dc793b6245d26df9b83197b349949ce5fc455021b02a6807">b85d65bd5cb71f9298fd63e227595d840402da5a2c650b99eda8f9791145ce419313381dc16ed82315d6e2dbdb7fdf16fcf807fc0f28e6f11b9d4098674e623b268aac62adbb6aecbd580f1f74b2c6c14771f0193d91bb07b826ce17bd2cfca980db04f2cdbbe44f59af61c7c146857e6bb005e2567e823d91c6e1aa92b39fb3f543b720c3e0e9eaec708eeeef34da639a88d821a951ee7d7d08d5ad8d84e0d7374a8ad207446af1cf9484bdc0fdcc5a61ce71a3c0743d4a75c0e0bb66947d7eb187d9159c421e4d028da05f1ef1b81d0fa046e39e85a786936bec3c00543a2513d3c4ec6ee3af3b87adea1bce51b0862ac28bb3172568614f48b4d89364600927f6772d3eda6125813e95b4ba2dd8d9037d953ac1b32f8fd2b2f8281493459daf7781d111bb225bad1f43ec91df68e10202332faca6a04eb0d63e217abcd9296f147f06f2b82b8dbf0ef6063198a68e164af050bc82edaa7bbf0e78d6f7ed37bb8c2bba47bbc28b75ba8d194a1ead762d1b3d877c986e37244404891de095ed80c6279c80b78462c3fd6ec6bef383b64f8beab2b5872ed7dbd71c20812e1376d3f0a0cbbcd2b13e25e1b9b49fce681a1283b37f00f3446c09faef61ca076939a30fa071e5d8af25e2988d5d73e81b88b4f87bc8880bcddb99c026b6d1603a88219f3e072bcf22e557ed7364692bf6bbc1f16c6736efc670b537358bd0f09272560b7b632827b6b77dbbcd015e65c2472a1930afcea8e7808d9c83e3e85ce88fcf5e9fd4bf02deb8da96b0009a6af69585daa0f1c3a55096939bda872025ddba36166041a159874e8e94715d5fa5a36a266500e8c4e09d920d12cd82bb12238366b0285a62db977606e376fc140d7c06dcd44f4b948f1a36d1c0a665a58756301fb779b2810c84dc04f5688cf835b4d021d61afd5e5d9e58f552ea28afee2f73624f440c3822395627d830e204f4f355fe248db5b044d2110444415e433d2858d336ced03a941b114a4324751da66daf087bc63a20d7dd8e94992734615ae450bc8024b3c1baf186ca11f235c20ad8bb4b91caad8f86da6317f252e04021b023d023f5d8acc4d7668fc09a27238de961ac2f0adfbcd6df4b3fa82db795c9ead450828bb54b989172bafddf03d3f6787f0fe792aa9d6da52cd37800a121f99bf34edad8d467401a068bf190994884572b11e9220821b0b8afc92c467aac7ba071c1a8a5ee44b91e4d309df7369ee641d5bb687ec54fb7fbf5def0dacafcfdc87776143b12a1eb801a217a1e62f9ac3b5ff1a1bbcdcde3b3e077e3f97316c596b542a7cb9c7cf236a67def31f37853d7c80bd079b043906adcb2f0965029be59b8c2fdee508c6f330c5759905a7790b15ac13c209efd22c56c3d732c8c47f1b2dea86f9971778920e5858fdda115bf1123c08d06f7fa5b6142b1ec9ba28b6794a74c16c78e645e3df0c5093e1d489fd212d8b9d26a6af2a412d13802d6fd07adaa947bc73ccb04a75d4dd15bf597f91ced635a69eb1943be06ae6f571a5c7cc63ea288acbf05145059b8b1d930b3cfc55bbc431bcba333e62e75966ea721b58799c7295d40f993aea6e5a7caec01e33924b7708569e9c2501279786b398239a5d1c8a27686fca8d7a37390e27723601704e62b2a62d39b225620e04fe5eba7eafc86691bed1d609ebd8d3e80b67d665d3334ec6aa10564e09fc0d428bf9f7ee0e24337ad09ef3cef4e2d689c7f493ee5c733bd04203fab63e5f434a38a90cb2847cf318579988532c3e10f31aafcbb91b9d30ec5ad44223f5565fa6af4e206de3d7e904662f7369bc2c570dd1f6c2e7728661f9e83efa3767f494d62160d5be1ea71a0a52945e70b82a9542b441cf193722cfb264bd64ff0ad98f94ea82401fdb2a07c684e87732a99413f0999f050cbbc86bcbe56a69b81e214aad49a5aab91ae3786af6d6a04144c4d9a4c1069c4669daef0e1391b8b2134f7f2ffdf835468ef66a293b5a99c4b5411286402785845d0427bb3baf85bcad8ccc97ca0874102f167c1b3020f4bb1205d1cd92020e5ae649c6cefee48ac625c65db388f910fa62b806a0fb4f6e3de19598fc1f1c95d5eaaa4334c078cf6768b16c4c53464fa6dfc24ccb962ebd1379c1e694266951938245d27aa0e1f200fa6f9b60bfa1f939a3b1e4130b33e6f5620236390561e050a5e53d7cdf9ee4fe39a974c8551f316e442107a63807a7a1d568d6e5d1cb7e26a44c2296f2d90a44d93edfe8f1191f2c16a7978e95013c05ba6aa7f533a2be900745ac79ea54735efe4be631161182a1622f07904b5cba14b71b8b91ebef8ec20b0b14bd552c55ecb907b95ba68d7b054392c0c728d1818d55615a53f62191314717d7d996ee4116ee71f6645f80724f1c4734f4212c043edd56ec149631956c720d45141906c4a47b807e5301f3d0651e16694004ec0f354cc22bbf81f228a4c0c3c403d4aa5310f6b3e9bd120254605e23ccb4405549c60961a7c682c75bce1bc5674c834a94f2f175e865c45f8ae8748cd2327623689d7c0ba1ff569e6784b77f966ea97e288bf0d7ef21140485c7ee2bdadfe8fdbbee0dee55f2bd6d4a011b2bea6e633f38bdedefc530f1a41d7dd1acc1784b907446fee0d09a8189d5981d91f2d680b07b943eb2c93d26c0eb183b3fc129422c540df2ba1a02bbc8d41e094595465392f8698226b2c94127371d3b9edba6946d2fb068cac81235ac939ef493f5e2b5b0b8eb1ce4a334b03cb22d111f98a552b66f4260d4133198d248e461275298cc0d557b157f459bdd94f6ffb68194c5b531b36110d53e084578d1697507b12eafc360224da1d84c9c9af78e48640fa32f7e75ed7fccb027e49a5c3c9297706293f71b72e34529076b9b067c533fa4e667dc8aa767de52f03c9c5275260c5a8fa3ffb5b94334a0c8f5d0edd3666ed53e1716c63306581e87c0ccf92ea4d604e628de7e009c20c2721ff3b690eb6ca74965f7e9ebd2ec16226a13da6be438601360ca7f68d461cb8f6892475d174c88194054b2b22a6200db6e5d5018655a14b7828856847d30a76c49beb7b595f49bcd9d4c63a5d6416a9b595a8e9e29bb065883fe8e4dff3388dfbc9515a4e76d676b58952d1fcdb8533ed5b85f34b02181d15ece2241bb89e1d0a91262b766b003bffbb2a469bd588ff717bde43940c9e7718405b4b36e0136720297a7c24487ea3c66f594b8570b88f6e1901db8f1587dbf99f82662cfb3188d04da732455aeb0ef7cefc4903ca9b0035484b44ac6b580b1338f8e0adcad6bcfe46b553dacb6184af8c85fe41c7aa573f3d5423265f28aa7505ad48c398deee74feaaa7bfde26872d14c80df4b865037106c301776128d5d5ed3e352f716f5e3e8c85a0ca286c8c87c02affc30a2231d988ccb2b87cef4792c9c230b3b8d6ca8056d2fca50778d36be8c1374398f09d1ae56d11bdbc598c9d1c3bf2fa21f01763b785c5799c9aedd6bac6424f9845734a0b70941a4a5d4c52c6806c51b5771d6ca12d24a14ab73c483a0ad2e0f3b0573887d17f7316e1bff113cea4048afa73fc973ffe44e3c81e10ea787b85dd20a5073ae4d8b3aefdae53fb2c190a3f2fa7bf775f72112758e8379325df1d34ddf8391d9c0ab727929affad2cf5d08f2012a4d61100f4f0378082737d70d15106a844741a0d818d5561744b6dab7fcd8caf7de50f66b9a4309b1ef49bde6f3cae789cf65d3389250649b67e487c88e13ac4c20b3a2df6bd24f003cf36c7f7028d13aae55a8707e4240416125b29ccdbe43fe4331d00d83e00cc9cb9a85378888ba2cdb44e7913efdf5ad9faa9c9148283818354fc098d6d45f2f0833637de731f68faf4911513f3d21e6d4e712d352d68e76ab9d0389fd24a7f8215e08697959e6a59bfc7d2fc5a70b9af831033245e100a8f194234b2869fb7eafbdc239299dffab7829f147ef63203d7bddd0584cd03299033d3bd5e60509d4cf1b17c2d89c8af002957353dbcac0b12dbfe068c264dc6696d379be2bfca2c0f94418c6210202d49336e61b1495df4db57280aaea3ce3981b1369b942876e7eb2bc29a0dd79fe56545e1c3daabd744f7124a49f669e9b44a4d37edea76c5308308869e91b6e14f9bd35e2ce2e02a173d1c14c6ae1990492f719d383762e83135822b4a5e50dafb33d78cc822890d7b52b65c14023983bb385916485d5ce568e3cf3ba1941fe87f4f054801fd3d3bd6e424938e00502d6a105749530ad5243a8d125515d307244bff10e3f8f975796035233fccce5f223e31173e6969e8f810e68451be23523de939b76dfd4ed4d6308c416bf4afd40bd130ee2cdd2ab8ab9d2ab2e04e158684ba48c6a1fc6aa3a3301e8862f9ee9f1cb52c5723959dea4b61e45df84cac0832ce410ef7294d367bf0d861e6cacd82974524c30fd68d71a74b49ba5ccd32249cd8c94f6cd3545242148261af45b73876ebf9c1919787ae9d561b3d0ede435103d99be0d6df544cbf27a13b601ccb0e15159567a35c8a19d5136d7ce05ee154e307284d5bbbcf3cc910e6ce877089ebbaf274a9525e8c1b504ca03330b8b133f4bed99145ba0efc4680b99a58a76e3f68543ebf9fa040e8864cae202593915f3172f89e9298d216e6eb264c837622523f56f76d1d375e97a250ae73b3cff9de27f42cea6a6250cf3f553312b17195dcd7be4bb3ec0a9223c650b6047a233af10a7c2c11b036d2c994961ff7912c47c458f30c33cd683de465ccef60404fa42165831b04fe952c546d849e5f5ebc79f247e4e6c6ed6bc78e9ee67b58c4321fd67979a5785371bd742c2ab7d6fd88916a7cd2722d25c0e08d4b8f75c91e9275ceff31338937f1b00122fb26bc3aa416ac865013f4cf54d7e47f15e24966d851999c871bb5914b5f490ea1152b2c8bc8e9fd2cdb7346219464d1bf91bd18c8f6e73e655be734ceda1736009394cfe9d1d4666d72c3fad8de86a5537d696161c035a6e647c1a4e7bd2ff49a0afeb9dea59c3f4d4093389c8f3521288a36aa8b3eb94b728253fb11828948783f4e07ffed103b36dd2ddc91847c9a7c71c05ebb55a12574a6f8d186254087a86972fb9803ef76e82c72c6270da62ccfcc7c9a28434318ca8d6f944dbbd287068924c14e479b591760c15be9155f6a0e2b0312594186ce0aafccfafac3b955fabe1ede7f1e5ea3e2cf1c0a46ff2a8f37aabeed3215214cfa17fab718216c524d43cc930ab05125c254c250b62b29548825395dc9a9e6b439628f7b19f2093a2e342606188e56fcb83b9a80ce48db5c20c0207a64d9c9d70f2a20f9e605ac18e51a840441e3e37039f5d30e809f276b2c93e14604d15166408e2e318996bb5e7ebc8e26c9f2a53a2290820ba6c86effe362cb6ca143f466c35183f9bb5a7b06b30d9ed0d25f33b33a150b3d4c57e64b88991767cd932057a59dd2a0c26f21f249a4aec8936f7768571bdcdf20c5aa6f32e2f5d24061347c7f4d0cd28eaf90c31e7494cef9a42733ed1ddc5b0b89f535a70ed626ed9a0a2cda0b04c4dc79f0404ae91cf045c4659e9a331dd407210d97627b499dd1e1867be8e953748816990830802aef70583fa669b10c49713ae08ba208269d510a690bb6625618a70dddf0f3cb3128580904df6b6caa56b24e88282b9a91349c2eb9113d76a1e9c5f6f9b638cb081ab038e7a1ecf28df5635c65597bf69e4ed498c77438765280608fb5ac3ddb98799ed74dcddf8d5119ac4cbfaf8ec88da3ad5a913013b72f51cc11f67c702c62aa929d5c4a8833fc34980a996bf7dc18f025cadc02ef07428015ff3da5aa744c92fd011652857f7b6b0470dff7bdf0ef4edcdfeeb7b3f5f866df1d499ea07b9f60e3b5fb77bb638db98991e2bfed5236240f0184b630e5268e0550cb18877f6af1f8f6e99f51b16d0fc064b0711c35708b357d8d89fce2630851c5caf2ab50a57b8de1ada93ab1fea38e0f72ed0e1424005d52226a776b132d425ed7636ba1bcb89eba7d6ecf7246fa6ba6acf3f4aeac97ef268497da41054bfb126d5f09c8db7ef929c7c406aca79c033166b404c675bd9aee6332f051754e504736935e582582a085709cfb20ff866e6cc64b54a6c21df123732a788943110a579d35784f461c28906e6a156565c48790d4a672cc3c4589944e44708b84d77587a10455f5fa59f4c07d6b1ca5191f5594cea7b78c94289c05535eeaf94cc4166e086dc41e2deebe76fec952b3b686c0c8d212514a416e993ce84d8257304e6d42757baa3a9cc592444d6aed0dd1e631319d7e6087c69801823a86838fbf6c9e5195ad30983a20c1b5e809bdfdf8ef31da3ce6541f1f006644b7e1b1d4fc3d5d4ed0da5689671ad706dbdafc31c570ad635e9e4f487fdae6c3a92d6063ed6d6aeb904e718bd03e6f30d54c83a0ecc11a0a3f63b27a86ec1c3e6687ea26b46ef44d745b1ca7e15bf731c2e9463480a973aa2cf1b347f310e24c5bfcdc3d83f3a8addfc6caba54cf0780ad12667f11ad4755c60b6bfdc689397363128f1c58ea77936c70dbf5075e1dcabab8fb28b02556da3162aa80fde21e50871f25399b24b96ffbea2c3d86ba556c9051db8dd97e04d8666b02d1050227754632a455d3c2680ceee95672347922832e505123c1fe725eebc8b5366878510ca1cdf3e6da58d3d498363e11c632b5373a927a46347ccea8c7bd7b3e3fc3fdd28ac7b4a65b21fbcc7c26a2c3f87ef705706a2a6fdd242f3f75336abef606093790e1bd162ed4db9e16d6e32fb00cc6159c9134d7973693ccfebcf7ee20715f4d0f3bf28c17442f4751003a0eca7e44a56cb1d4d6a0f03c8e203744f2d119a6bbb40fe982b8a82573e1497ebad836cc739150b8f3f09bb7cf8149462317a3c6ec596e9a4da0360ce10a857c951a9ea1cd030dce5d65d88c22d3e2199d0689ba633ac0f4f67bc7dab85f2851ca353ad99b4a081fc3bc4c9853c14c8b603e0ada12aacc588e4162bf134029745d843bdac14490a204ce41b53edd7409cc0f60140d833d415189decf600d5e34a67a4b4c6cb06e4f5d2a369c711b48a78421a9a62ae7b9d6139f6a3016b9b2132b2a2ee454e749d2ee71f74bf6e3c170c2952fb9255efe757dc8103bbf82464c9ecad17b451f38b485e8b50e9458d0a5f167f90a5f016d1d45b68a1ea91e4d11f064290f873b2e2f106ff15ccb6d267e30f5fbd24efd39f9a63dad8df2c8e308b11678aeef796a104baa3ac901f4d16b2ee69c1df05c02455b870558d688997df171a9e05e5d2ba11307f83e1f59591241da852dd5d8328e88544c87ea4091fc0d46a8d549663908ad825e36a80c7116db16903f3a756b85710e08591f616188094a80302ec026df347022ff923365d9e556524c4a0d40d668e98394cc7b8c30c8bbf7d6b1a59174857ccd89d9d64ff68b5a8fd38eb813179e0c072bf9d97d6b0b9e8488c0eda020df3bccb4a8e06ab8b66e004e081ac262f320ed572aca144e0baf09d6a55fd9a609ab98972bbb3b10e5ff3b2e63673def41fd570c6e083cbe5f03de9dbe2ef585485e2c8a2f21b8aad3f55f5c567df1c8f7d5531facf84ea770b57a8cf3378d1b15b839c65bd2ad5b75834c26a669e568da24e95a87610c6bd6717aa98ad5c7385b95aa89eaeaf229e65d19c18fbc91600a31b6bd1bb153e75e8f0642be8d93f13b6e589abd61133fd813e3ba3e1562452e99d7f3b20b6737fa71911774fcfcf5cb64794e4202949ba1288f9b815d7a78585dcad99dc67a450661fb6537b3b1d5d502f6e7818fcdb02b230ecd26de6912df4ed14437ecc0b0b97f5dd88173c2c45dfeb26b7bc9b3f3fddd4146fdd35ec42590a3723e7e9329d076282451dcd9f1cddba3e3884924aa0258ba751c30f31e06b3cc57ec35e27c7dc3b056e816d01c42b6d2cf84d7b9c6f20ba3ec4529eb3a0d217375418415e7228d553f466a791683502c87fe53d7b6738a8805dd9fa7007d6ea27bd8b24f9787f67f07b8e06ac7dc9ff70c5c58720b1bbad0716d7f39c4cae0b01a346dbcb50ed90e5001768c7200f72d828876973d3c5f0d81574413da19e6580a9fb254d4aa98942b18158aa1cb90c84c03fd18b963a4805e89313189786241e97dbe7d1504ea8d69e96c32c561c64f028a72ea62ccc9306b35d23bf49d1e8bb22c73783943efdedbde8a02e39bfca88259280e75a6f0055d9ed86790d615ef2a5f26a29894228df6422fc5c4c0ff64f4525fdebbfe78331530b3d57d41f74f777574d7489a5c8e1f41571706a7c1b378c5102e6c65d08d97f04b97a54b3fc2f5c49b655f5eea6084a97244541b1a81a85efdd4763a1f86099dff38a3c21743edda3ef696dc4eac4fca01a39a45b8de47e0ef6a80f942b828d72cbeb4c0bb0c449111b8862c65072cf25dece547a8743e6286be8073620d7d4599858dc9a1c37310ea13b660d5601327427e5fbca78e1a6d781ee739041ce6798076bed86e849ec744809804636494db5c18374098c8f4d69196e1e32d8857c92c3e2569ef0ae9ec38be17c52958547bc5771eb9b690936bc663bb982d3e2ee3d6262296173e55ebc3844499af103a6dcb6205c69c9573a8a59d652fc934c685585f73edc8e075c84a06a5a471ad2fc398f67a576b6365ce7f44f03303d0caf61530f42209302a92ec1d687052a6587a13903c0c40f62eda3a0a76f782d8370642c95be5ff6f872ed09f78e3869fbb55a7da4e2606f6e388afe868ebf3b6b8b0487e4b698fa28be08a0648d0a9bab528a19f6e6293c2ae82879d2f8b4e23d16c2b41a52855cb144e225b02f8f040d581b735254be2d8cda471b5b42c4088e4b36da333e762c5829ba0735894ec44f8fa43fea3b2f6e8f3416beb5519ecaaca7ae3ec8a7c34ebf51f62c14b4ee15730c9b12c5ae1123b7c78c82f63172bd1212760c5915553832ca70f6ed4711c221f508b167869daffbaef223fcaaa869a96b3daf5eea36e1f65e84e4909222b262a470e55c068ffa6ae0a2e6b28993d065fcda79f708f4d51a944d8a2c71a00d2e9bd7d8bb484a08b33b5ca97addbd0a8713ccd7edd172aa6c08030d1a5a8db8703d8d30707bdc883ddd0243459bd7989aa68ac00109b4251f4493266066e13f57b23da0133cfbf701daf8fc2ea559120733465b5f8f45d0082b2c11e02f353a36556291bcf83dd514afa4431c175b9ec81230dfcc00e38e1725e705a68231085ce7961153c23b78c99053836f30b6ab8f63f29ea6d9e0434990e5a36f067b858b5d08ca00bbc885a5f7bde4d7d9d714ca35e801b9cabe141609b747cdea2462ef8fb875c8add51ac24deb976ce81bffdec9906ba7634ca1b72d5e465c76df924f1867db929cc8651b7660373387c683a33df22d6434dda6252760274793f94f9afcbf04a9ecc69bdb295a3a52b69d0254fd3e0197be8d4d8e3614b7f223fd96f378b3c3e7e0b4b1752dcb29d21c35412d77dec907dbfc08f0c072106b4e6d79b2b0f0d9e9bc10ce8e8c4e6ee38beda8983f784e78bb5f2b32d2477589a0659d2fec8e2d3c45855b289aadb658a7f4b3e228abc0d5a4fdb7788f34a87ed755b2a8e191ef154df63066d1206deba0a8d3689c0be13e5fd738b030818318077f4008415254150d8c561806ecefe0a2b3c78d3671ff1382e5b101b99ee737c97d935dbfdde51d52199a288ad2d92ad9f1c0a004d774437f4d0e0b359fb9abb48eb6738d03e4b90319eb709b539b4933ed9486338445d59a0522fe86b1a88d8ad5ecccba80ccd2e465b8a5441f3448591f59069a6f3d8e092d8a6ef1ffbd9dce6749f9527fe23f02469a8f6a640c66c17518056fcbd9e0495510420b0dbc030c1c3f3f0c75bb625a8b0911f5732cc5d068721144fbc676f603146d60cb7f0c9153909da20c1a4b8ff571779c2e96d7c28ad74211bd73ddbc7ca1c68ffedf22a4b049571dcab395a6649e760583f4af122b2fcc70d386f5dc4dca18a6c260fae9b6f11ca2f8e196874f819cce9e084aa30888f588c7c9ca1651631df2c1fdaa1377ae2bfa1db087bd6ea518286f82063657b641fd8ed6734167e56db5a85c1c01300a0d441cb12699a59f01bacf8ce8db88890cdf23fa820bc0d05225e8ea87a2ac29e10bc1d33871312442263ec1a35278d370907c462709c34a96db89527346885d62c927a85efa4a304566f941b70bff2b16f64c271a04d1192ea439f46359773c0e5947a3dcb43e15fdf0c7bcdec0afd66cc4b1c0e9707e189514705db13af981903f4075de99e350bb276eef0e6185e52ffcbc72e11265ce33455ac816a56056e349892e7ff7a96200289c41354ab833ea8fb69738ad592743ccaba511186c5e88fe85bf682816961a4a4e296991a76377a101cdee92091e650c6afc41e7ca288e603d3cff0a0d992db7f639ca91b12be609b4e0f26fab36749b8d7f7d0bdea3a9a217fe9b9423c50fbc9736361bccc886a079e302270a201a84ec820bb9d6b3b97e05151b020d3d7fa1f594df715ae11f6fce76334490bb18b6c8a59048f1b6226729a3991e64ddc34ddd8e6f7fa2b6760f2ce57214419cc2a43afc9b9d538097c4a560690d1b50c7060f9c1eeefe838bdf3209337b7bb07fdb0cf774bc69822ffa1ba4fbb93b1fb52089eef46f2b9b88fbadc64dcad9f00d27d060974cca8bd0d4239fd3f7c6b35b34056de37d95adff9c5659bb1c614a94ab277d2787b2b24c9143bc163be1826c6adfc49ee1769af128d4d2117cd33f742c679e92c3fc35d90a9866be44e21a1ea5bec2bc1944e6bbae04f76d25b1f2b48376c3a9bdedcd71608d1f12eb54c97ebcab554d3f11b3e718d8a696e8ce08e44861e70842099dbc8c24a63e6427229c4231f186100ccf4d52d991d224d86d3ffabc92570b52e52dd806d5d152ffadd623c635d0764a7ef1c4e93fe14493f2f2269cab19cb3bbc3aa6d6db8d5fb280443a421323a7916f0db4088106493b9e451c112e968998a09cb85f6d2b52517b9977494226ab31228bd118e776dba080abeab07394ec98336c1ef3afcedf920ca3f2243c9a7dd3de87923e24ad5fbf80ff6be441025651b311cb3c312da8bb391a86af5da0285e59afa9a77eeecf46268c08a1b8c5ce6d473f8869cbd69fcc42bcda961a07b172efa0e637665078a7405f163e0a04f2e2b1d93ad466cd14b279bf807b34d5905805ce9a6e2efce01933c0899348700a6cf7a483dcb022986122c75ea27b38cf3d226730297bf470980ddbeb642e6ded6a56dd6f2904e54908e0f33ea3c1a5ecc0b2ae59eb27735e725a56dd5e65807aa17fd9b4e98b24b17ef7d499f0d898ead686304b21245e34293c63880e77dfd2a71954a8f7761c5cba455ed78e98d87c6ee850114b7353e7dd9ddd5d8ec75c05f5291e2e7107045ba943b95c9c9b7d646d50a6d6df56a54f4693faf900a4df3520aa43fa2fc8b8bbed8766196ba0994f8ce36cfce1eca21c9eb9cd562ff0bab3120ed51267636d591a606bc9a14488a63df8b6edf34ea7eb0d1c3a6a0cc0ac99586f5bef0e2238d4f741868836a2d4f1fc671891e65273f83c3715b579f2905e924b7d8f3218c2d3decd87e5c2fb81a5966aebb63fc6bffd2967f9508c1d5f070e8034525e7acdd6771c99e13ab2d8a26295cfc8d3d0750e8c6875a72e61601554c05bc5b65f84da99fcb7424bd473d54c8a6ae91c2e83175e1bccad358ccdb36042ac276db14a86e4459f7f53ff2b1e12fef16a33e9d8b9eff240ae5de4f3d71aa0ff7a5c8705f8024d478de233748d27c4d73eb1d458b2521ceb98858d93d61a76ec043e2c36855584bbf44a5a0d2fc1f2055f189661e49994483996d5d0ff999c04d22b23e05c3fbdbc713294cbb5ad838316ab545fde0d8a1aa78fe3a92538e28526c75611d93b373d48dbec712d25ededc4da60049c87fcdd079c2a0c6b0402cbfea0b6514ed76b861df3bef37e317a4f62a39d4fa36d3f0f4a84eecbd4593d8100f1624eaaa4dbd9a48a9bf12709b961be61f8b1517b2fa1d8f50461bc9d5c6e1e6672db5222155899ef9006f84319eaf57c21ad597ae358cbd0d9370e66b17fa2e59e29ed0397c25f6853204c0c8f0692b542aeebe5238d1a1dd24f9c331b884fa47d11d14ffcf4ea1c425f170944935b9a0931f16665c4398d6c3cf803fc4395dc372bf10a1cfb810c43ec2551f5d6e03c8b2deea89c9b66949be910184a024618dac73b50252db3121b19b8d3e4acce7b97d0b7d9d55206c55a800921786de19828aaef76a9d53ee5059aa571093f2173d18b85f3d6754710e64ffaf7f31443c24295445f82824a276e23824f559c4bb423236dd0eb80b9290c45dec30bc29d5b2fa2ee18389a8fb02fe1331e86f09d40cd03b4a831a45a586fb9031a3f6fd33e975b13bc29612ed2938d0e1b0997a9af0c2230df76cd7aa391ccb06fcba47aa63f6976f761590409e97b3391c58821023400612b264fd8852</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    <summary type="html">
    
      This blog is encrypted.
    
    </summary>
    
    
      <category term="自然语言处理" scheme="https://sulimin-nb.github.io/categories/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
    
      <category term="自然语言处理" scheme="https://sulimin-nb.github.io/tags/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>算法-卡特兰数</title>
    <link href="https://sulimin-nb.github.io/article/f37649e5.html"/>
    <id>https://sulimin-nb.github.io/article/f37649e5.html</id>
    <published>2020-07-16T18:21:11.000Z</published>
    <updated>2020-07-17T08:01:22.372Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>leetcode785-判断二分图</title>
    <link href="https://sulimin-nb.github.io/article/fba1bed.html"/>
    <id>https://sulimin-nb.github.io/article/fba1bed.html</id>
    <published>2020-07-16T10:01:30.000Z</published>
    <updated>2020-07-17T08:04:10.198Z</updated>
    
    <content type="html"><![CDATA[<h1 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785.判断二分图"></a>785.判断二分图</h1><p>给定一个无向图<code>graph</code>，当这个图为二分图时返回<code>true</code>。</p><p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p><p><code>graph</code>将会以邻接表方式给出，<code>graph[i]</code>表示图中与节点i相连的所有节点。每个节点都是一个在<code>0</code>到<code>graph.length-1</code>之间的整数。这图中没有自环和平行边： <code>graph[i]</code>中不存在<code>i</code>，并且<code>graph[i]</code>中没有重复的值。</p><pre><code class="hljs angelscript">示例 <span class="hljs-number">1</span>:输入: [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]]输出: <span class="hljs-literal">true</span>解释: 无向图如下:<span class="hljs-number">0</span>---<span class="hljs-number">-1</span>|    ||    |<span class="hljs-number">3</span>---<span class="hljs-number">-2</span>我们可以将节点分成两组: &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>&#125; 和 &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;。</code></pre><pre><code class="hljs angelscript">示例 <span class="hljs-number">2</span>:输入: [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]]输出: <span class="hljs-literal">false</span>解释: 无向图如下:<span class="hljs-number">0</span>---<span class="hljs-number">-1</span>| \  ||  \ |<span class="hljs-number">3</span>---<span class="hljs-number">-2</span>我们不能将节点分割成两个独立的子集。</code></pre><p><strong>注意:</strong></p><ul><li><code>graph</code> 的长度范围为 <code>[1, 100]</code>。</li><li><code>graph[i]</code> 中的元素的范围为 <code>[0, graph.length - 1]</code>。</li><li><code>graph[i]</code> 不会包含 <code>i</code> 或者有重复的值。</li><li>图是无向的: 如果<code>j</code> 在 <code>graph[i]</code>里边, 那么 <code>i</code> 也会在 <code>graph[j]</code>里边。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于图中的任意两个节点 $u$ 和 $v$，如果它们之间有一条边直接相连，那么 $u$ 和 $v$ 必须属于不同的集合。</p><p>如果给定的无向图连通，那么我们就可以任选一个节点开始，给它染成红色。随后将该节点直接相连的所有节点染成绿色，表示这些节点不能与起始节点属于同一个集合。我们再将这些绿色节点直接相连的所有节点染成红色，以此类推，直到无向图中的每个节点均被染色。</p><p>如果我们能够成功染色，那么红色和绿色的节点各属于一个集合，这个无向图就是一个二分图；如果我们未能成功染色，即在染色的过程中，某一时刻访问到了一个已经染色的节点，并且它的颜色与我们将要给它染上的颜色不相同(即一条边上两个节点同色)，也就说明这个无向图不是一个二分图。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ul><li><p>我们任选一个节点开始，将其染成红色，并从该节点开始对整个无向图进行遍历；</p></li><li><p>在遍历的过程中，如果我们通过节点 u 遍历到了节点 v（即 u 和 v 在图中有一条边直接相连），那么会有两种情况：</p><ul><li>如果 v 未被染色，那么我们将其染成与 u 不同的颜色，并对 v 直接相连的节点进行遍历；</li><li>如果 v 被染色，并且颜色与 u 相同，那么说明给定的无向图不是二分图。我们可以直接退出遍历并返回 $\text{False}$ 作为答案。</li></ul></li></ul><p>当遍历结束时，说明给定的无向图是二分图，返回 $\text{True}$ 作为答案。</p><p>注意：题目中给定的无向图不一定保证连通，因此我们需要遍历每个节点，直至每一个节点都被染色，或确定答案为False为止。每次遍历开始时，任选一个未被染色的节点，将所有与该节点直接或间接相连的节点进行染色。</p><p>我们可以使用「深度优先搜索」或「广度优先搜索」对无向图进行遍历。</p><h2 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h2><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(self, graph: List[List[int]])</span> -&gt; bool:</span>        <span class="hljs-comment"># 方法一 深度优先搜索</span>        n = len(graph)        uncolored, red, green = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>        color = [<span class="hljs-number">0</span>] * n        valid = <span class="hljs-literal">True</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(curr, c)</span>:</span>            <span class="hljs-keyword">nonlocal</span> valid            color[curr] = c            ncolor = green <span class="hljs-keyword">if</span> color[curr] == red <span class="hljs-keyword">else</span> red            <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[curr]:                <span class="hljs-keyword">if</span> color[neighbor] == uncolored:                    dfs(neighbor, ncolor)                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> valid:                        <span class="hljs-keyword">return</span>                <span class="hljs-keyword">elif</span> color[neighbor] != ncolor:                    valid = <span class="hljs-literal">False</span>                    <span class="hljs-keyword">return</span>            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):            <span class="hljs-keyword">if</span> color[i] == uncolored:                dfs(i, red)                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> valid:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre><h2 id="方法二：广度优先搜索"><a href="#方法二：广度优先搜索" class="headerlink" title="方法二：广度优先搜索"></a>方法二：广度优先搜索</h2><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(self, graph: List[List[int]])</span> -&gt; bool:</span>        <span class="hljs-comment"># 方法二 广度优先搜索        </span>        n = len(graph)        uncolored, red, green = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>        color = [<span class="hljs-number">0</span>] * n        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):            <span class="hljs-keyword">if</span> color[i] == uncolored:                color[i] = red                queue = collections.deque([i])                <span class="hljs-keyword">while</span> queue:                    curr = queue.popleft()                    ncolor = green <span class="hljs-keyword">if</span> color[curr] == red <span class="hljs-keyword">else</span> red                    <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[curr]:                        <span class="hljs-keyword">if</span> color[neighbor] == uncolored:                            color[neighbor] = ncolor                            queue.append(neighbor)                        <span class="hljs-keyword">elif</span> color[neighbor] != ncolor:                            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span>  <span class="hljs-literal">True</span></code></pre><h2 id="方法三：并查集"><a href="#方法三：并查集" class="headerlink" title="方法三：并查集"></a>方法三：并查集</h2><p>二分图中，每个顶点的所有邻接点都应该属于同一个集合，且捕鱼顶点处于同一个集合，所以可以使用并查集解决这个问题。遍历图中每个顶点，将当前顶点的所有邻接点进行合并，并判断这些邻接点中是否存在某一邻接点意见与当前顶点处于同一个集合中，若是，则说明此无向图不是二分图。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UFS</span>:</span>    <span class="hljs-comment"># 初始化p数组记录父节点，rank数组记录节点深度</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, length)</span>:</span>        self.p = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(length)]        self.rank = [<span class="hljs-number">0</span>] * length    <span class="hljs-comment"># 查找根节点</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-keyword">if</span> self.p[x] != x:            self.p[x] = self.find(self.p[x])        <span class="hljs-keyword">return</span> self.p[x]        <span class="hljs-comment"># 合并两个节点</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span><span class="hljs-params">(self, x, y)</span>:</span>        rx, ry = self.find(x), self.finx(y)        <span class="hljs-keyword">if</span> self.rank[rx] &lt; self.rank[ry]:            self.p[rx] = ry        <span class="hljs-keyword">elif</span> self.rank[rx] &gt; self.rank[ry]:            self.p[ry] = rx        <span class="hljs-keyword">else</span>:            self.p[rx] = ry            self.rank[ry] += <span class="hljs-number">1</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(self, graph)</span>:</span>        ufs = UFS(len(graph))        <span class="hljs-keyword">for</span> i, g <span class="hljs-keyword">in</span> enumerate(graph):            root = ufs.find(i)            <span class="hljs-comment"># 若对面节点的根节点和当前节点根节点相同，返回False</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(g)):                <span class="hljs-keyword">if</span> root == ufs.find(g[j]):                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-comment"># 否则就把对面节点都合并起来</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(g)):                ufs.union(g[j<span class="hljs-number">-1</span>],g[j])        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre><p>无rank版本</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(self, graph)</span>:</span><span class="hljs-comment"># 第二种并查集</span>        n=len(graph)        boss=[i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n)]        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(x)</span>:</span>            <span class="hljs-keyword">nonlocal</span> boss            <span class="hljs-keyword">if</span> boss[x]!=x:                boss[x]=find(boss[x])            <span class="hljs-keyword">return</span> boss[x]        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span><span class="hljs-params">(x,y)</span>:</span>            bx=find(x)            by=find(y)            boss[bx]=by        <span class="hljs-keyword">for</span> i, e <span class="hljs-keyword">in</span> enumerate(graph):            fi=find(i)            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> e:                <span class="hljs-keyword">if</span> find(j)==fi:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">if</span> e:                b=e[<span class="hljs-number">0</span>]                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> e[<span class="hljs-number">1</span>:]:                    merge(b,j)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre><p><strong>补充：</strong><br><span style="color:blue">非局部变量用于未定义局部作用域的嵌套函数。这意味着变量(nonlocal x)既不能在局部作用域内，也不能在全局作用域内(就是说只能在嵌套函数里使用)。<br>我们使用非局部关键字(nonlocal)来创建非局部变量。</span></p><blockquote><p><strong>Note</strong> : If we change the value of a nonlocal variable, the changes appear in the local variable.<br>注意:如果我们改变一个非局部变量的值，这些改变会出现在局部变量中。（nonlocal 表示将变量声明为外层变量（外层函数的局部变量，而且不能是全局变量）。）</p></blockquote><p>详细内容参考<a href="https://blog.csdn.net/HappyRocking/article/details/80115241" target="_blank" rel="noopener">python中global,nonlocal的区别</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/is-graph-bipartite/solution/pan-duan-er-fen-tu-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://leetcode-cn.com/problems/is-graph-bipartite/solution/bfs-dfs-bing-cha-ji-san-chong-fang-fa-pan-duan-er-/" target="_blank" rel="noopener">BFS+DFS+并查集</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;785-判断二分图&quot;&gt;&lt;a href=&quot;#785-判断二分图&quot; class=&quot;headerlink&quot; title=&quot;785.判断二分图&quot;&gt;&lt;/a&gt;785.判断二分图&lt;/h1&gt;&lt;p&gt;给定一个无向图&lt;code&gt;graph&lt;/code&gt;，当这个图为二分图时返回&lt;code
      
    
    </summary>
    
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/categories/leetcode/"/>
    
      <category term="深度优先搜索，广度优先搜索" scheme="https://sulimin-nb.github.io/categories/leetcode/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%8C%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="每日一题" scheme="https://sulimin-nb.github.io/tags/%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98/"/>
    
      <category term="leetcode" scheme="https://sulimin-nb.github.io/tags/leetcode/"/>
    
  </entry>
  
</feed>
