<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>leetcode24-两两交换链表中的节点</title>
    <link href="/article/76a9321a.html"/>
    <url>/article/76a9321a.html</url>
    
    <content type="html"><![CDATA[<h1 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24.两两交换链表中的节点"></a>24.两两交换链表中的节点</h1><p>给定一个链表，两两交换其中的相邻的节点，并返回交换后的链表。<br><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际的进行节点交换。<br><strong>示例1：</strong></p><p><img src="/article/76a9321a/swap_ex1.jpg" srcset="/img/loading.gif" alt="swap_ex1"></p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]输出：[<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>]</code></pre><p><strong>示例2：</strong></p><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[]</span>输出：<span class="hljs-comment">[]</span></code></pre><p><strong>示例3：</strong></p><pre><code class="hljs angelscript">输入：head = [<span class="hljs-number">1</span>]输出：[<span class="hljs-number">1</span>]</code></pre><p><strong>提示：</strong></p><ul><li><p>链表中节点的数目在范围[0, 100]内</p></li><li><p>0 &lt;= Node.val &lt;= 100</p></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h2><p>通过递归的方式实现两两交换链表中的节点。<br>递归的终止条件是链表中没有节点或者链表中只有一个节点，此时无法进行交换。<br>如果链表中至少存在两个节点，则在两两交换链表中的节点之后，原始链表的头节点变成新链表的第二个节点，原始链表的第二个节点变成新链表的头节点。链表中的其余节点的两两交换可以通过递归实现。在对链表中的其余节点递归地两两交换之后，更新节点之间的指针关系，即可完成整个链表的两两交换。</p><p>用head表示原始链表的头节点，newhead表示新链表的头节点，原始链表的第二个节点，则原始链表的其余节点的头节点是newhead.next。令head.next=swapPairs(newhead.next)，表示将其余节点进行两两交换，交换后的新的头节点为head的下一个节点。然后令newhead.next=head，即完成了所有节点的交换。最后返回新的链表的头节点newhead。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swapPairs</span><span class="hljs-params">(self, head: ListNode)</span>-&gt; ListNode:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> head <span class="hljs-keyword">or</span> <span class="hljs-keyword">not</span> head.next:            <span class="hljs-keyword">return</span> head        newhead = head.next        head.next = self.swapPairs(newhead.next)        newhead.next = head        <span class="hljs-keyword">return</span> newhead</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(n)$，其中$n$是链表的节点数量。需要对每个节点进行更新指针的操作。</li><li>空间复杂度：$O(n)$，其中$n$是链表中的节点数量。空间复杂度主要取决于递归调用的栈空间。</li></ul><h2 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h2><p>通过迭代的方式实现两两交换链表中的节点。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">swapPairs</span><span class="hljs-params">(self, head)</span>:</span>dummyhead = ListNode(<span class="hljs-number">0</span>)dummpyhead.next = headtemp = dummpyhead<span class="hljs-keyword">while</span> temp.next <span class="hljs-keyword">and</span> temp.next.next:        node1 = temp.next        node2 = temp.next.next        temp.next = node2        node1.next = node2.next        node2.next = node1        temp = node1   <span class="hljs-keyword">return</span> dummpyhead.next</code></pre><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度： $O(n)$，其中$n$是链表的节点数量。需要对每个节点进行更新指针的操作。</li><li>空间复杂度： $O(1)$。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/solution/liang-liang-jiao-huan-lian-biao-zhong-de-jie-di-91/" target="_blank" rel="noopener">官方题解(动图好评)</a></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>随笔-近来杂谈</title>
    <link href="/article/426de11c.html"/>
    <url>/article/426de11c.html</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">You must enter the password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="b6e6733a8f96b4cdb41cc0ca15b29910d79f9eed77212f59f01c68454b59698b">d62c84b181f96c70c33a04a16adc5455d6c55bdcd421eb78318dd662ea3adb7d8d52f237ec081b387bdb2df856c6c17115b144a2f8e1ceadd1618288f96f8272bfb46dceec1a99a48e83e26f9e49af80dcf3ed06a83e457443f894a4abd77f39387b81c39fbd36965e9a85763053ae7e71079937ef0a2f40b8d2e52e0286ebb2cef6046399f7844bd6d97c6697c1a90a3853f44bc62d506b12da08c6b143c2434b755002f5ea45334627d7528206ccd14bc88e42db3478ed193a290d42a3040c5ff151a3a27317f41c1b37eee9a5c56927d31593f5672a4081b86f6bb54459f6193f1b3e596430b8c9d29da4ec70d8023de8a1effcc4f4a20d206e532a693dc6a94a3cc961d1ff34c5e5826bae261204831141bce1e64a0bcfa138b60c0564f18d9472ce9b707e06ed8c68db7d01cf18368f3e92eeac293f1c2e9261a91b8729393361dc7898a9d508a52d7bdb5bc21811207416611a7e8bd8cdc007beb2e85c62a76445cd17e8d6d4d647a93e7fcb2418fcacda84794477c5181451a25e4b4d017c380887e0362decd0e9f868b6f9d073df1f9ab8f25c015a3ae21ba37230af4f7643f6c716b7b8c4dee404d6ffa6c4d499b49433b61568e3c940d51d89731c102eaedcecb58315ac423229b9cc740dffbaa6c0c16a4265beb3e3479cc28b39c688f3707aa001680c4f68080441a127e195084ca283d8a336657e55b3790a4a596772a65d6ffa00253d2d73aab160b646b0ef89fe52232661008952d9772838be7dae1d9491c96dda4017cfcbdfb25ff15f1f10e75144a1dca8cae3c7911ecf33f66731dfb836571ba43a0b216d655e99f7126c26f96839c661d83cace62456273999c87467dd5098dcd62aad9b922b5bb493a90735a44a8242a2cf6faf6d9e4ecdbdc170aa907235f68703b8b52e866f2cb1a8cbe10c65849521366f95b6ca5b7258335389aa9089d558f6f6df45c4b395773b04d511ab7d7f3895c762b2a00dc846ec718e0004c174f1ba26b91a06180d9f73baa100069b7189b9dbfa35ee92876cbddd64eed3a93a6acd492317640ff54abeb0bfa1b10945c2eeb420eab418e54fefaf3d861d580eabdb6e00b7fee986807ddaecec3a84cdebe4bf2d104d1530f4386d75630af6de0008ae00eb085d1f5f65d7ea5cf14a085e1eda234e151effebd129e570ce911be4d4923751978edd8e1a57646494ade845f15e72ec45afa8abe546041da0af46041ad5908815e8ba65bc8588d50f9d88031a468ea34c9375e74a5760e98bab202b870f55dbd1e415c4ad23810a3c6758d2e9e1faca99093229b1ace0a6ca0b2e30dd43aebec4aeafe815d0c57e07471ae8cfd727ef88d44df06c3d3e4ab343a57a03c257706aaa2fcef5e914aef9fffccbd3069f7ad30ef0f046c806c91a8b57c8c0d02e1687af6bda52f3d7b8853339f0fa3dd6989df88192581775f32b317cfa405cdaecfb158b0ceeb77ce4690c406b52669aca9bea882e7c3ea8962e70a5a6fd54d6ea917f8403a7fbd9c70f0633d143a34e4a702ea50c28533f8ea351d540a5ff5a8c51b7a82a163aa1681831976c62b7efb539450143cc835f64252ae00c7be9d2ac7fba4899978de6df76c864424e0b5952bf5befa03463d03b272227aa1b42d174a7513a0b2385698f5433f22f0caef5467398ec91deb2c6ee234d31771fbc06d9efb225585a8124c2220b4559ff4bc8f285b99bf56f08a8a85fabb29b9665db534c213bf865c806a87f14437065f622c52ea9422e9213e99c589a606a7d6953c40a20cbecbd1d9ac1e923edd4de241b2f76aeba473a91b1cbec014b5fb438c93a2c565775808169ff5fe01ef3a3f19b07f6eb175c1582993d3aeb37a24a1ec8c818f38d192d62d38643d5ab7e5f3c1a5f45a2d2883281a82e77ef1c2cec74fe747349dcc9d9b8b6862bb2bafd1c759da7dfea1919d0b03d53b5a1df3ff913c71d872ca335d4931713cf2bc5ca53b7dbc0d35da02ab18747cbaa4db3a343175a94489c17edcf3aa2b9cb6163092ec0064f2288bffe1e24e846afc7061265c4b06c24bc7ad5c6276d02709ce229fd5dde3723fd8c78ed4c874400a3fd2c428ae469e0d9478861582b1ee25f749246755de920895824d56afcc2ead3fad3390db4ca5f96eef7a622c31f08fa667d6224adc64e215728cc4e0b90ebc2d49ab7df8578d94dd67950246824f99cd92c3edbb554f10b7bcef9a56e9066aa66f888aff349c0fbbad6075ef67374de5034a2c854c06f0dbc0b86714a6535049e1b983655296b1cf1f1804efd5f622555d70838115c43def7449db3f2d3cb80da03916a70b151756f21b2d65d63acca69ec37731b593b25e9b9e239382923800db0c1396075aa52ac19f8a9514163c09949823778fcb13a42238ca5fff9b5b1bd7a8851f85f1f0461a6dc7be84a21d7689ecdf6af6cc564fdb6375bdced17fe61f389c59e4cb5a202f44a45808c59b851795412ed35287fa72f28f93a4c08987b5da894d2dc4006d98db000b33788bbf423e769067386ae7cdd6faf46723efc1b3114eae1b2ea2736f90776043067b3369ece2c435cbec9ed587c6b5346755de0fa63da3e549378fbaa510fd5358382d32e82294db0c0b9566bf993b10e9d7766849f7d68e8cc46b379aee49b1eb7398732d4ed1c0d863d65c9a143e9829542bd000aacd0f92eea94e3d696154c81705be1250891e4b35ad963c039d36a85e6cef565b1383e38baf0a85d06f2dc609a073e5c963302e1bd87ae22f42f7f2a1e3090358424ace74cb4862663d4e8c75b8525e07173f7069cc8411910872fa7e6707e7e42c538f12a6ffc161c73d72ebf323afaf4f8791d982cd8918c815d53900703fd6fc58441ffd6e0fc17631b6f223bdedc4589187bdc4071fcd18453b9e3ced3cf2c35c78949d0c4abefde0b56998472e7add9596a54e0222b3a01fd2cf6430876293fd37495892f1493f38330651203dd6385d8f5dc29b162a01daa5c9edda4ecd4cd9f04a03bf2683a50a430f3c3f7b3b78337d80f0474acaca3f27c1761add7406e304c66d751e5d3319f90d77b414fb21ea12ee00c3b4d9027ac2f476021113508d6df981f76f68357c1b01ef3573b3a91764ec5bbc12650373c5d37f632a093498fc0d691705a39b58531e7c6f0c477190cce521034c238e024cb7fdece492de43a0776f44503e1735bcab767a338062afb420c07541d74bbb64f5b21ad0c2df33e33a8ee93b11dea51585f98e02e90ca5ca5959ee19527afdd364da971f08e52a9560a2aec01105049b5de8fcafdffb61f09ff716b521934a31d08307656cabb9da6d54ed9b479a4ce48ede4eb36eb4f302b97b97279c37c3f6d7c80c71ef074336d4a0a7a9fdabbeb59b42991c579f193e9a704b927396b4d9701c4be220a77d204a69075903d77d5ee16101e97b7d7050acaad914d51e50d11f3d8d170c6c076fe29aecc373d24745aaeacd62b47cc707182754bb77121daa47180221db832b445ac7c41044e9e390f0fe1640fe82d98ab148bd0cf32e510c1a435095fbf398ea684a0ccff780dd6d32277675b6f169efbc260cb2af144040def23eb8a80a337bfa47c8c72bddaedde8587c58e4347beac8383fec91b31fe78a76eb258c03833716aa294a059686c41a83af74b33d55763412885d3aae678b35e43c2a47872cd963426233a0b4495bcbb56c31932eb38b94419d9000e8622f4080fe868e368a17805e8ba65a00ca40e5ca7a50681de178e24b8097208338b814f0f379c7483f7e57231b2107b4a3e1549cfd51e32a5b5a728863e7d19cca5163bfc8c1d7752dbfe7922c90dc36886bd454b2cd357f717004dd333f98378689374533d2048d0d2a652d60611bc0aee90ae3323a35a76830ae1b36fe555991646a14c3a99ac29b24c25f03d94e2b58bb80ba352e600aa44dcb88778462c2ca106d227a314eabdbc27</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode530-二叉搜索树的最小绝对差</title>
    <link href="/article/d3786335.html"/>
    <url>/article/d3786335.html</url>
    
    <content type="html"><![CDATA[<h1 id="二叉搜索树的最小绝对差"><a href="#二叉搜索树的最小绝对差" class="headerlink" title="二叉搜索树的最小绝对差"></a>二叉搜索树的最小绝对差</h1><p>给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>  git config —global user.email “you@example.com”<br>  git config —global user.name “Your Name”</p><p>对升序数组$a$求任意两个元素之差的绝对值的最小值，答案一定为相邻两个元素之差的最小值，即</p><script type="math/tex; mode=display">ans = min^{n-2}_{i=0}\{a[i+1] - a[i]\}</script><p>其中$n$为数组$a$的长度。<br>二叉搜索树的性质：<strong>二叉搜索树中序遍历得到的值序列是递增有序的。</strong>因此只要得到中序遍历后的值序列就能使用上述方法求解。<br>朴素的方法：经过一次中序遍历后将值保存在一个数组中进行遍历求解。简易：在中序遍历的过程中用$pre$变量保存前驱节点的值，这样能边遍历边更新答案，一次遍历即可得到答案(无需保存数组和再次遍历)。需要注意 的是$pre$的初始值需要设置为任意负数标记开头，代码中设置为1。<br>二叉树的中序遍历有多种方式，包括递归、栈、Morris遍历等。</p><h2 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h2><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-comment"># class TreeNode:</span><span class="hljs-comment">#     def __init__(self, x):</span><span class="hljs-comment">#         self.val = x</span><span class="hljs-comment">#         self.left = None</span><span class="hljs-comment">#         self.right = None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    ans = <span class="hljs-number">999</span>    pre = <span class="hljs-number">-1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getMinimumDifference</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; int:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(root)</span>:</span>            <span class="hljs-keyword">if</span> root == <span class="hljs-literal">None</span>:                <span class="hljs-keyword">return</span>            dfs(root.left)            <span class="hljs-keyword">if</span> self.pre == <span class="hljs-number">-1</span>:                self.pre = root.val            <span class="hljs-keyword">else</span>:                self.ans = min(self.ans, abs(root.val - self.pre))                self.pre = root.val            dfs(root.right)        dfs(root)        <span class="hljs-keyword">return</span> self.ans</code></pre><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><ul><li>时间复杂度：$O(n)$，其中$n$为二叉搜索树节点的个数。每个节点在中序遍历中都会访问一次且只会被访问一次，因此总时间复杂度为$O(n)$。</li><li>空间复杂度：$O(n)$。递归函数的空间复杂度取决于递归的栈深度，而栈深度在二叉搜索树为一条链的情况下会达到$O(n)$的级别。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-查找</title>
    <link href="/article/bd63ef17.html"/>
    <url>/article/bd63ef17.html</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="一-查找表"><a href="#一-查找表" class="headerlink" title="一.查找表"></a>一.查找表</h1><h2 id="考虑的基本数据结构"><a href="#考虑的基本数据结构" class="headerlink" title="考虑的基本数据结构"></a>考虑的基本数据结构</h2><p><strong>第一类： 查找有无—set</strong></p><p>元素’a’是否存在，通常用set：集合</p><p>set只存储键，而不需要对应其相应的值。 </p><p>set中的键不允许重复</p><p><strong>第二类： 查找对应关系(键值对应)—dict</strong></p><p>元素’a’出现了几次：dict—&gt;字典</p><p>dict中的键不允许重复</p><p><strong>第三类： 改变映射关系—map</strong></p><p>通过将原有序列的关系映射统一表示为其他</p><h2 id="算法应用"><a href="#算法应用" class="headerlink" title="算法应用"></a>算法应用</h2><h3 id="LeetCode-349-Intersection-Of-Two-Arrays-1"><a href="#LeetCode-349-Intersection-Of-Two-Arrays-1" class="headerlink" title="LeetCode 349 Intersection Of Two Arrays 1"></a>LeetCode 349 Intersection Of Two Arrays 1</h3><h4 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个数组nums,求两个数组的公共元素。</p><pre><code class="hljs angelscript">如nums1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],nums2 = [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]结果为[<span class="hljs-number">2</span>]结果中每个元素只能出现一次出现的顺序可以是任意的</code></pre><h4 id="分析实现"><a href="#分析实现" class="headerlink" title="分析实现"></a>分析实现</h4><p>由于每个元素只出现一次，因此不需要关注每个元素出现的次数，用set的数据结构就可以了。记录元素的有和无。</p><p>把nums1记录为set，判断nums2的元素是否在set中，是的话，就放在一个公共的set中，最后公共的set就是我们要的结果。</p><p>代码如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intersection</span><span class="hljs-params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span>        nums1 = set(nums1)        <span class="hljs-keyword">return</span> set([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> nums2 <span class="hljs-keyword">if</span> i <span class="hljs-keyword">in</span> nums1])</code></pre><p>也可以通过set的内置方法来实现，直接求set的交集：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intersection</span><span class="hljs-params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span>        set1 = set(nums1)        set2 = set(nums2)        <span class="hljs-keyword">return</span> set2 &amp; set1</code></pre><h3 id="LeetCode-350-Intersection-Of-Two-Arrays-2"><a href="#LeetCode-350-Intersection-Of-Two-Arrays-2" class="headerlink" title="LeetCode 350 Intersection Of Two Arrays 2"></a>LeetCode 350 Intersection Of Two Arrays 2</h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个数组nums,求两个数组的交集。</p><p>— 如nums1=[1,2,2,1],nums=[2,2]</p><p>— 结果为[2,2]</p><p>— 出现的顺序可以是任意的</p><h4 id="分析实现-1"><a href="#分析实现-1" class="headerlink" title="分析实现"></a>分析实现</h4><p>元素出现的次数有用，那么对于存储次数就是有意义的，所以选择数据结构时，就应该选择dict的结构，通过字典的比较来判断；</p><p>记录每个元素的同时要记录这个元素的频次。</p><p>记录num1的字典，遍历nums2，比较nums1的字典的nums的key是否大于零，从而进行判断。</p><p>代码如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intersect</span><span class="hljs-params">(self, nums1: List[int], nums2: List[int])</span> -&gt; List[int]:</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter        nums1_dict = Counter(nums1)        res = []        <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums2:            <span class="hljs-keyword">if</span> nums1_dict[num] &gt; <span class="hljs-number">0</span>:                <span class="hljs-comment"># 说明找到了一个元素即在num1也在nums2</span>                res.append(num)                nums1_dict[num] -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre><h3 id="LeetCode-242-Intersection-Of-Two-Arrays-2"><a href="#LeetCode-242-Intersection-Of-Two-Arrays-2" class="headerlink" title="LeetCode 242 Intersection Of Two Arrays 2"></a>LeetCode 242 Intersection Of Two Arrays 2</h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。</p><pre><code class="hljs nix">示例<span class="hljs-number">1</span>:输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"anagram"</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">"nagaram"</span>输出: <span class="hljs-literal">true</span>示例 <span class="hljs-number">2</span>:输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"rat"</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">"car"</span>输出: <span class="hljs-literal">false</span></code></pre><h4 id="分析实现-2"><a href="#分析实现-2" class="headerlink" title="分析实现"></a>分析实现</h4><p>判断异位词即判断变换位置后的字符串和原来是否相同，那么不仅需要存储元素，还需要记录元素的个数。可以选择dict的数据结构，将字符串s和t都用dict存储，而后直接比较两个dict是否相同。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(self, s: str, t: str)</span> -&gt; bool:</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter        s = Counter(s)        t = Counter(t)        <span class="hljs-keyword">if</span> s == t:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre><h3 id="LeetCode-202-Happy-number"><a href="#LeetCode-202-Happy-number" class="headerlink" title="LeetCode 202 Happy number"></a>LeetCode 202 Happy number</h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>编写一个算法来判断一个数是不是“快乐数”。</p><p>一个“快乐数”定义为：对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和，然后重复这个过程直到这个数变为 1，也可能是无限循环但始终变不到 1。如果可以变为 1，那么这个数就是快乐数。</p><pre><code class="hljs angelscript">示例: 输入: <span class="hljs-number">19</span>输出: <span class="hljs-literal">true</span>解释: <span class="hljs-number">1</span>^<span class="hljs-number">2</span> + <span class="hljs-number">9</span>^<span class="hljs-number">2</span> = <span class="hljs-number">82</span><span class="hljs-number">8</span>^<span class="hljs-number">2</span> + <span class="hljs-number">2</span>^<span class="hljs-number">2</span> = <span class="hljs-number">68</span><span class="hljs-number">6</span>^<span class="hljs-number">2</span> + <span class="hljs-number">8</span>^<span class="hljs-number">2</span> = <span class="hljs-number">100</span><span class="hljs-number">1</span>^<span class="hljs-number">2</span> + <span class="hljs-number">0</span>^<span class="hljs-number">2</span> + <span class="hljs-number">0</span>^<span class="hljs-number">2</span> = <span class="hljs-number">1</span></code></pre><h4 id="分析实现-3"><a href="#分析实现-3" class="headerlink" title="分析实现"></a>分析实现</h4><p>这道题目思路很明显，当n不等于1时就循环，每次循环时，将其最后一位到第一位的数依次平方求和，比较求和是否为1。</p><p>难点在于，什么时候跳出循环？</p><p>开始笔者的思路是，循环个100次，还没得出结果就false，但是小学在算无限循环小数时有一个特征，就是当除的数中，和之前历史的得到的数有重合时，这时就是无限循环小数。</p><p>那么这里也可以按此判断，因为只需要判断有或无，不需要记录次数，故用set的数据结构。每次对求和的数进行append，当新一次求和的值存在于set中时，就return false.</p><p>代码如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isHappy</span><span class="hljs-params">(self, n: int)</span> -&gt; bool:</span>        already = set()        <span class="hljs-keyword">while</span> n != <span class="hljs-number">1</span>:            sum = <span class="hljs-number">0</span>            <span class="hljs-keyword">while</span> n &gt; <span class="hljs-number">0</span>:                <span class="hljs-comment"># 取n的最后一位数</span>                tmp = n % <span class="hljs-number">10</span>                   sum += tmp ** <span class="hljs-number">2</span>                <span class="hljs-comment"># 将n的最后一位截掉</span>                n //= <span class="hljs-number">10</span>            <span class="hljs-comment"># 如果求的和在过程中出现过</span>            <span class="hljs-keyword">if</span> sum <span class="hljs-keyword">in</span> already:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">else</span>:                already.add(sum)            n = sum        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre><h4 id="tips"><a href="#tips" class="headerlink" title="tips"></a>tips</h4><pre><code class="hljs python"><span class="hljs-comment">#一般对多位数计算的套路是：</span><span class="hljs-comment">#循环从后向前取位数</span><span class="hljs-keyword">while</span> n &gt;<span class="hljs-number">0</span> :<span class="hljs-comment">#取最后一位： </span>tmp = n % <span class="hljs-number">10</span><span class="hljs-comment">#再截掉最后一位：</span>n = n // <span class="hljs-number">10</span></code></pre><h3 id="LeetCode-290-Word-Pattern"><a href="#LeetCode-290-Word-Pattern" class="headerlink" title="LeetCode 290 Word Pattern"></a>LeetCode 290 Word Pattern</h3><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><p>给出一个模式(pattern)以及一个字符串，判断这个字符串是否符合模式</p><pre><code class="hljs nix">示例<span class="hljs-number">1</span>:输入: <span class="hljs-attr">pattern</span> = <span class="hljs-string">"abba"</span>, <span class="hljs-attr">str</span> = <span class="hljs-string">"dog cat cat dog"</span>输出: <span class="hljs-literal">true</span>示例 <span class="hljs-number">2</span>:输入:<span class="hljs-attr">pattern</span> = <span class="hljs-string">"abba"</span>, <span class="hljs-attr">str</span> = <span class="hljs-string">"dog cat cat fish"</span>输出: <span class="hljs-literal">false</span>示例 <span class="hljs-number">3</span>:输入: <span class="hljs-attr">pattern</span> = <span class="hljs-string">"aaaa"</span>, <span class="hljs-attr">str</span> = <span class="hljs-string">"dog cat cat dog"</span>输出: <span class="hljs-literal">false</span>示例 <span class="hljs-number">4</span>:输入: <span class="hljs-attr">pattern</span> = <span class="hljs-string">"abba"</span>, <span class="hljs-attr">str</span> = <span class="hljs-string">"dog dog dog dog"</span>输出: <span class="hljs-literal">false</span></code></pre><h4 id="分析实现-4"><a href="#分析实现-4" class="headerlink" title="分析实现"></a>分析实现</h4><p>抓住变与不变，笔者开始的思路是选择了dict的数据结构，比较count值和dict对应的keys的个数是否相同，但是这样无法判断顺序的关系，如测试用例：’aba’,’cat cat dog’。</p><p>那么如何能<strong>既考虑顺序</strong>，也考虑<strong>键值对应的关系</strong>呢？</p><p>抓住变与不变，变的是键，但是不变的是各个字典中，对应的相同index下的值，如dict1[index] = dict2[index]，那么我们可以创建两个新的字典，遍历index对两个新的字典赋值，并比较value。</p><p>还有一个思路比较巧妙，既然不同，那么可以考虑怎么让它们相同，将原来的dict通过map映射为相同的key，再比较相同key的dict是否相同。</p><p>代码实现如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wordPattern</span><span class="hljs-params">(self,pattern, str)</span>:</span>        str = str.split()        <span class="hljs-keyword">return</span> list(map(pattern.index,pattern)) == list(map(str.index,str))</code></pre><h4 id="tips-1"><a href="#tips-1" class="headerlink" title="tips"></a>tips</h4><ol><li>因为str是字符串，不是由单个字符组成，所以开始需要根据空格拆成字符list：</li></ol><pre><code class="hljs python">str = str.split()</code></pre><ol><li>通过map将字典映射为index的list:</li></ol><pre><code class="hljs python">map(pattern.index, pattern)</code></pre><ol><li>map是通过hash存储的，不能直接进行比较，需要转换为list比较list</li></ol><h3 id="LeetCode-205-Isomorphic-Strings"><a href="#LeetCode-205-Isomorphic-Strings" class="headerlink" title="LeetCode 205 Isomorphic Strings"></a>LeetCode 205 Isomorphic Strings</h3><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定两个字符串 s 和 t，判断它们是否是同构的。</p><p>如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</p><p>所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</p><pre><code class="hljs nix">示例 <span class="hljs-number">1</span>:输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"egg"</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">"add"</span>输出: <span class="hljs-literal">true</span>示例 <span class="hljs-number">2</span>:输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"foo"</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">"bar"</span>输出: <span class="hljs-literal">false</span>示例 <span class="hljs-number">3</span>:输入: <span class="hljs-attr">s</span> = <span class="hljs-string">"paper"</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">"title"</span>输出: <span class="hljs-literal">true</span></code></pre><h4 id="分析实现-5"><a href="#分析实现-5" class="headerlink" title="分析实现"></a>分析实现</h4><p>思路与上题一致，可以考虑通过建两个dict，比较怎样不同，也可以将不同转化为相同。</p><p>直接用上题的套路代码：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isIsomorphic</span><span class="hljs-params">(self, s: str, t: str)</span> -&gt; bool:</span>        <span class="hljs-keyword">return</span> list(map(s.index,s)) == list(map(t.index,t))</code></pre><h3 id="LeetCode-451-Sort-Characters-By-Frequency"><a href="#LeetCode-451-Sort-Characters-By-Frequency" class="headerlink" title="LeetCode 451 Sort Characters By Frequency"></a>LeetCode 451 Sort Characters By Frequency</h3><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串，请将字符串里的字符按照出现的频率降序排列。</p><pre><code class="hljs makefile">示例 1:<span class="hljs-section">输入:</span><span class="hljs-string">"tree"</span><span class="hljs-section">输出:</span><span class="hljs-string">"eert"</span>示例 2:<span class="hljs-section">输入:</span><span class="hljs-string">"cccaaa"</span><span class="hljs-section">输出:</span><span class="hljs-string">"cccaaa"</span>示例 3:<span class="hljs-section">输入:</span><span class="hljs-string">"Aabb"</span><span class="hljs-section">输出:</span><span class="hljs-string">"bbAa"</span></code></pre><h4 id="分析实现-6"><a href="#分析实现-6" class="headerlink" title="分析实现"></a>分析实现</h4><p>对于相同频次的字母，顺序任意，需要考虑大小写，返回的是字符串。</p><p>使用字典统计频率，对字典的value进行排序，最终根据key的字符串乘上value次数，组合在一起输出。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">frequencySort</span><span class="hljs-params">(self, s: str)</span> -&gt; str:</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter        s_dict = Counter(s)        <span class="hljs-comment"># sorted返回的是列表元组</span>        s = sorted(s_dict.items(), key=<span class="hljs-keyword">lambda</span> item:item[<span class="hljs-number">1</span>], reverse = <span class="hljs-literal">True</span>)        <span class="hljs-comment"># 因为返回的是字符串</span>        res = <span class="hljs-string">''</span>        <span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> s:            res += key * value           <span class="hljs-keyword">return</span> res</code></pre><h4 id="tips-2"><a href="#tips-2" class="headerlink" title="tips"></a>tips</h4><ol><li>通过sorted的方法进行value排序，对字典排序后无法直接按照字典进行返回，返回的为列表元组：</li></ol><pre><code class="hljs python"><span class="hljs-comment"># 对value值由大到小排序</span>s = sorted(s_dict.items(), key=<span class="hljs-keyword">lambda</span> item:item[<span class="hljs-number">1</span>], reverse = <span class="hljs-literal">True</span>)<span class="hljs-comment"># 对key由小到大排序</span>s = sorted(s_dict.items(), key=<span class="hljs-keyword">lambda</span> item:item[<span class="hljs-number">0</span>])</code></pre><ol><li>输出为字符串的情况下，可以由字符串直接进行拼接:</li></ol><pre><code class="hljs python"><span class="hljs-comment"># 由key和value相乘进行拼接</span><span class="hljs-string">'s'</span> * <span class="hljs-number">5</span> + <span class="hljs-string">'d'</span>*<span class="hljs-number">2</span></code></pre><h1 id="二-对撞指针"><a href="#二-对撞指针" class="headerlink" title="二. 对撞指针"></a>二. 对撞指针</h1><h1 id="LeetCode-1-Two-Sum"><a href="#LeetCode-1-Two-Sum" class="headerlink" title="LeetCode 1 Two Sum"></a>LeetCode 1 Two Sum</h1><h2 id="题目描述-7"><a href="#题目描述-7" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个整型数组nums，返回这个数组中两个数字的索引值i和j，使得nums[i] + nums[j]等于一个给定的target值，两个索引不能相等。</p><p>如：nums= [2,7,11,15],target=9<br>返回[0,1]</p><h2 id="审题"><a href="#审题" class="headerlink" title="审题:"></a>审题:</h2><p>需要考虑：</p><ol><li>开始数组是否有序；</li><li>索引从0开始计算还是1开始计算？</li><li>没有解该怎么办？</li><li>有多个解怎么办？保证有唯一解。</li></ol><h2 id="分析实现-7"><a href="#分析实现-7" class="headerlink" title="分析实现"></a>分析实现</h2><h2 id="暴力法O-n-2"><a href="#暴力法O-n-2" class="headerlink" title="暴力法O(n^2)"></a>暴力法O(n^2)</h2><p>时间复杂度为O(n^2),第一遍遍历数组，第二遍遍历当前遍历值之后的元素，其和等于target则return。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span>        len_nums = len(nums)        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len_nums):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>,len_nums):                <span class="hljs-keyword">if</span> nums[i] + nums[j] == target:                    <span class="hljs-keyword">return</span> [i,j]</code></pre><h2 id="排序-指针对撞-O-n-O-nlogn-O-n"><a href="#排序-指针对撞-O-n-O-nlogn-O-n" class="headerlink" title="排序+指针对撞(O(n)+O(nlogn)=O(n))"></a>排序+指针对撞(O(n)+O(nlogn)=O(n))</h2><p>在数组篇的LeetCode 167题中，也遇到了找到两个数使得它们相加之和等于目标数，但那是对于排序的情况，因此也可以使用上述的思路来完成。</p><p>因为问题本身不是有序的，因此需要对原来的数组进行一次排序，排序后就可以用O(n)的指针对撞进行解决。</p><p>但是问题是，返回的是数字的索引，如果只是对数组的值进行排序，那么数组原来表示的索引的信息就会丢失，所以在排序前要进行些处理。</p><p><strong>错误代码示例—只使用dict来进行保存：</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span>        record = dict()        <span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> range(len(nums)):            record[nums[index]] = index         nums.sort()        l,r = <span class="hljs-number">0</span>,len(nums)<span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> l &lt; r:            <span class="hljs-keyword">if</span> nums[l] + nums[r] == target:                <span class="hljs-keyword">return</span> [record[nums[l]],record[nums[r]]]            <span class="hljs-keyword">elif</span> nums[l] + nums[r] &lt; target:                l += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                r -= <span class="hljs-number">1</span></code></pre><p>当遇到<strong>相同的元素的索引</strong>问题时，会不满足条件：</p><p>如：[3,3]  6</p><p>在排序前先使用一个额外的数组<strong>拷贝</strong>一份原来的数组，对于两个相同元素的索引问题，使用一个<strong>bool型变量</strong>辅助将两个索引都找到，总的时间复杂度为O(n)+O(nlogn) = O(nlogn)</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span>        record = dict()        nums_copy = nums.copy()        sameFlag = <span class="hljs-literal">True</span>;        nums.sort()        l,r = <span class="hljs-number">0</span>,len(nums)<span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> l &lt; r:            <span class="hljs-keyword">if</span> nums[l] + nums[r] == target:                <span class="hljs-keyword">break</span>            <span class="hljs-keyword">elif</span> nums[l] + nums[r] &lt; target:                l += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                r -= <span class="hljs-number">1</span>        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            <span class="hljs-keyword">if</span> nums_copy[i] == nums[l] <span class="hljs-keyword">and</span> sameFlag:                res.append(i)                sameFlag = <span class="hljs-literal">False</span>            <span class="hljs-keyword">elif</span> nums_copy[i] == nums[r]:                res.append(i)        <span class="hljs-keyword">return</span> res</code></pre><h3 id="小套路"><a href="#小套路" class="headerlink" title="小套路:"></a>小套路:</h3><p>如果只是对数组的值进行排序，那么数组原来表示的索引的信息就会丢失的情况，可以在排序前：</p><h3 id="更加pythonic的实现"><a href="#更加pythonic的实现" class="headerlink" title="更加pythonic的实现"></a>更加pythonic的实现</h3><p>通过list(enumerate(nums))开始实现下标和值的绑定，不用专门的再copy加bool判断。</p><pre><code class="hljs python">nums = list(enumerate(nums))nums.sort(key = <span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>])i,j = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span><span class="hljs-keyword">while</span> i &lt; j:    <span class="hljs-keyword">if</span> nums[i][<span class="hljs-number">1</span>] + nums[j][<span class="hljs-number">1</span>] &gt; target:        j -= <span class="hljs-number">1</span>    <span class="hljs-keyword">elif</span> nums[i][<span class="hljs-number">1</span>] + nums[j][<span class="hljs-number">1</span>] &lt; target:        i += <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">if</span> nums[j][<span class="hljs-number">0</span>] &lt; nums[i][<span class="hljs-number">0</span>]:            nums[j],nums[i] = nums[i],nums[j]        <span class="hljs-keyword">return</span> num[i][<span class="hljs-number">0</span>],nums[j][<span class="hljs-number">0</span>]</code></pre><p><strong>拷贝数组 + bool型变量辅助</strong></p><h2 id="查找表—O-n"><a href="#查找表—O-n" class="headerlink" title="查找表—O(n)"></a>查找表—O(n)</h2><p>遍历数组过程中，当遍历到元素v时，可以只看v前面的元素，是否含有target-v的元素存在。</p><ol><li>如果查找成功，就返回解；</li><li>如果没有查找成功，就把v放在查找表中，继续查找下一个解。</li></ol><p>即使v放在了之前的查找表中覆盖了v，也不影响当前v元素的查找。因为只需要找到两个元素，只需要找target-v的另一个元素即可。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span>        record = dict()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            complement = target - nums[i]            <span class="hljs-comment"># 已经在之前的字典中找到这个值</span>            <span class="hljs-keyword">if</span> record.get(complement) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:                res = [i,record[complement]]                <span class="hljs-keyword">return</span> res            record[nums[i]] = i</code></pre><p>只进行一次循环，故时间复杂度O(n),空间复杂度为O(n)</p><h2 id="补充思路："><a href="#补充思路：" class="headerlink" title="补充思路："></a>补充思路：</h2><p>通过enumerate来把索引和值进行绑定，进而对value进行sort，前后对撞指针进行返回。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">twoSum</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span>        nums = list(enumerate(nums))        <span class="hljs-comment"># 根据value来排序</span>        nums.sort(key = <span class="hljs-keyword">lambda</span> x:x[<span class="hljs-number">1</span>])        l,r = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> l &lt; r:            <span class="hljs-keyword">if</span> nums[l][<span class="hljs-number">1</span>] + nums[r][<span class="hljs-number">1</span>] == target:                <span class="hljs-keyword">return</span> nums[l][<span class="hljs-number">0</span>],nums[r][<span class="hljs-number">0</span>]            <span class="hljs-keyword">elif</span> nums[l][<span class="hljs-number">1</span>] + nums[r][<span class="hljs-number">1</span>] &lt; target:                l += <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                r -= <span class="hljs-number">1</span></code></pre><h1 id="LeetCode-15-3Sum"><a href="#LeetCode-15-3Sum" class="headerlink" title="LeetCode 15 3Sum"></a>LeetCode 15 3Sum</h1><h2 id="题目描述-8"><a href="#题目描述-8" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个整型数组，寻找其中的所有不同的三元组(a,b,c)，使得a+b+c=0</p><p>注意：答案中不可以包含重复的三元组。</p><p>如：nums = [-1, 0, 1, 2, -1, -4]，</p><p>结果为：[[-1, 0, 1],[-1, -1, 2]]</p><h2 id="审题-1"><a href="#审题-1" class="headerlink" title="审题"></a>审题</h2><ol><li>数组不是有序的；</li><li>返回结果为全部解，多个解的顺序是否需要考虑？—不需要考虑顺序</li><li>什么叫不同的三元组？索引不同即不同，还是值不同？—题目定义的是，值不同才为不同的三元组</li><li>没有解时怎么返回？—空列表</li></ol><h2 id="分析实现-8"><a href="#分析实现-8" class="headerlink" title="分析实现"></a>分析实现</h2><p>因为上篇中已经实现了Two Sum的问题，因此对于3Sum，首先想到的思路就是，开始固定一个k，然后在其后都当成two sum问题来进行解决，但是这样就ok了吗？</p><h3 id="没有考虑重复元素导致错误"><a href="#没有考虑重复元素导致错误" class="headerlink" title="没有考虑重复元素导致错误"></a>没有考虑重复元素导致错误</h3><p>直接使用Two Sum问题中的查找表的解法，根据第一层遍历的i，将i之后的数组作为two sum问题进行解决。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(self, nums: [int])</span> -&gt; [[int]]:</span>        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            num = <span class="hljs-number">0</span> - nums[i]            record = dict()            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i + <span class="hljs-number">1</span>, len(nums)):                complement = num - nums[j]                <span class="hljs-comment"># 已经在之前的字典中找到这个值</span>                <span class="hljs-keyword">if</span> record.get(complement) <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:                    res_lis = [nums[i], nums[j], complement]                    res.append(res_lis)                record[nums[j]] = i        <span class="hljs-keyword">return</span> res</code></pre><p>但是这样会导致一个错误，错误用例如下:</p><pre><code class="hljs angelscript">输入：[<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">-4</span>]输出：[[<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>]]预期结果：[[<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">-1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]]</code></pre><p>代码在实现的过程中没有把第一次遍历的i的索引指向相同元素的情况排除掉，于是出现了当i指针后面位置的元素有和之前访问过的相同的值，于是重复遍历。</p><p>那么可以考虑，开始时对nums数组进行排序，排序后，当第一次遍历的指针k遇到下一个和前一个指向的值重复时，就将其跳过。为了方便计算，在第二层循环中，可以使用<strong>对撞指针</strong>的套路：</p><pre><code class="hljs python"><span class="hljs-comment"># 对撞指针套路</span>l,r = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span><span class="hljs-keyword">while</span> l &lt; r:    <span class="hljs-keyword">if</span> nums[l] + nums[r] == target:        <span class="hljs-keyword">return</span> nums[l],nums[r]    <span class="hljs-keyword">elif</span> nums[l] + nums[r] &lt; target:        l += <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>:        r -= <span class="hljs-number">1</span></code></pre><p>其中需要注意的是，在里层循环中，也要考虑重复值的情况，因此当值相等时，再次移动指针时，需要保证其指向的值和前一次指向的值不重复，因此可以：</p><pre><code class="hljs python"><span class="hljs-comment"># 对撞指针套路</span>l,r = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span><span class="hljs-keyword">while</span> l &lt; r:    sum = nums[i] + nums[l] + nums[r]    <span class="hljs-keyword">if</span> sum == target:        res.append([nums[i],nums[l],nums[r])        l += <span class="hljs-number">1</span>        r -= <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> nums[l] == nums[l<span class="hljs-number">-1</span>]: l += <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> nums[r] == nums[r+<span class="hljs-number">1</span>]: r -= <span class="hljs-number">1</span>    <span class="hljs-keyword">elif</span> sum &lt; target:        l += <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>:        r -= <span class="hljs-number">1</span></code></pre><p>再调整下遍历的范围，因为设了3个索引：i，l，r。边界情况下，r索引指向len-1, l指向len-2，索引i遍历的边界为len-3，故for循环是从0到len-2。</p><p>代码实现如下：</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">threeSum</span><span class="hljs-params">(self, nums: [int])</span> -&gt; [[int]]:</span>        nums.sort()        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)<span class="hljs-number">-2</span>):            <span class="hljs-comment"># 因为是排序好的数组，如果最小的都大于0可以直接排除</span>            <span class="hljs-keyword">if</span> nums[i] &gt; <span class="hljs-number">0</span>: <span class="hljs-keyword">break</span>            <span class="hljs-comment"># 排除i的重复值</span>            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i<span class="hljs-number">-1</span>]: <span class="hljs-keyword">continue</span>            l,r = i+<span class="hljs-number">1</span>, len(nums)<span class="hljs-number">-1</span>            <span class="hljs-keyword">while</span> l &lt; r:                sum = nums[i] + nums[l] + nums[r]                <span class="hljs-keyword">if</span> sum == <span class="hljs-number">0</span>:                    res.append([nums[i],nums[l],nums[r]])                    l += <span class="hljs-number">1</span>                    r -= <span class="hljs-number">1</span>                    <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> nums[l] == nums[l<span class="hljs-number">-1</span>]: l += <span class="hljs-number">1</span>                    <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> nums[r] == nums[r+<span class="hljs-number">1</span>]: r -= <span class="hljs-number">1</span>                <span class="hljs-keyword">elif</span> sum &lt; <span class="hljs-number">0</span>:                    l += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    r -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre><h2 id="小套路-1"><a href="#小套路-1" class="headerlink" title="小套路"></a>小套路</h2><ol><li>采用<strong>for + while</strong>的形式来处理三索引；</li><li>当数组不是有序时需要注意，有序的特点在哪里，有序就可以用哪些方法解决？无序的话不便在哪里？</li><li>对撞指针套路：</li></ol><pre><code class="hljs python"><span class="hljs-comment"># 对撞指针套路</span>l,r = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span><span class="hljs-keyword">while</span> l &lt; r:    <span class="hljs-keyword">if</span> nums[l] + nums[r] == target:        <span class="hljs-keyword">return</span> nums[l],nums[r]    <span class="hljs-keyword">elif</span> nums[l] + nums[r] &lt; target:        l += <span class="hljs-number">1</span>    <span class="hljs-keyword">else</span>:        r -= <span class="hljs-number">1</span></code></pre><ol><li>处理重复值的套路：先转换为有序数组，再循环判断其与上一次值是否重复：</li></ol><pre><code class="hljs python"><span class="hljs-comment"># 1.</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):    <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i<span class="hljs-number">-1</span>]: <span class="hljs-keyword">continue</span><span class="hljs-comment"># 2.</span><span class="hljs-keyword">while</span> l &lt; r:    <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> nums[l] == nums[l<span class="hljs-number">-1</span>]: l += <span class="hljs-number">1</span></code></pre><h1 id="LeetCode-18-4Sum"><a href="#LeetCode-18-4Sum" class="headerlink" title="LeetCode 18 4Sum"></a>LeetCode 18 4Sum</h1><h2 id="题目描述-9"><a href="#题目描述-9" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个整形数组，寻找其中的所有不同的四元组(a,b,c,d)，使得a+b+c+d等于一个给定的数字target。</p><pre><code class="hljs angelscript">如:nums = [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>]，target = <span class="hljs-number">0</span>结果为：[[<span class="hljs-number">-1</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>],[<span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>],[<span class="hljs-number">-2</span>,  <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>]]</code></pre><h2 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h2><p>4Sum可以当作是3Sum问题的扩展，注意事项仍是一样的，同样是不能返回重复值得解。首先排序。接着从[0,len-1]遍历i，跳过i的重复元素，再在[i+1,len-1]中遍历j，得到i，j后，再选择首尾的l和r，通过对撞指针的思路，四数和大的话r—，小的话l++,相等的话纳入结果list，最后返回。</p><p>套用3Sum得代码，在其前加一层循环，对边界情况进行改动即可:</p><ol><li>原来3个是到len-2,现在外层循环是到len-3;</li><li>在中间层得迭代中，当第二个遍历得值在第一个遍历得值之后且后项大于前项时，认定为重复；</li><li>加些边界条件判断：当len小于4时，直接返回；当只有4个值且长度等于target时，直接返回本身即可。</li></ol><p>代码实现如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fourSum</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span>        nums.sort()        res = []        <span class="hljs-keyword">if</span> len(nums) &lt; <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span> res        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">4</span> <span class="hljs-keyword">and</span> sum(nums) == target:            res.append(nums)            <span class="hljs-keyword">return</span> res        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)<span class="hljs-number">-3</span>):            <span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> nums[i] == nums[i<span class="hljs-number">-1</span>]: <span class="hljs-keyword">continue</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>,len(nums)<span class="hljs-number">-2</span>):                <span class="hljs-keyword">if</span> j &gt; i+<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> nums[j] == nums[j<span class="hljs-number">-1</span>]: <span class="hljs-keyword">continue</span>                l,r = j+<span class="hljs-number">1</span>, len(nums)<span class="hljs-number">-1</span>                <span class="hljs-keyword">while</span> l &lt; r:                    sum_value = nums[i] + nums[j] + nums[l] + nums[r]                    <span class="hljs-keyword">if</span> sum_value == target:                        res.append([nums[i],nums[j],nums[l],nums[r]])                        l += <span class="hljs-number">1</span>                        r -= <span class="hljs-number">1</span>                        <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> nums[l] == nums[l<span class="hljs-number">-1</span>]: l += <span class="hljs-number">1</span>                        <span class="hljs-keyword">while</span> l &lt; r <span class="hljs-keyword">and</span> nums[r] == nums[r+<span class="hljs-number">1</span>]: r -= <span class="hljs-number">1</span>                    <span class="hljs-keyword">elif</span> sum_value &lt; target:                        l += <span class="hljs-number">1</span>                    <span class="hljs-keyword">else</span>:                        r -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre><p>还可以使用combinations(nums, 4)来对原数组中得4个元素全排列，在开始sort后，对排列得到得元素进行set去重。但单纯利用combinations实现会超时。</p><h2 id="超出时间限制"><a href="#超出时间限制" class="headerlink" title="超出时间限制"></a>超出时间限制</h2><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fourSum</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; List[List[int]]:</span>        nums.sort()        <span class="hljs-keyword">from</span> itertools <span class="hljs-keyword">import</span> combinations        res = []        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> combinations(nums, <span class="hljs-number">4</span>):            <span class="hljs-keyword">if</span> sum(i) == target:                res.append(i)        res = set(res)        <span class="hljs-keyword">return</span> res</code></pre><h1 id="LeetCode-16-3Sum-Closest"><a href="#LeetCode-16-3Sum-Closest" class="headerlink" title="LeetCode 16 3Sum Closest"></a>LeetCode 16 3Sum Closest</h1><h2 id="题目描述-10"><a href="#题目描述-10" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个整形数组，寻找其中的三个元素a,b,c，使得a+b+c的值最接近另外一个给定的数字target。</p><p>如：给定数组 nums = [-1，2，1，-4], 和 target = 1.</p><p>与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</p><h2 id="分析实现-9"><a href="#分析实现-9" class="headerlink" title="分析实现"></a>分析实现</h2><p>这道题也是2sum,3sum等题组中的，只不过变形的地方在于不是找相等的target，而是找最近的。</p><p>那么开始时可以随机设定一个三个数的和为结果值，在每次比较中，先判断三个数的和是否和target相等，如果相等直接返回和。如果不相等，则判断三个数的和与target的差是否小于这个结果值时，如果小于则进行则进行替换，并保存和的结果值。</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><pre><code class="hljs python"><span class="hljs-comment"># 先排序</span>nums.sort()<span class="hljs-comment"># 随机选择一个和作为结果值</span>res = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>]<span class="hljs-comment"># 记录这个差值</span>diff = abs(nums[<span class="hljs-number">0</span>]+nums[<span class="hljs-number">1</span>]+nums[<span class="hljs-number">2</span>]-target)<span class="hljs-comment"># 第一遍遍历</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):    <span class="hljs-comment"># 标记好剩余元素的l和r</span>    l,r = i+<span class="hljs-number">1</span>, len(nums<span class="hljs-number">-1</span>)    <span class="hljs-keyword">while</span> l &lt; r:        <span class="hljs-keyword">if</span> 后续的值等于target:            <span class="hljs-keyword">return</span> 三个数值得和        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">if</span> 差值小于diff:                更新diff值                更新res值            <span class="hljs-keyword">if</span> 和小于target:                将l移动            <span class="hljs-keyword">else</span>:(开始已经排除了等于得情况，要判断和大于target)                将r移动</code></pre><h3 id="3Sum问题两层遍历得套路代码："><a href="#3Sum问题两层遍历得套路代码：" class="headerlink" title="3Sum问题两层遍历得套路代码："></a>3Sum问题两层遍历得套路代码：</h3><pre><code class="hljs python">nums.sort()res = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)<span class="hljs-number">-2</span>):    l,r = i+<span class="hljs-number">1</span>, len(nums)<span class="hljs-number">-1</span>    <span class="hljs-keyword">while</span> l &lt; r:        sum = nums[i] + nums[l] + nums[r]        <span class="hljs-keyword">if</span> sum == <span class="hljs-number">0</span>:            res.append([nums[i],nums[l],nums[r]])        <span class="hljs-keyword">elif</span> sum &lt; <span class="hljs-number">0</span>:            l += <span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            r -= <span class="hljs-number">1</span></code></pre><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">threeSumClosest</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; int:</span>        nums.sort()        diff = abs(nums[<span class="hljs-number">0</span>]+nums[<span class="hljs-number">1</span>]+nums[<span class="hljs-number">2</span>]-target)        res = nums[<span class="hljs-number">0</span>] + nums[<span class="hljs-number">1</span>] + nums[<span class="hljs-number">2</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            l,r = i+<span class="hljs-number">1</span>,len(nums)<span class="hljs-number">-1</span>            t = target - nums[i]            <span class="hljs-keyword">while</span> l &lt; r:                <span class="hljs-keyword">if</span> nums[l] + nums[r] == t:                    <span class="hljs-keyword">return</span> nums[i] + t                <span class="hljs-keyword">else</span>:                    <span class="hljs-keyword">if</span> abs(nums[l]+nums[r]-t) &lt; diff:                        diff = abs(nums[l]+nums[r]-t)                        res = nums[i]+nums[l]+nums[r]                    <span class="hljs-keyword">if</span> nums[l]+nums[r] &lt; t:                        l += <span class="hljs-number">1</span>                    <span class="hljs-keyword">else</span>:                        r -= <span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> res</code></pre><p>时间复杂度为O(n^2)，空间复杂度为O(1);</p><h1 id="LeetCode-454-4SumⅡ"><a href="#LeetCode-454-4SumⅡ" class="headerlink" title="LeetCode 454 4SumⅡ"></a>LeetCode 454 4SumⅡ</h1><h2 id="题目描述-11"><a href="#题目描述-11" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出四个整形数组A,B,C,D,寻找有多少i,j,k,l的组合,使得A[i]+B[j]+C[k]+D[l]=0。其中,A,B,C,D中均含有相同的元素个数N，且0&lt;=N&lt;=500；</p><p>输入:</p><p>A = [ 1, 2]<br>B = [-2,-1]<br>C = [-1, 2]<br>D = [ 0, 2]</p><p>输出:2</p><h2 id="分析实现-10"><a href="#分析实现-10" class="headerlink" title="分析实现"></a>分析实现</h2><p>这个问题同样是Sum类问题得变种，其将同一个数组的条件，变为了四个数组中，依然可以用查找表的思想来实现。</p><p>首先可以考虑把D数组中的元素都放入查找表，然后遍历前三个数组，判断target减去每个元素后的值是否在查找表中存在，存在的话，把结果值加1。那么查找表的数据结构选择用set还是dict？考虑到数组中可能存在重复的元素，而重复的元素属于不同的情况，因此用dict存储，最后的结果值加上dict相应key的value，代码如下：</p><h3 id="O-n-3-代码"><a href="#O-n-3-代码" class="headerlink" title="O(n^3)代码"></a>O(n^3)代码</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counterrecord = Counter()<span class="hljs-comment"># 先建立数组D的查找表</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(D)):    record[D[i]] += <span class="hljs-number">1</span>res = <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(A)):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(B)):        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(len(C)):            num_find = <span class="hljs-number">0</span>-A[i]-B[j]-C[k]            <span class="hljs-keyword">if</span> record.get(num_find) != <span class="hljs-literal">None</span>:                res += record(num_find)<span class="hljs-keyword">return</span> res</code></pre><p>但是对于题目中给出的数据规模：N&lt;=500，如果N为500时，n^3的算法依然消耗很大，能否再进行优化呢？</p><p>根据之前的思路继续往前走，如果只遍历两个数组，那么就可以得到O(n^2)级别的算法，但是遍历两个数组，那么还剩下C和D两个数组，上面的值怎么放？</p><p>对于查找表问题而言，<strong>很多时候到底要查找什么</strong>，是解决的关键。对于C和D的数组，可以通过dict来记录其中和的个数，之后遍历结果在和中进行查找。代码如下：</p><h3 id="O-n-2-级代码"><a href="#O-n-2-级代码" class="headerlink" title="O(n^2)级代码"></a>O(n^2)级代码</h3><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(self, A: List[int], B: List[int], C: List[int], D: List[int])</span> -&gt; int:</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter        record = Counter()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(A)):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(B)):                record[A[i]+B[j]] += <span class="hljs-number">1</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(C)):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(D)):                find_num = <span class="hljs-number">0</span> - C[i] - D[j]                <span class="hljs-keyword">if</span> record.get(find_num) != <span class="hljs-literal">None</span>:                    res += record[find_num]        <span class="hljs-keyword">return</span> res</code></pre><p>再使用Pythonic的列表生成式和sum函数进行优化，如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fourSumCount</span><span class="hljs-params">(self, A: List[int], B: List[int], C: List[int], D: List[int])</span> -&gt; int:</span>        record = collections.Counter(a + b <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> A <span class="hljs-keyword">for</span> b <span class="hljs-keyword">in</span> B)        <span class="hljs-keyword">return</span> sum(record.get(- c - d, <span class="hljs-number">0</span>) <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> C <span class="hljs-keyword">for</span> d <span class="hljs-keyword">in</span> D)</code></pre><h1 id="LeetCode-49-Group-Anagrams"><a href="#LeetCode-49-Group-Anagrams" class="headerlink" title="LeetCode 49 Group Anagrams"></a>LeetCode 49 Group Anagrams</h1><h2 id="题目描述-12"><a href="#题目描述-12" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个字符串数组，将其中所有可以通过颠倒字符顺序产生相同结果的单词进行分组。</p><pre><code class="hljs prolog">示例:输入: [<span class="hljs-string">"eat"</span>, <span class="hljs-string">"tea"</span>, <span class="hljs-string">"tan"</span>, <span class="hljs-string">"ate"</span>, <span class="hljs-string">"nat"</span>, <span class="hljs-string">"bat"</span>],输出:[[<span class="hljs-string">"ate"</span>,<span class="hljs-string">"eat"</span>,<span class="hljs-string">"tea"</span>],[<span class="hljs-string">"nat"</span>,<span class="hljs-string">"tan"</span>],[<span class="hljs-string">"bat"</span>]]说明：所有输入均为小写字母。不考虑答案输出的顺序。</code></pre><h2 id="分析实现-11"><a href="#分析实现-11" class="headerlink" title="分析实现"></a>分析实现</h2><p>在之前LeetCode 242的问题中，对字符串t和s来判断，判断t是否是s的字母异位词。当时的方法是通过构建t和s的字典，比较字典是否相同来判断是否为异位词。</p><p>在刚开始解决这个问题时，我也局限于了这个思路，以为是通过移动指针，来依次比较两个字符串是否对应的字典相等，进而确定异位词列表，再把异位词列表添加到结果集res中。于是有：</p><h3 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h3><pre><code class="hljs python">nums = [<span class="hljs-string">"eat"</span>, <span class="hljs-string">"tea"</span>, <span class="hljs-string">"tan"</span>, <span class="hljs-string">"ate"</span>, <span class="hljs-string">"nat"</span>, <span class="hljs-string">"bat"</span>]<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Countercum = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):    l,r = i+<span class="hljs-number">1</span>,len(nums)<span class="hljs-number">-1</span>    i_dict = Counter(nums[i])    res = []    <span class="hljs-keyword">if</span> nums[i] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> cum:        res.append(nums[i])    <span class="hljs-keyword">while</span> l &lt; r:        l_dict = Counter(nums[l])        r_dict = Counter(nums[r])        <span class="hljs-keyword">if</span> i_dict == l_dict <span class="hljs-keyword">and</span> l_dict == r_dict:            res.append(nums[l],nums[r])            l += <span class="hljs-number">1</span>            r -= <span class="hljs-number">1</span>        <span class="hljs-keyword">elif</span> i_dict == l_dict:            res.append(nums[l])            l += <span class="hljs-number">1</span>        <span class="hljs-keyword">elif</span> i_dict == r_dict:            res.append(nums[r])            r -= <span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            l += <span class="hljs-number">1</span>    print(res)    cum.append(res)......................................</code></pre><p>这时发现长长绵绵考虑不完，而且还要注意指针的条件，怎样遍历才能遍历所有的情况且判断列表是否相互间包含。。。</p><p>于是立即开始反思是否哪块考虑错了?回顾第一开始的选择数据结构，在dict和list中，自己错误的选择了list来当作数据结构，进而用指针移动来判断元素的情况。而<strong>没有利用题目中不变的条件</strong>。</p><p>题目的意思，对异位词的进行分组，同异位词的分为一组，那么考虑对这一组内什么是相同的，且这个相同的也能作为不同组的判断条件。</p><p>不同组的判断条件，就可以用数据结构dict中的key来代表，那么什么相同的适合当作key呢？</p><p>这时回顾下下LeetCode 242，当时是因为异位字符串中包含的<strong>字符串的字母个数</strong>都是相同的，故把字母当作key来进行判断是否为异位词。</p><p>但是对于本题，把每个字符串的字母dict，再当作字符串数组的dict的key，显然不太合适，那么对于异位词，还有什么是相同的？</p><p>显然，如果将字符串统一排序，<strong>异位词排序后的字符串</strong>，显然都是相同的。那么就可以把其当作key，把遍历的数组中的异位词当作value，对字典进行赋值，进而遍历字典的value，得到结果list。</p><p>需要注意的细节是，<strong>字符串和list之间的转换</strong>：</p><ol><li>默认构造字典需为list的字典；</li><li>排序使用sorted()函数，而不用list.sort()方法，因为其不返回值；</li><li>通过’’.join(list)，将list转换为字符串；</li><li>通过str.split(‘,’)将字符串整个转换为list中的一项；</li></ol><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">groupAnagrams</span><span class="hljs-params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict        strs_dict = defaultdict(list)        res = []        <span class="hljs-keyword">for</span> str <span class="hljs-keyword">in</span> strs:            key = <span class="hljs-string">''</span>.join(sorted(list(str)))            strs_dict[key] += str.split(<span class="hljs-string">','</span>)        <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> strs_dict.values():            res.append(v)        <span class="hljs-keyword">return</span> res</code></pre><p>再将能用列表生成式替换的地方替换掉,代码实现如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">groupAnagrams</span><span class="hljs-params">(self, strs: List[str])</span> -&gt; List[List[str]]:</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict        strs_dict = defaultdict(list)        <span class="hljs-keyword">for</span> str <span class="hljs-keyword">in</span> strs:            key = <span class="hljs-string">''</span>.join(sorted(list(str)))            strs_dict[key] += str.split(<span class="hljs-string">','</span>)        <span class="hljs-keyword">return</span> [v <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> strs_dict.values()]</code></pre><h1 id="LeetCode-447-Number-of-Boomerangs"><a href="#LeetCode-447-Number-of-Boomerangs" class="headerlink" title="LeetCode 447 Number of Boomerangs"></a>LeetCode 447 Number of Boomerangs</h1><h2 id="题目描述-13"><a href="#题目描述-13" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个平面上的n个点，寻找存在多少个由这些点构成的三元组(i,j,k)，<strong>使得i,j两点的距离等于i,k两点的距离</strong>。</p><p>其中n最多为500,且所有的点坐标的范围在[-10000,10000]之间。</p><pre><code class="hljs angelscript">输入:[[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]]输出:<span class="hljs-number">2</span>解释:两个结果为： [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>]] 和 [[<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">0</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]]</code></pre><h2 id="分析实现-12"><a href="#分析实现-12" class="headerlink" title="分析实现"></a>分析实现</h2><h3 id="原始思路"><a href="#原始思路" class="headerlink" title="原始思路"></a>原始思路</h3><p>题目的要求是：使得i,j两点的距离等于i,k两点的距离，那么相当于是比较三个点之间距离的，那么开始的思路就是三层遍历，i从0到len，j从i+1到len，k从j+1到len，然后比较三个点的距离，相等则结果数加一。</p><p>显然这样的时间复杂度为O(n^3)，对于这道题目，能否用查找表的思路进行解决优化？</p><h3 id="查找表"><a href="#查找表" class="headerlink" title="查找表"></a>查找表</h3><p>之前的查找表问题，大多是通过<strong>构建一个查找表</strong>，而避免了在查找中再内层嵌套循环，从而降低了时间复杂度。那么可以考虑在这道题中，可以通过查找表进行代替哪两层循环。</p><p>当i,j两点距离等于i,k时，用查找表的思路，等价于：对距离key(i,j或i,k的距离)，其值value(个数)为2。</p><p>那么就可以做一个查找表，用来查找相同距离key的个数value是多少。遍历每一个节点i，扫描得到其他点到节点i的距离，在查找表中，对应的键就是距离的值，对应的值就是距离值得个数。</p><p>在拿到对于元素i的距离查找表后，接下来就是排列选择问题了：</p><ol><li>如果当距离为x的值有2个时，那么选择j,k的可能情况有：第一次选择有2种，第二次选择有1种，为2*1；</li><li>如果当距离为x的值有3个时，那么选择j,k的可能的情况有：第一次选择有3种，第二次选择有2种，为3*2;</li><li>那么当距离为x的值有n个时，选择j,k的可能情况有：第一次选择有n种，第二次选择有n-1种。</li></ol><h3 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h3><p>对于距离值的求算，按照欧式距离的方法进行求算的话，容易产生浮点数，可以将根号去掉，用差的平方和来进行比较距离。</p><p>实现代码如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numberOfBoomerangs</span><span class="hljs-params">(self, points: List[List[int]])</span> -&gt; int:</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> points:            record = Counter()            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> points:                <span class="hljs-keyword">if</span> i != j:                    record[self.dis(i,j)] += <span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> k,v <span class="hljs-keyword">in</span> record.items():                res += v*(v<span class="hljs-number">-1</span>)        <span class="hljs-keyword">return</span> res    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dis</span><span class="hljs-params">(self,point1,point2)</span>:</span>        <span class="hljs-keyword">return</span> (point1[<span class="hljs-number">0</span>]-point2[<span class="hljs-number">0</span>]) ** <span class="hljs-number">2</span> + (point1[<span class="hljs-number">1</span>]-point2[<span class="hljs-number">1</span>]) ** <span class="hljs-number">2</span></code></pre><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>对实现的代码进行优化：</p><ol><li>将for循环遍历改为列表生成式;</li><li>对sum+=的操作，考虑使用sum函数。</li><li>对不同的函数使用闭包的方式内嵌；</li></ol><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numberOfBoomerangs</span><span class="hljs-params">(self, points: List[List[int]])</span> -&gt; int:</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(x1, y1)</span>:</span>            <span class="hljs-comment"># 对一个i下j,k的距离值求和</span>            d = Counter((x2 - x1) ** <span class="hljs-number">2</span> + (y2 - y1) ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> x2, y2 <span class="hljs-keyword">in</span> points)            <span class="hljs-keyword">return</span> sum(t * (t<span class="hljs-number">-1</span>) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> d.values())        <span class="hljs-comment"># 对每个i的距离进行求和</span>        <span class="hljs-keyword">return</span> sum(f(x1, y1) <span class="hljs-keyword">for</span> x1, y1 <span class="hljs-keyword">in</span> points)</code></pre><h1 id="LeetCode-149-Max-Points-on-a-Line"><a href="#LeetCode-149-Max-Points-on-a-Line" class="headerlink" title="LeetCode 149 Max Points on a Line"></a>LeetCode 149 Max Points on a Line</h1><h2 id="题目描述-14"><a href="#题目描述-14" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二维平面，平面上有 n 个点，求最多有多少个点在同一条直线上。</p><pre><code class="hljs angelscript">示例 <span class="hljs-number">1</span>:输入: [[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">3</span>]]输出: <span class="hljs-number">3</span>示例 <span class="hljs-number">2</span>:输入: [[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">3</span>,<span class="hljs-number">2</span>],[<span class="hljs-number">5</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">1</span>,<span class="hljs-number">4</span>]]输出: <span class="hljs-number">4</span></code></pre><h2 id="分析实现-13"><a href="#分析实现-13" class="headerlink" title="分析实现"></a>分析实现</h2><p>本道题目的要求是：看有多少个点在同一条直线上，那么判断点是否在一条直线上，其实就等价于判断i,j两点的斜率是否等于i,k两点的斜率。</p><p>回顾上道447题目中的要求：使得i,j两点的距离等于i,k两点的距离，那么在这里，直接考虑使用查找表实现，即<strong>查找相同斜率key的个数value是多少</strong>。</p><p>在上个问题中，i和j，j和i算是两种不同的情况，但是这道题目中，这是属于相同的两个点，<br>因此在对遍历每个i,查找与i相同斜率的点时，不能再对结果数res++，而应该取查找表中的最大值。如果有两个斜率相同时，返回的应该是3个点，故返回的是结果数+1。</p><p>查找表实现套路如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxPoints</span><span class="hljs-params">(self,points)</span>:</span>        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(points)):            record = defaultdict(int)            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(points)):                <span class="hljs-keyword">if</span> i != j:                    record[self.get_Slope(points,i,j)] += <span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> record.values():                res = max(res, v)        <span class="hljs-keyword">return</span> res + <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_Slope</span><span class="hljs-params">(self,points,i,j)</span>:</span>        <span class="hljs-keyword">return</span> (points[i][<span class="hljs-number">0</span>] - points[j][<span class="hljs-number">0</span>]) / (points[i][<span class="hljs-number">1</span>] - points[j][<span class="hljs-number">1</span>])</code></pre><p>但是这样会出现一个问题，即斜率的求算中，有时会出现直线为垂直的情况，故需要对返回的结果进行判断，如果分母为0，则返回inf，如下：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_Slope</span><span class="hljs-params">(self,points,i,j)</span>:</span>    <span class="hljs-keyword">if</span> points[i][<span class="hljs-number">1</span>] - points[j][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:        <span class="hljs-keyword">return</span> float(<span class="hljs-string">'Inf'</span>)    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">return</span> (points[i][<span class="hljs-number">0</span>] - points[j][<span class="hljs-number">0</span>]) / (points[i][<span class="hljs-number">1</span>] - points[j][<span class="hljs-number">1</span>])</code></pre><p>再次提交，发现对于空列表的测试用例会判断错误，于是对边界情况进行判断，如果初始长度小于等于1,则直接返回len：</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> len(points) &lt;= <span class="hljs-number">1</span>:    <span class="hljs-keyword">return</span> len(points)</code></pre><p>再次提交，对于相同元素的测试用例会出现错误，回想刚才的过程，当有相同元素时，题目的要求是算作两个不同的点，但是在程序运行时，会将其考虑为相同的点，return回了inf。但在实际运行时，需要对相同元素的情况单独考虑。</p><p>于是可以设定samepoint值，遍历时判断，如果相同时，same值++,最后取v+same的值作为结果数。</p><p>考虑到如果全是相同值，那么这时dict中的record为空，也要将same值当作结果数返回，代码实现如下：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxPoints</span><span class="hljs-params">(self,points)</span>:</span>        <span class="hljs-keyword">if</span> len(points) &lt;= <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> len(points)        res = <span class="hljs-number">0</span>        <span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> defaultdict        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(points)):            record = defaultdict(int)            samepoint = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(points)):                <span class="hljs-keyword">if</span> points[i][<span class="hljs-number">0</span>] == points[j][<span class="hljs-number">0</span>] <span class="hljs-keyword">and</span> points[i][<span class="hljs-number">1</span>] == points[j][<span class="hljs-number">1</span>]:                    samepoint += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    record[self.get_Slope(points,i,j)] += <span class="hljs-number">1</span>            <span class="hljs-keyword">for</span> v <span class="hljs-keyword">in</span> record.values():                res = max(res, v+samepoint)            res = max(res, samepoint)        <span class="hljs-keyword">return</span> res    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_Slope</span><span class="hljs-params">(self,points,i,j)</span>:</span>        <span class="hljs-keyword">if</span> points[i][<span class="hljs-number">1</span>] - points[j][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> float(<span class="hljs-string">'Inf'</span>)        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> (points[i][<span class="hljs-number">0</span>] - points[j][<span class="hljs-number">0</span>]) / (points[i][<span class="hljs-number">1</span>] - points[j][<span class="hljs-number">1</span>])</code></pre><p>时间复杂度为O(n^2)，空间复杂度为O(n)</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>遍历时多用索引，而不要直接用值进行遍历；</p><h1 id="三-滑动数组"><a href="#三-滑动数组" class="headerlink" title="三. 滑动数组"></a>三. 滑动数组</h1><h1 id="LeetCode-219-Contains-Dupliccate-Ⅱ"><a href="#LeetCode-219-Contains-Dupliccate-Ⅱ" class="headerlink" title="LeetCode 219 Contains Dupliccate Ⅱ"></a>LeetCode 219 Contains Dupliccate Ⅱ</h1><h2 id="题目描述-15"><a href="#题目描述-15" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出一个整形数组nums和一个整数k，是否存在索引i和j，使得nums[i]==nums[j]，且i和J之间的差不超过k。</p><pre><code class="hljs angelscript">示例<span class="hljs-number">1</span>:输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>], k = <span class="hljs-number">3</span>输出: <span class="hljs-literal">true</span>示例 <span class="hljs-number">2</span>:输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], k = <span class="hljs-number">2</span>输出: <span class="hljs-literal">false</span></code></pre><h2 id="分析实现-14"><a href="#分析实现-14" class="headerlink" title="分析实现"></a>分析实现</h2><p>翻译下这个题目：在这个数组中，如果有两个元素索引i和j，它们对应的元素是相等的，且索引j-i是小于等于k，那么就返回True，否则返回False。</p><p>因为对于这道题目可以用暴力解法双层循环，即：</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>,len(nums)):        <span class="hljs-keyword">if</span> i == j:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre><p>故这道题目可以考虑使用滑动数组来解决：</p><p>固定滑动数组的长度为K+1，当这个滑动数组内如果能找到两个元素的值相等，就可以保证两个元素的索引的差是小于等于k的。如果当前的滑动数组中没有元素相同，就右移滑动数组的右边界r,同时将左边界l右移。查看r++的元素是否在l右移过后的数组里，如果不在就将其添加数组，在的话返回true表示两元素相等。</p><p>因为滑动数组中的元素是不同的，考虑用set作为数据结构：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(self, nums: List[int], k: int)</span> -&gt; bool:</span>        record = set()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            <span class="hljs-keyword">if</span> nums[i] <span class="hljs-keyword">in</span> record:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            record.add(nums[i])            <span class="hljs-keyword">if</span> len(record) == k+<span class="hljs-number">1</span>:                record.remove(nums[i-k])        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre><p>时间复杂度为O(n)，空间复杂度为O(n)</p><h1 id="LeetCode-220-Contains-Dupliccate-Ⅲ"><a href="#LeetCode-220-Contains-Dupliccate-Ⅲ" class="headerlink" title="LeetCode 220 Contains Dupliccate Ⅲ"></a>LeetCode 220 Contains Dupliccate Ⅲ</h1><h2 id="题目描述-16"><a href="#题目描述-16" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组，判断数组中是否有两个不同的索引 i 和 j，使得nums [i] 和nums [j]的差的绝对值最大为 t，并且 i 和 j 之间的差的绝对值最大为 ķ。</p><p>示例 1:</p><p>输入: nums = [1,2,3,1], k = 3, t = 0</p><p>输出: true</p><p>示例 2:</p><p>输入: nums = [1,0,1,1], k = 1, t = 2</p><p>输出: true</p><p>示例 3:</p><p>输入: nums = [1,5,9,1,5,9], k = 2, t = 3</p><p>输出: false</p><h2 id="分析实现-15"><a href="#分析实现-15" class="headerlink" title="分析实现"></a>分析实现</h2><p>相比较上一个问题，这个问题多了一个限定条件，条件不仅索引差限定k，数值差也限定为了t。</p><p>将索引的差值固定，于是问题和上道一样，同样转化为了固定长度K+1的滑动窗口内，是否存在两个值的差距不超过 t，考虑使用<strong>滑动窗口</strong>的思想来解决。</p><p>在遍历的过程中，目的是要在“已经出现、但还未滑出滑动窗口”的所有数中查找，是否有一个数与滑动数组中的数的<strong>差的绝对值</strong>最大为 t。对于差的绝对值最大为t，实际上等价于所要找的这个元素v的范围是在v-t到v+t之间，即查找“滑动数组”中的元素有没有[v-t，v+t]范围内的数存在。</p><p>因为只需证明是否存在即可，这时判断的逻辑是：如果在滑动数组<strong>查找比v-t大的最小的元素</strong>,如果这个元素小于等于v+t,即可以证明存在[v-t,v+t]。</p><p>那么实现过程其实和上题是一致的，只是上题中的判断条件是<strong>在查找表中找到和nums[i]相同的元素</strong>，而这题中的判断条件是<strong>查找比v-t大的最小的元素，判断其小于等于v+t</strong>，下面是实现的框架：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">containsNearbyDuplicate</span><span class="hljs-params">(self, nums: List[int], k: int)</span> -&gt; bool:</span>        record = set()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            <span class="hljs-keyword">if</span> 查找的比v-t大的最小的元素 &lt;= v+t:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            record.add(nums[i])            <span class="hljs-keyword">if</span> len(record) == k+<span class="hljs-number">1</span>:                record.remove(nums[i-k])        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre><p>接下来考虑，如何查找比v-t大的最小的元素呢？</p><p>【注：C++中有lower_bound(v-t)的实现，py需要自己写函数】</p><p>当然首先考虑可以通过O(n)的解法来完成，如下：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(self,array,v)</span>:</span>    array = list(array)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(array)):        <span class="hljs-keyword">if</span> array[i] &gt;= v:            <span class="hljs-keyword">return</span> i    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span></code></pre><p>但是滑动数组作为set，是有序的数组。对于有序的数组，应该第一反应就是<strong>二分查找</strong>，于是考虑二分查找实现，查找比v-t大的最小的元素：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(self, nums, target)</span>:</span>    low, high = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span>    <span class="hljs-keyword">while</span> low&lt;high:        mid = int((low+high)/<span class="hljs-number">2</span>)        <span class="hljs-keyword">if</span> nums[mid] &lt; target:            low = mid+<span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            high = mid    <span class="hljs-keyword">return</span> low <span class="hljs-keyword">if</span> nums[low] &gt;= target <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span></code></pre><p>整体代码实现如下，时间复杂度为O(nlogn),空间复杂度为O(n):</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(self, nums, k, t)</span> -&gt; bool:</span>        record = set()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            <span class="hljs-keyword">if</span> len(record) != <span class="hljs-number">0</span>:                rec = list(record)                find_index = self.lower_bound(rec,nums[i]-t)                <span class="hljs-keyword">if</span> find_index != <span class="hljs-number">-1</span> <span class="hljs-keyword">and</span> rec[find_index] &lt;= nums[i] + t:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            record.add(nums[i])            <span class="hljs-keyword">if</span> len(record) == k + <span class="hljs-number">1</span>:                record.remove(nums[i - k])        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(self, nums, target)</span>:</span>        low, high = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> low&lt;high:            mid = int((low+high)/<span class="hljs-number">2</span>)            <span class="hljs-keyword">if</span> nums[mid] &lt; target:                low = mid+<span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                high = mid        <span class="hljs-keyword">return</span> low <span class="hljs-keyword">if</span> nums[low] &gt;= target <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span></code></pre><p>当然。。。在和小伙伴一起刷的时候，这样写的O(n^2)的结果会比上面要高，讨论的原因应该是上面的步骤存在着大量set和list的转换导致，对于py，仍旧是考虑算法思想实现为主，下面是O(n^2)的代码：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">containsNearbyAlmostDuplicate</span><span class="hljs-params">(self, nums: List[int], k: int, t: int)</span> -&gt; bool:</span>        <span class="hljs-keyword">if</span> t == <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> len(nums) == len(set(nums)):            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,k+<span class="hljs-number">1</span>):                <span class="hljs-keyword">if</span> i+j &gt;= len(nums): <span class="hljs-keyword">break</span>                <span class="hljs-keyword">if</span> abs(nums[i+j]-nums[i]) &lt;= t: <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span></code></pre><h2 id="小套路："><a href="#小套路：" class="headerlink" title="小套路："></a>小套路：</h2><p>二分查找实现，查找比v-t大的最小的元素：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lower_bound</span><span class="hljs-params">(self, nums, target)</span>:</span>    low, high = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span>    <span class="hljs-keyword">while</span> low&lt;high:        mid = int((low+high)/<span class="hljs-number">2</span>)        <span class="hljs-keyword">if</span> nums[mid] &lt; target:            low = mid+<span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:            high = mid    <span class="hljs-keyword">return</span> low <span class="hljs-keyword">if</span> nums[low] &gt;= target <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span></code></pre><p>二分查找实现，查找比v-t大的最小的元素：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">upper_bound</span><span class="hljs-params">(nums, target)</span>:</span>    low, high = <span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span>    <span class="hljs-keyword">while</span> low&lt;high:        mid=(low+high)/<span class="hljs-number">2</span>        <span class="hljs-keyword">if</span> nums[mid]&lt;=target:            low = mid+<span class="hljs-number">1</span>        <span class="hljs-keyword">else</span>:<span class="hljs-comment">#&gt;</span>            high = mid            pos = high    <span class="hljs-keyword">if</span> nums[low]&gt;target:        pos = low    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span></code></pre><h1 id="四-二分查找"><a href="#四-二分查找" class="headerlink" title="四. 二分查找"></a>四. 二分查找</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><p>查找在算法题中是很常见的，但是怎么最大化查找的效率和写出bugfree的代码才是难的部分。一般查找方法有顺序查找、二分查找和双指针，推荐一开始可以直接用顺序查找，如果遇到TLE的情况再考虑剩下的两种，毕竟AC是最重要的。</p><p>一般二分查找的对象是有序或者由有序部分变化的（可能暂时理解不了，看例题即可），但还存在一种可以运用的地方是按值二分查找，之后会介绍。</p><h2 id="代码模板"><a href="#代码模板" class="headerlink" title="代码模板"></a>代码模板</h2><p>总体来说二分查找是比较简单的算法，网上看到的写法也很多，掌握一种就可以了。<br>以下是我的写法，参考C++标准库里<algorithm>的写法。这种写法比较好的点在于：</algorithm></p><ul><li>1.即使区间为空、答案不存在、有重复元素、搜索开/闭区间的上/下界也同样适用</li><li>2.+-1 的位置调整只出现了一次，而且最后返回lo还是hi都是对的，无需纠结</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">firstBadVersion</span><span class="hljs-params">(self, arr)</span>:</span>        <span class="hljs-comment"># 第一点</span>        lo, hi = <span class="hljs-number">0</span>, len(arr)<span class="hljs-number">-1</span>        <span class="hljs-keyword">while</span> lo &lt; hi:            <span class="hljs-comment"># 第二点</span>            mid = (lo+hi) // <span class="hljs-number">2</span>            <span class="hljs-comment"># 第三点</span>            <span class="hljs-keyword">if</span> f(x):                lo = mid + <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hi = mid        <span class="hljs-keyword">return</span> lo</code></pre><p><strong>解释</strong>：</p><ul><li>第一点：lo和hi分别对应搜索的上界和下界，但不一定为0和arr最后一个元素的下标。</li><li><p>第二点：因为Python没有溢出，int型不够了会自动改成long int型，所以无需担心。如果再苛求一点，可以把这一行改成</p><pre><code class="hljs python">mid = lo + (hi-lo) // <span class="hljs-number">2</span><span class="hljs-comment"># 之所以 //2 这部分不用位运算 &gt;&gt; 1 是因为会自动优化，效率不会提升</span></code></pre></li><li><p>第三点：<br>比较重要的就是这个f(x)，在带入模板的情况下，写对函数就完了。</p></li></ul><p>那么我们一步一步地揭开二分查找的神秘面纱，首先来一道简单的题。</p><h2 id="LeetCode-35-Search-Insert-Position"><a href="#LeetCode-35-Search-Insert-Position" class="headerlink" title="LeetCode 35. Search Insert Position"></a>LeetCode 35. Search Insert Position</h2><p>给定排序数组和目标值，如果找到目标，则返回索引。如果不是，则返回按顺序插入索引的位置的索引。 您可以假设数组中没有重复项。</p><p><strong>Example</strong></p><pre><code class="hljs angelscript">Example <span class="hljs-number">1</span>:Input: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-number">5</span>Output: <span class="hljs-number">2</span>Example <span class="hljs-number">2</span>:Input: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-number">2</span>Output: <span class="hljs-number">1</span>Example <span class="hljs-number">3</span>:Input: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-number">7</span>Output: <span class="hljs-number">4</span>Example <span class="hljs-number">4</span>:Input: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>], <span class="hljs-number">0</span>Output: <span class="hljs-number">0</span></code></pre><p><strong>分析：</strong> 这里要注意的点是 high 要设置为 len(nums) 的原因是像第三个例子会超出数组的最大值，所以要让 lo 能到 这个下标。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(self, nums: List[int], target: int)</span> -&gt; int:</span>                lo, hi = <span class="hljs-number">0</span>, len(nums)        <span class="hljs-keyword">while</span> lo &lt; hi:            mid = (lo + hi) // <span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> nums[mid] &lt; target:                lo = mid + <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hi = mid        <span class="hljs-keyword">return</span> lo</code></pre><h2 id="LeetCode540-Single-Element-in-a-Sorted-Array"><a href="#LeetCode540-Single-Element-in-a-Sorted-Array" class="headerlink" title="LeetCode540. Single Element in a Sorted Array"></a>LeetCode540. Single Element in a Sorted Array</h2><p>您将获得一个仅由整数组成的排序数组，其中每个元素精确出现两次，但一个元素仅出现一次。 找到只出现一次的单个元素。</p><p><strong>Example</strong></p><pre><code class="hljs angelscript">Example <span class="hljs-number">1</span>:Input: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">8</span>]Output: <span class="hljs-number">2</span>Example <span class="hljs-number">2</span>:Input: [<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">10</span>,<span class="hljs-number">11</span>,<span class="hljs-number">11</span>]Output: <span class="hljs-number">10</span></code></pre><p><strong>分析：</strong> 异或的巧妙应用！如果mid是偶数，那么和1异或的话，那么得到的是mid+1，如果mid是奇数，得到的是mid-1。如果相等的话，那么唯一的元素还在这之后，往后找就可以了。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNonDuplicate</span><span class="hljs-params">(self, nums)</span>:</span>        lo, hi = <span class="hljs-number">0</span>, len(nums) - <span class="hljs-number">1</span>        <span class="hljs-keyword">while</span> lo &lt; hi:            mid = (lo + hi) // <span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> nums[mid] == nums[mid ^ <span class="hljs-number">1</span>]:                lo = mid + <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hi = mid        <span class="hljs-keyword">return</span> nums[lo]</code></pre><p><strong>是不是还挺简单哈哈，那我们来道HARD难度的题!</strong></p><h2 id="LeetCode-410-Split-Array-Largest-Sum"><a href="#LeetCode-410-Split-Array-Largest-Sum" class="headerlink" title="LeetCode 410. Split Array Largest Sum"></a>LeetCode 410. Split Array Largest Sum</h2><p>给定一个由非负整数和整数m组成的数组，您可以将该数组拆分为m个非空连续子数组。编写算法以最小化这m个子数组中的最大和。</p><p><strong>Example</strong></p><pre><code class="hljs angelscript">Input:nums = [<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">8</span>]m = <span class="hljs-number">2</span>Output:<span class="hljs-number">18</span>Explanation:There are four ways to split nums <span class="hljs-built_in">int</span>o two subarrays.The best way <span class="hljs-keyword">is</span> to split it <span class="hljs-built_in">int</span>o [<span class="hljs-number">7</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>] <span class="hljs-keyword">and</span> [<span class="hljs-number">10</span>,<span class="hljs-number">8</span>],where the largest sum among the two subarrays <span class="hljs-keyword">is</span> only <span class="hljs-number">18.</span></code></pre><p><strong>分析：</strong></p><ul><li>这其实就是二分查找里的按值二分了，可以看出这里的元素就无序了。但是我们的目标是找到一个合适的最小和，换个角度理解我们要找的值在最小值max(nums)和sum(nums)内，而这两个值中间是连续的。是不是有点难理解，那么看代码吧</li><li>辅助函数的作用是判断当前的“最小和”的情况下，区间数是多少，来和m判断</li><li>这里的下界是数组的最大值是因为如果比最大值小那么一个区间就装不下，数组的上界是数组和因为区间最少是一个，没必要扩大搜索的范围</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(self, nums: List[int], m: int)</span> -&gt; int:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span><span class="hljs-params">(mid)</span>:</span>            res = tmp = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:                <span class="hljs-keyword">if</span> tmp + num &lt;= mid:                    tmp += num                <span class="hljs-keyword">else</span>:                    res += <span class="hljs-number">1</span>                    tmp = num            <span class="hljs-keyword">return</span> res + <span class="hljs-number">1</span>        lo, hi = max(nums), sum(nums)        <span class="hljs-keyword">while</span> lo &lt; hi:            mid = (lo + hi) // <span class="hljs-number">2</span>            <span class="hljs-keyword">if</span> helper(mid) &gt; m:                lo = mid + <span class="hljs-number">1</span>            <span class="hljs-keyword">else</span>:                hi = mid        <span class="hljs-keyword">return</span> lo</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-动态规划</title>
    <link href="/article/e57c001c.html"/>
    <url>/article/e57c001c.html</url>
    
    <content type="html"><![CDATA[<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划常常适用于<strong>有重叠子问题</strong>和<strong>最优子结构</strong>性质的问题，动态规划方法<strong>所耗时间往往远少于朴素解法</strong>。</p><h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。动态规划往往用于优化递归问题，例如斐波那契数列，如果运用递归的方式来求解会重复计算很多相同的子问题，利用动态规划的思想可以减少计算量。</p><p>动态规划法仅仅解决每个子问题一次，具有天然剪枝的功能，从而减少计算量，</p><p>一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。</p><h3 id="动态规划模板步骤："><a href="#动态规划模板步骤：" class="headerlink" title="动态规划模板步骤："></a>动态规划模板步骤：</h3><ul><li><p>确定动态规划状态</p></li><li><p>写出状态转移方程（画出状态转移表）</p></li><li><p>考虑初始化条件</p></li><li><p>考虑输出状态</p></li><li><p>考虑对时间，空间复杂度的优化（Bonus）</p></li></ul><h2 id="例题详解"><a href="#例题详解" class="headerlink" title="例题详解"></a>例题详解</h2><p>接下来，我们对每个步骤进行详细的讲解，并给出不同题目中考虑的不同方式，争取让大家吃透动态规划的套路。<br>我们以最经典的动态规划题目——<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">Leetcode 300.最长上升子序列</a> 为例子。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">10</span>,<span class="hljs-number">9</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>,<span class="hljs-number">18</span>]输出: <span class="hljs-number">4</span> 解释: 最长的上升子序列是 [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>,<span class="hljs-number">101</span>]，它的长度是 <span class="hljs-number">4</span>。</code></pre><p>说明:</p><pre><code class="hljs reasonml">可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 <span class="hljs-constructor">O(<span class="hljs-params">n2</span>)</span> 。</code></pre><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>第一步：确定动态规划状态</strong></p><ul><li><p>是否存在状态转移?</p></li><li><p>什么样的状态比较好转移，找到对求解问题最方便的状态转移?</p><p>想清楚到底是直接用需要求的，比如长度作为dp保存的变量还是用某个判断问题的状态比如是否是回文子串来作为方便求解的状态</p><p>该题目可以直接用一个一维数组<code>dp</code>来存储转移状态，<code>dp[i]</code>可以定义为以<code>nums[i]</code>这个数结尾的最长递增子序列的长度。举个实际例子，比如在<code>nums[10,9,2,5,3,7,101,18]</code>中，<code>dp[0]</code>表示数字10的最长递增子序列长度，那就是本身，所以为1，对于<code>dp[5]</code>对应的数字7来说的最长递增子序列是<code>[2,5,7]</code>（或者<code>[2,3,7]</code>）所以<code>dp[5]=3</code>。</p></li></ul><p><strong>第二步：写出一个好的状态转移方程</strong></p><ul><li><p>使用<strong>数学归纳法</strong>思维，写出准确的状态方程</p><p>比如还是用刚刚那个<code>nums</code>数组，我们<strong>思考一下是如何得到<code>dp[5]=3</code>的</strong>：既然是递增的子序列，我们只要找到<code>nums[5]</code> (也就是7)前面那些结尾比7小的子序列，然后把7接到最后，就可以形成一个新的递增的子序列，也就是这个新的子序列也就是在找到的前面那些数后面加上7，相当长度加1。当然可能会找到很多不同的子序列，比如刚刚在上面列举的，但是只需要找到长度最长的作为<code>dp[5]</code>的值就行。总结来说就是比较当前<code>dp[i]</code>的长度和<code>dp[i]</code>对应产生新的子序列长度，我们用<code>j</code>来表示所有比<code>i</code>小的组数中的索引，可以用如下代码公式表示</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i):    <span class="hljs-keyword">if</span> nums[i]&gt;nums[j]:    dp[i]=max(dp[i],dp[j]+<span class="hljs-number">1</span>)</code></pre><p><strong>Tips:</strong> 在实际问题中，如果不能很快得出这个递推公式，可以先尝试一步一步把前面几步写出来，如果还是不行很可能就是 dp 数组的定义不够恰当，需要回到第一步重新定义 dp 数组的含义；或者可能是 dp 数组存储的信息还不够，不足以推出下一步的答案，需要把 dp 数组扩大成二维数组甚至三维数组。</p></li></ul><p><strong>第三步：考虑初始条件</strong></p><p>​    这是决定整个程序能否跑通的重要步骤，当我们确定好状态转移方程，我们就需要考虑一下边界值，边界值考虑主要又分为三个地方：</p><ul><li><p>dp数组整体的初始值</p></li><li><p>dp数组(二维)i=0和j=0的地方</p></li><li><p>dp存放状态的长度，是整个数组的长度还是数组长度加一，这点需要特别注意。</p><p>对于本问题，子序列最少也是自己，所以长度为1，这样我们就可以方便的把所有的<code>dp</code>初始化为1，再考虑长度问题，由于<code>dp[i]</code>代表的是<code>nums[i]​</code>的最长子序列长度，所以并不需要加一。<br>所以用代码表示就是​<code>dp=[1]*len(nums)​</code></p><p><strong>Tips：</strong>还有一点需要注意，找到一个方便的状态转移会使问题变得非常简单。举个例子，对于<a href="https://leetcode-cn.com/problems/triangle/" target="_blank" rel="noopener">Leetcode120.三角形最小路径和</a>问题，大多数人刚开始想到的应该是自顶向下的定义状态转移的思路，也就是从最上面的数开始定义状态转移，但是这题优化的解法则是通过定义由下到上的状态转移方程会大大简化问题，同样的对于<a href="https://leetcode-cn.com/problems/maximum-subarray/solution/" target="_blank" rel="noopener">Leetcode53.最大子序和</a>也是采用从下往上遍历，保证每个子问题都是已经算好的。这个具体我们在题目中会讲到。</p></li></ul><p>  这里额外总结几种Python常用的初始化方法：</p><ul><li><p>对于产生一个全为1，长度为n的数组：</p><pre><code class="hljs python"><span class="hljs-number">1.</span> dp=[<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n)]<span class="hljs-number">2.</span> dp=[<span class="hljs-number">1</span>]*n</code></pre></li><li><p>对于产生一个全为0，长度为m，宽度为n的二维矩阵：</p><pre><code class="hljs python"><span class="hljs-number">1.</span> dp=[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m)]<span class="hljs-number">2.</span> dp=[[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m)]</code></pre></li></ul><p><strong>第四步：考虑输出状态</strong></p><p>主要有以下三种形式，对于具体问题，我们一定要想清楚到底dp数组里存储的是哪些值，最后我们需要的是数组中的哪些值：</p><ul><li><p>返回dp数组中最后一个值作为输出，一般对应二维dp问题。</p></li><li><p>返回dp数组中最大的那个数字，一般对应记录最大值问题。</p></li><li><p>返回保存的最大值，一般是<code>Maxval=max(Maxval,dp[i])</code>这样的形式。</p><p><strong>Tips：</strong>这个公式必须是在满足递增的条件下，也就是<code>nums[i]&gt;nums[j]​</code>的时候才能成立，并不是<code>nums[i]​</code>前面所有数字都满足这个条件的，理解好这个条件就很容易懂接下来在输出时候应该是​<code>max(dp)​</code>而不是​<code>dp[-1]​</code>，原因就是dp数组由于计算递增的子序列长度，所以dp数组里中间可能有值会是比最后遍历的数值大的情况，每次遍历<code>nums[j]</code>所对应的位置都是比<code>nums[i]</code>小的那个数。举个例子，比如<code>nums=[1,3,6,7,9,4,10,5,6]</code>,而最后<code>dp=[1,2,3,4,5,3,6,4,5]</code>。<br>总结一下，最后的结果应该返回dp数组中值最大的数。</p><p>最后加上考虑数组是否为空的判断条件，下面是该问题完整的代码：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(self, nums: List[int])</span> -&gt; int:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>  <span class="hljs-comment">#判断边界条件</span>        dp=[<span class="hljs-number">1</span>]*len(nums)      <span class="hljs-comment">#初始化dp数组状态</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i):                <span class="hljs-keyword">if</span> nums[i]&gt;nums[j]:   <span class="hljs-comment">#根据题目所求得到状态转移方程</span>                    dp[i]=max(dp[i],dp[j]+<span class="hljs-number">1</span>)        <span class="hljs-keyword">return</span> max(dp)  <span class="hljs-comment">#确定输出状态</span></code></pre></li></ul><p><strong>第五步：考虑对时间，空间复杂度的优化（Bonus）</strong></p><p><strong>切入点：</strong><br>我们看到，之前方法遍历dp列表需要$O(N)$，计算每个<code>dp[i]</code>需要$O(N)$的时间，所以总复杂度是$O(N^2)$</p><p>前面遍历dp列表的时间复杂度肯定无法降低了，但是我们看后面在每轮遍历<code>[0,i]</code>的<code>dp[i]​</code>元素的时间复杂度可以考虑设计状态定义，使得整个dp为一个排序列表，这样我们自然想到了可以利用二分法来把时间复杂度降到了$O(NlogN)$。这里由于篇幅原因，如果大家感兴趣的话详细的解题步骤可以看好心人写的<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/" target="_blank" rel="noopener">二分方法+动态规划详解</a></p><p><strong>模板总结：</strong></p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i):            dp[i]=最值(dp[i],dp[j]+...)</code></pre><p>对于子序列问题，很多也都是用这个模板来进行解题，比如<a href="https://leetcode-cn.com/problems/maximum-subarray/solution/" target="_blank" rel="noopener">Leetcode53.最大子序和</a>。此外，其他情况的子序列问题可能需要二维的dp数组来记录状态，比如：<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">Leetcode5. 最长回文子串</a>（下面会讲到） 、  <a href="https://leetcode-cn.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">Leetcode1143. 最长公共子序列</a> (当涉及到两个字符串/数组时)<br>如果你觉得刚刚那题有点难的话，不如我们从简单一点的题目开始理解一下这类子序列问题。接下来所有题目我们都按照那五个步骤考虑</p><h2 id="算法应用"><a href="#算法应用" class="headerlink" title="算法应用"></a>算法应用</h2><h3 id="Leetcode-674-最长连续递增序列"><a href="#Leetcode-674-最长连续递增序列" class="headerlink" title="Leetcode 674.最长连续递增序列"></a><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">Leetcode 674.最长连续递增序列</a></h3><h4 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个未经排序的整数数组，找到最长且连续的的递增序列。</p><pre><code class="hljs angelscript">示例 <span class="hljs-number">1</span>:输入: [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">7</span>]输出: <span class="hljs-number">3</span>解释: 最长连续递增序列是 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>], 长度为<span class="hljs-number">3</span>。尽管 [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>] 也是升序的子序列, 但它不是连续的，因为<span class="hljs-number">5</span>和<span class="hljs-number">7</span>在原数组里被<span class="hljs-number">4</span>隔开。</code></pre><h4 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h4><p>这道题是不是一眼看过去和上题非常的像，没错了，这个题目最大的不同就是<strong>连续</strong>两个字，这样就让这个问题简单很多了，因为如果要求连续的话，那么就不需要和上题一样遍历两遍数组，只需要比较前后的值是不是符合递增的关系。</p><ul><li><p><strong>第一步：确定动态规划状态</strong><br>对于这个问题，我们的状态<strong>dp[i]也是以nums[i]这个数结尾的最长递增子序列的长度</strong></p></li><li><p><strong>第二步：写出状态转移方程</strong><br>这个问题，我们需要分两种情况考虑，第一种情况是如果遍历到的数<code>nums[i]</code>后面一个数不是比他大或者前一个数不是比他小，也就是所谓的不是连续的递增，那么这个数列最长连续递增序列就是他本身，也就是长度为1。<br>第二种情况就是如果满足有递增序列，就意味着当前状态只和前一个状态有关，<code>dp[i]</code>只需要在前一个状态基础上加一就能得到当前最长连续递增序列的长度。总结起来，状态的转移方程可以写成<br><code>dp[i]=dp[i-1]+1</code></p></li><li><p><strong>第三步：考虑初始化条件</strong><br>和上面最长子序列相似，这个题目的初始化状态就是一个一维的全为1的数组。</p></li><li><p><strong>第四步：考虑输出状态</strong><br>与上题相似，这个问题输出条件也是求dp数组中最大的数。</p></li><li><p><strong>第五步：考虑是否可以优化</strong><br>这个题目只需要一次遍历就能求出连续的序列，所以在时间上已经没有可以优化的余地了，空间上来看的话也是一维数组，并没有优化余地。</p></li></ul><p>综上所述，可以很容易得到最后的代码：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">findLengthOfLCIS</span><span class="hljs-params">(self, nums: List[int])</span> -&gt; int:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>  <span class="hljs-comment">#判断边界条件</span>        dp=[<span class="hljs-number">1</span>]*len(nums)      <span class="hljs-comment">#初始化dp数组状态</span>        <span class="hljs-comment">#注意需要得到前一个数，所以从1开始遍历，否则会超出范围</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,len(nums)):         <span class="hljs-keyword">if</span> nums[i]&gt;nums[i<span class="hljs-number">-1</span>]:<span class="hljs-comment">#根据题目所求得到状态转移方程</span>                    dp[i]=dp[i<span class="hljs-number">-1</span>]+<span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>:                    dp[i]=<span class="hljs-number">1</span>        <span class="hljs-keyword">return</span> max(dp)  <span class="hljs-comment">#确定输出状态</span></code></pre><p><strong>总结: 通过这个题目和例题的比较，我们需要理清子序列和子数组（连续序列）的差别，前者明显比后者要复杂一点，因为前者是不连续的序列，后者是连续的序列，从复杂度来看也很清楚能看到即使穷举子序列也比穷举子数组要复杂很多。</strong></p><p>承接上面的话题，我们接下来继续来看一个子序列问题，这次是另外一种涉及二维状态的题目。</p><h3 id="Leetcode5-最长回文子串"><a href="#Leetcode5-最长回文子串" class="headerlink" title="Leetcode5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">Leetcode5. 最长回文子串</a></h3><h4 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</p><pre><code class="hljs 1c">示例 <span class="hljs-number">1</span>：输入: <span class="hljs-string">"babad"</span>输出: <span class="hljs-string">"bab"</span>注意: <span class="hljs-string">"aba"</span> 也是一个有效答案。</code></pre><ul><li><p><strong>第一步：确定动态规划状态</strong><br>与上面两题不同的是，这个题目必须用二维的dp数组来记录状态，主要原因就是子串有回文的限制。用两个指针来记录子串的位置可以很好的实现子串的回文要求，又因为最后结果需要返回的是子串，这里不同于之前题目的用dp保存长度，我们必须找到具体哪个部分符合回文子串的要求。这里插一句，其实也有求回文子串长度的题目<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">Leetcode516. 最长回文子序列</a>,如果有兴趣可以看一下。这里我们定义<code>dp[i][j]</code>表示子串s从i到j是否为回文子串。</p></li><li><p><strong>第二步：写出状态转移方程</strong><br>首先我们需要知道符合回文的条件：</p><ul><li><p>字符串首尾两个字符必须相等，否则肯定不是回文。</p></li><li><p>当字符串首尾两个字符相等时：如果子串是回文，整体就是回文，这里就有了动态规划的思想，出现了子问题；相反，如果子串不是回文，那么整体肯定不是。<br>对于字符串<code>s,s[i,j]</code>的子串是<code>s[i+1,j-1]</code>，如果子串只有本身或者空串，那肯定是回文子串了，所以我们讨论的状态转移方程不是对于<code>j-1-(i+1)+1&lt;2</code>的情况(整理得<code>j-i&lt;3</code>)，当<code>s[i]</code>和<code>s[j]</code>相等并且<code>j-i&lt;3</code>时，我们可以直接得出<code>dp[i][j]</code>是True。</p><p>综上所述，可以得到状态转移方程</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> s[i]==s[j]:<span class="hljs-keyword">if</span> j-i&lt;<span class="hljs-number">3</span>:dp[i][j]=<span class="hljs-literal">True</span><span class="hljs-keyword">else</span>:dp[i][j]=dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]</code></pre></li></ul></li></ul><ul><li><p><strong>第三步：考虑初始化条件</strong><br>我们需要建立一个二维的初始状态是False的来保存状态的数组来表示dp，又因为考虑只有一个字符的时候肯定是回文串，所以dp表格的对角线<code>dp[i][i]</code>肯定是True。</p></li><li><p><strong>第四步：考虑输出状态</strong><br>这里dp表示的是从<code>i</code>到<code>j</code>是否是回文子串，这样一来就告诉我们子串的起始位置和结束位置，但是由于我们需要找到最长的子串，所以我们优化一下可以只记录起始位置和当前长度（当然你要是喜欢记录终止位置和当前长度也是没问题的）</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> dp[i][j]: <span class="hljs-comment">#只要dp[i][j]成立就表示是回文子串，然后我们记录位置，返回有效答案</span>    cur_len=j-i+<span class="hljs-number">1</span>    <span class="hljs-keyword">if</span> cur_len&gt;max_len:    max_len=cur_len    start=i</code></pre></li><li><p><strong>第五步：考虑对时间，空间复杂度的优化</strong><br>对于这个问题，时间和空间都可以进一步优化，对于空间方面的优化：这里采用一种叫中心扩散的方法来进行，而对于时间方面的优化，则是用了Manacher‘s Algorithm（马拉车算法）来进行优化。具体的实现可以参考<a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">动态规划、Manacher 算法</a></p><p>这里给出比较容易理解的经典方法的代码：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(self, s: str)</span> -&gt; str:</span>       length=len(s)       <span class="hljs-keyword">if</span> length&lt;<span class="hljs-number">2</span>:  <span class="hljs-comment">#判断边界条件</span>           <span class="hljs-keyword">return</span> s       dp=[[<span class="hljs-literal">False</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(length)]<span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(length)] <span class="hljs-comment">#定义dp状态矩阵</span>       <span class="hljs-comment">#定义初试状态，这步其实可以省略</span>       <span class="hljs-comment"># for i in range(length):</span>       <span class="hljs-comment">#     dp[i][i]=True</span>              max_len=<span class="hljs-number">1</span>       start=<span class="hljs-number">0</span> <span class="hljs-comment">#后续记录回文串初试位置</span>       <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,length):           <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(j):               <span class="hljs-comment">#矩阵中逐个遍历</span>               <span class="hljs-keyword">if</span> s[i]==s[j]:                   <span class="hljs-keyword">if</span> j-i&lt;<span class="hljs-number">3</span>:                       dp[i][j]=<span class="hljs-literal">True</span>                   <span class="hljs-keyword">else</span>:                       dp[i][j]=dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]               <span class="hljs-keyword">if</span> dp[i][j]: <span class="hljs-comment">#记录位置，返回有效答案</span>                   cur_len=j-i+<span class="hljs-number">1</span>                   <span class="hljs-keyword">if</span> cur_len&gt;max_len:                       max_len=cur_len                       start=i       <span class="hljs-keyword">return</span> s[start:start+max_len]</code></pre></li></ul><p><strong>总结：这个是一个二维dp的经典题目，需要注意的就是定义dp数组的状态是什么，这里不用长度作为dp值而用是否是回文子串这个状态来存储也是一个比较巧妙的方法，使得题目变得容易理解。</strong></p><p>看了这么多套路相信你也对动态规划有点感觉了，这里再介绍一个求长度的子序列问题。</p><h3 id="Leetcode516-最长回文子序列"><a href="#Leetcode516-最长回文子序列" class="headerlink" title="Leetcode516. 最长回文子序列"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">Leetcode516. 最长回文子序列</a></h3><h4 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h4><p>给定一个字符串s，找到其中最长的回文子序列。可以假设s的最大长度为1000。</p><pre><code class="hljs makefile">示例 1:<span class="hljs-section">输入:</span><span class="hljs-string">"bbbab"</span><span class="hljs-section">输出:</span>4</code></pre><h4 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个问题和上面的例题也非常相似，直接套用动态规划套路也可以很快解决出来：</p><ul><li><p><strong>第一步：确定动态规划状态</strong><br>这里求的是最长子串的长度，所以我们可以直接定义一个二维的<code>dp[i][j]</code>来表示字符串第<code>i</code>个字符到第<code>j</code>个字符的长度，子问题也就是每个子回文字符串的长度。</p></li><li><p><strong>第二步：写出状态转移方程</strong><br>我们先来具体分析一下整个题目状态转移的规律。对于<code>d[i][j]</code>,我们根据上题的分析依然可以看出，<br>当<code>s[i]</code>和<code>s[j]</code>相等时，<code>s[i+1...j-1]</code>这个字符串加上2就是最长回文子序列；<br>当<code>s[i]</code>和<code>s[j]</code>不相等时，就说明可能只有其中一个出现在s[i,j]的最长回文子序列中，我们只需要取<code>s[i-1,j-1]</code>加上<code>s[i]</code>或者<code>s[j]</code>的数值中较大的；<br>综上所述，状态转移方程也就可以写成：</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> s[i]==s[j]:     dp[i][j]= dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span><span class="hljs-keyword">else</span>: dp[i][j]=max(dp[i][j<span class="hljs-number">-1</span>],dp[i+<span class="hljs-number">1</span>][j])</code></pre><p>但是问题来了，具体我们应该怎么求每个状态的值呢？这里介绍一种利用状态转移表法写出状态转移方程，我们通过把<code>dp[i][j]</code>的状态转移直接画成一张二维表格，我们所要做的也就是往这张表中填充所有的状态，进而得到我们想要的结果。如下图：</p></li></ul><p><img src="https://img-blog.csdnimg.cn/2020040820484089.png" srcset="/img/loading.gif" alt></p><p>  我们用字符串为”<strong>cbbd</strong>“作为输入来举例子，每次遍历就是求出右上角那些红色的值，通过上面的图我们会发现，按照一般的习惯都会先计算第一行的数值，但是当我们计算<code>dp[0,2]</code>的时候，我们会需要<code>dp[1,2]</code>，按照这个逻辑，我们就可以很容易发现遍历从下往上遍历会很方便计算。</p><ul><li><p><strong>第三步：考虑初始化条件</strong><br>很明显看出来的当只有一个字符的时候，最长回文子序列就是1，所以可以得到<code>dp[i][j]=1(i=j)</code><br>接下来我们来看看<br>当<code>i&gt;j</code>时，不符合题目要求，不存在子序列，所以直接初始化为0。<br>当<code>i&lt;j</code>时，每次计算表中对应的值就会根据前一个状态的值来计算。</p></li><li><p><strong>第四步：考虑输出状态</strong></p><p>我们想要求最长子序列的时候，我们可以直接看出来<code>dp[0][-1]</code>是最大的值，直接返回这个值就是最后的答案。</p></li><li><p><strong>第五步：考虑对时间，空间复杂度的优化</strong><br>对于这个题目，同样可以考虑空间复杂度的优化，因为我们在计算<code>dp[i][j]</code>的时候，只用到左边和下边。如果改为用一维数组存储，那么左边和下边的信息也需要存在数组里，所以我们可以考虑在每次变化前用临时变量<code>tmp</code>记录会发生变化的左下边信息。所以状态转移方程就变成了：</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> s[i] == s[j]:    tmp, dp[j] = dp[j], tmp + <span class="hljs-number">2</span><span class="hljs-keyword">else</span>:    dp[j] =max(dp[j],dp[j<span class="hljs-number">-1</span>])</code></pre><p>这里给出基本版的实现代码，如果需要优化后的可以看<a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence/solution/dong-tai-gui-hua-jiang-wei-kong-jian-ya-suo-te-shu/" target="_blank" rel="noopener">空间压缩优化解法</a></p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(self, s: str)</span> -&gt; int:</span>        n=len(s)        dp=[[<span class="hljs-number">0</span>]*n <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n)]  <span class="hljs-comment">#定义动态规划状态转移矩阵</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):  <span class="hljs-comment">#   初始化对角线，单个字符子序列就是1</span>            dp[i][i]=<span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n,<span class="hljs-number">-1</span>,<span class="hljs-number">-1</span>):  <span class="hljs-comment">#从右下角开始往上遍历</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i+<span class="hljs-number">1</span>,n):                <span class="hljs-keyword">if</span> s[i]==s[j]:   <span class="hljs-comment">#当两个字符相等时，直接子字符串加2</span>                    dp[i][j]= dp[i+<span class="hljs-number">1</span>][j<span class="hljs-number">-1</span>]+<span class="hljs-number">2</span>                  <span class="hljs-keyword">else</span>:           <span class="hljs-comment">#不相等时，取某边最长的字符</span>                    dp[i][j]=max(dp[i][j<span class="hljs-number">-1</span>],dp[i+<span class="hljs-number">1</span>][j])        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][<span class="hljs-number">-1</span>]   <span class="hljs-comment">#返回右上角位置的状态就是最长</span></code></pre></li></ul><p><strong>总结：对于二维的数组的动态规划，采用了画状态转移表的方法来得到输出的状态，这种方法更加直观能看出状态转移的具体过程，同时也不容易出错。当然具体选择哪种方法则需要根据具体题目来确定，如果状态转移方程比较复杂的利用这种方法就能简化很多。</strong></p><p><strong>模板总结：</strong></p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)):    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n):    <span class="hljs-keyword">if</span> s[i]==s[j]:            dp[i][j]=dp[i][j]+...        <span class="hljs-keyword">else</span>:        dp[i][j]=最值(...)</code></pre><p>当然，动态规划除了解决子序列问题，也可以用来解决其他实际的问题，比如之前提到过的各种AI的经典算法，接下来我们来看一道动态规划的高频面试题，也是实际开发中很常用的。</p><h3 id="Leetcode72-编辑距离"><a href="#Leetcode72-编辑距离" class="headerlink" title="Leetcode72. 编辑距离"></a><a href="https://leetcode-cn.com/problems/edit-distance/" target="_blank" rel="noopener">Leetcode72. 编辑距离</a></h3><p>给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。</p><h4 id="题目描述-4"><a href="#题目描述-4" class="headerlink" title="题目描述"></a>题目描述</h4><pre><code class="hljs python">你可以对一个单词进行如下三种操作：插入一个字符删除一个字符替换一个字符示例 <span class="hljs-number">1</span>:输入: word1 = <span class="hljs-string">"horse"</span>, word2 = <span class="hljs-string">"ros"</span>输出: <span class="hljs-number">3</span>解释: horse -&gt; rorse (将 'h' 替换为 'r')rorse -&gt; rose (删除 'r')rose -&gt; ros (删除 'e')</code></pre><h4 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><strong>第一步：确定动态规划状态</strong></li></ul><p>这个题目涉及到两个字符串，所以我们最先想到就是用两维数组来保存转移状态，定义<code>dp[i][j]</code>为字符串word1长度为<code>i</code>和字符串word2长度为<code>j</code>时，word1转化成word2所执行的最少操作次数的值。</p><ul><li><p><strong>第二步：写出状态转移方程</strong></p><p>关于这个问题的状态转移方程其实很难想到，这里提供的一个方向就是试着举个例子，然后通过例子的变化记录每一步变化得到的最少次数，来找到删除，插入，替换操作的状态转移方程具体应该怎么写。<br>我们采用从末尾开始遍历<code>word1</code>和<code>word2</code>，<br>当<code>word1[i]</code>等于<code>word2[j]</code>时，说明两者完全一样，所以<code>i</code>和<code>j</code>指针可以任何操作都不做，用状态转移式子表示就是<code>dp[i][j]=dp[i-1][j-1]</code>，也就是前一个状态和当前状态是一样的。<br>当<code>word1[i]</code>和<code>word2[j]</code>不相等时，就需要对三个操作进行递归了，这里就需要仔细思考状态转移方程的写法了。<br>对于<strong>插入</strong>操作，当我们在word1中插入一个和word2一样的字符，那么word2就被匹配了，所以可以直接表示为<code>dp[i][j-1]+1</code><br>对于<strong>删除</strong>操作，直接表示为<code>dp[i-1][j]+1</code><br>对于<strong>替换</strong>操作，直接表示为<code>dp[i-1][j-1]+1</code><br>所以状态转移方程可以写成<code>min(dp[i][j-1]+1,dp[i-1][j]+1,dp[i-1][j-1]+1)​</code></p></li><li><p><strong>第三步：考虑初始化条件</strong><br>我们还是利用dp转移表法来找到状态转移的变化（读者可以自行画一张dp表，具体方法在求最长子序列中已经演示过了），这里我们用空字符串来额外加入到word1和word2中，这样的目的是方便记录每一步操作，例如如果其中一个是空字符串，那么另外一个字符至少的操作数都是1，就从1开始计数操作数，以后每一步都执行插入操作，也就是当<code>i=0</code>时，<code>dp[0][j]=j</code>,同理可得，如果另外一个是空字符串，则对当前字符串执行删除操作就可以了，也就是<code>dp[i][0]=i​</code>。</p></li><li><p><strong>第四步：考虑输出状态</strong><br>在转移表中我们可以看到，可以从左上角一直遍历到左下角的值，所以最终的编辑距离就是最后一个状态的值，对应的就是<code>dp[-1][-1]​</code>。</p></li><li><p><strong>第五步：考虑对时间，空间复杂度的优化</strong><br>和上题一样，这里由于<code>dp[i][j]</code>只和dp表中附近的三个状态（左边，右边和左上边）有关，所以同样可以进行压缩状态转移的空间存储，如果觉得有兴趣可以参考<a href="https://leetcode-cn.com/u/lyncien/" target="_blank" rel="noopener">@Lyncien</a>的解法,对于时间方面应该并没有可以优化的方法。</p></li></ul><p>总结起来代码如下：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">minDistance</span><span class="hljs-params">(self, word1, word2)</span>:</span> <span class="hljs-comment">#m,n 表示两个字符串的长度</span> m=len(word1)  n=len(word2) <span class="hljs-comment">#构建二维数组来存储子问题</span> dp=[[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(m+<span class="hljs-number">1</span>)] <span class="hljs-comment">#考虑边界条件，第一行和第一列的条件</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n+<span class="hljs-number">1</span>):     dp[<span class="hljs-number">0</span>][i]=i  <span class="hljs-comment">#对于第一行，每次操作都是前一次操作基础上增加一个单位的操作</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(m+<span class="hljs-number">1</span>):     dp[j][<span class="hljs-number">0</span>]=j <span class="hljs-comment">#对于第一列也一样，所以应该是1,2,3,4,5...</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,m+<span class="hljs-number">1</span>):  <span class="hljs-comment">#对其他情况进行填充</span>     <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,n+<span class="hljs-number">1</span>):         <span class="hljs-keyword">if</span> word1[i<span class="hljs-number">-1</span>]==word2[j<span class="hljs-number">-1</span>]: <span class="hljs-comment">#当最后一个字符相等的时候，就不会产生任何操作代价，所以与dp[i-1][j-1]一样</span>             dp[i][j]=dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>]         <span class="hljs-keyword">else</span>:             dp[i][j]=min(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>])+<span class="hljs-number">1</span> <span class="hljs-comment">#分别对应删除，添加和替换操作</span> <span class="hljs-keyword">return</span> dp[<span class="hljs-number">-1</span>][<span class="hljs-number">-1</span>] <span class="hljs-comment">#返回最终状态就是所求最小的编辑距离</span></code></pre><p>如果上面的题目看起来还是有点吃力的话，接下我们来来看轻松一点的题目，下面的题目和斐波那契数列求解类似，既可用迭代也可用动态规划做。</p><h3 id="Leetcode198-打家劫舍"><a href="#Leetcode198-打家劫舍" class="headerlink" title="Leetcode198. 打家劫舍"></a><a href="https://leetcode-cn.com/problems/house-robber/" target="_blank" rel="noopener">Leetcode198. 打家劫舍</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><h4 id="题目描述-5"><a href="#题目描述-5" class="headerlink" title="题目描述"></a>题目描述</h4><pre><code class="hljs angelscript">给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。示例 <span class="hljs-number">1</span>:输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>]输出: <span class="hljs-number">4</span>解释: 偷窃 <span class="hljs-number">1</span> 号房屋 (金额 = <span class="hljs-number">1</span>) ，然后偷窃 <span class="hljs-number">3</span> 号房屋 (金额 = <span class="hljs-number">3</span>)。     偷窃到的最高金额 = <span class="hljs-number">1</span> + <span class="hljs-number">3</span> = <span class="hljs-number">4</span> 。</code></pre><h4 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h4><p>这个问题不复杂，其实利用一般的迭代可以直接解出来，但是这里讲动态规划，所以还是按照标准的套路来</p><ul><li><p><strong>第一步：确定动态规划状态</strong><br>直接定义题目所求的偷窃的最高金额，所以<code>dp[i]</code>表示偷窃第<code>i</code>号房子能得到的最高金额。</p></li><li><p><strong>第二步：写出状态转移方程</strong><br>如果我们不考虑限制条件相邻两个房子不能抢，那么问题就很简单。想得到第<code>i</code>个房间偷窃到的最高金额的时候，我们会考虑子问题前<code>i-1​</code>间的最高金额<code>dp[i-1]</code>，然后再加上当前房间的金额，所以最后可以表达为<code>dp[i]=dp[i-1]+nums[i]</code>。<br>需要注意的是，这里限制了相邻两个房子是不能抢的，接下来我们就要考虑两种情况。<br>如果抢了第i个房间，那么第<code>i-1​</code>肯定是不能抢的，这个时候需要再往前一间，用第<code>i-2</code>间的金额加上当前房间的金额，得到的状态转移方程是<code>dp[i]=dp[i-2]+nums[i]</code>。<br>如果没有抢第<code>i​</code>个房间，那么肯定抢了第<code>i-1</code>间的金额，所以直接有<code>dp[i]=dp[i-1]</code>。</p><p>最后综合一下两种情况，就可以很快得到状态转移方程：<code>dp[i]=max(dp[i-2]+nums[i],dp[i-1])​</code></p></li><li><p><strong>第三步：考虑初始化条件</strong><br>初始化条件需要考虑第一个房子和第二个房子，之后的房子都可以按照规律直接求解，当我们只有一个房子的时候，自然只抢那间房子，当有两间房的时候，就抢金额较大的那间。综合起来就是<code>dp[0]=nums[0]，dp[1]=max(nums[0],nums[1])​</code>。</p></li><li><p><strong>第四步:考虑输出状态</strong><br>直接返回状态转移数组的最后一个值就是所求的最大偷窃金额。</p></li><li><p><strong>第五步：考虑对时间，空间复杂度的优化</strong><br>时间复杂度为$O(N)$不能再优化了，空间复杂度方面如果用动态规划是不能优化，但是如果用迭代的方法只存储临时变量来记录每一步计算结果，这样可以降到$O(1)$。</p></li></ul><p>这里给出动态规划版本的实现代码：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span><span class="hljs-params">(self, nums)</span>:</span>   <span class="hljs-keyword">if</span>(<span class="hljs-keyword">not</span> nums):   <span class="hljs-comment">#特殊情况处理</span>       <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>   <span class="hljs-keyword">if</span> len(nums)==<span class="hljs-number">1</span>:       <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]   n=len(nums)   dp=[<span class="hljs-number">0</span>]*n    <span class="hljs-comment">#初始化状态转移数组</span>   dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>]  <span class="hljs-comment">#第一个边界值处理</span>   dp[<span class="hljs-number">1</span>]=max(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>])<span class="hljs-comment">#第二个边界值处理</span>   <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,n):       dp[i]=max(dp[i<span class="hljs-number">-2</span>]+nums[i],dp[i<span class="hljs-number">-1</span>]) <span class="hljs-comment">#状态转移方程</span>   <span class="hljs-keyword">return</span> dp[<span class="hljs-number">-1</span>]</code></pre><h3 id="Leetcode213-打家劫舍-II"><a href="#Leetcode213-打家劫舍-II" class="headerlink" title="Leetcode213. 打家劫舍 II"></a><a href="https://leetcode-cn.com/problems/house-robber-ii/" target="_blank" rel="noopener">Leetcode213. 打家劫舍 II</a></h3><p>你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><h4 id="题目描述-6"><a href="#题目描述-6" class="headerlink" title="题目描述"></a>题目描述</h4><pre><code class="hljs angelscript">给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。示例 <span class="hljs-number">1</span>:输入: [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>]输出: <span class="hljs-number">3</span>解释: 你不能先偷窃 <span class="hljs-number">1</span> 号房屋（金额 = <span class="hljs-number">2</span>），然后偷窃 <span class="hljs-number">3</span> 号房屋（金额 = <span class="hljs-number">2</span>）, 因为他们是相邻的。</code></pre><h4 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h4><ul><li><p><strong>第一步：确定动态规划状态</strong></p><p>直接定义题目所求的偷窃的最高金额，所以<code>dp[i]</code>表示偷窃第<code>i</code>号房子能得到的最高金额。</p></li><li><p><strong>第二步：写出状态转移方程</strong></p><p>和上个题目类似，这个题目不一样的是现在所有房屋都围成一个圈，相比于上个问题又增加了一个限制，这样一来第一个房子和最后一个房子只能选择其中一个偷窃了。所有我们把这个问题拆分成两个问题：</p><ul><li>偷窃了第一个房子，此时对应的是<code>nums[1:]</code>，得到最大的金额value是<code>v1</code>。</li><li>偷窃了最后一个房子，此时对应的是<code>nums[:n-1]</code>(其中n是所有房子的数量)，得到的最大金额value是<code>v2</code>。<br>最后的结果就是取这两种情况的最大值，即<code>max(v1,v2)</code>。</li></ul><p>每个子问题就和上题是一样的了，所以可以直接得到状态转移方程还是<code>dp[i]=max(dp[i-2]+nums[i],dp[i-1])</code></p></li><li><p><strong>第三步：考虑初始化条件</strong><br>初始化一个房子和两个房子的情况就是<code>dp[0]=nums[0]，dp[1]=max(nums[0],nums[1])</code>。</p></li><li><p><strong>第四步：考虑输出状态</strong><br>直接返回状态转移数组的最后一个值就是所求的最大偷窃金额。</p></li><li><p><strong>第五步：考虑对时间，空间复杂度的优化</strong></p></li></ul><p>时间复杂度为$O(N)$不能再优化了，空间复杂度方面如果用动态规划是不能优化，但是如果用迭代的方法只存储临时变量来记录每一步计算结果，这样可以降到$O(1)$。</p><p>最后的代码实现：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">rob</span><span class="hljs-params">(self, nums: List[int])</span> -&gt; int:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>        <span class="hljs-keyword">elif</span> len(nums)&lt;=<span class="hljs-number">2</span>:            <span class="hljs-keyword">return</span> max(nums)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">helper</span><span class="hljs-params">(nums)</span>:</span>            <span class="hljs-keyword">if</span> len(nums)&lt;=<span class="hljs-number">2</span>:                <span class="hljs-keyword">return</span> max(nums)            dp=[<span class="hljs-number">0</span>]*len(nums)            dp[<span class="hljs-number">0</span>]=nums[<span class="hljs-number">0</span>]            dp[<span class="hljs-number">1</span>]=max(nums[<span class="hljs-number">0</span>],nums[<span class="hljs-number">1</span>])            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>,len(nums)):                dp[i]=max(dp[i<span class="hljs-number">-1</span>],dp[i<span class="hljs-number">-2</span>]+nums[i])            <span class="hljs-keyword">return</span> dp[<span class="hljs-number">-1</span>]        <span class="hljs-keyword">return</span> max(helper(nums[<span class="hljs-number">1</span>:]),helper(nums[:<span class="hljs-number">-1</span>]))</code></pre><h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>动态规划是算法中比较难的类型，但是其实主要是掌握一种思维，有了这种思维，其实很难的问题都能一步一步解决好。最后再推荐一些比较优质的动态规划文章。</p><p><a href="https://www.jiqizhixin.com/articles/2019-09-29-5" target="_blank" rel="noopener">掌握动态规划，助你成为优秀的算法工程师</a></p><p>推荐MIT的动态规划练习资料，这份资料通过动态规划经典的问题让我们很清晰的了解到这个算法的魅力所在，对于新手入门动态规划是一个很不错的资料。<a href="https://people.cs.clemson.edu/~bcdean/dp_practice/" target="_blank" rel="noopener">Dynamic Programming Practice Problems</a></p><p>五分钟学算法的动态规划系列:<br><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247485288&amp;idx=1&amp;sn=fd043fc723f38bcaecc90d9945981f8a&amp;chksm=fa0e68e9cd79e1ffd965205bb06b1731539bf2e0bbc5991664f5d1d9721b346ec08c85bb9042&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">浅谈什么是动态规划以及相关的「股票」算法题</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247486904&amp;idx=1&amp;sn=099d5560ab25c0163349dff0c7f51490&amp;chksm=fa0e6239cd79eb2fe6e831d7debba60aa906721d592b8766a944ef88bf91bf82568c20d71891&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">有了四步解题法模板，再也不害怕动态规划!</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzUyNjQxNjYyMg==&amp;mid=2247486923&amp;idx=2&amp;sn=6c1c8aeb4db68522e67ddf8c1e933660&amp;chksm=fa0e624acd79eb5cdb410808921609a830b9b9221e813e4eb89cf551ca48f317668d44b095d2&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">（进阶版）有了四步解题法模板，再也不害怕动态规划！</a></p><p>主要参考的Leetcode 优秀题解：<br><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-she-ji-fang-fa-zhi-pai-you-xi-jia/" target="_blank" rel="noopener">动态规划设计方法&amp;&amp;纸牌游戏讲解二分解法</a><br><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zhong-xin-kuo-san-dong-tai-gui-hua-by-liweiwei1419/" target="_blank" rel="noopener">动态规划、Manacher 算法</a><br><a href="https://leetcode-cn.com/problems/edit-distance/solution/bian-ji-ju-chi-mian-shi-ti-xiang-jie-by-labuladong/" target="_blank" rel="noopener">编辑距离面试题详解</a><br><a href="https://leetcode-cn.com/problems/house-robber-ii/solution/213-da-jia-jie-she-iidong-tai-gui-hua-jie-gou-hua-/" target="_blank" rel="noopener">打家劫舍 II（动态规划，结构化思路，清晰题解）</a></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动手学数据分析-2</title>
    <link href="/article/dc948b2c.html"/>
    <url>/article/dc948b2c.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>动手学数据分析-1</title>
    <link href="/article/459dda96.html"/>
    <url>/article/459dda96.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-数据载入及观察"><a href="#1-数据载入及观察" class="headerlink" title="1. 数据载入及观察"></a>1. 数据载入及观察</h2><p>在数据处理中，第一步通常都需要导入数据，并进行对数据的初步预览</p><ol><li><strong>导入库</strong> 导入所需数据库:import numpy as np; import pandas as pd</li><li><strong>载入数据</strong> pd.read_csv(‘filename’), csv为文件格式，可替换为其他格式：tsv;xlsx</li><li><strong>逐块读取</strong> 有时数据库过大，为了节约内存需要分批次读取：pd.read_csv(‘filename’, chunksize=int)</li><li><strong>修改column索引名称</strong> pd.read_csv(‘names=[‘a’,‘b’,…],index_col=‘乘客ID’,header=0)</li><li><strong>初步观察</strong> 前(n+1)个数据：head(n),后（n+1)个数据tail(n), 判断数据是否为空isnull()</li><li><strong>保存数据</strong> to_csv(‘filename’)</li></ol><h2 id="2-pandas基础"><a href="#2-pandas基础" class="headerlink" title="2. pandas基础"></a>2. pandas基础</h2><ol><li><strong>数据类型</strong> pandas中有两个数据类型DataFrame, Series; Series比较适合一个属性对应一个数据， DataFrame则适用于一个实例具有多种属性，很符合数据挖掘所需要的数据模式</li><li><strong>查看DataFrame数据的每列的项</strong> 根据数据的列索引可以很容易实现 data[‘Column_name’]</li><li><strong>将多余的列的删除</strong> del data[‘Column_name’]</li><li><strong>将某些列暂时隐藏</strong> data.drop([‘Columb_name’],axis=1)<br>若想完全删除 data.drop([‘Columb_name’]，axis=1, inplace = True)</li><li><strong>显示满足某条件的数据</strong><br>criteria = data[‘Column_name’]&gt; x<br>此时criteria所含元素数据类型皆为bool<br>显示满足条件的数据(bool=True): Desired = data[criteria]</li></ol><p>但此时index为old index, 若想得到此数据集某一行的值，需要重新设置index: Desird.reset_index(drop=True); drop=True将old index隐藏<br>\6. <strong>显示数据集中某行某列的值</strong> data.loc[[index_x,index_y, index_z…],[’Column_x‘,‘Columb_name_y’…]]</p><p>也可以都用索引值 函数：iloc<br>midage.iloc[[100,105,108],[2,3,4]]</p><h2 id="3-探索性数据分析"><a href="#3-探索性数据分析" class="headerlink" title="3. 探索性数据分析"></a>3. 探索性数据分析</h2><ol><li><strong>对数据值进行排序</strong> 一组数据DataFrame.sort_<strong>values</strong>(by=‘column_name’, ascending=False)<br>默认 ascending = True 升序， False 降序<br>两组数据排序(先对第一个排序)<br>DataFrame.sort_<strong>values</strong>(by=[‘column_name1’,‘column_name2’], ascending=False)</li><li><strong>索引排序</strong> 行索引升序排序：DataFrame.sort_<strong>index</strong>()<br>列索引升序排序 DataFrame.sort_<strong>index</strong>(axis = 1)</li><li><strong>算术计算</strong>两个DataFrame运算后，会返回一个新的DataFrame，对应的行和列的值会相加，没有对应的会变成空值NaN</li><li><strong>查看DataFrame数据信息</strong><br>函数：DataFrame.describe()<br>输出:<br>count : 样本数据大小<br>mean : 样本数据的平均值<br>std : 样本数据的标准差<br>min : 样本数据的最小值<br>25% : 样本数据25%的时候的值<br>50% : 样本数据50%的时候的值<br>75% : 样本数据75%的时候的值<br>max : 样本数据的最大值</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法-分治</title>
    <link href="/article/1768cd4c.html"/>
    <url>/article/1768cd4c.html</url>
    
    <content type="html"><![CDATA[<h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>分治算法的主要思想是将原问题<strong>递归地分成</strong>若干个子问题，直到子问题<strong>满足边界条件</strong>，停止递归。将子问题逐个击破(一般是同种方法)，将已经解决的子问题合并，最后，算法会<strong>层层合并</strong>得到原问题的答案。</p><h3 id="分治算法的步骤"><a href="#分治算法的步骤" class="headerlink" title="分治算法的步骤"></a>分治算法的步骤</h3><ul><li>分：<strong>递归地</strong>将问题<strong>分解</strong>为各个的子<strong>问题</strong>(性质相同的、相互独立的子问题)；</li><li>治：将这些规模更小的子问题<strong>逐个击破</strong>；</li><li>合：将已解决的子问题<strong>逐层合并</strong>，最终得出原问题的解；</li></ul><p><img src="https://img-blog.csdnimg.cn/20200408204450701.png" srcset="/img/loading.gif" alt></p><h3 id="分治法适用的情况"><a href="#分治法适用的情况" class="headerlink" title="分治法适用的情况"></a>分治法适用的情况</h3><ul><li>原问题的<strong>计算复杂度</strong>随着问题的规模的增加而增加。</li><li>原问题<strong>能够被分解</strong>成更小的子问题。</li><li>子问题的<strong>结构和性质</strong>与原问题一样，并且<strong>相互独立</strong>，子问题之间<strong>不包含</strong>公共的子子问题。</li><li>原问题分解出的子问题的解<strong>可以合并</strong>为该问题的解。</li></ul><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">divide_conquer</span><span class="hljs-params">(problem, paraml, param2,...)</span>:</span>    <span class="hljs-comment"># 不断切分的终止条件</span>    <span class="hljs-keyword">if</span> problem <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        print_result        <span class="hljs-keyword">return</span>    <span class="hljs-comment"># 准备数据</span>    data=prepare_data(problem)    <span class="hljs-comment"># 将大问题拆分为小问题</span>    subproblems=split_problem(problem, data)    <span class="hljs-comment"># 处理小问题，得到子结果</span>    subresult1=self.divide_conquer(subproblems[<span class="hljs-number">0</span>],p1,..…)    subresult2=self.divide_conquer(subproblems[<span class="hljs-number">1</span>],p1,...)    subresult3=self.divide_conquer(subproblems[<span class="hljs-number">2</span>],p1,.…)    <span class="hljs-comment"># 对子结果进行合并 得到最终结果</span>    result=process_result(subresult1, subresult2, subresult3,...)</code></pre><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>​        通过应用举例分析理解分治算法的原理其实并不难，但是要想灵活应用并在编程中体现这种思想中却并不容易。所以，这里这里用分治算法应用在排序的时候的一个栗子，加深对分治算法的理解。</p><p>相关概念：</p><ul><li><strong>有序度</strong>：表示一组数据的有序程度</li><li><strong>逆序度</strong>：表示一组数据的无序程度</li></ul><p>一般通过<strong>计算有序对或者逆序对的个数</strong>，来表示数据的有序度或逆序度。</p><p>假设我们有 <code>n</code> 个数据，我们期望数据从小到大排列，那完全有序的数据的有序度就是 $n(n-1)/2$，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 $n(n-1)/2$。</p><p><strong>Q：如何编程求出一组数据的有序对个数或者逆序对个数呢？</strong></p><p>因为有序对个数和逆序对个数的求解方式是类似的，所以这里可以只思考逆序对（常接触的）个数的求解方法。</p><ul><li>方法1<ul><li>拿数组里的每个数字跟它后面的数字比较，看有几个比它小的。</li><li>把比它小的数字个数记作 <code>k</code>，通过这样的方式，把每个数字都考察一遍之后，然后对每个数字对应的 <code>k</code> 值求和</li><li>最后得到的总和就是逆序对个数。</li><li>这样操作的时间复杂度是$O(n^2)$（需要两层循环过滤）。那有没有更加高效的处理方法呢？这里尝试套用分治的思想来求数组 A 的逆序对个数。</li></ul></li><li>方法2<ul><li>首先将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2</li><li>然后再计算 A1 与 A2 之间的逆序对个数 K3。那数组 A 的逆序对个数就等于 K1+K2+K3。</li><li>注意使用分治算法其中一个要求是，<strong>子问题合并的代价不能太大</strong>，否则就起不了降低时间复杂度的效果了。</li><li><strong>如何快速计算出两个子问题 A1 与 A2 之间的逆序对个数呢？这里就要借助归并排序算法了。（这里先回顾一下归并排序思想）</strong>如何借助归并排序算法来解决呢？归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。实际上，在这个合并的过程中，可以计算这两个小数组的逆序对个数了。每次合并操作，我们都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了。</li></ul></li></ul><h3 id="算法应用"><a href="#算法应用" class="headerlink" title="算法应用"></a>算法应用</h3><h4 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode-cn.com/problems/majority-element/" target="_blank" rel="noopener">169. 多数元素</a></h4><ul><li><p>题目描述</p><p>给定一个大小为 n 的数组，找到其中的众数。众数是指在数组中出现次数大于 [n/2] 的元素。</p><p>你可以假设数组是非空的，并且给定的数组总是存在众数。</p><p>示例 1:</p><pre><code class="hljs python">输入: [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]输出: <span class="hljs-number">3</span></code></pre><p>示例 2:</p><pre><code class="hljs python">输入: [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]输出: <span class="hljs-number">2</span></code></pre></li><li><p>解题思路</p><ul><li><p>确定切分的终止条件</p><p>直到所有的子问题都是长度为 1 的数组，停止切分。</p></li><li><p>准备数据，将大问题切分为小问题</p><p>递归地将原数组二分为左区间与右区间，直到最终的数组只剩下一个元素，将其返回</p></li><li><p>处理子问题得到子结果，并合并</p><ul><li><p>长度为 1 的子数组中唯一的数显然是众数，直接返回即可。</p></li><li><p>如果它们的众数相同，那么显然这一段区间的众数是它们相同的值。</p></li><li><p>如果他们的众数不同，比较两个众数在整个区间内出现的次数来决定该区间的众数</p></li></ul></li></ul></li><li><p>代码</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majorityElement2</span><span class="hljs-params">(self, nums)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type nums: List[int]</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># 【不断切分的终止条件】</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> nums:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>        <span class="hljs-keyword">if</span> len(nums) == <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]        <span class="hljs-comment"># 【准备数据，并将大问题拆分为小问题】</span>        left = self.majorityElement(nums[:len(nums)//<span class="hljs-number">2</span>])        right = self.majorityElement(nums[len(nums)//<span class="hljs-number">2</span>:])        <span class="hljs-comment"># 【处理子问题，得到子结果】</span>        <span class="hljs-comment"># 【对子结果进行合并 得到最终结果】</span>        <span class="hljs-keyword">if</span> left == right:            <span class="hljs-keyword">return</span> left        <span class="hljs-keyword">if</span> nums.count(left) &gt; nums.count(right):            <span class="hljs-keyword">return</span> left        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> right</code></pre></li></ul><h4 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a><a href="https://leetcode-cn.com/problems/maximum-subarray/" target="_blank" rel="noopener">53. 最大子序和</a></h4><ul><li><p>题目描述</p><p>给定一个整数数组 <code>nums</code> ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</p><p>示例:</p><pre><code class="hljs angelscript">输入: [<span class="hljs-number">-2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-5</span>,<span class="hljs-number">4</span>],输出: <span class="hljs-number">6</span>解释: 连续子数组 [<span class="hljs-number">4</span>,<span class="hljs-number">-1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] 的和最大为<span class="hljs-number">6</span>。</code></pre></li><li><p>解题思路</p></li><li><p><img src="/article/1768cd4c/image-20200819190726688.png" srcset="/img/loading.gif" alt="image-20200819190726688"></p></li><li><p>```python<br>from typing import List<br>class Solution:<br>  def maxSubArray(self, nums: List[int]) -&gt; int:</p><pre><code>    ans = nums[0]  pre=0    for x in nums:      pre = max(pre+x, x)        ans = max(ans, pre)      print(pre, ans)    return ans</code></pre><pre><code class="hljs python">  * **方法二：分治**  * 确定切分的终止条件    直到所有的子问题都是长度为 <span class="hljs-number">1</span> 的数组，停止切分。  * 准备数据，将大问题切分为小问题    递归地将原数组二分为左区间与右区间，直到最终的数组只剩下一个元素，将其返回  * 处理子问题得到子结果，并合并    - 将数组切分为左右区间      - 对与左区间：从右到左计算左边的最大子序和      - 对与右区间：从左到右计算右边的最大子序和    - 由于左右区间计算累加和的方向不一致，因此，左右区间直接合并相加之后就是整个区间的和    - 最终返回左区间的元素、右区间的元素、以及整个区间(相对子问题)和的最大值* 代码  ```python  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>      <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxSubArray</span><span class="hljs-params">(self, nums)</span>:</span>          <span class="hljs-string">"""</span><span class="hljs-string">          :type nums: List[int]</span><span class="hljs-string">          :rtype: int</span><span class="hljs-string">          """</span>          <span class="hljs-comment"># 【确定不断切分的终止条件】</span>          n = len(nums)          <span class="hljs-keyword">if</span> n == <span class="hljs-number">1</span>:              <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>]            <span class="hljs-comment"># 【准备数据，并将大问题拆分为小的问题】</span>          left = self.maxSubArray(nums[:len(nums)//<span class="hljs-number">2</span>])          right = self.maxSubArray(nums[len(nums)//<span class="hljs-number">2</span>:])            <span class="hljs-comment"># 【处理小问题，得到子结果】</span>          <span class="hljs-comment">#　从右到左计算左边的最大子序和</span>          max_l = nums[len(nums)//<span class="hljs-number">2</span> <span class="hljs-number">-1</span>] <span class="hljs-comment"># max_l为该数组的最右边的元素</span>          tmp = <span class="hljs-number">0</span> <span class="hljs-comment"># tmp用来记录连续子数组的和</span>                    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range( len(nums)//<span class="hljs-number">2</span><span class="hljs-number">-1</span> , <span class="hljs-number">-1</span> , <span class="hljs-number">-1</span> ):<span class="hljs-comment"># 从右到左遍历数组的元素</span>              tmp += nums[i]              max_l = max(tmp ,max_l)                        <span class="hljs-comment"># 从左到右计算右边的最大子序和</span>          max_r = nums[len(nums)//<span class="hljs-number">2</span>]          tmp = <span class="hljs-number">0</span>          <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(nums)//<span class="hljs-number">2</span>,len(nums)):              tmp += nums[i]              max_r = max(tmp,max_r)                        <span class="hljs-comment"># 【对子结果进行合并 得到最终结果】</span>          <span class="hljs-comment"># 返回三个中的最大值</span>          <span class="hljs-keyword">return</span> max(left,right,max_l+ max_r)</code></pre></li></ul><h4 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50. Pow(x, n)"></a><a href="https://leetcode-cn.com/problems/powx-n/" target="_blank" rel="noopener">50. Pow(x, n)</a></h4><ul><li><p>题目描述</p><p>实现 <code>pow(x, n)</code>，即计算 <code>x</code> 的 <code>n</code> 次幂函数。</p><p>示例 1:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">2.00000</span>, <span class="hljs-number">10</span>输出: <span class="hljs-number">1024.00000</span></code></pre><p>示例 2:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">2.10000</span>, <span class="hljs-number">3</span>输出: <span class="hljs-number">9.26100</span></code></pre><p>示例 3:</p><pre><code class="hljs angelscript">输入: <span class="hljs-number">2.00000</span>, <span class="hljs-number">-2</span>输出: <span class="hljs-number">0.25000</span>解释: <span class="hljs-number">2</span><span class="hljs-number">-2</span> = <span class="hljs-number">1</span>/<span class="hljs-number">22</span> = <span class="hljs-number">1</span>/<span class="hljs-number">4</span> = <span class="hljs-number">0.25</span></code></pre><p>说明:</p><p><code>-100.0 &lt; x &lt; 100.0</code><br><code>n</code>是 32 位有符号整数，其数值范围是$[−2^{31}, 2^{31} − 1] $。</p></li><li><p>解题思路</p><ul><li><p>确定切分的终止条件</p><p>对<code>n</code>不断除以2，并更新<code>n</code>，直到为0，终止切分</p></li><li><p>准备数据，将大问题切分为小问题</p><p>对<code>n</code>不断除以2，更新</p></li><li><p>处理子问题得到子结果，并合并</p><ul><li><code>x</code>与自身相乘更新<code>x</code></li><li>如果<code>n%2 ==1</code><ul><li>将<code>p</code>乘以<code>x</code>之后赋值给<code>p</code>(初始值为1)，返回<code>p</code></li></ul></li></ul></li><li><p>最终返回<code>p</code></p></li></ul></li><li><p>代码</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type x: float</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: float</span><span class="hljs-string">        """</span>        <span class="hljs-comment"># 处理n为负的情况</span>        <span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">0</span> :            x = <span class="hljs-number">1</span>/x            n = -n        <span class="hljs-comment"># 【确定不断切分的终止条件】</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span> :            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>        <span class="hljs-comment"># 【准备数据，并将大问题拆分为小的问题】</span>        <span class="hljs-keyword">if</span> n%<span class="hljs-number">2</span> ==<span class="hljs-number">1</span>:          <span class="hljs-comment"># 【处理小问题，得到子结果】</span>          p = x * self.myPow(x,n<span class="hljs-number">-1</span>)<span class="hljs-comment"># 【对子结果进行合并 得到最终结果】</span>          <span class="hljs-keyword">return</span> p        <span class="hljs-keyword">return</span> self.myPow(x*x,n/<span class="hljs-number">2</span>)</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python06-字典、集合和序列</title>
    <link href="/article/8b342fda.html"/>
    <url>/article/8b342fda.html</url>
    
    <content type="html"><![CDATA[<h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><h2 id="1-可变类型与不可变类型"><a href="#1-可变类型与不可变类型" class="headerlink" title="1. 可变类型与不可变类型"></a>1. 可变类型与不可变类型</h2><ul><li>序列是以连续的整数为索引，与此不同的是，字典以”关键字”为索引，关键字可以是任意不可变类型，通常用字符串或数值。</li><li>字典是 Python 唯一的一个 <u>映射类型</u>，字符串、元组、列表属于<u>序列类型</u>。</li></ul><p>那么如何快速判断一个数据类型 <code>X</code> 是不是可变类型的呢？两种方法：</p><ul><li>麻烦方法：用 <code>id(X)</code> 函数，对 X 进行某种操作，比较操作前后的 <code>id</code>，如果不一样，则 <code>X</code> 不可变，如果一样，则 <code>X</code> 可变。</li><li>便捷方法：用 <code>hash(X)</code>，只要不报错，证明 <code>X</code> 可被哈希，即不可变，反过来不可被哈希，即可变。</li></ul><pre><code class="hljs python">i = <span class="hljs-number">1</span>print(id(i))  <span class="hljs-comment"># 140732167000896</span>i = i + <span class="hljs-number">2</span>print(id(i))  <span class="hljs-comment"># 140732167000960</span>l = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]print(id(l))  <span class="hljs-comment"># 4300825160</span>l.append(<span class="hljs-string">'Python'</span>)print(id(l))  <span class="hljs-comment"># 4300825160</span></code></pre><ul><li>整数 <code>i</code> 在加 1 之后的 <code>id</code> 和之前不一样，因此加完之后的这个 <code>i</code> (虽然名字没变)，但不是加之前的那个 <code>i</code> 了，因此整数是不可变类型。</li><li>列表 <code>l</code> 在附加 <code>&#39;Python&#39;</code> 之后的 <code>id</code> 和之前一样，因此列表是可变类型。</li></ul><pre><code class="hljs python">print(hash(<span class="hljs-string">'Name'</span>))  <span class="hljs-comment"># -9215951442099718823</span>print(hash((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'Python'</span>)))  <span class="hljs-comment"># 823362308207799471</span>print(hash([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'Python'</span>]))<span class="hljs-comment"># TypeError: unhashable type: 'list'</span>print(hash(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;))<span class="hljs-comment"># TypeError: unhashable type: 'set'</span></code></pre><ul><li>数值、字符和元组 都能被哈希，因此它们是不可变类型。</li><li>列表、集合、字典不能被哈希，因此它是可变类型。</li></ul><h2 id="2-字典的定义"><a href="#2-字典的定义" class="headerlink" title="2. 字典的定义"></a>2. 字典的定义</h2><p>字典 是无序的 键:值（<code>key:value</code>）对集合，键必须是互不相同的（在同一个字典之内）。</p><ul><li><code>dict</code> 内部存放的顺序和 <code>key</code> 放入的顺序是没有关系的。</li><li><code>dict</code> 查找和插入的速度极快，不会随着 <code>key</code> 的增加而增加，但是需要占用大量的内存。</li></ul><p>字典 定义语法为 <code>{元素1, 元素2, ..., 元素n}</code></p><ul><li>其中每一个元素是一个「键值对」— 键:值 (<code>key:value</code>)</li><li>关键点是「大括号 {}」,「逗号 ,」和「冒号 :」</li><li>大括号 — 把所有元素绑在一起</li><li>逗号 — 将每个键值对分开</li><li>冒号 — 将键和值分开</li></ul><h2 id="3-创建和访问字典"><a href="#3-创建和访问字典" class="headerlink" title="3. 创建和访问字典"></a>3. 创建和访问字典</h2><p>【例子】</p><pre><code class="hljs python">brand = [<span class="hljs-string">'李宁'</span>, <span class="hljs-string">'耐克'</span>, <span class="hljs-string">'阿迪达斯'</span>]slogan = [<span class="hljs-string">'一切皆有可能'</span>, <span class="hljs-string">'Just do it'</span>, <span class="hljs-string">'Impossible is nothing'</span>]print(<span class="hljs-string">'耐克的口号是:'</span>, slogan[brand.index(<span class="hljs-string">'耐克'</span>)])  <span class="hljs-comment"># 耐克的口号是: Just do it</span>dic = &#123;<span class="hljs-string">'李宁'</span>: <span class="hljs-string">'一切皆有可能'</span>, <span class="hljs-string">'耐克'</span>: <span class="hljs-string">'Just do it'</span>, <span class="hljs-string">'阿迪达斯'</span>: <span class="hljs-string">'Impossible is nothing'</span>&#125;print(<span class="hljs-string">'耐克的口号是:'</span>, dic[<span class="hljs-string">'耐克'</span>])  <span class="hljs-comment"># 耐克的口号是: Just do it</span></code></pre><p>通过字符串或数值作为<code>key</code>来创建字典。</p><p>注意：如果我们取的键在字典中不存在，会直接报错<code>KeyError</code>。</p><p>【例子】</p><pre><code class="hljs python">dic1 = &#123;<span class="hljs-number">1</span>: <span class="hljs-string">'one'</span>, <span class="hljs-number">2</span>: <span class="hljs-string">'two'</span>, <span class="hljs-number">3</span>: <span class="hljs-string">'three'</span>&#125;print(dic1)  <span class="hljs-comment"># &#123;1: 'one', 2: 'two', 3: 'three'&#125;</span>print(dic1[<span class="hljs-number">1</span>])  <span class="hljs-comment"># one</span>print(dic1[<span class="hljs-number">4</span>])  <span class="hljs-comment"># KeyError: 4</span>dic2 = &#123;<span class="hljs-string">'rice'</span>: <span class="hljs-number">35</span>, <span class="hljs-string">'wheat'</span>: <span class="hljs-number">101</span>, <span class="hljs-string">'corn'</span>: <span class="hljs-number">67</span>&#125;print(dic2)  <span class="hljs-comment"># &#123;'wheat': 101, 'corn': 67, 'rice': 35&#125;</span>print(dic2[<span class="hljs-string">'rice'</span>])  <span class="hljs-comment"># 35</span></code></pre><p>【例子】通过元组作为<code>key</code>来创建字典，但一般不这样使用。</p><pre><code class="hljs python">dic = &#123;(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>): <span class="hljs-string">"Tom"</span>, <span class="hljs-string">"Age"</span>: <span class="hljs-number">12</span>, <span class="hljs-number">3</span>: [<span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>]&#125;print(dic)  <span class="hljs-comment"># &#123;(1, 2, 3): 'Tom', 'Age': 12, 3: [3, 5, 7]&#125;</span>print(type(dic))  <span class="hljs-comment"># &lt;class 'dict'&gt;</span></code></pre><p>通过构造函数<code>dict</code>来创建字典。</p><ul><li><code>dict()</code> -&gt; 创建一个空的字典。</li></ul><p>【例子】通过<code>key</code>直接把数据放入字典中，但一个<code>key</code>只能对应一个<code>value</code>，多次对一个<code>key</code>放入 <code>value</code>，后面的值会把前面的值冲掉。</p><pre><code class="hljs python">dic = dict()dic[<span class="hljs-string">'a'</span>] = <span class="hljs-number">1</span>dic[<span class="hljs-string">'b'</span>] = <span class="hljs-number">2</span>dic[<span class="hljs-string">'c'</span>] = <span class="hljs-number">3</span>print(dic)<span class="hljs-comment"># &#123;'a': 1, 'b': 2, 'c': 3&#125;</span>dic[<span class="hljs-string">'a'</span>] = <span class="hljs-number">11</span>print(dic)<span class="hljs-comment"># &#123;'a': 11, 'b': 2, 'c': 3&#125;</span>dic[<span class="hljs-string">'d'</span>] = <span class="hljs-number">4</span>print(dic)<span class="hljs-comment"># &#123;'a': 11, 'b': 2, 'c': 3, 'd': 4&#125;</span></code></pre><ul><li><code>dict(mapping)</code> -&gt; new dictionary initialized from a mapping object’s (key, value) pairs</li></ul><p>【例子】</p><pre><code class="hljs python">dic1 = dict([(<span class="hljs-string">'apple'</span>, <span class="hljs-number">4139</span>), (<span class="hljs-string">'peach'</span>, <span class="hljs-number">4127</span>), (<span class="hljs-string">'cherry'</span>, <span class="hljs-number">4098</span>)])print(dic1)  <span class="hljs-comment"># &#123;'cherry': 4098, 'apple': 4139, 'peach': 4127&#125;</span>dic2 = dict(((<span class="hljs-string">'apple'</span>, <span class="hljs-number">4139</span>), (<span class="hljs-string">'peach'</span>, <span class="hljs-number">4127</span>), (<span class="hljs-string">'cherry'</span>, <span class="hljs-number">4098</span>)))print(dic2)  <span class="hljs-comment"># &#123;'peach': 4127, 'cherry': 4098, 'apple': 4139&#125;</span></code></pre><ul><li><code>dict(**kwargs)</code> -&gt; new dictionary initialized with the name=value pairs in the keyword argument list.  For example:  dict(one=1, two=2)</li></ul><p>【例子】这种情况下，键只能为字符串类型，并且创建的时候字符串不能加引号，加上就会直接报语法错误。</p><pre><code class="hljs python">dic = dict(name=<span class="hljs-string">'Tom'</span>, age=<span class="hljs-number">10</span>)print(dic)  <span class="hljs-comment"># &#123;'name': 'Tom', 'age': 10&#125;</span>print(type(dic))  <span class="hljs-comment"># &lt;class 'dict'&gt;</span></code></pre><h2 id="4-字典的内置方法"><a href="#4-字典的内置方法" class="headerlink" title="4. 字典的内置方法"></a>4. 字典的内置方法</h2><ul><li><code>dict.fromkeys(seq[, value])</code> 用于创建一个新字典，以序列 <code>seq</code> 中元素做字典的键，<code>value</code> 为字典所有键对应的初始值。</li></ul><p>【例子】</p><pre><code class="hljs python">seq = (<span class="hljs-string">'name'</span>, <span class="hljs-string">'age'</span>, <span class="hljs-string">'sex'</span>)dic1 = dict.fromkeys(seq)print(<span class="hljs-string">"新的字典为 : %s"</span> % str(dic1))  <span class="hljs-comment"># 新的字典为 : &#123;'name': None, 'age': None, 'sex': None&#125;</span>dic2 = dict.fromkeys(seq, <span class="hljs-number">10</span>)print(<span class="hljs-string">"新的字典为 : %s"</span> % str(dic2))  <span class="hljs-comment"># 新的字典为 : &#123;'name': 10, 'age': 10, 'sex': 10&#125;</span>dic3 = dict.fromkeys(seq, (<span class="hljs-string">'小马'</span>, <span class="hljs-string">'8'</span>, <span class="hljs-string">'男'</span>))print(<span class="hljs-string">"新的字典为 : %s"</span> % str(dic3))  <span class="hljs-comment"># 新的字典为 : &#123;'name': ('小马', '8', '男'), 'age': ('小马', '8', '男'), 'sex': ('小马', '8', '男')&#125;</span></code></pre><ul><li><code>dict.keys()</code>返回一个可迭代对象，可以使用 <code>list()</code> 来转换为列表，列表为字典中的所有键。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;print(dic.keys())  <span class="hljs-comment"># dict_keys(['Name', 'Age'])</span>lst = list(dic.keys())  <span class="hljs-comment"># 转换为列表</span>print(lst)  <span class="hljs-comment"># ['Name', 'Age']</span></code></pre><ul><li><code>dict.values()</code>返回一个迭代器，可以使用 <code>list()</code> 来转换为列表，列表为字典中的所有值。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Sex'</span>: <span class="hljs-string">'female'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>, <span class="hljs-string">'Name'</span>: <span class="hljs-string">'Zara'</span>&#125;print(<span class="hljs-string">"字典所有值为 : "</span>, list(dic.values()))  <span class="hljs-comment"># 字典所有值为 :  [7, 'female', 'Zara']</span></code></pre><ul><li><code>dict.items()</code>以列表返回可遍历的 (键, 值) 元组数组。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;print(<span class="hljs-string">"Value : %s"</span> % dic.items())  <span class="hljs-comment"># Value : dict_items([('Name', 'Lsgogroup'), ('Age', 7)])</span>print(tuple(dic.items()))  <span class="hljs-comment"># (('Name', 'Lsgogroup'), ('Age', 7))</span></code></pre><ul><li><code>dict.get(key, default=None)</code>返回指定键的值，如果值不在字典中返回默认值。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">27</span>&#125;print(<span class="hljs-string">"Age 值为 : %s"</span> % dic.get(<span class="hljs-string">'Age'</span>))  <span class="hljs-comment"># Age 值为 : 27</span>print(<span class="hljs-string">"Sex 值为 : %s"</span> % dic.get(<span class="hljs-string">'Sex'</span>, <span class="hljs-string">"NA"</span>))  <span class="hljs-comment"># Sex 值为 : NA</span></code></pre><ul><li><code>dict.setdefault(key, default=None)</code>和<code>get()</code>方法 类似, 如果键不存在于字典中，将会添加键并将值设为默认值。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;print(<span class="hljs-string">"Age 键的值为 : %s"</span> % dic.setdefault(<span class="hljs-string">'Age'</span>, <span class="hljs-literal">None</span>))  <span class="hljs-comment"># Age 键的值为 : 7</span>print(<span class="hljs-string">"Sex 键的值为 : %s"</span> % dic.setdefault(<span class="hljs-string">'Sex'</span>, <span class="hljs-literal">None</span>))  <span class="hljs-comment"># Sex 键的值为 : None</span>print(<span class="hljs-string">"新字典为："</span>, dic)  <span class="hljs-comment"># 新字典为： &#123;'Age': 7, 'Name': 'Lsgogroup', 'Sex': None&#125;</span></code></pre><ul><li><code>key in dict</code> <code>in</code> 操作符用于判断键是否存在于字典中，如果键在字典 dict 里返回<code>true</code>，否则返回<code>false</code>。而<code>not in</code>操作符刚好相反，如果键在字典 dict 里返回<code>false</code>，否则返回<code>true</code>。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;<span class="hljs-comment"># in 检测键 Age 是否存在</span><span class="hljs-keyword">if</span> <span class="hljs-string">'Age'</span> <span class="hljs-keyword">in</span> dic:    print(<span class="hljs-string">"键 Age 存在"</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"键 Age 不存在"</span>)<span class="hljs-comment"># 检测键 Sex 是否存在</span><span class="hljs-keyword">if</span> <span class="hljs-string">'Sex'</span> <span class="hljs-keyword">in</span> dic:    print(<span class="hljs-string">"键 Sex 存在"</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"键 Sex 不存在"</span>)<span class="hljs-comment"># not in 检测键 Age 是否存在</span><span class="hljs-keyword">if</span> <span class="hljs-string">'Age'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> dic:    print(<span class="hljs-string">"键 Age 不存在"</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"键 Age 存在"</span>)<span class="hljs-comment"># 键 Age 存在</span><span class="hljs-comment"># 键 Sex 不存在</span><span class="hljs-comment"># 键 Age 存在</span></code></pre><ul><li><code>dict.pop(key[,default])</code>删除字典给定键 <code>key</code> 所对应的值，返回值为被删除的值。<code>key</code> 值必须给出。若<code>key</code>不存在，则返回 <code>default</code> 值。</li><li><code>del dict[key]</code> 删除字典给定键 <code>key</code> 所对应的值。</li></ul><p>【例子】</p><pre><code class="hljs python">dic1 = &#123;<span class="hljs-number">1</span>: <span class="hljs-string">"a"</span>, <span class="hljs-number">2</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]&#125;print(dic1.pop(<span class="hljs-number">1</span>), dic1)  <span class="hljs-comment"># a &#123;2: [1, 2]&#125;</span><span class="hljs-comment"># 设置默认值，必须添加，否则报错</span>print(dic1.pop(<span class="hljs-number">3</span>, <span class="hljs-string">"nokey"</span>), dic1)  <span class="hljs-comment"># nokey &#123;2: [1, 2]&#125;</span><span class="hljs-keyword">del</span> dic1[<span class="hljs-number">2</span>]print(dic1)  <span class="hljs-comment"># &#123;&#125;</span></code></pre><ul><li><code>dict.popitem()</code>随机返回并删除字典中的一对键和值，如果字典已经为空，却调用了此方法，就报出KeyError异常。</li></ul><p>【例子】</p><pre><code class="hljs python">dic1 = &#123;<span class="hljs-number">1</span>: <span class="hljs-string">"a"</span>, <span class="hljs-number">2</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]&#125;print(dic1.popitem())  <span class="hljs-comment"># (1, 'a')</span>print(dic1)  <span class="hljs-comment"># &#123;2: [1, 2]&#125;</span></code></pre><ul><li><code>dict.clear()</code>用于删除字典内所有元素。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Zara'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;print(<span class="hljs-string">"字典长度 : %d"</span> % len(dic))  <span class="hljs-comment"># 字典长度 : 2</span>dict.clear()print(<span class="hljs-string">"字典删除后长度 : %d"</span> % len(dic))  <span class="hljs-comment"># 字典删除后长度 : 0</span></code></pre><ul><li><code>dict.copy()</code>返回一个字典的浅复制。</li></ul><p>【例子】</p><pre><code class="hljs python">dic1 = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>, <span class="hljs-string">'Class'</span>: <span class="hljs-string">'First'</span>&#125;dic2 = dic1.copy()print(<span class="hljs-string">"新复制的字典为 : "</span>, dic2)  <span class="hljs-comment"># 新复制的字典为 :  &#123;'Age': 7, 'Name': 'Lsgogroup', 'Class': 'First'&#125;</span></code></pre><p>【例子】直接赋值和 copy 的区别</p><pre><code class="hljs python">dic1 = &#123;<span class="hljs-string">'user'</span>: <span class="hljs-string">'lsgogroup'</span>, <span class="hljs-string">'num'</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]&#125;<span class="hljs-comment"># 引用对象</span>dic2 = dic1  <span class="hljs-comment"># 深拷贝父对象（一级目录），子对象（二级目录）不拷贝，还是引用</span>dic3 = dic1.copy()  print(id(dic1))  <span class="hljs-comment"># 148635574728</span>print(id(dic2))  <span class="hljs-comment"># 148635574728</span>print(id(dic3))  <span class="hljs-comment"># 148635574344</span><span class="hljs-comment"># 修改 data 数据</span>dic1[<span class="hljs-string">'user'</span>] = <span class="hljs-string">'root'</span>dic1[<span class="hljs-string">'num'</span>].remove(<span class="hljs-number">1</span>)<span class="hljs-comment"># 输出结果</span>print(dic1)  <span class="hljs-comment"># &#123;'user': 'root', 'num': [2, 3]&#125;</span>print(dic2)  <span class="hljs-comment"># &#123;'user': 'root', 'num': [2, 3]&#125;</span>print(dic3)  <span class="hljs-comment"># &#123;'user': 'runoob', 'num': [2, 3]&#125;</span></code></pre><ul><li><code>dict.update(dict2)</code>把字典参数 <code>dict2</code> 的 <code>key:value</code>对 更新到字典 <code>dict</code> 里。</li></ul><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'Name'</span>: <span class="hljs-string">'Lsgogroup'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">7</span>&#125;dic2 = &#123;<span class="hljs-string">'Sex'</span>: <span class="hljs-string">'female'</span>, <span class="hljs-string">'Age'</span>: <span class="hljs-number">8</span>&#125;dic.update(dic2)print(<span class="hljs-string">"更新字典 dict : "</span>, dic)  <span class="hljs-comment"># 更新字典 dict :  &#123;'Sex': 'female', 'Age': 8, 'Name': 'Lsgogroup'&#125;</span></code></pre><hr><p><strong>练习题</strong>：</p><p>1、字典基本操作</p><p>字典内容如下:</p><pre><code class="hljs python">dic = &#123;    <span class="hljs-string">'python'</span>: <span class="hljs-number">95</span>,    <span class="hljs-string">'java'</span>: <span class="hljs-number">99</span>,    <span class="hljs-string">'c'</span>: <span class="hljs-number">100</span>    &#125;</code></pre><p>用程序解答下面的题目</p><ul><li>字典的长度是多少</li><li>请修改’java’ 这个key对应的value值为98</li><li>删除 c 这个key</li><li>增加一个key-value对，key值为 php, value是90</li><li>获取所有的key值，存储在列表里</li><li>获取所有的value值，存储在列表里</li><li>判断 javascript 是否在字典中</li><li>获得字典里所有value 的和</li><li>获取字典里最大的value</li><li>获取字典里最小的value</li><li>字典 dic1 = {‘php’: 97}， 将dic1的数据更新到dic中</li></ul><p>2、字典中的value</p><p>有一个字典，保存的是学生各个编程语言的成绩，内容如下</p><pre><code class="hljs prolog">data = &#123;        <span class="hljs-string">'python'</span>: &#123;<span class="hljs-string">'上学期'</span>: <span class="hljs-string">'90'</span>, <span class="hljs-string">'下学期'</span>: <span class="hljs-string">'95'</span>&#125;,        <span class="hljs-string">'c++'</span>: [<span class="hljs-string">'95'</span>, <span class="hljs-string">'96'</span>, <span class="hljs-string">'97'</span>],        <span class="hljs-string">'java'</span>: [&#123;<span class="hljs-string">'月考'</span>:<span class="hljs-string">'90'</span>, <span class="hljs-string">'期中考试'</span>: <span class="hljs-string">'94'</span>, <span class="hljs-string">'期末考试'</span>: <span class="hljs-string">'98'</span>&#125;]        &#125;</code></pre><p>各门课程的考试成绩存储方式并不相同，有的用字典，有的用列表，但是分数都是字符串类型，请实现函数<code>transfer_score(score_dict)</code>，将分数修改成int类型</p><pre><code class="hljs python">   <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transfer_score</span><span class="hljs-params">(data)</span>:</span>    <span class="hljs-comment"># your code here</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python05-列表、字典和字符串</title>
    <link href="/article/a112c8e7.html"/>
    <url>/article/a112c8e7.html</url>
    
    <content type="html"><![CDATA[<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><p>简单数据类型</p><ul><li>整型<code>&lt;class &#39;int&#39;&gt;</code></li><li>浮点型<code>&lt;class &#39;float&#39;&gt;</code></li><li>布尔型<code>&lt;class &#39;bool&#39;&gt;</code></li></ul><p>容器数据类型</p><ul><li>列表<code>&lt;class &#39;list&#39;&gt;</code></li><li>元组<code>&lt;class &#39;tuple&#39;&gt;</code></li><li>字典<code>&lt;class &#39;dict&#39;&gt;</code></li><li>集合<code>&lt;class &#39;set&#39;&gt;</code></li><li>字符串<code>&lt;class &#39;str&#39;&gt;</code></li></ul><h2 id="1-列表的定义"><a href="#1-列表的定义" class="headerlink" title="1. 列表的定义"></a>1. 列表的定义</h2><p>列表是有序集合，没有固定大小，能够保存任意数量任意类型的 Python 对象，语法为 <code>[元素1, 元素2, ..., 元素n]</code>。</p><ul><li>关键点是「中括号 []」和「逗号 ,」</li><li>中括号 把所有元素绑在一起</li><li>逗号 将每个元素一一分开</li></ul><h2 id="2-列表的创建"><a href="#2-列表的创建" class="headerlink" title="2. 列表的创建"></a>2. 列表的创建</h2><ul><li>创建一个普通列表</li></ul><p>【例子】 </p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(x, type(x))<span class="hljs-comment"># ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'] &lt;class 'list'&gt;</span>x = [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]print(x, type(x))<span class="hljs-comment"># [2, 3, 4, 5, 6, 7] &lt;class 'list'&gt;</span></code></pre><ul><li>利用<code>range()</code>创建列表</li></ul><p>【例子】 </p><pre><code class="hljs python">x = list(range(<span class="hljs-number">10</span>))print(x, type(x))<span class="hljs-comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class 'list'&gt;</span>x = list(range(<span class="hljs-number">1</span>, <span class="hljs-number">11</span>, <span class="hljs-number">2</span>))print(x, type(x))<span class="hljs-comment"># [1, 3, 5, 7, 9] &lt;class 'list'&gt;</span>x = list(range(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-2</span>))print(x, type(x))<span class="hljs-comment"># [10, 8, 6, 4, 2] &lt;class 'list'&gt;</span></code></pre><ul><li>利用推导式创建列表</li></ul><p>【例子】 </p><pre><code class="hljs python">x = [<span class="hljs-number">0</span>] * <span class="hljs-number">5</span>print(x, type(x))<span class="hljs-comment"># [0, 0, 0, 0, 0] &lt;class 'list'&gt;</span>x = [<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>)]print(x, type(x))<span class="hljs-comment"># [0, 0, 0, 0, 0] &lt;class 'list'&gt;</span>x = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)]print(x, type(x))<span class="hljs-comment"># [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] &lt;class 'list'&gt;</span>x = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>)]print(x, type(x))<span class="hljs-comment"># [1, 3, 5, 7, 9] &lt;class 'list'&gt;</span>x = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-2</span>)]print(x, type(x))<span class="hljs-comment"># [10, 8, 6, 4, 2] &lt;class 'list'&gt;</span>x = [i ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)]print(x, type(x))<span class="hljs-comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81] &lt;class 'list'&gt;</span>x = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>) <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> (i % <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>]print(x, type(x))<span class="hljs-comment"># [3, 9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99] &lt;class 'list'&gt;</span></code></pre><ul><li>创建一个 4×3的二维数组</li></ul><p>【例子】</p><pre><code class="hljs python">x = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>], [<span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]]print(x, type(x))<span class="hljs-comment"># [[1, 2, 3], [4, 5, 6], [7, 8, 9], [0, 0, 0]] &lt;class 'list'&gt;</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> x:    print(i, type(i))<span class="hljs-comment"># [1, 2, 3] &lt;class 'list'&gt;</span><span class="hljs-comment"># [4, 5, 6] &lt;class 'list'&gt;</span><span class="hljs-comment"># [7, 8, 9] &lt;class 'list'&gt;</span><span class="hljs-comment"># [0, 0, 0] &lt;class 'list'&gt;</span>x = [[<span class="hljs-number">0</span> <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(<span class="hljs-number">3</span>)] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>)]print(x, type(x))<span class="hljs-comment"># [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span>x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>print(x, type(x))<span class="hljs-comment"># [[1, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span>x = [[<span class="hljs-number">0</span>] * <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> range(<span class="hljs-number">4</span>)]print(x, type(x))<span class="hljs-comment"># [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span>x[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>print(x, type(x))<span class="hljs-comment"># [[0, 0, 0], [0, 1, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span></code></pre><p>注意：</p><p>由于list的元素可以是任何对象，因此列表中所保存的是对象的指针。即使保存一个简单的<code>[1,2,3]</code>，也有3个指针和3个整数对象。</p><p><code>x = [a] * 4</code>操作中，只是创建4个指向list的引用，所以一旦<code>a</code>改变，<code>x</code>中4个<code>a</code>也会随之改变。</p><p>【例子】</p><pre><code class="hljs python">x = [[<span class="hljs-number">0</span>] * <span class="hljs-number">3</span>] * <span class="hljs-number">4</span>print(x, type(x))<span class="hljs-comment"># [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span>x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>print(x, type(x))<span class="hljs-comment"># [[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class 'list'&gt;</span>a = [<span class="hljs-number">0</span>] * <span class="hljs-number">3</span>x = [a] * <span class="hljs-number">4</span>print(x, type(x))<span class="hljs-comment"># [[0, 0, 0], [0, 0, 0], [0, 0, 0], [0, 0, 0]] &lt;class 'list'&gt;</span>x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>print(x, type(x))<span class="hljs-comment"># [[1, 0, 0], [1, 0, 0], [1, 0, 0], [1, 0, 0]] &lt;class 'list'&gt;</span></code></pre><ul><li>创建一个混合列表</li></ul><p>【例子】 </p><pre><code class="hljs python">mix = [<span class="hljs-number">1</span>, <span class="hljs-string">'lsgo'</span>, <span class="hljs-number">3.14</span>, [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]]print(mix)  <span class="hljs-comment"># [1, 'lsgo', 3.14, [1, 2, 3]]</span></code></pre><ul><li>创建一个空列表</li></ul><p>【例子】 </p><pre><code class="hljs python">empty = []print(empty)  <span class="hljs-comment"># []</span></code></pre><p>列表不像元组，列表内容可更改 (mutable)，因此附加 (<code>append</code>, <code>extend</code>)、插入 (<code>insert</code>)、删除 (<code>remove</code>, <code>pop</code>) 这些操作都可以用在它身上。</p><h2 id="3-向列表中添加元素"><a href="#3-向列表中添加元素" class="headerlink" title="3. 向列表中添加元素"></a>3. 向列表中添加元素</h2><ul><li><code>list.append(obj)</code> 在列表末尾添加新的对象，只接受一个参数，参数可以是任何数据类型，被追加的元素在 list 中保持着原结构类型。</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]x.append(<span class="hljs-string">'Thursday'</span>)print(x)  <span class="hljs-comment"># ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Thursday']</span>print(len(x))  <span class="hljs-comment"># 6</span></code></pre><p>此元素如果是一个 list，那么这个 list 将作为一个整体进行追加，注意<code>append()</code>和<code>extend()</code>的区别。</p><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]x.append([<span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Sunday'</span>])print(x)  <span class="hljs-comment"># ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', ['Thursday', 'Sunday']]</span>print(len(x))  <span class="hljs-comment"># 6</span></code></pre><ul><li><code>list.extend(seq)</code> 在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表）</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]x.extend([<span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Sunday'</span>])print(x)  <span class="hljs-comment"># ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Thursday', 'Sunday']</span>print(len(x))  <span class="hljs-comment"># 7</span></code></pre><p>严格来说 <code>append</code> 是追加，把一个东西整体添加在列表后，而 <code>extend</code> 是扩展，把一个东西里的所有元素添加在列表后。</p><ul><li><code>list.insert(index, obj)</code> 在编号 <code>index</code> 位置前插入 <code>obj</code>。</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]x.insert(<span class="hljs-number">2</span>, <span class="hljs-string">'Sunday'</span>)print(x)<span class="hljs-comment"># ['Monday', 'Tuesday', 'Sunday', 'Wednesday', 'Thursday', 'Friday']</span>print(len(x))  <span class="hljs-comment"># 6</span></code></pre><h2 id="4-删除列表中的元素"><a href="#4-删除列表中的元素" class="headerlink" title="4. 删除列表中的元素"></a>4. 删除列表中的元素</h2><ul><li><code>list.remove(obj)</code> 移除列表中某个值的第一个匹配项</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]x.remove(<span class="hljs-string">'Monday'</span>)print(x)  <span class="hljs-comment"># ['Tuesday', 'Wednesday', 'Thursday', 'Friday']</span></code></pre><ul><li><code>list.pop([index=-1])</code> 移除列表中的一个元素（默认最后一个元素），并且返回该元素的值</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]y = x.pop()print(y)  <span class="hljs-comment"># Friday</span>y = x.pop(<span class="hljs-number">0</span>)print(y)  <span class="hljs-comment"># Monday</span>y = x.pop(<span class="hljs-number">-2</span>)print(y)  <span class="hljs-comment"># Wednesday</span>print(x)  <span class="hljs-comment"># ['Tuesday', 'Thursday']</span></code></pre><p><code>remove</code> 和 <code>pop</code> 都可以删除元素，前者是指定具体要删除的元素，后者是指定一个索引。</p><ul><li><code>del var1[, var2 ……]</code> 删除单个或多个对象。</li></ul><p>【例子】</p><p>如果知道要删除的元素在列表中的位置，可使用<code>del</code>语句。</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]<span class="hljs-keyword">del</span> x[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>]print(x)  <span class="hljs-comment"># ['Wednesday', 'Thursday', 'Friday']</span></code></pre><p>如果你要从列表中删除一个元素，且不再以任何方式使用它，就使用<code>del</code>语句；如果你要在删除元素后还能继续使用它，就使用方法<code>pop()</code>。</p><h2 id="5-获取列表中的元素"><a href="#5-获取列表中的元素" class="headerlink" title="5. 获取列表中的元素"></a>5. 获取列表中的元素</h2><ul><li>通过元素的索引值，从列表获取单个元素，注意，列表索引值是从0开始的。</li><li>通过将索引指定为-1，可让Python返回最后一个列表元素，索引 -2 返回倒数第二个列表元素，以此类推。</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(x[<span class="hljs-number">0</span>], type(x[<span class="hljs-number">0</span>]))  <span class="hljs-comment"># Monday &lt;class 'str'&gt;</span>print(x[<span class="hljs-number">-1</span>], type(x[<span class="hljs-number">-1</span>]))  <span class="hljs-comment"># Friday &lt;class 'str'&gt;</span>print(x[<span class="hljs-number">-2</span>], type(x[<span class="hljs-number">-2</span>]))  <span class="hljs-comment"># Thursday &lt;class 'str'&gt;</span></code></pre><p>切片的通用写法是 <code>start : stop : step</code></p><ul><li>情况 1 - “start :” </li><li>以 <code>step</code> 为 1 (默认) 从编号 <code>start</code> 往列表尾部切片。</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(x[<span class="hljs-number">3</span>:])  <span class="hljs-comment"># ['Thursday', 'Friday']</span>print(x[<span class="hljs-number">-3</span>:])  <span class="hljs-comment"># ['Wednesday', 'Thursday', 'Friday']</span></code></pre><ul><li>情况 2 - “: stop”</li><li>以 <code>step</code> 为 1 (默认) 从列表头部往编号 <code>stop</code> 切片。</li></ul><p>【例子】</p><pre><code class="hljs python">week = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(week[:<span class="hljs-number">3</span>])  <span class="hljs-comment"># ['Monday', 'Tuesday', 'Wednesday']</span>print(week[:<span class="hljs-number">-3</span>])  <span class="hljs-comment"># ['Monday', 'Tuesday']</span></code></pre><ul><li>情况 3 - “start : stop”</li><li>以 <code>step</code> 为 1 (默认) 从编号 <code>start</code> 往编号 <code>stop</code> 切片。</li></ul><p>【例子】</p><pre><code class="hljs python">week = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(week[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>])  <span class="hljs-comment"># ['Tuesday', 'Wednesday']</span>print(week[<span class="hljs-number">-3</span>:<span class="hljs-number">-1</span>])  <span class="hljs-comment"># ['Wednesday', 'Thursday']</span></code></pre><ul><li>情况 4 - “start : stop : step”</li><li>以具体的 <code>step</code> 从编号 <code>start</code> 往编号 <code>stop</code> 切片。注意最后把 <code>step</code> 设为 -1，相当于将列表反向排列。</li></ul><p>【例子】</p><pre><code class="hljs python">week = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(week[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>])  <span class="hljs-comment"># ['Tuesday', 'Thursday']</span>print(week[:<span class="hljs-number">4</span>:<span class="hljs-number">2</span>])  <span class="hljs-comment"># ['Monday', 'Wednesday']</span>print(week[<span class="hljs-number">1</span>::<span class="hljs-number">2</span>])  <span class="hljs-comment"># ['Tuesday', 'Thursday']</span>print(week[::<span class="hljs-number">-1</span>])  <span class="hljs-comment"># ['Friday', 'Thursday', 'Wednesday', 'Tuesday', 'Monday']</span></code></pre><ul><li>情况 5 - “ : “</li><li>复制列表中的所有元素（浅拷贝）。</li></ul><p>【例子】</p><pre><code class="hljs python">week = [<span class="hljs-string">'Monday'</span>, <span class="hljs-string">'Tuesday'</span>, <span class="hljs-string">'Wednesday'</span>, <span class="hljs-string">'Thursday'</span>, <span class="hljs-string">'Friday'</span>]print(week[:])  <span class="hljs-comment"># week的拷贝 ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday']</span>list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-number">789</span>, <span class="hljs-number">213</span>]list2 = list1list3 = list1[:]print(list2)  <span class="hljs-comment"># [123, 456, 789, 213]</span>print(list3)  <span class="hljs-comment"># [123, 456, 789, 213]</span>list1.sort()print(list2)  <span class="hljs-comment"># [123, 213, 456, 789] </span>print(list3)  <span class="hljs-comment"># [123, 456, 789, 213]</span>list1 = [[<span class="hljs-number">123</span>, <span class="hljs-number">456</span>], [<span class="hljs-number">789</span>, <span class="hljs-number">213</span>]]list2 = list1list3 = list1[:]print(list2)  <span class="hljs-comment"># [[123, 456], [789, 213]]</span>print(list3)  <span class="hljs-comment"># [[123, 456], [789, 213]]</span>list1[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">111</span>print(list2)  <span class="hljs-comment"># [[111, 456], [789, 213]]</span>print(list3)  <span class="hljs-comment"># [[111, 456], [789, 213]]</span></code></pre><h2 id="6-列表的常用操作符"><a href="#6-列表的常用操作符" class="headerlink" title="6. 列表的常用操作符"></a>6. 列表的常用操作符</h2><ul><li>等号操作符：<code>==</code></li><li>连接操作符 <code>+</code></li><li>重复操作符 <code>*</code></li><li>成员关系操作符 <code>in</code>、<code>not in</code></li></ul><p>「等号 ==」，只有成员、成员位置都相同时才返回True。</p><p>和元组拼接一样， 列表拼接也有两种方式，用「加号 +」和「乘号 *」，前者首尾拼接，后者复制拼接。</p><p>【例子】</p><pre><code class="hljs Python">list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>]list2 = [<span class="hljs-number">456</span>, <span class="hljs-number">123</span>]list3 = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>]print(list1 == list2)  <span class="hljs-comment"># False</span>print(list1 == list3)  <span class="hljs-comment"># True</span>list4 = list1 + list2  <span class="hljs-comment"># extend()</span>print(list4)  <span class="hljs-comment"># [123, 456, 456, 123]</span>list5 = list3 * <span class="hljs-number">3</span>print(list5)  <span class="hljs-comment"># [123, 456, 123, 456, 123, 456]</span>list3 *= <span class="hljs-number">3</span>print(list3)  <span class="hljs-comment"># [123, 456, 123, 456, 123, 456]</span>print(<span class="hljs-number">123</span> <span class="hljs-keyword">in</span> list3)  <span class="hljs-comment"># True</span>print(<span class="hljs-number">456</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> list3)  <span class="hljs-comment"># False</span></code></pre><p>前面三种方法（<code>append</code>, <code>extend</code>, <code>insert</code>）可对列表增加元素，它们没有返回值，是直接修改了原数据对象。<br>将两个list相加，需要创建新的 list 对象，从而需要消耗额外的内存，特别是当 list 较大时，尽量不要使用 “+” 来添加list。</p><h2 id="7-列表的其它方法"><a href="#7-列表的其它方法" class="headerlink" title="7. 列表的其它方法"></a>7. 列表的其它方法</h2><p><code>list.count(obj)</code> 统计某个元素在列表中出现的次数</p><p>【例子】</p><pre><code class="hljs python">list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>] * <span class="hljs-number">3</span>print(list1)  <span class="hljs-comment"># [123, 456, 123, 456, 123, 456]</span>num = list1.count(<span class="hljs-number">123</span>)print(num)  <span class="hljs-comment"># 3</span></code></pre><p><code>list.index(x[, start[, end]])</code> 从列表中找出某个值第一个匹配项的索引位置</p><p>【例子】</p><pre><code class="hljs python">list1 = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>] * <span class="hljs-number">5</span>print(list1.index(<span class="hljs-number">123</span>))  <span class="hljs-comment"># 0</span>print(list1.index(<span class="hljs-number">123</span>, <span class="hljs-number">1</span>))  <span class="hljs-comment"># 2</span>print(list1.index(<span class="hljs-number">123</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>))  <span class="hljs-comment"># 4</span></code></pre><p><code>list.reverse()</code> 反向列表中元素</p><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-number">789</span>]x.reverse()print(x)  <span class="hljs-comment"># [789, 456, 123]</span></code></pre><p><code>list.sort(key=None, reverse=False)</code> 对原列表进行排序。</p><ul><li><code>key</code> — 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li><code>reverse</code> — 排序规则，<code>reverse = True</code> 降序， <code>reverse = False</code> 升序（默认）。</li><li>该方法没有返回值，但是会对列表的对象进行排序。</li></ul><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-number">789</span>, <span class="hljs-number">213</span>]x.sort()print(x)<span class="hljs-comment"># [123, 213, 456, 789]</span>x.sort(reverse=<span class="hljs-literal">True</span>)print(x)<span class="hljs-comment"># [789, 456, 213, 123]</span><span class="hljs-comment"># 获取列表的第二个元素</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">takeSecond</span><span class="hljs-params">(elem)</span>:</span>    <span class="hljs-keyword">return</span> elem[<span class="hljs-number">1</span>]x = [(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">4</span>), (<span class="hljs-number">4</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)]x.sort(key=takeSecond)print(x)<span class="hljs-comment"># [(4, 1), (2, 2), (1, 3), (3, 4)]</span>x.sort(key=<span class="hljs-keyword">lambda</span> a: a[<span class="hljs-number">0</span>])print(x)<span class="hljs-comment"># [(1, 3), (2, 2), (3, 4), (4, 1)]</span></code></pre><hr><p><strong>参考文献</strong>：</p><ul><li><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-tutorial.html</a></li><li><a href="https://www.bilibili.com/video/av4050443" target="_blank" rel="noopener">https://www.bilibili.com/video/av4050443</a></li><li><a href="https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ</a></li></ul><hr><p><strong>练习题</strong>：</p><p>1、列表操作练习</p><p>列表lst 内容如下</p><p>lst = [2, 5, 6, 7, 8, 9, 2, 9, 9]</p><p>请写程序完成下列操作：</p><ol><li>在列表的末尾增加元素15</li><li>在列表的中间位置插入元素20</li><li>将列表[2, 5, 6]合并到lst中</li><li>移除列表中索引为3的元素</li><li>翻转列表里的所有元素</li><li>对列表里的元素进行排序，从小到大一次，从大到小一次</li></ol><p>2、修改列表</p><p>问题描述：</p><p>lst = [1, [4, 6], True]</p><p>请将列表里所有数字修改成原来的两倍</p><p>3、leetcode 852题 山脉数组的峰顶索引</p><p>如果一个数组k符合下面两个属性，则称之为山脉数组</p><p>数组的长度大于等于3</p><p>存在$i$，$i$ &gt;0 且$i&lt;\operatorname{len}(k)-1$， 使得<script type="math/tex">\mathrm{k}[0]<\mathrm{k}[1]<\ldots<\mathrm{k}[\mathrm{i}-1]<\mathrm{k}[\mathrm{j}]>\mathrm{k}[\mathrm{i}+1] \ldots>\mathrm{k}[\operatorname{len}(\mathrm{k})-1]</script></p><p>这个$i$就是顶峰索引。</p><p>现在，给定一个山脉数组，求顶峰索引。</p><p>示例:</p><p>输入：[1, 3, 4, 5, 3]</p><p>输出：True</p><p>输入：[1, 2, 4, 6, 4, 5]</p><p>输出：False</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">peakIndexInMountainArray</span><span class="hljs-params">(self, A: List[int])</span> -&gt; int:</span>           <span class="hljs-comment"># your code here</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python04-异常处理</title>
    <link href="/article/60fd2cd8.html"/>
    <url>/article/60fd2cd8.html</url>
    
    <content type="html"><![CDATA[<h1 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h1><p>异常就是运行期检测到的错误。计算机语言针对可能出现的错误定义了异常类型，某种错误引发对应的异常时，异常处理程序将被启动，从而恢复程序的正常运行。</p><h2 id="1-Python-标准异常总结"><a href="#1-Python-标准异常总结" class="headerlink" title="1. Python 标准异常总结"></a>1. Python 标准异常总结</h2><ul><li>BaseException：所有异常的 <strong>基类</strong></li><li>Exception：常规异常的 <strong>基类</strong></li><li>StandardError：所有的内建标准异常的基类</li><li>ArithmeticError：所有数值计算异常的基类</li><li>FloatingPointError：浮点计算异常</li><li><u>OverflowError</u>：数值运算超出最大限制</li><li><u>ZeroDivisionError</u>：除数为零</li><li><u>AssertionError</u>：断言语句（assert）失败</li><li><u>AttributeError</u>：尝试访问未知的对象属性</li><li>EOFError：没有内建输入，到达EOF标记</li><li>EnvironmentError：操作系统异常的基类</li><li>IOError：输入/输出操作失败</li><li><u>OSError</u>：操作系统产生的异常（例如打开一个不存在的文件）</li><li>WindowsError：系统调用失败</li><li><u>ImportError</u>：导入模块失败的时候</li><li>KeyboardInterrupt：用户中断执行</li><li>LookupError：无效数据查询的基类</li><li><u>IndexError</u>：索引超出序列的范围</li><li><u>KeyError</u>：字典中查找一个不存在的关键字</li><li><u>MemoryError</u>：内存溢出（可通过删除对象释放内存）</li><li><u>NameError</u>：尝试访问一个不存在的变量</li><li>UnboundLocalError：访问未初始化的本地变量</li><li>ReferenceError：弱引用试图访问已经垃圾回收了的对象</li><li>RuntimeError：一般的运行时异常</li><li>NotImplementedError：尚未实现的方法</li><li><u>SyntaxError</u>：语法错误导致的异常</li><li>IndentationError：缩进错误导致的异常</li><li>TabError：Tab和空格混用</li><li>SystemError：一般的解释器系统异常</li><li><u>TypeError</u>：不同类型间的无效操作</li><li><u>ValueError</u>：传入无效的参数</li><li>UnicodeError：Unicode相关的异常</li><li>UnicodeDecodeError：Unicode解码时的异常</li><li>UnicodeEncodeError：Unicode编码错误导致的异常</li><li>UnicodeTranslateError：Unicode转换错误导致的异常</li></ul><p>异常体系内部有层次关系，Python异常体系中的部分关系如下所示：</p><p><img src="https://img-blog.csdnimg.cn/20200710131404548.png" srcset="/img/loading.gif" alt></p><hr><h2 id="2-Python标准警告总结"><a href="#2-Python标准警告总结" class="headerlink" title="2. Python标准警告总结"></a>2. Python标准警告总结</h2><ul><li>Warning：警告的基类</li><li>DeprecationWarning：关于被弃用的特征的警告</li><li>FutureWarning：关于构造将来语义会有改变的警告</li><li>UserWarning：用户代码生成的警告</li><li>PendingDeprecationWarning：关于特性将会被废弃的警告</li><li>RuntimeWarning：可疑的运行时行为(runtime behavior)的警告</li><li>SyntaxWarning：可疑语法的警告</li><li>ImportWarning：用于在导入模块过程中触发的警告</li><li>UnicodeWarning：与Unicode相关的警告</li><li>BytesWarning：与字节或字节码相关的警告</li><li>ResourceWarning：与资源使用相关的警告</li></ul><hr><h2 id="3-try-except-语句"><a href="#3-try-except-语句" class="headerlink" title="3. try - except 语句"></a>3. try - except 语句</h2><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    检测范围<span class="hljs-keyword">except</span> Exception[<span class="hljs-keyword">as</span> reason]:    出现异常后的处理代码</code></pre><p>try 语句按照如下方式工作：</p><ul><li>首先，执行<code>try</code>子句（在关键字<code>try</code>和关键字<code>except</code>之间的语句）</li><li>如果没有异常发生，忽略<code>except</code>子句，<code>try</code>子句执行后结束。</li><li>如果在执行<code>try</code>子句的过程中发生了异常，那么<code>try</code>子句余下的部分将被忽略。如果异常的类型和<code>except</code>之后的名称相符，那么对应的<code>except</code>子句将被执行。最后执行<code>try</code>语句之后的代码。</li><li>如果一个异常没有与任何的<code>except</code>匹配，那么这个异常将会传递给上层的<code>try</code>中。</li></ul><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    f = open(<span class="hljs-string">'test.txt'</span>)    print(f.read())    f.close()<span class="hljs-keyword">except</span> OSError:    print(<span class="hljs-string">'打开文件出错'</span>)<span class="hljs-comment"># 打开文件出错</span></code></pre><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    f = open(<span class="hljs-string">'test.txt'</span>)    print(f.read())    f.close()<span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> error:    print(<span class="hljs-string">'打开文件出错\n原因是：'</span> + str(error))<span class="hljs-comment"># 打开文件出错</span><span class="hljs-comment"># 原因是：[Errno 2] No such file or directory: 'test.txt'</span></code></pre><p>一个<code>try</code>语句可能包含多个<code>except</code>子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    int(<span class="hljs-string">"abc"</span>)    s = <span class="hljs-number">1</span> + <span class="hljs-string">'1'</span>    f = open(<span class="hljs-string">'test.txt'</span>)    print(f.read())    f.close()<span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> error:    print(<span class="hljs-string">'打开文件出错\n原因是：'</span> + str(error))<span class="hljs-keyword">except</span> TypeError <span class="hljs-keyword">as</span> error:    print(<span class="hljs-string">'类型出错\n原因是：'</span> + str(error))<span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> error:    print(<span class="hljs-string">'数值出错\n原因是：'</span> + str(error))<span class="hljs-comment"># 数值出错</span><span class="hljs-comment"># 原因是：invalid literal for int() with base 10: 'abc'</span></code></pre><p>【例子】</p><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'v'</span>: <span class="hljs-number">22</span>&#125;<span class="hljs-keyword">try</span>:    x = dict1[<span class="hljs-string">'y'</span>]<span class="hljs-keyword">except</span> LookupError:    print(<span class="hljs-string">'查询错误'</span>)<span class="hljs-keyword">except</span> KeyError:    print(<span class="hljs-string">'键错误'</span>)<span class="hljs-keyword">else</span>:    print(x)<span class="hljs-comment"># 查询错误</span></code></pre><p><code>try-except-else</code>语句尝试查询不在<code>dict</code>中的键值对，从而引发了异常。这一异常准确地说应属于<code>KeyError</code>，但由于<code>KeyError</code>是<code>LookupError</code>的子类，且将<code>LookupError</code>置于<code>KeyError</code>之前，因此程序优先执行该<code>except</code>代码块。所以，使用多个<code>except</code>代码块时，必须坚持对其规范排序，要从最具针对性的异常到最通用的异常。</p><p>【例子】</p><pre><code class="hljs python">dict1 = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'v'</span>: <span class="hljs-number">22</span>&#125;<span class="hljs-keyword">try</span>:    x = dict1[<span class="hljs-string">'y'</span>]<span class="hljs-keyword">except</span> KeyError:    print(<span class="hljs-string">'键错误'</span>)<span class="hljs-keyword">except</span> LookupError:    print(<span class="hljs-string">'查询错误'</span>)<span class="hljs-keyword">else</span>:    print(x)<span class="hljs-comment"># 键错误</span></code></pre><p>【例子】一个 <code>except</code> 子句可以同时处理多个异常，这些异常将被放在一个括号里成为一个元组。</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    s = <span class="hljs-number">1</span> + <span class="hljs-string">'1'</span>    int(<span class="hljs-string">"abc"</span>)    f = open(<span class="hljs-string">'test.txt'</span>)    print(f.read())    f.close()<span class="hljs-keyword">except</span> (OSError, TypeError, ValueError) <span class="hljs-keyword">as</span> error:    print(<span class="hljs-string">'出错了！\n原因是：'</span> + str(error))<span class="hljs-comment"># 出错了！</span><span class="hljs-comment"># 原因是：unsupported operand type(s) for +: 'int' and 'str'</span></code></pre><hr><h2 id="4-try-except-finally-语句"><a href="#4-try-except-finally-语句" class="headerlink" title="4. try - except - finally 语句"></a>4. try - except - finally 语句</h2><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    检测范围<span class="hljs-keyword">except</span> Exception[<span class="hljs-keyword">as</span> reason]:    出现异常后的处理代码<span class="hljs-keyword">finally</span>:    无论如何都会被执行的代码</code></pre><p>不管<code>try</code>子句里面有没有发生异常，<code>finally</code>子句都会执行。</p><p>如果一个异常在<code>try</code>子句里被抛出，而又没有任何的<code>except</code>把它截住，那么这个异常会在<code>finally</code>子句执行后被抛出。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">divide</span><span class="hljs-params">(x, y)</span>:</span>    <span class="hljs-keyword">try</span>:        result = x / y        print(<span class="hljs-string">"result is"</span>, result)    <span class="hljs-keyword">except</span> ZeroDivisionError:        print(<span class="hljs-string">"division by zero!"</span>)    <span class="hljs-keyword">finally</span>:        print(<span class="hljs-string">"executing finally clause"</span>)divide(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<span class="hljs-comment"># result is 2.0</span><span class="hljs-comment"># executing finally clause</span>divide(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>)<span class="hljs-comment"># division by zero!</span><span class="hljs-comment"># executing finally clause</span>divide(<span class="hljs-string">"2"</span>, <span class="hljs-string">"1"</span>)<span class="hljs-comment"># executing finally clause</span><span class="hljs-comment"># TypeError: unsupported operand type(s) for /: 'str' and 'str'</span></code></pre><hr><h2 id="5-try-except-else-语句"><a href="#5-try-except-else-语句" class="headerlink" title="5. try - except - else 语句"></a>5. try - except - else 语句</h2><p>如果在<code>try</code>子句执行时没有发生异常，Python将执行<code>else</code>语句后的语句。</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    检测范围<span class="hljs-keyword">except</span>:    出现异常后的处理代码<span class="hljs-keyword">else</span>:    如果没有异常执行这块代码</code></pre><p>使用<code>except</code>而不带任何异常类型，这不是一个很好的方式，我们不能通过该程序识别出具体的异常信息，因为它捕获所有的异常。</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    检测范围<span class="hljs-keyword">except</span>(Exception1[, Exception2[,...ExceptionN]]]):   发生以上多个异常中的一个，执行这块代码<span class="hljs-keyword">else</span>:    如果没有异常执行这块代码</code></pre><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    fh = open(<span class="hljs-string">"testfile"</span>, <span class="hljs-string">"w"</span>)    fh.write(<span class="hljs-string">"这是一个测试文件，用于测试异常!!"</span>)<span class="hljs-keyword">except</span> IOError:    print(<span class="hljs-string">"Error: 没有找到文件或读取文件失败"</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"内容写入文件成功"</span>)    fh.close()<span class="hljs-comment"># 内容写入文件成功</span></code></pre><p>注意：<code>else</code>语句的存在必须以<code>except</code>语句的存在为前提，在没有<code>except</code>语句的<code>try</code>语句中使用<code>else</code>语句，会引发语法错误。</p><hr><h2 id="6-raise语句"><a href="#6-raise语句" class="headerlink" title="6. raise语句"></a>6. raise语句</h2><p>Python 使用<code>raise</code>语句抛出一个指定的异常。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:    <span class="hljs-keyword">raise</span> NameError(<span class="hljs-string">'HiThere'</span>)<span class="hljs-keyword">except</span> NameError:    print(<span class="hljs-string">'An exception flew by!'</span>)    <span class="hljs-comment"># An exception flew by!</span></code></pre><hr><p><strong>练习题</strong>：</p><p>1、猜数字游戏</p><p>题目描述:</p><p>电脑产生一个零到100之间的随机数字，然后让用户来猜，如果用户猜的数字比这个数字大，提示太大，否则提示太小，当用户正好猜中电脑会提示，”恭喜你猜到了这个数是……”。在用户每次猜测之前程序会输出用户是第几次猜测，如果用户输入的根本不是一个数字，程序会告诉用户”输入无效”。</p><p>(尝试使用try catch异常处理结构对输入情况进行处理)</p><p>获取随机数采用random模块。</p><p><img src="https://img-blog.csdnimg.cn/20200714230819193.png" srcset="/img/loading.gif" alt></p><pre><code class="hljs python"><span class="hljs-comment"># your code here</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python03-条件语句</title>
    <link href="/article/22d0bd28.html"/>
    <url>/article/22d0bd28.html</url>
    
    <content type="html"><![CDATA[<h1 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h1><h2 id="1-if-语句"><a href="#1-if-语句" class="headerlink" title="1. if 语句"></a>1. if 语句</h2><pre><code class="hljs python"><span class="hljs-keyword">if</span> expression:    expr_true_suite</code></pre><ul><li>if 语句的 <code>expr_true_suite</code> 代码块只有当条件表达式 <code>expression</code> 结果为真时才执行，否则将继续执行紧跟在该代码块后面的语句。</li><li>单个 if 语句中的 <code>expression</code> 条件表达式可以通过布尔操作符 <code>and</code>，<code>or</code>和<code>not</code> 实现多重条件判断。</li></ul><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> <span class="hljs-number">2</span> &gt; <span class="hljs-number">3</span>:    print(<span class="hljs-string">'Correct Judgement!'</span>)<span class="hljs-comment"># Correct Judgement!</span></code></pre><h2 id="2-if-else-语句"><a href="#2-if-else-语句" class="headerlink" title="2. if - else 语句"></a>2. if - else 语句</h2><pre><code class="hljs python"><span class="hljs-keyword">if</span> expression:    expr_true_suite<span class="hljs-keyword">else</span>:    expr_false_suite</code></pre><ul><li>Python 提供与 if 搭配使用的 else，如果 if 语句的条件表达式结果布尔值为假，那么程序将执行 else 语句后的代码。</li></ul><p>【例子】</p><pre><code class="hljs python">temp = input(<span class="hljs-string">"猜一猜小姐姐想的是哪个数字？"</span>)guess = int(temp) <span class="hljs-comment"># input 函数将接收的任何数据类型都默认为 str。</span><span class="hljs-keyword">if</span> guess == <span class="hljs-number">666</span>:    print(<span class="hljs-string">"你太了解小姐姐的心思了！"</span>)    print(<span class="hljs-string">"哼，猜对也没有奖励！"</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"猜错了，小姐姐现在心里想的是666！"</span>)print(<span class="hljs-string">"游戏结束，不玩儿啦！"</span>)</code></pre><p><code>if</code>语句支持嵌套，即在一个<code>if</code>语句中嵌入另一个<code>if</code>语句，从而构成不同层次的选择结构。<strong>Python 使用缩进而不是大括号来标记代码块边界</strong>，因此要特别注意<code>else</code>的悬挂问题。</p><p>【例子】</p><pre><code class="hljs python">hi = <span class="hljs-number">6</span><span class="hljs-keyword">if</span> hi &gt; <span class="hljs-number">2</span>:    <span class="hljs-keyword">if</span> hi &gt; <span class="hljs-number">7</span>:        print(<span class="hljs-string">'好棒!好棒!'</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'切~'</span>)</code></pre><p>【例子】</p><pre><code class="hljs python">temp = input(<span class="hljs-string">"不妨猜一下小哥哥现在心里想的是那个数字："</span>)guess = int(temp)<span class="hljs-keyword">if</span> guess &gt; <span class="hljs-number">8</span>:    print(<span class="hljs-string">"大了，大了"</span>)<span class="hljs-keyword">else</span>:    <span class="hljs-keyword">if</span> guess == <span class="hljs-number">8</span>:        print(<span class="hljs-string">"你这么懂小哥哥的心思吗？"</span>)        print(<span class="hljs-string">"哼，猜对也没有奖励！"</span>)    <span class="hljs-keyword">else</span>:        print(<span class="hljs-string">"小了，小了"</span>)print(<span class="hljs-string">"游戏结束，不玩儿啦！"</span>)</code></pre><h2 id="3-if-elif-else-语句"><a href="#3-if-elif-else-语句" class="headerlink" title="3. if - elif - else 语句"></a>3. if - elif - else 语句</h2><pre><code class="hljs python"><span class="hljs-keyword">if</span> expression1:    expr1_true_suite<span class="hljs-keyword">elif</span> expression2:    expr2_true_suite    .    .<span class="hljs-keyword">elif</span> expressionN:    exprN_true_suite<span class="hljs-keyword">else</span>:    expr_false_suite</code></pre><ul><li>elif 语句即为 else if，用来检查多个表达式是否为真，并在为真时执行特定代码块中的代码。</li></ul><p>【例子】</p><pre><code class="hljs python">temp = input(<span class="hljs-string">'请输入成绩:'</span>)source = int(temp)<span class="hljs-keyword">if</span> <span class="hljs-number">100</span> &gt;= source &gt;= <span class="hljs-number">90</span>:    print(<span class="hljs-string">'A'</span>)<span class="hljs-keyword">elif</span> <span class="hljs-number">90</span> &gt; source &gt;= <span class="hljs-number">80</span>:    print(<span class="hljs-string">'B'</span>)<span class="hljs-keyword">elif</span> <span class="hljs-number">80</span> &gt; source &gt;= <span class="hljs-number">60</span>:    print(<span class="hljs-string">'C'</span>)<span class="hljs-keyword">elif</span> <span class="hljs-number">60</span> &gt; source &gt;= <span class="hljs-number">0</span>:    print(<span class="hljs-string">'D'</span>)<span class="hljs-keyword">else</span>:    print(<span class="hljs-string">'输入错误！'</span>)</code></pre><h2 id="4-assert-关键词"><a href="#4-assert-关键词" class="headerlink" title="4. assert 关键词"></a>4. assert 关键词</h2><ul><li><code>assert</code>这个关键词我们称之为“断言”，当这个关键词后边的条件为 False 时，程序自动崩溃并抛出<code>AssertionError</code>的异常。</li></ul><p>【例子】</p><pre><code class="hljs python">my_list = [<span class="hljs-string">'lsgogroup'</span>]my_list.pop(<span class="hljs-number">0</span>)<span class="hljs-keyword">assert</span> len(my_list) &gt; <span class="hljs-number">0</span><span class="hljs-comment"># AssertionError</span></code></pre><ul><li>在进行单元测试时，可以用来在程序中置入检查点，只有条件为 True 才能让程序正常工作。</li></ul><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">assert</span> <span class="hljs-number">3</span> &gt; <span class="hljs-number">7</span><span class="hljs-comment"># AssertionError</span></code></pre><h1 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h1><h2 id="1-while-循环"><a href="#1-while-循环" class="headerlink" title="1. while 循环"></a>1. while 循环</h2><p><code>while</code>语句最基本的形式包括一个位于顶部的布尔表达式，一个或多个属于<code>while</code>代码块的缩进语句。</p><pre><code class="hljs python"><span class="hljs-keyword">while</span> 布尔表达式:    代码块</code></pre><p><code>while</code>循环的代码块会一直循环执行，直到布尔表达式的值为布尔假。</p><p>如果布尔表达式不带有<code>&lt;、&gt;、==、！=、in、not in</code>等运算符，仅仅给出数值之类的条件，也是可以的。当<code>while</code>后写入一个非零整数时，视为真值，执行循环体；写入<code>0</code>时，视为假值，不执行循环体。也可以写入<code>str、list</code>或任何序列，长度非零则视为真值，执行循环体；否则视为假值，不执行循环体。</p><p>【例子】</p><pre><code class="hljs python">count = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">3</span>:    temp = input(<span class="hljs-string">"不妨猜一下小哥哥现在心里想的是那个数字："</span>)    guess = int(temp)    <span class="hljs-keyword">if</span> guess &gt; <span class="hljs-number">8</span>:        print(<span class="hljs-string">"大了，大了"</span>)    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">if</span> guess == <span class="hljs-number">8</span>:            print(<span class="hljs-string">"你是小哥哥心里的蛔虫吗？"</span>)            print(<span class="hljs-string">"哼，猜对也没有奖励！"</span>)            count = <span class="hljs-number">3</span>        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">"小了，小了"</span>)    count = count + <span class="hljs-number">1</span>print(<span class="hljs-string">"游戏结束，不玩儿啦！"</span>)</code></pre><p>【例子】布尔表达式返回0，循环终止。</p><pre><code class="hljs python">string = <span class="hljs-string">'abcd'</span><span class="hljs-keyword">while</span> string:    print(string)    string = string[<span class="hljs-number">1</span>:]<span class="hljs-comment"># abcd</span><span class="hljs-comment"># bcd</span><span class="hljs-comment"># cd</span><span class="hljs-comment"># d</span></code></pre><hr><h2 id="2-while-else-循环"><a href="#2-while-else-循环" class="headerlink" title="2. while - else 循环"></a>2. while - else 循环</h2><pre><code class="hljs python"><span class="hljs-keyword">while</span> 布尔表达式:    代码块<span class="hljs-keyword">else</span>:    代码块</code></pre><p><strong>当<code>while</code>循环正常执行完的情况下，执行<code>else</code>输出，如果<code>while</code>循环中执行了跳出循环的语句，比如 <code>break</code>，将不执行<code>else</code>代码块的内容。</strong>    </p><p>【例子】</p><pre><code class="hljs python">count = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">5</span>:    print(<span class="hljs-string">"%d is  less than 5"</span> % count)    count = count + <span class="hljs-number">1</span><span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"%d is not less than 5"</span> % count)    <span class="hljs-comment"># 0 is  less than 5</span><span class="hljs-comment"># 1 is  less than 5</span><span class="hljs-comment"># 2 is  less than 5</span><span class="hljs-comment"># 3 is  less than 5</span><span class="hljs-comment"># 4 is  less than 5</span><span class="hljs-comment"># 5 is not less than 5</span></code></pre><p>【例子】</p><pre><code class="hljs python">count = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> count &lt; <span class="hljs-number">5</span>:    print(<span class="hljs-string">"%d is  less than 5"</span> % count)    count = <span class="hljs-number">6</span>    <span class="hljs-keyword">break</span><span class="hljs-keyword">else</span>:    print(<span class="hljs-string">"%d is not less than 5"</span> % count)<span class="hljs-comment"># 0 is  less than 5</span></code></pre><hr><h2 id="3-for-循环"><a href="#3-for-循环" class="headerlink" title="3. for 循环"></a>3. for 循环</h2><p><code>for</code>循环是迭代循环，在Python中相当于一个通用的序列迭代器，可以遍历任何有序序列，如<code>str、list、tuple</code>等，也可以遍历任何可迭代对象，如<code>dict</code>。</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> 迭代变量 <span class="hljs-keyword">in</span> 可迭代对象:    代码块</code></pre><p>每次循环，迭代变量被设置为可迭代对象的当前元素，提供给代码块使用。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">'ILoveLSGO'</span>:    print(i, end=<span class="hljs-string">' '</span>)  <span class="hljs-comment"># 不换行输出</span><span class="hljs-comment"># I L o v e L S G O</span></code></pre><p>【例子】</p><pre><code class="hljs python">member = [<span class="hljs-string">'张三'</span>, <span class="hljs-string">'李四'</span>, <span class="hljs-string">'刘德华'</span>, <span class="hljs-string">'刘六'</span>, <span class="hljs-string">'周润发'</span>]<span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> member:    print(each)<span class="hljs-comment"># 张三</span><span class="hljs-comment"># 李四</span><span class="hljs-comment"># 刘德华</span><span class="hljs-comment"># 刘六</span><span class="hljs-comment"># 周润发</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(member)):    print(member[i])<span class="hljs-comment"># 张三</span><span class="hljs-comment"># 李四</span><span class="hljs-comment"># 刘德华</span><span class="hljs-comment"># 刘六</span><span class="hljs-comment"># 周润发</span></code></pre><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">4</span>&#125;<span class="hljs-keyword">for</span> key, value <span class="hljs-keyword">in</span> dic.items():    print(key, value, sep=<span class="hljs-string">':'</span>, end=<span class="hljs-string">' '</span>)    <span class="hljs-comment"># a:1 b:2 c:3 d:4</span></code></pre><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">4</span>&#125;<span class="hljs-keyword">for</span> key <span class="hljs-keyword">in</span> dic.keys():    print(key, end=<span class="hljs-string">' '</span>)    <span class="hljs-comment"># a b c d</span></code></pre><p>【例子】</p><pre><code class="hljs python">dic = &#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'d'</span>: <span class="hljs-number">4</span>&#125;<span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> dic.values():    print(value, end=<span class="hljs-string">' '</span>)    <span class="hljs-comment"># 1 2 3 4</span></code></pre><hr><h2 id="4-for-else-循环"><a href="#4-for-else-循环" class="headerlink" title="4. for - else 循环"></a>4. for - else 循环</h2><pre><code class="hljs python"><span class="hljs-keyword">for</span> 迭代变量 <span class="hljs-keyword">in</span> 可迭代对象:    代码块<span class="hljs-keyword">else</span>:    代码块</code></pre><p>当<code>for</code>循环正常执行完的情况下，执行<code>else</code>输出，如果<code>for</code>循环中执行了跳出循环的语句，比如 <code>break</code>，将不执行<code>else</code>代码块的内容，与<code>while - else</code>语句一样。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>):  <span class="hljs-comment"># 迭代 10 到 20 之间的数字</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, num):  <span class="hljs-comment"># 根据因子迭代</span>        <span class="hljs-keyword">if</span> num % i == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 确定第一个因子</span>            j = num / i  <span class="hljs-comment"># 计算第二个因子</span>            print(<span class="hljs-string">'%d 等于 %d * %d'</span> % (num, i, j))            <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 跳出当前循环</span>    <span class="hljs-keyword">else</span>:  <span class="hljs-comment"># 循环的 else 部分</span>        print(num, <span class="hljs-string">'是一个质数'</span>)<span class="hljs-comment"># 10 等于 2 * 5</span><span class="hljs-comment"># 11 是一个质数</span><span class="hljs-comment"># 12 等于 2 * 6</span><span class="hljs-comment"># 13 是一个质数</span><span class="hljs-comment"># 14 等于 2 * 7</span><span class="hljs-comment"># 15 等于 3 * 5</span><span class="hljs-comment"># 16 等于 2 * 8</span><span class="hljs-comment"># 17 是一个质数</span><span class="hljs-comment"># 18 等于 2 * 9</span><span class="hljs-comment"># 19 是一个质数</span></code></pre><hr><h2 id="5-range-函数"><a href="#5-range-函数" class="headerlink" title="5. range() 函数"></a>5. range() 函数</h2><pre><code class="hljs python">range([start,] stop[, step=<span class="hljs-number">1</span>])</code></pre><ul><li>这个BIF（Built-in functions内置函数）有三个参数，其中用中括号括起来的两个表示这两个参数是可选的。</li><li><code>step=1</code> 表示第三个参数的默认值是1。</li><li><code>range</code> 这个BIF的作用是生成一个从<code>start</code>参数的值开始到<code>stop</code>参数的值结束的数字序列，该序列包含<code>start</code>的值但不包含<code>stop</code>的值。</li></ul><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, <span class="hljs-number">9</span>):  <span class="hljs-comment"># 不包含9</span>    print(i)<span class="hljs-comment"># 2</span><span class="hljs-comment"># 3</span><span class="hljs-comment"># 4</span><span class="hljs-comment"># 5</span><span class="hljs-comment"># 6</span><span class="hljs-comment"># 7</span><span class="hljs-comment"># 8</span></code></pre><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, <span class="hljs-number">2</span>):    print(i)<span class="hljs-comment"># 1</span><span class="hljs-comment"># 3</span><span class="hljs-comment"># 5</span><span class="hljs-comment"># 7</span><span class="hljs-comment"># 9</span></code></pre><hr><h2 id="6-enumerate-函数"><a href="#6-enumerate-函数" class="headerlink" title="6. enumerate()函数"></a>6. enumerate()函数</h2><pre><code class="hljs python">enumerate(sequence, [start=<span class="hljs-number">0</span>])</code></pre><ul><li>sequence — 一个序列、迭代器或其他支持迭代对象。</li><li>start — 下标起始位置。</li><li>返回 enumerate(枚举) 对象</li></ul><p>【例子】</p><pre><code class="hljs python">seasons = [<span class="hljs-string">'Spring'</span>, <span class="hljs-string">'Summer'</span>, <span class="hljs-string">'Fall'</span>, <span class="hljs-string">'Winter'</span>]lst = list(enumerate(seasons))print(lst)<span class="hljs-comment"># [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]</span>lst = list(enumerate(seasons, start=<span class="hljs-number">1</span>))  <span class="hljs-comment"># 下标从 1 开始</span>print(lst)<span class="hljs-comment"># [(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]</span></code></pre><p><code>enumerate()</code>与 for 循环的结合使用</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i, a <span class="hljs-keyword">in</span> enumerate(A)    do something <span class="hljs-keyword">with</span> a</code></pre><p>用 <code>enumerate(A)</code> 不仅返回了 <code>A</code> 中的元素，还顺便给该元素一个索引值 (默认从 0 开始)。此外，用 <code>enumerate(A, j)</code> 还可以确定索引起始值为 <code>j</code>。</p><p>【例子】</p><pre><code class="hljs python">languages = [<span class="hljs-string">'Python'</span>, <span class="hljs-string">'R'</span>, <span class="hljs-string">'Matlab'</span>, <span class="hljs-string">'C++'</span>]<span class="hljs-keyword">for</span> language <span class="hljs-keyword">in</span> languages:    print(<span class="hljs-string">'I love'</span>, language)print(<span class="hljs-string">'Done!'</span>)<span class="hljs-string">'''</span><span class="hljs-string">I love Python</span><span class="hljs-string">I love R</span><span class="hljs-string">I love Matlab</span><span class="hljs-string">I love C++</span><span class="hljs-string">Done!</span><span class="hljs-string">'''</span><span class="hljs-keyword">for</span> i, language <span class="hljs-keyword">in</span> enumerate(languages, <span class="hljs-number">2</span>):    print(i, <span class="hljs-string">'I love'</span>, language)print(<span class="hljs-string">'Done!'</span>)<span class="hljs-string">'''</span><span class="hljs-string">2 I love Python</span><span class="hljs-string">3 I love R</span><span class="hljs-string">4 I love Matlab</span><span class="hljs-string">5 I love C++</span><span class="hljs-string">Done!</span><span class="hljs-string">'''</span></code></pre><hr><h2 id="7-break-语句"><a href="#7-break-语句" class="headerlink" title="7. break 语句"></a>7. break 语句</h2><p><code>break</code>语句可以跳出当前所在层的循环。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> randomsecret = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">#[1,10]之间的随机数</span><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:    temp = input(<span class="hljs-string">"不妨猜一下小哥哥现在心里想的是那个数字："</span>)    guess = int(temp)    <span class="hljs-keyword">if</span> guess &gt; secret:        print(<span class="hljs-string">"大了，大了"</span>)    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">if</span> guess == secret:            print(<span class="hljs-string">"你这样懂小哥哥的心思啊？"</span>)            print(<span class="hljs-string">"哼，猜对也没有奖励！"</span>)            <span class="hljs-keyword">break</span>        <span class="hljs-keyword">else</span>:            print(<span class="hljs-string">"小了，小了"</span>)print(<span class="hljs-string">"游戏结束，不玩儿啦！"</span>)</code></pre><hr><h2 id="8-continue-语句"><a href="#8-continue-语句" class="headerlink" title="8. continue 语句"></a>8. continue 语句</h2><p><code>continue</code>终止本轮循环并开始下一轮循环。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):    <span class="hljs-keyword">if</span> i % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>:        print(i)        <span class="hljs-keyword">continue</span>    i += <span class="hljs-number">2</span>    print(i)<span class="hljs-comment"># 2</span><span class="hljs-comment"># 1</span><span class="hljs-comment"># 4</span><span class="hljs-comment"># 3</span><span class="hljs-comment"># 6</span><span class="hljs-comment"># 5</span><span class="hljs-comment"># 8</span><span class="hljs-comment"># 7</span><span class="hljs-comment"># 10</span><span class="hljs-comment"># 9</span></code></pre><hr><h2 id="9-pass-语句"><a href="#9-pass-语句" class="headerlink" title="9. pass 语句"></a>9. pass 语句</h2><p><code>pass</code> 语句的意思是“不做任何事”，如果你在需要有语句的地方不写任何语句，那么解释器会提示出错，而 <code>pass</code> 语句就是用来解决这些问题的。</p><p>【例子】</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a_func</span><span class="hljs-params">()</span>:</span><span class="hljs-comment"># SyntaxError: unexpected EOF while parsing</span></code></pre><p>【例子】</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">a_func</span><span class="hljs-params">()</span>:</span>    <span class="hljs-keyword">pass</span></code></pre><p><code>pass</code>是空语句，不做任何操作，只起到占位的作用，其作用是为了保持程序结构的完整性。尽管<code>pass</code>语句不做任何操作，但如果暂时不确定要在一个位置放上什么样的代码，可以先放置一个<code>pass</code>语句，让代码可以正常运行。</p><hr><h2 id="10-推导式"><a href="#10-推导式" class="headerlink" title="10. 推导式"></a>10. 推导式</h2><p><strong>列表推导式</strong></p><pre><code class="hljs python">[ expr <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> collection [<span class="hljs-keyword">if</span> condition] ]</code></pre><p>【例子】</p><pre><code class="hljs python">x = [<span class="hljs-number">-4</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>]y = [a * <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> a <span class="hljs-keyword">in</span> x]print(y)<span class="hljs-comment"># [-8, -4, 0, 4, 8]</span></code></pre><p>【例子】</p><pre><code class="hljs python">x = [i ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)]print(x)<span class="hljs-comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></code></pre><p>【例子】</p><pre><code class="hljs python">x = [(i, i ** <span class="hljs-number">2</span>) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">6</span>)]print(x)<span class="hljs-comment"># [(0, 0), (1, 1), (2, 4), (3, 9), (4, 16), (5, 25)]</span></code></pre><p>【例子】</p><pre><code class="hljs python">x = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">100</span>) <span class="hljs-keyword">if</span> (i % <span class="hljs-number">2</span>) != <span class="hljs-number">0</span> <span class="hljs-keyword">and</span> (i % <span class="hljs-number">3</span>) == <span class="hljs-number">0</span>]print(x)<span class="hljs-comment"># [3, 9, 15, 21, 27, 33, 39, 45, 51, 57, 63, 69, 75, 81, 87, 93, 99]</span></code></pre><p>【例子】</p><pre><code class="hljs python">a = [(i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)]print(a)<span class="hljs-comment"># [(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]</span></code></pre><p>【例子】</p><pre><code class="hljs python">x = [[i, j] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>)]print(x)<span class="hljs-comment"># [[0, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]</span>x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>print(x)<span class="hljs-comment"># [[10, 0], [0, 1], [0, 2], [1, 0], [1, 1], [1, 2], [2, 0], [2, 1], [2, 2]]</span></code></pre><p>【例子】</p><pre><code class="hljs python">a = [(i, j) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">if</span> i &lt; <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>) <span class="hljs-keyword">if</span> j &gt; <span class="hljs-number">1</span>]print(a)<span class="hljs-comment"># [(0, 2)]</span></code></pre><p><strong>元组推导式</strong></p><pre><code class="hljs python">( expr <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> collection [<span class="hljs-keyword">if</span> condition] )</code></pre><p>【例子】</p><pre><code class="hljs python">a = (x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>))print(a)<span class="hljs-comment"># &lt;generator object &lt;genexpr&gt; at 0x0000025BE511CC48&gt;</span>print(tuple(a))<span class="hljs-comment"># (0, 1, 2, 3, 4, 5, 6, 7, 8, 9)</span></code></pre><p><strong>字典推导式</strong></p><pre><code class="hljs python">&#123; key_expr: value_expr <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> collection [<span class="hljs-keyword">if</span> condition] &#125;</code></pre><p>【例子】</p><pre><code class="hljs python">b = &#123;i: i % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> i % <span class="hljs-number">3</span> == <span class="hljs-number">0</span>&#125;print(b)<span class="hljs-comment"># &#123;0: True, 3: False, 6: True, 9: False&#125;</span></code></pre><p><strong>集合推导式</strong></p><pre><code class="hljs clojure">&#123; expr for value in collection [if condition] &#125;</code></pre><p>【例子】</p><pre><code class="hljs python">c = &#123;i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>]&#125;print(c)<span class="hljs-comment"># &#123;1, 2, 3, 4, 5, 6&#125;</span></code></pre><p><strong>其它</strong></p><pre><code class="hljs python">d = <span class="hljs-string">'i for i in "I Love Lsgogroup"'</span>print(d)<span class="hljs-comment"># i for i in "I Love Lsgogroup"</span>e = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>))print(e)<span class="hljs-comment"># &lt;generator object &lt;genexpr&gt; at 0x0000007A0B8D01B0&gt;</span>print(next(e))  <span class="hljs-comment"># 0</span>print(next(e))  <span class="hljs-comment"># 1</span><span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> e:    print(each, end=<span class="hljs-string">' '</span>)<span class="hljs-comment"># 2 3 4 5 6 7 8 9</span>s = sum([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">101</span>)])print(s)  <span class="hljs-comment"># 5050</span>s = sum((i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">101</span>)))print(s)  <span class="hljs-comment"># 5050</span></code></pre><hr><h2 id="11-综合例子"><a href="#11-综合例子" class="headerlink" title="11. 综合例子"></a>11. 综合例子</h2><pre><code class="hljs python">passwdList = [<span class="hljs-string">'123'</span>, <span class="hljs-string">'345'</span>, <span class="hljs-string">'890'</span>]valid = <span class="hljs-literal">False</span>count = <span class="hljs-number">3</span><span class="hljs-keyword">while</span> count &gt; <span class="hljs-number">0</span>:    password = input(<span class="hljs-string">'enter password:'</span>)    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> passwdList:        <span class="hljs-keyword">if</span> password == item:            valid = <span class="hljs-literal">True</span>            <span class="hljs-keyword">break</span>                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> valid:        print(<span class="hljs-string">'invalid input'</span>)        count -= <span class="hljs-number">1</span>        <span class="hljs-keyword">continue</span>    <span class="hljs-keyword">else</span>:        <span class="hljs-keyword">break</span></code></pre><hr><p><strong>参考文献</strong>：</p><ul><li><a href="https://www.runoob.com/python3/python3-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/python3/python3-tutorial.html</a></li><li><a href="https://www.bilibili.com/video/av4050443" target="_blank" rel="noopener">https://www.bilibili.com/video/av4050443</a></li><li><a href="https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/DZ589xEbOQ2QLtiq8mP1qQ</a></li></ul><hr><p><strong>练习题</strong>：</p><p>1、编写一个Python程序来查找那些可以被7除以5的整数的数字，介于1500和2700之间。</p><pre><code class="hljs python"><span class="hljs-comment"># your code here</span></code></pre><p>2、龟兔赛跑游戏</p><p>题目描述：</p><p>话说这个世界上有各种各样的兔子和乌龟，但是研究发现，所有的兔子和乌龟都有一个共同的特点——喜欢赛跑。于是世界上各个角落都不断在发生着乌龟和兔子的比赛，小华对此很感兴趣，于是决定研究不同兔  子和乌龟的赛跑。他发现，兔子虽然跑比乌龟快，但它们有众所周知的毛病——骄傲且懒惰，于是在与乌龟的比赛中，一旦任一秒结束后兔子发现自己领先t米或以  上，它们就会停下来休息s秒。对于不同的兔子，t，s的数值是不同的，但是所有的乌龟却是一致——它们不到终点决不停止。 </p><p>然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子和乌龟的数据——兔子的速度v1（表示每秒兔子能跑v1  米），乌龟的速度v2，以及兔子对应的t，s值，以及赛道的长度l——就能预测出比赛的结果。但是小华很懒，不想通过手工计算推测出比赛的结果，于是他找 到了你——清华大学计算机系的高才生——请求帮助，请你写一个程序，对于输入的一场比赛的数据v1，v2，t，s，l，预测该场比赛的结果。</p><p>输入:</p><p>输入只有一行，包含用空格隔开的五个正整数v1，v2，t，s，l，其中(v1,v2&lt; =100;t&lt; =300;s&lt; =10;l&lt; =10000且为v1,v2的公倍数) </p><p>输出:</p><p>输出包含两行，第一行输出比赛结果——一个大写字母“T”或“R”或“D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点。 </p><p>第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）。 </p><hr><p>样例输入：</p><p>10  5  5  2  20 </p><p>样例输出</p><p>D<br><br>4</p><pre><code class="hljs python"><span class="hljs-comment"># your code here</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python02-位运算</title>
    <link href="/article/392be851.html"/>
    <url>/article/392be851.html</url>
    
    <content type="html"><![CDATA[<h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="1-原码、反码和补码"><a href="#1-原码、反码和补码" class="headerlink" title="1. 原码、反码和补码"></a>1. 原码、反码和补码</h2><p>二进制有三种不同的表示形式：原码、反码和补码，<u>计算机内部使用补码来表示</u>。</p><p><strong>原码</strong>：就是其二进制表示（注意，有一位符号位）。</p><pre><code class="hljs python">00 00 00 11 -&gt; 310 00 00 11 -&gt; -3</code></pre><p><strong>反码</strong>：正数的反码就是原码，负数的反码是符号位不变，其余位取反（对应正数按位取反）。</p><pre><code class="hljs python">00 00 00 11 -&gt; 311 11 11 00 -&gt; -3</code></pre><p><strong>补码</strong>：正数的补码就是原码，负数的补码是反码+1。</p><pre><code class="hljs python">00 00 00 11 -&gt; 311 11 11 01 -&gt; -3</code></pre><p><strong>符号位</strong>：最高位为符号位，0表示正数，1表示负数。在位运算中符号位也参与运算。</p><h2 id="2-按位非操作"><a href="#2-按位非操作" class="headerlink" title="2. 按位非操作 ~"></a>2. 按位非操作 ~</h2><pre><code class="hljs python">~ <span class="hljs-number">1</span> = <span class="hljs-number">0</span>~ <span class="hljs-number">0</span> = <span class="hljs-number">1</span></code></pre><p><code>~</code> 把<code>num</code>的补码中的 0 和 1 全部取反（0 变为 1，1 变为 0）有符号整数的符号位在 <code>~</code> 运算中同样会取反。</p><pre><code class="hljs python">00 00 01 01 -&gt; 5~---11 11 10 10 -&gt; -611 11 10 11 -&gt; -5~---00 00 01 00 -&gt; 4</code></pre><h2 id="3-按位与操作-amp"><a href="#3-按位与操作-amp" class="headerlink" title="3. 按位与操作 &amp;"></a>3. 按位与操作 &amp;</h2><pre><code class="hljs python"><span class="hljs-number">1</span> &amp; <span class="hljs-number">1</span> = <span class="hljs-number">1</span><span class="hljs-number">1</span> &amp; <span class="hljs-number">0</span> = <span class="hljs-number">0</span><span class="hljs-number">0</span> &amp; <span class="hljs-number">1</span> = <span class="hljs-number">0</span><span class="hljs-number">0</span> &amp; <span class="hljs-number">0</span> = <span class="hljs-number">0</span></code></pre><p>只有两个对应位都为 1 时才为 1</p><pre><code class="hljs python">00 00 01 01 -&gt; 5&amp;00 00 01 10 -&gt; 6---00 00 01 00 -&gt; 4</code></pre><h2 id="4-按位或操作"><a href="#4-按位或操作" class="headerlink" title="4. 按位或操作 |"></a>4. 按位或操作 |</h2><pre><code class="hljs python"><span class="hljs-number">1</span> | <span class="hljs-number">1</span> = <span class="hljs-number">1</span><span class="hljs-number">1</span> | <span class="hljs-number">0</span> = <span class="hljs-number">1</span><span class="hljs-number">0</span> | <span class="hljs-number">1</span> = <span class="hljs-number">1</span><span class="hljs-number">0</span> | <span class="hljs-number">0</span> = <span class="hljs-number">0</span></code></pre><p>只要两个对应位中有一个 1 时就为 1</p><pre><code class="hljs python">00 00 01 01 -&gt; 5|00 00 01 10 -&gt; 6---00 00 01 11 -&gt; 7</code></pre><h2 id="5-按位异或操作"><a href="#5-按位异或操作" class="headerlink" title="5. 按位异或操作 ^"></a>5. 按位异或操作 ^</h2><pre><code class="hljs python"><span class="hljs-number">1</span> ^ <span class="hljs-number">1</span> = <span class="hljs-number">0</span><span class="hljs-number">1</span> ^ <span class="hljs-number">0</span> = <span class="hljs-number">1</span><span class="hljs-number">0</span> ^ <span class="hljs-number">1</span> = <span class="hljs-number">1</span><span class="hljs-number">0</span> ^ <span class="hljs-number">0</span> = <span class="hljs-number">0</span></code></pre><p>只有两个对应位不同时才为 1</p><pre><code class="hljs python">00 00 01 01 -&gt; 5^00 00 01 10 -&gt; 6---00 00 00 11 -&gt; 3</code></pre><p>异或操作的性质：满足交换律和结合律</p><pre><code class="hljs python">A: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span>B: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">11</span>A^B: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>B^A: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span>A^A: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span>A^<span class="hljs-number">0</span>: <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span>A^B^A: = A^A^B = <span class="hljs-number">0</span>^B = <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">11</span></code></pre><h2 id="6-按位左移操作-lt-lt"><a href="#6-按位左移操作-lt-lt" class="headerlink" title="6. 按位左移操作 &lt;&lt;"></a>6. 按位左移操作 &lt;&lt;</h2><p><code>num &lt;&lt; i</code> 将<code>num</code>的二进制表示向左移动<code>i</code>位所得的值。</p><pre><code class="hljs python">00 00 10 11 -&gt; 11<span class="hljs-number">11</span> &lt;&lt; <span class="hljs-number">3</span>---01 01 10 00 -&gt; 88 = 11 x 8</code></pre><h2 id="7-按位右移操作-gt-gt"><a href="#7-按位右移操作-gt-gt" class="headerlink" title="7. 按位右移操作 &gt;&gt;"></a>7. 按位右移操作 &gt;&gt;</h2><p><code>num &gt;&gt; i</code> 将<code>num</code>的二进制表示向右移动<code>i</code>位所得的值。</p><pre><code class="hljs python">00 00 10 11 -&gt; 11<span class="hljs-number">11</span> &gt;&gt; <span class="hljs-number">2</span>---00 00 00 10 -&gt; 2 = 11 // 4</code></pre><h2 id="8-利用位运算实现快速计算"><a href="#8-利用位运算实现快速计算" class="headerlink" title="8. 利用位运算实现快速计算"></a>8. 利用位运算实现快速计算</h2><p>通过 <code>&lt;&lt;</code>，<code>&gt;&gt;</code> 快速计算2的倍数问题。</p><pre><code class="hljs excel"><span class="hljs-built_in">n</span> &lt;&lt; <span class="hljs-number">1</span> -&gt; 计算 <span class="hljs-built_in">n</span>*<span class="hljs-number">2</span><span class="hljs-built_in">n</span> &gt;&gt; <span class="hljs-number">1</span> -&gt; 计算 <span class="hljs-built_in">n</span>//<span class="hljs-number">2</span>，负奇数的运算不可用<span class="hljs-built_in">n</span> &lt;&lt; m -&gt; 计算 <span class="hljs-built_in">n</span>*(<span class="hljs-number">2</span>^m)，即乘以 <span class="hljs-number">2</span> 的 m 次方<span class="hljs-built_in">n</span> &gt;&gt; m -&gt; 计算 <span class="hljs-built_in">n</span>//(<span class="hljs-number">2</span>^m)，即除以 <span class="hljs-number">2</span> 的 m 次方<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-built_in">n</span> -&gt; <span class="hljs-number">2</span>^<span class="hljs-built_in">n</span></code></pre><p>通过 <code>^</code> 快速交换两个整数。</p><pre><code class="hljs c">a ^= bb ^= aa ^= b</code></pre><p>通过 <code>a &amp; (-a)</code> 快速获取<code>a</code>的最后为 1 位置的整数。</p><p><span style="color:blue">(-a) = a的补码+1，最后一个1之后的0全变为1，+1后为0，进一000位后，原先的最后一个1保持不变。</span></p><pre><code class="hljs c"><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> <span class="hljs-number">01</span> -&gt; <span class="hljs-number">5</span>&amp;<span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> -&gt; <span class="hljs-number">-5</span>---<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">01</span> -&gt; <span class="hljs-number">1</span><span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">11</span> <span class="hljs-number">10</span> -&gt; <span class="hljs-number">14</span>&amp;<span class="hljs-number">11</span> <span class="hljs-number">11</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> -&gt; <span class="hljs-number">-14</span>---<span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">00</span> <span class="hljs-number">10</span> -&gt; <span class="hljs-number">2</span></code></pre><h2 id="9-利用位运算实现整数集合"><a href="#9-利用位运算实现整数集合" class="headerlink" title="9. 利用位运算实现整数集合"></a>9. 利用位运算实现整数集合</h2><p>一个数的二进制表示可以看作是一个集合（0 表示不在集合中，1 表示在集合中）。</p><p>比如集合 <code>{1, 3, 4, 8}</code>，可以表示成 <code>01 00 01 10 10(876543210,1表示在集合中,0表示不在集合中)</code> 而对应的位运算也就可以看作是对集合进行的操作。</p><p>元素与集合的操作：</p><pre><code class="hljs livescript">a | <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>&lt;&lt;i)</span>  -&gt;</span> 把 i 插入到集合中a &amp; ~<span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>&lt;&lt;i)</span> -&gt;</span> 把 i 从集合中删除a &amp; <span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">1</span>&lt;&lt;i)</span>  -&gt;</span> 判断 i 是否属于该集合（<span class="hljs-number">0</span>:不属于，<span class="hljs-number">1</span>:属于）</code></pre><p>集合之间的操作：</p><pre><code class="hljs c">a 补   -&gt; ~aa 交 b -&gt; a &amp; ba 并 b -&gt; a | ba 差 b -&gt; a &amp; (~b)</code></pre><p>注意：整数在内存中是以补码的形式存在的，输出自然也是按照补码输出。</p><p>【例子】C#语言输出负数。</p><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Program</span></span><span class="hljs-class">&#123;</span>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Main</span><span class="hljs-params">(<span class="hljs-built_in">string</span>[] args)</span></span><span class="hljs-function">    </span>&#123;        <span class="hljs-built_in">string</span> s1 = Convert.ToString(<span class="hljs-number">-3</span>, <span class="hljs-number">2</span>);        <span class="hljs-built_in">Console</span>.WriteLine(s1);         <span class="hljs-comment">// 11111111111111111111111111111101</span>                <span class="hljs-built_in">string</span> s2 = Convert.ToString(<span class="hljs-number">-3</span>, <span class="hljs-number">16</span>);        <span class="hljs-built_in">Console</span>.WriteLine(s2);         <span class="hljs-comment">// fffffffd</span>    &#125;&#125;</code></pre><p>【例子】 Python 的<code>bin()</code> 输出。</p><pre><code class="hljs python">print(bin(<span class="hljs-number">3</span>))  <span class="hljs-comment"># 0b11</span>print(bin(<span class="hljs-number">-3</span>))  <span class="hljs-comment"># -0b11</span>print(bin(<span class="hljs-number">-3</span> &amp; <span class="hljs-number">0xffffffff</span>))  <span class="hljs-comment"># 0b11111111111111111111111111111101</span>print(bin(<span class="hljs-number">0xfffffffd</span>))       <span class="hljs-comment"># 0b11111111111111111111111111111101</span>print(<span class="hljs-number">0xfffffffd</span>)  <span class="hljs-comment"># 4294967293</span></code></pre><p>是不是很颠覆认知，我们从结果可以看出：</p><ul><li>Python中<code>bin</code>一个负数（十进制表示），输出的是它的原码的二进制表示加上个负号，巨坑。</li><li>Python中的整型是补码形式存储的。</li><li>Python中整型是不限制长度的不会超范围溢出。</li></ul><p>所以为了获得负数（十进制表示）的补码，需要手动将其和十六进制数<code>0xffffffff</code>进行按位与操作，再交给<code>bin()</code>进行输出，得到的才是负数的补码表示。</p><hr><p><strong>练习题</strong>：</p><p>leetcode 习题 136. 只出现一次的数字</p><p>给定一个<strong>非空</strong>整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>尝试使用位运算解决此题。</p><p>题目说明:</p><pre><code class="hljs python"><span class="hljs-string">"""</span><span class="hljs-string">Input file</span><span class="hljs-string">example1: [2,2,1]</span><span class="hljs-string">example2: [4,1,2,1,2]</span><span class="hljs-string"></span><span class="hljs-string">Output file</span><span class="hljs-string">result1: 1</span><span class="hljs-string">result2: 4</span><span class="hljs-string">"""</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(self, nums: List[int])</span> -&gt; int:</span>        <span class="hljs-comment"># your code here</span>        <span class="hljs-keyword">return</span> reduce(<span class="hljs-keyword">lambda</span> x,y: x^y, nums)</code></pre><p>思路：</p><p>$a \bigoplus a = 0$, $0 \bigoplus a=a$,$0 \bigoplus 0=0$,所以把所有数字做异或操作，得到$(a_1 \bigoplus a_1) \bigoplus (a_2 \bigoplus a_2) \bigoplus \ldots (a_n) = a_n$</p>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python01-变量、运算符与数据类型</title>
    <link href="/article/fcab5e80.html"/>
    <url>/article/fcab5e80.html</url>
    
    <content type="html"><![CDATA[<h1 id="变量、运算符与数据类型"><a href="#变量、运算符与数据类型" class="headerlink" title="变量、运算符与数据类型"></a>变量、运算符与数据类型</h1><h2 id="1-注释"><a href="#1-注释" class="headerlink" title="1. 注释"></a>1. 注释</h2><ul><li>在 Python 中，<code>#</code> 表示注释，作用于整行。</li></ul><p>【例子】单行注释</p><pre><code class="hljs python"><span class="hljs-comment"># 这是一个注释</span>print(<span class="hljs-string">"Hello world"</span>)<span class="hljs-comment"># Hello world</span></code></pre><ul><li><code>&#39;&#39;&#39; &#39;&#39;&#39;</code> 或者 <code>&quot;&quot;&quot; &quot;&quot;&quot;</code> 表示区间注释，在三引号之间的所有内容被注释</li></ul><p>【例子】多行注释</p><pre><code class="hljs python"><span class="hljs-string">'''</span><span class="hljs-string">这是多行注释，用三个单引号</span><span class="hljs-string">这是多行注释，用三个单引号</span><span class="hljs-string">这是多行注释，用三个单引号</span><span class="hljs-string">'''</span>print(<span class="hljs-string">"Hello china"</span>) <span class="hljs-comment"># Hello china</span><span class="hljs-string">"""</span><span class="hljs-string">这是多行注释，用三个双引号</span><span class="hljs-string">这是多行注释，用三个双引号 </span><span class="hljs-string">这是多行注释，用三个双引号</span><span class="hljs-string">"""</span>print(<span class="hljs-string">"hello china"</span>) <span class="hljs-comment"># hello china</span></code></pre><h2 id="2-运算符"><a href="#2-运算符" class="headerlink" title="2. 运算符"></a>2. 运算符</h2><p><b>算术运算符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>+</code></td><td style="text-align:center">加</td><td style="text-align:center"><code>1 + 1</code></td></tr><tr><td style="text-align:center"><code>-</code></td><td style="text-align:center">减</td><td style="text-align:center"><code>2 - 1</code></td></tr><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center">乘</td><td style="text-align:center"><code>3 * 4</code></td></tr><tr><td style="text-align:center"><code>/</code></td><td style="text-align:center">除</td><td style="text-align:center"><code>3 / 4</code></td></tr><tr><td style="text-align:center"><code>//</code></td><td style="text-align:center">整除（地板除）</td><td style="text-align:center"><code>3 // 4</code></td></tr><tr><td style="text-align:center"><code>%</code></td><td style="text-align:center">取余</td><td style="text-align:center"><code>3 % 4</code></td></tr><tr><td style="text-align:center"><code>**</code></td><td style="text-align:center">幂</td><td style="text-align:center"><code>2 ** 3</code></td></tr></tbody></table></div><p>【例子】</p><pre><code class="hljs python">print(<span class="hljs-number">1</span> + <span class="hljs-number">1</span>)  <span class="hljs-comment"># 2</span>print(<span class="hljs-number">2</span> - <span class="hljs-number">1</span>)  <span class="hljs-comment"># 1</span>print(<span class="hljs-number">3</span> * <span class="hljs-number">4</span>)  <span class="hljs-comment"># 12</span>print(<span class="hljs-number">3</span> / <span class="hljs-number">4</span>)  <span class="hljs-comment"># 0.75</span>print(<span class="hljs-number">3</span> // <span class="hljs-number">4</span>)  <span class="hljs-comment"># 0</span>print(<span class="hljs-number">3</span> % <span class="hljs-number">4</span>)  <span class="hljs-comment"># 3</span>print(<span class="hljs-number">2</span> ** <span class="hljs-number">3</span>)  <span class="hljs-comment"># 8</span></code></pre><p><b>比较运算符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>&gt;</code></td><td style="text-align:center">大于</td><td style="text-align:center"><code>2 &gt; 1</code></td></tr><tr><td style="text-align:center"><code>&gt;=</code></td><td style="text-align:center">大于等于</td><td style="text-align:center"><code>2 &gt;= 4</code></td></tr><tr><td style="text-align:center"><code>&lt;</code></td><td style="text-align:center">小于</td><td style="text-align:center"><code>1 &lt; 2</code></td></tr><tr><td style="text-align:center"><code>&lt;=</code></td><td style="text-align:center">小于等于</td><td style="text-align:center"><code>5 &lt;= 2</code></td></tr><tr><td style="text-align:center"><code>==</code></td><td style="text-align:center">等于</td><td style="text-align:center"><code>3 == 4</code></td></tr><tr><td style="text-align:center"><code>!=</code></td><td style="text-align:center">不等于</td><td style="text-align:center"><code>3 != 5</code></td></tr></tbody></table></div><p>【例子】</p><pre><code class="hljs python">print(<span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span>)  <span class="hljs-comment"># True</span>print(<span class="hljs-number">2</span> &gt;= <span class="hljs-number">4</span>)  <span class="hljs-comment"># False</span>print(<span class="hljs-number">1</span> &lt; <span class="hljs-number">2</span>)  <span class="hljs-comment"># True</span>print(<span class="hljs-number">5</span> &lt;= <span class="hljs-number">2</span>)  <span class="hljs-comment"># False</span>print(<span class="hljs-number">3</span> == <span class="hljs-number">4</span>)  <span class="hljs-comment"># False</span>print(<span class="hljs-number">3</span> != <span class="hljs-number">5</span>)  <span class="hljs-comment"># True</span></code></pre><p><b>逻辑运算符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>and</code></td><td style="text-align:center">与</td><td style="text-align:center"><code>(3 &gt; 2) and (3 &lt; 5)</code></td></tr><tr><td style="text-align:center"><code>or</code></td><td style="text-align:center">或</td><td style="text-align:center"><code>(1 &gt; 3) or (9 &lt; 2)</code></td></tr><tr><td style="text-align:center"><code>not</code></td><td style="text-align:center">非</td><td style="text-align:center"><code>not (2 &gt; 1)</code></td></tr></tbody></table></div><p>【例子】</p><pre><code class="hljs python">print((<span class="hljs-number">3</span> &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">and</span> (<span class="hljs-number">3</span> &lt; <span class="hljs-number">5</span>))  <span class="hljs-comment"># True</span>print((<span class="hljs-number">1</span> &gt; <span class="hljs-number">3</span>) <span class="hljs-keyword">or</span> (<span class="hljs-number">9</span> &lt; <span class="hljs-number">2</span>))  <span class="hljs-comment"># False</span>print(<span class="hljs-keyword">not</span> (<span class="hljs-number">2</span> &gt; <span class="hljs-number">1</span>))  <span class="hljs-comment"># False</span></code></pre><p><b>位运算符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>~</code></td><td style="text-align:center">按位取反</td><td style="text-align:center"><code>~4</code></td></tr><tr><td style="text-align:center"><code>&amp;</code></td><td style="text-align:center">按位与</td><td style="text-align:center"><code>4 &amp; 5</code></td></tr><tr><td style="text-align:center">`</td><td style="text-align:center">`</td><td style="text-align:center">按位或</td><td>`4</td><td>5`</td></tr><tr><td style="text-align:center"><code>^</code></td><td style="text-align:center">按位异或</td><td style="text-align:center"><code>4 ^ 5</code></td></tr><tr><td style="text-align:center"><code>&lt;&lt;</code></td><td style="text-align:center">左移</td><td style="text-align:center"><code>4 &lt;&lt; 2</code></td></tr><tr><td style="text-align:center"><code>&gt;&gt;</code></td><td style="text-align:center">右移</td><td style="text-align:center"><code>4 &gt;&gt; 2</code></td></tr></tbody></table></div><p>【例子】有关二进制的运算，参见“位运算”部分的讲解。</p><pre><code class="hljs python">print(bin(<span class="hljs-number">4</span>))  <span class="hljs-comment"># 0b100</span>print(bin(<span class="hljs-number">5</span>))  <span class="hljs-comment"># 0b101</span>print(bin(~<span class="hljs-number">4</span>), ~<span class="hljs-number">4</span>)  <span class="hljs-comment"># -0b101 -5</span>print(bin(<span class="hljs-number">4</span> &amp; <span class="hljs-number">5</span>), <span class="hljs-number">4</span> &amp; <span class="hljs-number">5</span>)  <span class="hljs-comment"># 0b100 4</span>print(bin(<span class="hljs-number">4</span> | <span class="hljs-number">5</span>), <span class="hljs-number">4</span> | <span class="hljs-number">5</span>)  <span class="hljs-comment"># 0b101 5</span>print(bin(<span class="hljs-number">4</span> ^ <span class="hljs-number">5</span>), <span class="hljs-number">4</span> ^ <span class="hljs-number">5</span>)  <span class="hljs-comment"># 0b1 1</span>print(bin(<span class="hljs-number">4</span> &lt;&lt; <span class="hljs-number">2</span>), <span class="hljs-number">4</span> &lt;&lt; <span class="hljs-number">2</span>)  <span class="hljs-comment"># 0b10000 16</span>print(bin(<span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">2</span>), <span class="hljs-number">4</span> &gt;&gt; <span class="hljs-number">2</span>)  <span class="hljs-comment"># 0b1 1</span></code></pre><p><b>三元运算符</b></p><p>【例子】</p><pre><code class="hljs python">x, y = <span class="hljs-number">4</span>, <span class="hljs-number">5</span><span class="hljs-keyword">if</span> x &lt; y:    small = x<span class="hljs-keyword">else</span>:    small = yprint(small)  <span class="hljs-comment"># 4</span></code></pre><p>有了这个三元操作符的条件表达式，你可以使用一条语句来完成以上的条件判断和赋值操作。</p><p>【例子】</p><pre><code class="hljs python">x, y = <span class="hljs-number">4</span>, <span class="hljs-number">5</span>small = x <span class="hljs-keyword">if</span> x &lt; y <span class="hljs-keyword">else</span> yprint(small)  <span class="hljs-comment"># 4</span></code></pre><p><b>其他运算符</b></p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center"><code>in</code></td><td style="text-align:center">存在</td><td style="text-align:center"><code>&#39;A&#39; in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></td></tr><tr><td style="text-align:center"><code>not in</code></td><td style="text-align:center">不存在</td><td style="text-align:center"><code>&#39;h&#39; not in [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</code></td></tr><tr><td style="text-align:center"><code>is</code></td><td style="text-align:center">是</td><td style="text-align:center"><code>&quot;hello&quot; is &quot;hello&quot;</code></td></tr><tr><td style="text-align:center"><code>is not</code></td><td style="text-align:center">不是</td><td style="text-align:center"><code>&quot;hello&quot; is not &quot;hello&quot;</code></td></tr></tbody></table></div><p>【例子】</p><pre><code class="hljs python">letters = [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>]<span class="hljs-keyword">if</span> <span class="hljs-string">'A'</span> <span class="hljs-keyword">in</span> letters:    print(<span class="hljs-string">'A'</span> + <span class="hljs-string">' exists'</span>)<span class="hljs-keyword">if</span> <span class="hljs-string">'h'</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> letters:    print(<span class="hljs-string">'h'</span> + <span class="hljs-string">' not exists'</span>)<span class="hljs-comment"># A exists</span><span class="hljs-comment"># h not exists</span></code></pre><p>【例子】比较的两个变量均指向不可变类型。</p><pre><code class="hljs python">a = <span class="hljs-string">"hello"</span>b = <span class="hljs-string">"hello"</span>print(a <span class="hljs-keyword">is</span> b, a == b)  <span class="hljs-comment"># True True</span>print(a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> b, a != b)  <span class="hljs-comment"># False False</span>print(id(a)) <span class="hljs-comment"># 2085367637744</span>print(id(b)) <span class="hljs-comment"># 2085367637744</span></code></pre><p>【例子】比较的两个变量均指向可变类型。</p><pre><code class="hljs python">a = [<span class="hljs-string">"hello"</span>]b = [<span class="hljs-string">"hello"</span>]print(a <span class="hljs-keyword">is</span> b, a == b)  <span class="hljs-comment"># False True</span>print(a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> b, a != b)  <span class="hljs-comment"># True False</span>print(id(a)) <span class="hljs-comment"># 2085336762952</span>print(id(b)) <span class="hljs-comment"># 2085340033544</span></code></pre><p>【例子】比较的两个变量均指向可变类型。</p><pre><code class="hljs python">e = dprint(e <span class="hljs-keyword">is</span> d, e == d) <span class="hljs-comment"># True True</span>print(e <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> d, e != d) <span class="hljs-comment"># False False</span></code></pre><p>注意：</p><ul><li>is, is not 对比的是两个变量的内存地址</li><li>==, != 对比的是两个变量的值</li><li>比较的两个变量，指向的都是地址不可变的类型（str等），那么is，is not 和 ==，！= 是完全等价的。<ul><li>通常，具有相同值的不可变对象在默认情况下具有相同的id。例如，数字-5到256在CPython中被保存，每个数字都存储在内存中单一且固定的位置，这为常用整数节省了内存。(可使用id()查看内存地址)</li></ul></li><li>对比的两个变量，指向的是地址可变的类型（list，dict，tuple等），则两者是有区别的。<ul><li>可变对象一般具有不同的id。除非是一个对象引用另一个对象，此时is的结果为True。</li></ul></li></ul><p><b>运算符的优先级</b></p><ul><li>一元运算符优于二元运算符。例如<code>3 ** -2</code>等价于<code>3 ** (-2)</code>。</li><li>先算术运算，后移位运算，最后位运算。例如 <code>1 &lt;&lt; 3 + 2 &amp; 7</code>等价于 <code>(1 &lt;&lt; (3 + 2)) &amp; 7</code>。</li><li>逻辑运算最后结合。例如<code>3 &lt; 4 and 4 &lt; 5</code>等价于<code>(3 &lt; 4) and (4 &lt; 5)</code>。</li></ul><p>【例子】</p><pre><code class="hljs python">print(<span class="hljs-number">-3</span> ** <span class="hljs-number">2</span>)  <span class="hljs-comment"># -9</span>print(<span class="hljs-number">3</span> ** <span class="hljs-number">-2</span>)  <span class="hljs-comment"># 0.1111111111111111</span>print(<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span> + <span class="hljs-number">2</span> &amp; <span class="hljs-number">7</span>)  <span class="hljs-comment"># 0</span>print(<span class="hljs-number">-3</span> * <span class="hljs-number">2</span> + <span class="hljs-number">5</span> / <span class="hljs-number">-2</span> - <span class="hljs-number">4</span>)  <span class="hljs-comment"># -12.5</span>print(<span class="hljs-number">3</span> &lt; <span class="hljs-number">4</span> <span class="hljs-keyword">and</span> <span class="hljs-number">4</span> &lt; <span class="hljs-number">5</span>)  <span class="hljs-comment"># True</span></code></pre><h2 id="3-变量和赋值"><a href="#3-变量和赋值" class="headerlink" title="3. 变量和赋值"></a>3. 变量和赋值</h2><ul><li>在使用变量之前，需要对其先赋值。</li><li>变量名可以包括字母、数字、下划线、但变量名不能以数字开头。</li><li>Python 变量名是大小写敏感的，foo != Foo。</li></ul><p>【例子】</p><pre><code class="hljs python">teacher = <span class="hljs-string">"hey, bro"</span>print(teacher)  <span class="hljs-comment"># hey, bro</span></code></pre><p>【例子】</p><pre><code class="hljs python">first = <span class="hljs-number">2</span>second = <span class="hljs-number">3</span>third = first + secondprint(third)  <span class="hljs-comment"># 5</span></code></pre><p>【例子】</p><pre><code class="hljs python">myTeacher = <span class="hljs-string">"老马"</span>yourTeacher = <span class="hljs-string">"小马"</span>ourTeacher = myTeacher + <span class="hljs-string">','</span> + yourTeacherprint(ourTeacher)  <span class="hljs-comment"># 老马,小马</span></code></pre><h2 id="4-数据类型与转换"><a href="#4-数据类型与转换" class="headerlink" title="4. 数据类型与转换"></a>4. 数据类型与转换</h2><div class="table-container"><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">名称</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">整型 <code>&lt;class &#39;int&#39;&gt;</code></td><td style="text-align:center"><code>-876, 10</code></td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">浮点型<code>&lt;class &#39;float&#39;&gt;</code></td><td style="text-align:center"><code>3.149, 11.11</code></td></tr><tr><td style="text-align:center">bool</td><td style="text-align:center">布尔型<code>&lt;class &#39;bool&#39;&gt;</code></td><td style="text-align:center"><code>True, False</code></td></tr></tbody></table></div><p><b>整型</b></p><p>【例子】通过 <code>print()</code> 可看出 <code>a</code> 的值，以及类 (class) 是<code>int</code>。</p><pre><code class="hljs python">a = <span class="hljs-number">1031</span>print(a, type(a))<span class="hljs-comment"># 1031 &lt;class 'int'&gt;</span></code></pre><p>Python 里面万物皆对象（object），整型也不例外，只要是对象，就有相应的属性 （attributes） 和方法（methods）。</p><p>【例子】</p><pre><code class="hljs python">b = dir(int)print(b)<span class="hljs-comment"># ['__abs__', '__add__', '__and__', '__bool__', '__ceil__', '__class__',</span><span class="hljs-comment"># '__delattr__', '__dir__', '__divmod__', '__doc__', '__eq__',</span><span class="hljs-comment"># '__float__', '__floor__', '__floordiv__', '__format__', '__ge__',</span><span class="hljs-comment"># '__getattribute__', '__getnewargs__', '__gt__', '__hash__',</span><span class="hljs-comment"># '__index__', '__init__', '__init_subclass__', '__int__', '__invert__',</span><span class="hljs-comment"># '__le__', '__lshift__', '__lt__', '__mod__', '__mul__', '__ne__',</span><span class="hljs-comment"># '__neg__', '__new__', '__or__', '__pos__', '__pow__', '__radd__',</span><span class="hljs-comment"># '__rand__', '__rdivmod__', '__reduce__', '__reduce_ex__', '__repr__',</span><span class="hljs-comment"># '__rfloordiv__', '__rlshift__', '__rmod__', '__rmul__', '__ror__',</span><span class="hljs-comment"># '__round__', '__rpow__', '__rrshift__', '__rshift__', '__rsub__',</span><span class="hljs-comment"># '__rtruediv__', '__rxor__', '__setattr__', '__sizeof__', '__str__',</span><span class="hljs-comment"># '__sub__', '__subclasshook__', '__truediv__', '__trunc__', '__xor__',</span><span class="hljs-comment"># 'bit_length', 'conjugate', 'denominator', 'from_bytes', 'imag',</span><span class="hljs-comment"># 'numerator', 'real', 'to_bytes']</span></code></pre><p>对它们有个大概印象就可以了，具体怎么用，需要哪些参数 （argument），还需要查文档。看个<code>bit_length()</code>的例子。</p><p>【例子】找到一个整数的二进制表示，再返回其长度。</p><pre><code class="hljs python">a = <span class="hljs-number">1031</span>print(bin(a))  <span class="hljs-comment"># 0b10000000111</span>print(a.bit_length())  <span class="hljs-comment"># 11</span></code></pre><p><b>浮点型</b></p><p>【例子】</p><pre><code class="hljs python">print(<span class="hljs-number">1</span>, type(<span class="hljs-number">1</span>))<span class="hljs-comment"># 1 &lt;class 'int'&gt;</span>print(<span class="hljs-number">1.</span>, type(<span class="hljs-number">1.</span>))<span class="hljs-comment"># 1.0 &lt;class 'float'&gt;</span>a = <span class="hljs-number">0.00000023</span>b = <span class="hljs-number">2.3e-7</span>print(a)  <span class="hljs-comment"># 2.3e-07</span>print(b)  <span class="hljs-comment"># 2.3e-07</span></code></pre><p>有时候我们想保留浮点型的小数点后 <code>n</code> 位。可以用 <code>decimal</code> 包里的 <code>Decimal</code> 对象和 <code>getcontext()</code> 方法来实现。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> decimal<span class="hljs-keyword">from</span> decimal <span class="hljs-keyword">import</span> Decimal</code></pre><p>Python 里面有很多用途广泛的包 (package)，用什么你就引进 (import) 什么。包也是对象，也可以用上面提到的<code>dir(decimal)</code> 来看其属性和方法。</p><p>【例子】<code>getcontext()</code> 显示了 <code>Decimal</code> 对象的默认精度值是 28 位 (<code>prec=28</code>)。</p><pre><code class="hljs python">a = decimal.getcontext()print(a)<span class="hljs-comment"># Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999,</span><span class="hljs-comment"># capitals=1, clamp=0, flags=[], </span><span class="hljs-comment"># traps=[InvalidOperation, DivisionByZero, Overflow])</span></code></pre><pre><code class="hljs python">b = Decimal(<span class="hljs-number">1</span>) / Decimal(<span class="hljs-number">3</span>)print(b)<span class="hljs-comment"># 0.3333333333333333333333333333</span></code></pre><p>【例子】使 1/3 保留 4 位，用 <code>getcontext().prec</code> 来调整精度。</p><pre><code class="hljs python">decimal.getcontext().prec = <span class="hljs-number">4</span>c = Decimal(<span class="hljs-number">1</span>) / Decimal(<span class="hljs-number">3</span>)print(c)<span class="hljs-comment"># 0.3333</span></code></pre><p><b>布尔型</b></p><p>布尔 (boolean) 型变量只能取两个值，<code>True</code> 和 <code>False</code>。当把布尔型变量用在数字运算中，用 <code>1</code> 和 <code>0</code> 代表 <code>True</code> 和 <code>False</code>。</p><p>【例子】</p><pre><code class="hljs python">print(<span class="hljs-literal">True</span> + <span class="hljs-literal">True</span>)  <span class="hljs-comment"># 2</span>print(<span class="hljs-literal">True</span> + <span class="hljs-literal">False</span>)  <span class="hljs-comment"># 1</span>print(<span class="hljs-literal">True</span> * <span class="hljs-literal">False</span>)  <span class="hljs-comment"># 0</span></code></pre><p>除了直接给变量赋值 <code>True</code> 和 <code>False</code>，还可以用 <code>bool(X)</code> 来创建变量，其中 <code>X</code> 可以是</p><ul><li>基本类型：整型、浮点型、布尔型</li><li>容器类型：字符串、元组、列表、字典和集合</li></ul><p>【例子】<code>bool</code> 作用在基本类型变量：<code>X</code> 只要不是整型 <code>0</code>、浮点型 <code>0.0</code>，<code>bool(X)</code> 就是 <code>True</code>，其余就是 <code>False</code>。</p><pre><code class="hljs python">print(type(<span class="hljs-number">0</span>), bool(<span class="hljs-number">0</span>), bool(<span class="hljs-number">1</span>))<span class="hljs-comment"># &lt;class 'int'&gt; False True</span>print(type(<span class="hljs-number">10.31</span>), bool(<span class="hljs-number">0.00</span>), bool(<span class="hljs-number">10.31</span>))<span class="hljs-comment"># &lt;class 'float'&gt; False True</span>print(type(<span class="hljs-literal">True</span>), bool(<span class="hljs-literal">False</span>), bool(<span class="hljs-literal">True</span>))<span class="hljs-comment"># &lt;class 'bool'&gt; False True</span></code></pre><p>【例子】<code>bool</code> 作用在容器类型变量：<code>X</code> 只要不是空的变量，<code>bool(X)</code> 就是 <code>True</code>，其余就是 <code>False</code>。</p><pre><code class="hljs python">print(type(<span class="hljs-string">''</span>), bool(<span class="hljs-string">''</span>), bool(<span class="hljs-string">'python'</span>))<span class="hljs-comment"># &lt;class 'str'&gt; False True</span>print(type(()), bool(()), bool((<span class="hljs-number">10</span>,)))<span class="hljs-comment"># &lt;class 'tuple'&gt; False True</span>print(type([]), bool([]), bool([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]))<span class="hljs-comment"># &lt;class 'list'&gt; False True</span>print(type(&#123;&#125;), bool(&#123;&#125;), bool(&#123;<span class="hljs-string">'a'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'b'</span>: <span class="hljs-number">2</span>&#125;))<span class="hljs-comment"># &lt;class 'dict'&gt; False True</span>print(type(set()), bool(set()), bool(&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;))<span class="hljs-comment"># &lt;class 'set'&gt; False True</span></code></pre><p>确定<code>bool(X)</code> 的值是 <code>True</code> 还是 <code>False</code>，就看 <code>X</code> 是不是空，空的话就是 <code>False</code>，不空的话就是 <code>True</code>。</p><ul><li>对于数值变量，<code>0</code>, <code>0.0</code> 都可认为是空的。</li><li>对于容器变量，里面没元素就是空的。</li></ul><p><b>获取类型信息</b></p><ul><li>获取类型信息 <code>type(object)</code></li></ul><p>【例子】</p><pre><code class="hljs python">print(type(<span class="hljs-number">1</span>))  <span class="hljs-comment"># &lt;class 'int'&gt;</span>print(type(<span class="hljs-number">5.2</span>))  <span class="hljs-comment"># &lt;class 'float'&gt;</span>print(type(<span class="hljs-literal">True</span>))  <span class="hljs-comment"># &lt;class 'bool'&gt;</span>print(type(<span class="hljs-string">'5.2'</span>))  <span class="hljs-comment"># &lt;class 'str'&gt;</span></code></pre><ul><li>获取类型信息 <code>isinstance(object, classinfo)</code></li></ul><p>【例子】</p><pre><code class="hljs python">print(isinstance(<span class="hljs-number">1</span>, int))  <span class="hljs-comment"># True</span>print(isinstance(<span class="hljs-number">5.2</span>, float))  <span class="hljs-comment"># True</span>print(isinstance(<span class="hljs-literal">True</span>, bool))  <span class="hljs-comment"># True</span>print(isinstance(<span class="hljs-string">'5.2'</span>, str))  <span class="hljs-comment"># True</span></code></pre><p>注：</p><ul><li><code>type()</code> 不会认为子类是一种父类类型，不考虑继承关系。</li><li><code>isinstance()</code> 会认为子类是一种父类类型，考虑继承关系。</li></ul><p>如果要判断两个类型是否相同推荐使用 <code>isinstance()</code>。</p><p><strong>类型转换</strong></p><ul><li>转换为整型 <code>int(x, base=10)</code></li><li>转换为字符串 <code>str(object=&#39;&#39;)</code></li><li>转换为浮点型 <code>float(x)</code></li><li>转换为布尔型 <code>bool(x)</code></li></ul><p>【例子】</p><pre><code class="hljs python">print(int(<span class="hljs-string">'520'</span>))  <span class="hljs-comment"># 520</span>print(int(<span class="hljs-number">520.52</span>))  <span class="hljs-comment"># 520</span>print(float(<span class="hljs-string">'520.52'</span>))  <span class="hljs-comment"># 520.52</span>print(float(<span class="hljs-number">520</span>))  <span class="hljs-comment"># 520.0</span>print(str(<span class="hljs-number">10</span> + <span class="hljs-number">10</span>))  <span class="hljs-comment"># 20</span>print(str(<span class="hljs-number">10.1</span> + <span class="hljs-number">5.2</span>))  <span class="hljs-comment"># 15.3</span>print(bool([])) <span class="hljs-comment"># False</span></code></pre><h2 id="5-print-函数"><a href="#5-print-函数" class="headerlink" title="5. print() 函数"></a>5. print() 函数</h2><pre><code class="hljs python">print(*objects, sep=<span class="hljs-string">' '</span>, end=<span class="hljs-string">'\n'</span>, file=sys.stdout, flush=<span class="hljs-literal">False</span>)</code></pre><ul><li>将对象以字符串表示的方式格式化输出到流文件对象file里。其中所有非关键字参数都按<code>str()</code>方式进行转换为字符串输出；</li><li>关键字参数<code>sep</code>是实现分隔符，比如多个参数输出时想要输出中间的分隔字符；</li><li>关键字参数<code>end</code>是输出结束时的字符，默认是换行符<code>\n</code>；</li><li>关键字参数<code>file</code>是定义流输出的文件，可以是标准的系统输出<code>sys.stdout</code>，也可以重定义为别的文件；</li><li>关键字参数<code>flush</code>是立即把内容输出到流文件，不作缓存。</li></ul><p>【例子】没有参数时，每次输出后都会换行。</p><pre><code class="hljs python">shoplist = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'mango'</span>, <span class="hljs-string">'carrot'</span>, <span class="hljs-string">'banana'</span>]print(<span class="hljs-string">"This is printed without 'end'and 'sep'."</span>)<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> shoplist:    print(item)<span class="hljs-comment"># This is printed without 'end'and 'sep'.</span><span class="hljs-comment"># apple</span><span class="hljs-comment"># mango</span><span class="hljs-comment"># carrot</span><span class="hljs-comment"># banana</span></code></pre><p>【例子】每次输出结束都用<code>end</code>设置的参数<code>&amp;</code>结尾，并没有默认换行。</p><pre><code class="hljs python">shoplist = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'mango'</span>, <span class="hljs-string">'carrot'</span>, <span class="hljs-string">'banana'</span>]print(<span class="hljs-string">"This is printed with 'end='&amp;''."</span>)<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> shoplist:    print(item, end=<span class="hljs-string">'&amp;'</span>)print(<span class="hljs-string">'hello world'</span>)<span class="hljs-comment"># This is printed with 'end='&amp;''.</span><span class="hljs-comment"># apple&amp;mango&amp;carrot&amp;banana&amp;hello world</span></code></pre><p>【例子】<code>item</code>值与<code>&#39;another string&#39;</code>两个值之间用<code>sep</code>设置的参数<code>&amp;</code>分割。由于<code>end</code>参数没有设置，因此默认是输出解释后换行，即<code>end</code>参数的默认值为<code>\n</code>。</p><pre><code class="hljs python">shoplist = [<span class="hljs-string">'apple'</span>, <span class="hljs-string">'mango'</span>, <span class="hljs-string">'carrot'</span>, <span class="hljs-string">'banana'</span>]print(<span class="hljs-string">"This is printed with 'sep='&amp;''."</span>)<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> shoplist:    print(item, <span class="hljs-string">'another string'</span>, sep=<span class="hljs-string">'&amp;'</span>)<span class="hljs-comment"># This is printed with 'sep='&amp;''.</span><span class="hljs-comment"># apple&amp;another string</span><span class="hljs-comment"># mango&amp;another string</span><span class="hljs-comment"># carrot&amp;another string</span><span class="hljs-comment"># banana&amp;another string</span></code></pre><hr><h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><ol><li><p>怎样对python中的代码进行注释？</p><h1 id="：单行注释"><a href="#：单行注释" class="headerlink" title="：单行注释"></a>：单行注释</h1><p><code>&#39;&#39;&#39; &#39;&#39;&#39;</code> 或者 <code>&quot;&quot;&quot; &quot;&quot;&quot;</code> ：区间注释，在三引号之间的所有内容被注释</p></li><li><p>python有哪些运算符，这些运算符的优先级是怎样的？</p><p><b>运算符的优先级</b></p><ul><li>一元运算符优于二元运算符。</li><li>先算术运算，后移位运算，最后位运算。</li><li>逻辑运算最后结合。</li></ul></li><li><p>python 中 <code>is</code>, <code>is not</code> 与 <code>==</code>, <code>!=</code> 的区别是什么？</p><p><code>is</code>，<code>is not</code>对比的是两个变量的内存地址</p><p><code>==</code>，<code>！=</code>对比的是两个变量的值</p></li><li><p>python 中包含哪些数据类型？这些数据类型之间如何转换？</p><p>数据类型：整型，浮点型，字符型，布尔型</p><p><strong>类型转换</strong></p><ul><li>转换为整型 <code>int(x, base=10)</code></li><li>转换为字符串 <code>str(object=&#39;&#39;)</code></li><li>转换为浮点型 <code>float(x)</code></li><li>转换为布尔型 <code>bool(x)</code></li></ul></li></ol><hr><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://github.com/datawhalechina/team-learning-program/blob/master/Python-Language/01. 变量、运算符与数据类型.md" target="_blank" rel="noopener">datawhale-01.变量、运算符与数据类型</a></li><li><a href="https://zhuanlan.zhihu.com/p/105849984" target="_blank" rel="noopener">【译】Python中的 !=与is not不同</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自然语言处理-新闻文本分类</title>
    <link href="/article/1ddf0dd3.html"/>
    <url>/article/1ddf0dd3.html</url>
    
    <content type="html"><![CDATA[<h2 id="赛题理解"><a href="#赛题理解" class="headerlink" title="赛题理解"></a>赛题理解</h2><ul><li>赛题名称：零基础入门NLP之新闻文本分类</li><li>赛题任务：赛题以自然语言处理为背景，要求选手对新闻文本进行分类，这是一个典型的字符识别问题。</li></ul><h3 id="赛题数据"><a href="#赛题数据" class="headerlink" title="赛题数据"></a>赛题数据</h3><p>赛题以匿名处理后的新闻数据为赛题数据，数据集报名后可见并可下载。赛题数据为新闻文本，并按照字符级别进行匿名处理。整合划分出14个候选分类类别：财经、彩票、房产、股票、家居、教育、科技、社会、时尚、时政、体育、星座、游戏、娱乐的文本数据。</p><p>赛题数据由以下几个部分构成：训练集20w条样本，测试集A包括5w条样本，测试集B包括5w条样本。为了预防选手人工标注测试集的情况，我们将比赛数据的文本按照字符级别进行了匿名处理。</p><h3 id="数据标签"><a href="#数据标签" class="headerlink" title="数据标签"></a>数据标签</h3><p>处理后的赛题训练数据如下：</p><div class="table-container"><table><thead><tr><th>label</th><th>text</th></tr></thead><tbody><tr><td>6</td><td>57 44 66 56 2 3 3 37 5 41 9 57 44 47 45 33 13 63 58 31 17 47 0 1 1 69 26 60 62 15 21 12 49 18 38 20 50 23 57 44 45 33 25 28 47 22 52 35 30 14 24 69 54 7 48 19 11 51 16 43 26 34 53 27 64 8 4 42 36 46 65 69 29 39 15 37 57 44 45 33 69 54 7 25 40 35 30 66 56 47 55 69 61 10 60 42 36 46 65 37 5 41 32 67 6 59 47 0 1 1 68</td></tr></tbody></table></div><p>在数据集中标签的对应的关系如下：{‘科技’: 0, ‘股票’: 1, ‘体育’: 2, ‘娱乐’: 3, ‘时政’: 4, ‘社会’: 5, ‘教育’: 6, ‘财经’: 7, ‘家居’: 8, ‘游戏’: 9, ‘房产’: 10, ‘时尚’: 11, ‘彩票’: 12, ‘星座’: 13}</p><h3 id="评测指标"><a href="#评测指标" class="headerlink" title="评测指标"></a>评测指标</h3><p>评价标准为类别<code>f1_score</code>的均值，选手提交结果与实际测试集的类别进行对比，结果越大越好。</p><h3 id="数据读取"><a href="#数据读取" class="headerlink" title="数据读取"></a>数据读取</h3><p>使用<code>Pandas</code>库完成数据读取操作，并对赛题数据进行分析。</p><h2 id="数据读取与数据分析"><a href="#数据读取与数据分析" class="headerlink" title="数据读取与数据分析"></a>数据读取与数据分析</h2><p>本章主要内容为数据读取和数据分析，具体使用<code>Pandas</code>库完成数据读取操作，并对赛题数据进行分析构成。</p><h3 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>学习使用<code>Pandas</code>读取赛题数据</li><li>分析赛题数据的分布规律</li></ul><h3 id="数据读取-1"><a href="#数据读取-1" class="headerlink" title="数据读取"></a>数据读取</h3><p>赛题数据虽然是文本数据，每个新闻是不定长的，但任然使用csv格式进行存储。因此可以直接用<code>Pandas</code>完成数据读取的操作。</p><pre><code class="hljs reasonml">import pandas <span class="hljs-keyword">as</span> pdtrain_df = pd.read<span class="hljs-constructor">_csv('..<span class="hljs-operator">/</span><span class="hljs-params">input</span><span class="hljs-operator">/</span><span class="hljs-params">train_set</span>.<span class="hljs-params">csv</span>', <span class="hljs-params">sep</span>='\<span class="hljs-params">t</span>', <span class="hljs-params">nrows</span>=100)</span></code></pre><p>这里的<code>read_csv</code>由三部分构成：</p><ul><li>读取的文件路径，这里需要根据改成你本地的路径，可以使用相对路径或绝对路径；</li><li>分隔符<code>sep</code>，为每列分割的字符，设置为<code>\t</code>即可；</li><li>读取行数<code>nrows</code>，为此次读取文件的函数，是数值类型（由于数据集比较大，建议先设置为100）；</li></ul><p><a href="https://camo.githubusercontent.com/3cfb75e212d4e8259de4c4151e52b405dbe256de/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333733303733392e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/3cfb75e212d4e8259de4c4151e52b405dbe256de/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333733303733392e706e67" srcset="/img/loading.gif" alt="task2_train_head"></a></p><p>上图是读取好的数据，是表格的形式。第一列为新闻的类别，第二列为新闻的字符。</p><h3 id="数据分析"><a href="#数据分析" class="headerlink" title="数据分析"></a>数据分析</h3><p>在读取完成数据集后，我们还可以对数据集进行数据分析的操作。虽然对于非结构数据并不需要做很多的数据分析，但通过数据分析还是可以找出一些规律的。</p><p>此步骤我们读取了所有的训练集数据，在此我们通过数据分析希望得出以下结论：</p><ul><li>赛题数据中，新闻文本的长度是多少？</li><li>赛题数据的类别分布是怎么样的，哪些类别比较多？</li><li>赛题数据中，字符分布是怎么样的？</li></ul><h4 id="句子长度分析"><a href="#句子长度分析" class="headerlink" title="句子长度分析"></a>句子长度分析</h4><p>在赛题数据中每行句子的字符使用空格进行隔开，所以可以直接统计单词的个数来得到每个句子的长度。统计并如下：</p><pre><code class="hljs sas"><span class="hljs-name">%pylab</span> inlinetrain_df[<span class="hljs-string">'text_len'</span>] = train_df[<span class="hljs-string">'text'</span>].apply(lambda <span class="hljs-meta">x</span>: l<span class="hljs-meta">en(</span><span class="hljs-meta">x</span>.split(<span class="hljs-string">' '</span>)))p<span class="hljs-meta">rint(</span>train_df[<span class="hljs-string">'text_len'</span>].<span class="hljs-meta">describe</span>())</code></pre><p>输出结果为：</p><pre><code class="hljs yaml"><span class="hljs-string">Populating</span> <span class="hljs-string">the</span> <span class="hljs-string">interactive</span> <span class="hljs-string">namespace</span> <span class="hljs-string">from</span> <span class="hljs-string">numpy</span> <span class="hljs-string">and</span> <span class="hljs-string">matplotlib</span><span class="hljs-string">count</span>    <span class="hljs-number">200000.000000</span><span class="hljs-string">mean</span>        <span class="hljs-number">907.207110</span><span class="hljs-string">std</span>         <span class="hljs-number">996.029036</span><span class="hljs-string">min</span>           <span class="hljs-number">2.000000</span><span class="hljs-number">25</span><span class="hljs-string">%</span>         <span class="hljs-number">374.000000</span><span class="hljs-number">50</span><span class="hljs-string">%</span>         <span class="hljs-number">676.000000</span><span class="hljs-number">75</span><span class="hljs-string">%</span>        <span class="hljs-number">1131.000000</span><span class="hljs-string">max</span>       <span class="hljs-number">57921.000000</span><span class="hljs-attr">Name:</span> <span class="hljs-string">text_len,</span> <span class="hljs-attr">dtype:</span> <span class="hljs-string">float64</span></code></pre><p>对新闻句子的统计可以得出，本次赛题给定的文本比较长，每个句子平均由907个字符构成，最短的句子长度为2，最长的句子长度为57921。</p><p>下图将句子长度绘制了直方图，可见大部分句子的长度都几种在2000以内。</p><pre><code class="hljs routeros">_ = plt.hist(train_df[<span class="hljs-string">'text_len'</span>], <span class="hljs-attribute">bins</span>=200)plt.xlabel(<span class="hljs-string">'Text char count'</span>)plt.title(<span class="hljs-string">"Histogram of char count"</span>)</code></pre><p><a href="https://camo.githubusercontent.com/656471f35c5df332c6ca027756cfd048324e5727/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333833363930352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/656471f35c5df332c6ca027756cfd048324e5727/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333833363930352e706e67" srcset="/img/loading.gif" alt="task2_char_hist"></a></p><h4 id="新闻类别分布"><a href="#新闻类别分布" class="headerlink" title="新闻类别分布"></a>新闻类别分布</h4><p>接下来可以对数据集的类别进行分布统计，具体统计每类新闻的样本个数。</p><pre><code class="hljs less"><span class="hljs-selector-tag">train_df</span><span class="hljs-selector-attr">['label']</span><span class="hljs-selector-class">.value_counts</span>()<span class="hljs-selector-class">.plot</span>(kind=<span class="hljs-string">'bar'</span>)<span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.title</span>(<span class="hljs-string">'News class count'</span>)<span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.xlabel</span>(<span class="hljs-string">"category"</span>)</code></pre><p><a href="https://camo.githubusercontent.com/ea8ab6a105f74fa197f29cb09e5dfd97ae6a573e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333932393239362e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/ea8ab6a105f74fa197f29cb09e5dfd97ae6a573e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333932393239362e706e67" srcset="/img/loading.gif" alt="task2_class_hist"></a></p><p>在数据集中标签的对应的关系如下：{‘科技’: 0, ‘股票’: 1, ‘体育’: 2, ‘娱乐’: 3, ‘时政’: 4, ‘社会’: 5, ‘教育’: 6, ‘财经’: 7, ‘家居’: 8, ‘游戏’: 9, ‘房产’: 10, ‘时尚’: 11, ‘彩票’: 12, ‘星座’: 13}</p><p>从统计结果可以看出，赛题的数据集类别分布存在较为不均匀的情况。在训练集中科技类新闻最多，其次是股票类新闻，最少的新闻是星座新闻。</p><h4 id="字符分布统计"><a href="#字符分布统计" class="headerlink" title="字符分布统计"></a>字符分布统计</h4><p>接下来可以统计每个字符出现的次数，首先可以将训练集中所有的句子进行拼接进而划分为字符，并统计每个字符的个数。</p><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> collections import Counterall_lines = <span class="hljs-string">' '</span>.join(list(train_df[<span class="hljs-string">'text'</span>]))word_count = Counter(all_lines.split(<span class="hljs-string">" "</span>))word_count = sorted(word_count.items(), <span class="hljs-attribute">key</span>=lambda d:d[1], reverse = <span class="hljs-literal">True</span>)<span class="hljs-builtin-name">print</span>(len(word_count))<span class="hljs-comment"># 6869</span><span class="hljs-builtin-name">print</span>(word_count[0])<span class="hljs-comment"># ('3750', 7482224)</span><span class="hljs-builtin-name">print</span>(word_count[-1])<span class="hljs-comment"># ('3133', 1)</span></code></pre><p>从统计结果中可以看出，在训练集中总共包括6869个字，其中编号3750的字出现的次数最多，编号3133的字出现的次数最少。</p><p>这里还可以根据字在每个句子的出现情况，反推出标点符号。下面代码统计了不同字符在句子中出现的次数，其中字符3750，字符900和字符648在20w新闻的覆盖率接近99%，很有可能是标点符号。</p><pre><code class="hljs vim">train_df[<span class="hljs-string">'text_unique'</span>] = train_df[<span class="hljs-string">'text'</span>].apply(lambda <span class="hljs-keyword">x</span>: <span class="hljs-string">' '</span>.<span class="hljs-keyword">join</span>(<span class="hljs-keyword">list</span>(<span class="hljs-keyword">set</span>(<span class="hljs-keyword">x</span>.<span class="hljs-keyword">split</span>(<span class="hljs-string">' '</span>)))))all_lines = <span class="hljs-string">' '</span>.<span class="hljs-keyword">join</span>(<span class="hljs-keyword">list</span>(train_df[<span class="hljs-string">'text_unique'</span>]))word_count = Counter(all_lines.<span class="hljs-keyword">split</span>(<span class="hljs-string">" "</span>))word_count = sorted(word_count.<span class="hljs-built_in">items</span>(), key=lambda d:<span class="hljs-keyword">int</span>(d[<span class="hljs-number">1</span>]), <span class="hljs-built_in">reverse</span> = True)<span class="hljs-keyword">print</span>(word_count[<span class="hljs-number">0</span>])# (<span class="hljs-string">'3750'</span>, <span class="hljs-number">197997</span>)<span class="hljs-keyword">print</span>(word_count[<span class="hljs-number">1</span>])# (<span class="hljs-string">'900'</span>, <span class="hljs-number">197653</span>)<span class="hljs-keyword">print</span>(word_count[<span class="hljs-number">2</span>])# (<span class="hljs-string">'648'</span>, <span class="hljs-number">191975</span>)</code></pre><h3 id="数据分析的结论"><a href="#数据分析的结论" class="headerlink" title="数据分析的结论"></a>数据分析的结论</h3><p>通过上述分析我们可以得出以下结论：</p><ol><li>赛题中每个新闻包含的字符个数平均为1000个，还有一些新闻字符较长；</li><li>赛题中新闻类别分布不均匀，科技类新闻样本量接近4w，星座类新闻样本量不到1k；</li><li>赛题总共包括7000-8000个字符；</li></ol><p>通过数据分析，我们还可以得出以下结论：</p><ol><li>每个新闻平均字符个数较多，可能需要截断；</li><li>由于类别不均衡，会严重影响模型的精度；</li></ol><h3 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章对赛题数据进行读取，并新闻句子长度、类别和字符进行了可视化分析。</p><h3 id="本章作业"><a href="#本章作业" class="headerlink" title="本章作业"></a>本章作业</h3><ol><li>假设字符3750，字符900和字符648是句子的标点符号，请分析赛题每篇新闻平均由多少个句子构成？</li><li>统计每类新闻中出现次数对多的字符</li></ol><h1 id="基于机器学习的文本分类"><a href="#基于机器学习的文本分类" class="headerlink" title="基于机器学习的文本分类"></a>基于机器学习的文本分类</h1><p>在上一章节，我们对赛题的数据进行了读取，并在末尾给出了两个小作业。如果你顺利完成了作业，那么你基本上对<code>Python</code>也比较熟悉了。在本章我们将使用传统机器学习算法来完成新闻分类的过程，将会结束到赛题的核心知识点。</p><h2 id="基于机器学习的文本分类-1"><a href="#基于机器学习的文本分类-1" class="headerlink" title="基于机器学习的文本分类"></a>基于机器学习的文本分类</h2><p>在本章我们将开始使用机器学习模型来解决文本分类。机器学习发展比较广，且包括多个分支，本章侧重使用传统机器学习，从下一章开始是基于深度学习的文本分类。</p><h3 id="学习目标-1"><a href="#学习目标-1" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>学会TF-IDF的原理和使用</li><li>使用sklearn的机器学习模型完成文本分类</li></ul><h3 id="机器学习模型"><a href="#机器学习模型" class="headerlink" title="机器学习模型"></a>机器学习模型</h3><p>机器学习是对能通过经验自动改进的计算机算法的研究。机器学习通过历史数据<strong>训练</strong>出<strong>模型</strong>对应于人类对经验进行<strong>归纳</strong>的过程，机器学习利用<strong>模型</strong>对新数据进行<strong>预测</strong>对应于人类利用总结的<strong>规律</strong>对新问题进行<strong>预测</strong>的过程。</p><p>机器学习有很多种分支，对于学习者来说应该优先掌握机器学习算法的分类，然后再其中一种机器学习算法进行学习。由于机器学习算法的分支和细节实在是太多，所以如果你一开始就被细节迷住了眼，你就很难知道全局是什么情况的。</p><p>如果你是机器学习初学者，你应该知道如下的事情：</p><ol><li>机器学习能解决一定的问题，但不能奢求机器学习是万能的；</li><li>机器学习算法有很多种，看具体问题需要什么，再来进行选择；</li><li>每种机器学习算法有一定的偏好，需要具体问题具体分析；</li></ol><p><a href="https://camo.githubusercontent.com/d8e9a12417a2a2a754a874af0ae163bb1bddbb0b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333232333235332e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d8e9a12417a2a2a754a874af0ae163bb1bddbb0b/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230333232333235332e6a7067" srcset="/img/loading.gif" alt="machine_learning_overview"></a></p><h3 id="文本表示方法-Part1"><a href="#文本表示方法-Part1" class="headerlink" title="文本表示方法 Part1"></a>文本表示方法 Part1</h3><p>在机器学习算法的训练过程中，假设给定$N$个样本，每个样本有$M$个特征，这样组成了$N×M$的样本矩阵，然后完成算法的训练和预测。同样的在计算机视觉中可以将图片的像素看作特征，每张图片看作hight×width×3的特征图，一个三维的矩阵来进入计算机进行计算。</p><p>但是在自然语言领域，上述方法却不可行：文本是不定长度的。文本表示成计算机能够运算的数字或向量的方法一般称为词嵌入（Word Embedding）方法。词嵌入将不定长的文本转换到定长的空间内，是文本分类的第一步。</p><h4 id="One-hot"><a href="#One-hot" class="headerlink" title="One-hot"></a>One-hot</h4><p>这里的One-hot与数据挖掘任务中的操作是一致的，即将每一个单词使用一个离散的向量表示。具体将每个字/词编码一个索引，然后根据索引进行赋值。</p><p>One-hot表示方法的例子如下：</p><pre><code class="hljs angelscript">句子<span class="hljs-number">1</span>：我 爱 北 京 天 安 门句子<span class="hljs-number">2</span>：我 喜 欢 上 海</code></pre><p>首先对所有句子的字进行索引，即将每个字确定一个编号：</p><pre><code class="hljs 1c">&#123;'我': <span class="hljs-number">1</span>, '爱': <span class="hljs-number">2</span>, '北': <span class="hljs-number">3</span>, '京': <span class="hljs-number">4</span>, '天': <span class="hljs-number">5</span>,  '安': <span class="hljs-number">6</span>, '门': <span class="hljs-number">7</span>, '喜': <span class="hljs-number">8</span>, '欢': <span class="hljs-number">9</span>, '上': <span class="hljs-number">10</span>, '海': <span class="hljs-number">11</span>&#125;</code></pre><p>在这里共包括11个字，因此每个字可以转换为一个11维度稀疏向量：</p><pre><code class="hljs angelscript">我：[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]爱：[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]...海：[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>]</code></pre><h4 id="Bag-of-Words"><a href="#Bag-of-Words" class="headerlink" title="Bag of Words"></a>Bag of Words</h4><p>Bag of Words（词袋表示），也称为Count Vectors，每个文档的字/词可以使用其出现次数来进行表示。</p><pre><code class="hljs angelscript">句子<span class="hljs-number">1</span>：我 爱 北 京 天 安 门句子<span class="hljs-number">2</span>：我 喜 欢 上 海</code></pre><p>直接统计每个字出现的次数，并进行赋值：</p><pre><code class="hljs angelscript">句子<span class="hljs-number">1</span>：我 爱 北 京 天 安 门转换为 [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]句子<span class="hljs-number">2</span>：我 喜 欢 上 海转换为 [<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>]</code></pre><p>在sklearn中可以直接<code>CountVectorizer</code>来实现这一步骤：</p><pre><code class="hljs vbnet"><span class="hljs-keyword">from</span> sklearn.feature_extraction.<span class="hljs-keyword">text</span> import CountVectorizercorpus = [    <span class="hljs-comment">'This is the first document.',</span>    <span class="hljs-comment">'This document is the second document.',</span>    <span class="hljs-comment">'And this is the third one.',</span>    <span class="hljs-comment">'Is this the first document?',</span>]vectorizer = CountVectorizer()vectorizer.fit_transform(corpus).toarray()</code></pre><h4 id="N-gram"><a href="#N-gram" class="headerlink" title="N-gram"></a>N-gram</h4><p>N-gram与Count Vectors类似，不过加入了相邻单词组合成为新的单词，并进行计数。</p><p>如果N取值为2，则句子1和句子2就变为：</p><pre><code class="hljs angelscript">句子<span class="hljs-number">1</span>：我爱 爱北 北京 京天 天安 安门句子<span class="hljs-number">2</span>：我喜 喜欢 欢上 上海</code></pre><h4 id="TF-IDF"><a href="#TF-IDF" class="headerlink" title="TF-IDF"></a>TF-IDF</h4><p>TF-IDF 分数由两部分组成：第一部分是<strong>词语频率</strong>（Term Frequency），第二部分是<strong>逆文档频率</strong>（Inverse Document Frequency）。其中计算语料库中文档总数除以含有该词语的文档数量，然后再取对数就是逆文档频率。</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">TF</span><span class="hljs-params">(t)</span></span>= 该词语在当前文档出现的次数 / 当前文档中词语的总数<span class="hljs-function"><span class="hljs-title">IDF</span><span class="hljs-params">(t)</span></span>= log_e（文档总数 / 出现该词语的文档总数）</code></pre><h3 id="基于机器学习的文本分类-2"><a href="#基于机器学习的文本分类-2" class="headerlink" title="基于机器学习的文本分类"></a>基于机器学习的文本分类</h3><p>接下来我们将对比不同文本表示算法的精度，通过本地构建验证集计算F1得分。</p><h4 id="Count-Vectors-RidgeClassifier"><a href="#Count-Vectors-RidgeClassifier" class="headerlink" title="Count Vectors + RidgeClassifier"></a>Count Vectors + RidgeClassifier</h4><pre><code class="hljs reasonml">import pandas <span class="hljs-keyword">as</span> pdfrom sklearn.feature_extraction.text import CountVectorizerfrom sklearn.linear_model import RidgeClassifierfrom sklearn.metrics import f1_scoretrain_df = pd.read<span class="hljs-constructor">_csv('..<span class="hljs-operator">/</span><span class="hljs-params">input</span><span class="hljs-operator">/</span><span class="hljs-params">train_set</span>.<span class="hljs-params">csv</span>', <span class="hljs-params">sep</span>='\<span class="hljs-params">t</span>', <span class="hljs-params">nrows</span>=15000)</span>vectorizer = <span class="hljs-constructor">CountVectorizer(<span class="hljs-params">max_features</span>=3000)</span>train_test = vectorizer.fit<span class="hljs-constructor">_transform(<span class="hljs-params">train_df</span>['<span class="hljs-params">text</span>'])</span>clf = <span class="hljs-constructor">RidgeClassifier()</span>clf.fit(train_test<span class="hljs-literal">[:<span class="hljs-number">10000</span>]</span>, train_df<span class="hljs-literal">['<span class="hljs-identifier">label</span>']</span>.values<span class="hljs-literal">[:<span class="hljs-number">10000</span>]</span>)val_pred = clf.predict(train_test<span class="hljs-literal">[<span class="hljs-number">10000</span>:]</span>)print(f1<span class="hljs-constructor">_score(<span class="hljs-params">train_df</span>['<span class="hljs-params">label</span>'].<span class="hljs-params">values</span>[10000:], <span class="hljs-params">val_pred</span>, <span class="hljs-params">average</span>='<span class="hljs-params">macro</span>')</span>)# <span class="hljs-number">0.74</span></code></pre><h4 id="TF-IDF-RidgeClassifier"><a href="#TF-IDF-RidgeClassifier" class="headerlink" title="TF-IDF + RidgeClassifier"></a>TF-IDF + RidgeClassifier</h4><pre><code class="hljs reasonml">import pandas <span class="hljs-keyword">as</span> pdfrom sklearn.feature_extraction.text import TfidfVectorizerfrom sklearn.linear_model import RidgeClassifierfrom sklearn.metrics import f1_scoretrain_df = pd.read<span class="hljs-constructor">_csv('..<span class="hljs-operator">/</span><span class="hljs-params">input</span><span class="hljs-operator">/</span><span class="hljs-params">train_set</span>.<span class="hljs-params">csv</span>', <span class="hljs-params">sep</span>='\<span class="hljs-params">t</span>', <span class="hljs-params">nrows</span>=15000)</span>tfidf = <span class="hljs-constructor">TfidfVectorizer(<span class="hljs-params">ngram_range</span>=(1,3)</span>, max_features=<span class="hljs-number">3000</span>)train_test = tfidf.fit<span class="hljs-constructor">_transform(<span class="hljs-params">train_df</span>['<span class="hljs-params">text</span>'])</span>clf = <span class="hljs-constructor">RidgeClassifier()</span>clf.fit(train_test<span class="hljs-literal">[:<span class="hljs-number">10000</span>]</span>, train_df<span class="hljs-literal">['<span class="hljs-identifier">label</span>']</span>.values<span class="hljs-literal">[:<span class="hljs-number">10000</span>]</span>)val_pred = clf.predict(train_test<span class="hljs-literal">[<span class="hljs-number">10000</span>:]</span>)print(f1<span class="hljs-constructor">_score(<span class="hljs-params">train_df</span>['<span class="hljs-params">label</span>'].<span class="hljs-params">values</span>[10000:], <span class="hljs-params">val_pred</span>, <span class="hljs-params">average</span>='<span class="hljs-params">macro</span>')</span>)# <span class="hljs-number">0.87</span></code></pre><h2 id="基于深度学习的文本分类"><a href="#基于深度学习的文本分类" class="headerlink" title="基于深度学习的文本分类"></a>基于深度学习的文本分类</h2><p>与传统机器学习不同，深度学习既提供特征提取功能，也可以完成分类的功能。从本章开始我们将学习如何使用深度学习来完成文本表示。</p><h3 id="学习目标-2"><a href="#学习目标-2" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>学习FastText的使用和基础原理</li><li>学会使用验证集进行调参</li></ul><h3 id="文本表示方法-Part2"><a href="#文本表示方法-Part2" class="headerlink" title="文本表示方法 Part2"></a>文本表示方法 Part2</h3><h4 id="现有文本表示方法的缺陷"><a href="#现有文本表示方法的缺陷" class="headerlink" title="现有文本表示方法的缺陷"></a>现有文本表示方法的缺陷</h4><p>在上一章节，我们介绍几种文本表示方法：</p><ul><li>One-hot</li><li>Bag of Words</li><li>N-gram</li><li>TF-IDF</li></ul><p>也通过sklean进行了相应的实践，相信你也有了初步的认知。但上述方法都或多或少存在一定的问题：转换得到的向量维度很高，需要较长的训练实践；没有考虑单词与单词之间的关系，只是进行了统计。</p><p>与这些表示方法不同，深度学习也可以用于文本表示，还可以将其映射到一个低纬空间。其中比较典型的例子有：FastText、Word2Vec和Bert。在本章我们将介绍FastText，将在后面的内容介绍Word2Vec和Bert。</p><h4 id="FastText"><a href="#FastText" class="headerlink" title="FastText"></a>FastText</h4><p>FastText是一种典型的深度学习词向量的表示方法，它非常简单通过Embedding层将单词映射到稠密空间，然后将句子中所有的单词在Embedding空间中进行平均，进而完成分类操作。</p><p>所以FastText是一个三层的神经网络，输入层、隐含层和输出层。</p><p><a href="https://camo.githubusercontent.com/4e01004146c81db5ee15df1b373374b3ff145bfa/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343835363538392e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/4e01004146c81db5ee15df1b373374b3ff145bfa/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343835363538392e706e67" srcset="/img/loading.gif" alt="fast_text"></a></p><p>下图是使用keras实现的FastText网络结构：</p><p><a href="https://camo.githubusercontent.com/d4f33365b75bdddd0c80a857dc1a9e99789f1600/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343234393436332e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/d4f33365b75bdddd0c80a857dc1a9e99789f1600/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343234393436332e6a7067" srcset="/img/loading.gif" alt="keras_fasttext"></a></p><p>FastText在文本分类任务上，是优于TF-IDF的：</p><ul><li>FastText用单词的Embedding叠加获得的文档向量，将相似的句子分为一类</li><li>FastText学习到的Embedding空间维度比较低，可以快速进行训练</li></ul><p>如果想深度学习，可以参考论文：</p><p>Bag of Tricks for Efficient Text Classification, <a href="https://arxiv.org/abs/1607.01759" target="_blank" rel="noopener">https://arxiv.org/abs/1607.01759</a></p><h3 id="基于FastText的文本分类"><a href="#基于FastText的文本分类" class="headerlink" title="基于FastText的文本分类"></a>基于FastText的文本分类</h3><p>FastText可以快速的在CPU上进行训练，最好的实践方法就是官方开源的版本： <a href="https://github.com/facebookresearch/fastText/tree/master/python" target="_blank" rel="noopener">https://github.com/facebookresearch/fastText/tree/master/python</a></p><ul><li>pip安装</li></ul><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> fasttext</code></pre><ul><li>源码安装</li></ul><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/facebookresearch/fastText.gitcd fastTextsudo pip install .</code></pre><p>两种安装方法都可以安装，如果你是初学者可以优先考虑使用pip安装。</p><ul><li>分类模型</li></ul><pre><code class="hljs routeros">import pandas as pd<span class="hljs-keyword">from</span> sklearn.metrics import f1_score<span class="hljs-comment"># 转换为FastText需要的格式</span>train_df = pd.read_csv(<span class="hljs-string">'../input/train_set.csv'</span>, <span class="hljs-attribute">sep</span>=<span class="hljs-string">'\t'</span>, <span class="hljs-attribute">nrows</span>=15000)train_df[<span class="hljs-string">'label_ft'</span>] = <span class="hljs-string">'__label__'</span> + train_df[<span class="hljs-string">'label'</span>].astype(str)train_df[[<span class="hljs-string">'text'</span>,<span class="hljs-string">'label_ft'</span>]].iloc[:-5000].to_csv(<span class="hljs-string">'train.csv'</span>, <span class="hljs-attribute">index</span>=None, <span class="hljs-attribute">header</span>=None, <span class="hljs-attribute">sep</span>=<span class="hljs-string">'\t'</span>)import fasttextmodel = fasttext.train_supervised(<span class="hljs-string">'train.csv'</span>, <span class="hljs-attribute">lr</span>=1.0, <span class="hljs-attribute">wordNgrams</span>=2,                                   <span class="hljs-attribute">verbose</span>=2, <span class="hljs-attribute">minCount</span>=1, <span class="hljs-attribute">epoch</span>=25, <span class="hljs-attribute">loss</span>=<span class="hljs-string">"hs"</span>)val_pred = [model.predict(x)[0][0].split(<span class="hljs-string">'__'</span>)[-1] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> train_df.iloc[-5000:][<span class="hljs-string">'text'</span>]]<span class="hljs-builtin-name">print</span>(f1_score(train_df[<span class="hljs-string">'label'</span>].values[-5000:].astype(str), val_pred, <span class="hljs-attribute">average</span>=<span class="hljs-string">'macro'</span>))<span class="hljs-comment"># 0.82</span></code></pre><p>此时数据量比较小得分为0.82，当不断增加训练集数量时，FastText的精度也会不断增加5w条训练样本时，验证集得分可以到0.89-0.90左右。</p><h3 id="如何使用验证集调参"><a href="#如何使用验证集调参" class="headerlink" title="如何使用验证集调参"></a>如何使用验证集调参</h3><p>在使用TF-IDF和FastText中，有一些模型的参数需要选择，这些参数会在一定程度上影响模型的精度，那么如何选择这些参数呢？</p><ul><li>通过阅读文档，要弄清楚这些参数的大致含义，那些参数会增加模型的复杂度</li><li>通过在验证集上进行验证模型精度，找到模型在是否过拟合还是欠拟合</li></ul><p><a href="https://camo.githubusercontent.com/3c19cda9d91954875be0b59abe99fad024552d29/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343430333834342e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/3c19cda9d91954875be0b59abe99fad024552d29/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343230343430333834342e706e67" srcset="/img/loading.gif" alt="train_val"></a></p><p>这里我们使用10折交叉验证，每折使用9/10的数据进行训练，剩余1/10作为验证集检验模型的效果。这里需要注意每折的划分必须保证标签的分布与整个数据集的分布一致。</p><pre><code class="hljs dockerfile">label2id = &#123;&#125;for i in range(total):    <span class="hljs-keyword">label</span><span class="bash"> = str(all_labels[i])</span>    if <span class="hljs-keyword">label</span><span class="bash"> not <span class="hljs-keyword">in</span> label2id:</span>        label2id[<span class="hljs-keyword">label</span><span class="bash">] = [i]</span>    else:        label2id[<span class="hljs-keyword">label</span><span class="bash">].append(i)</span></code></pre><p>通过10折划分，我们一共得到了10份分布一致的数据，索引分别为0到9，每次通过将一份数据作为验证集，剩余数据作为训练集，获得了所有数据的10种分割。不失一般性，我们选择最后一份完成剩余的实验，即索引为9的一份做为验证集，索引为1-8的作为训练集，然后基于验证集的结果调整超参数，使得模型性能更优。</p><h3 id="本章小结-1"><a href="#本章小结-1" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章介绍了FastText的原理和基础使用，并进行相应的实践。然后介绍了通过10折交叉验证划分数据集。</p><h3 id="本章作业-1"><a href="#本章作业-1" class="headerlink" title="本章作业"></a>本章作业</h3><ul><li>阅读FastText的文档，尝试修改参数，得到更好的分数</li><li>基于验证集的结果调整超参数，使得模型性能更优</li></ul><h2 id="基于深度学习的文本分类-1"><a href="#基于深度学习的文本分类-1" class="headerlink" title="基于深度学习的文本分类"></a>基于深度学习的文本分类</h2><h3 id="学习目标-3"><a href="#学习目标-3" class="headerlink" title="学习目标"></a>学习目标</h3><ul><li>了解Transformer的原理和基于预训练语言模型（Bert）的词表示</li><li>学会Bert的使用，具体包括pretrain和finetune</li></ul><h3 id="文本表示方法Part4"><a href="#文本表示方法Part4" class="headerlink" title="文本表示方法Part4"></a>文本表示方法Part4</h3><h4 id="Transformer原理"><a href="#Transformer原理" class="headerlink" title="Transformer原理"></a>Transformer原理</h4><p>Transformer是在”<a href="https://arxiv.org/abs/1706.03762" target="_blank" rel="noopener">Attention is All You Need</a>“中提出的，模型的编码部分是一组编码器的堆叠（论文中依次堆叠六个编码器），模型的解码部分是由相同数量的解码器的堆叠。</p><p><a href="https://camo.githubusercontent.com/1da32c07cd7d544113673ba47624f0a47af51ba6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313034363636382e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1da32c07cd7d544113673ba47624f0a47af51ba6/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313034363636382e706e67" srcset="/img/loading.gif" alt="img"></a></p><p>我们重点关注编码部分。他们结构完全相同，但是并不共享参数，每一个编码器都可以拆解成两部分。在对输入序列做词的向量化之后，它们首先流过一个self-attention层，该层帮助编码器在它编码单词的时候能够看到输入序列中的其他单词。self-attention的输出流向一个前向网络（Feed Forward Neural Network），每个输入位置对应的前向网络是独立互不干扰的。最后将输出传入下一个编码器。</p><p><a href="https://camo.githubusercontent.com/70959c74cbf7ac3c3dae3fd0eceddf180715cb39/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313131353934352e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/70959c74cbf7ac3c3dae3fd0eceddf180715cb39/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313131353934352e706e67" srcset="/img/loading.gif" alt="img"></a></p><p>这里能看到Transformer的一个关键特性，每个位置的词仅仅流过它自己的编码器路径。在self-attention层中，这些路径两两之间是相互依赖的。<strong>前向网络层则没有这些依赖性</strong>，但这些路径在流经前向网络时可以并行执行。</p><p>Self-Attention中使用多头机制，使得不同的attention heads所关注的的部分不同。</p><p><a href="https://camo.githubusercontent.com/1173d083304d3e60a81342717cd52d3f1a5124e1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313135333638372e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1173d083304d3e60a81342717cd52d3f1a5124e1/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313135333638372e706e67" srcset="/img/loading.gif" alt="img"></a></p><p>编码”it”时，一个attention head集中于”the animal”，另一个head集中于“tired”，某种意义上讲，模型对“it”的表达合成了的“animal”和“tired”两者。</p><p>对于自注意力的详细计算，欢迎大家参考<a href="https://jalammar.github.io/illustrated-transformer/" target="_blank" rel="noopener">Jay Alammar</a>关于Transformer的博客，这里不再展开。</p><p>除此之外，为了使模型保持单词的语序，模型中添加了位置编码向量。如下图所示，每行对应一个向量的位置编码。因此，第一行将是我们要添加到输入序列中第一个单词的嵌入的向量。每行包含512个值—每个值都在1到-1之间。因为左侧是用sine函数生成，右侧是用cosine生成，所以可以观察到中间显著的分隔。</p><p><a href="https://camo.githubusercontent.com/1598ac84eeeca72eb271d7bc4696d36f564bc759/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313233323731362e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1598ac84eeeca72eb271d7bc4696d36f564bc759/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313233323731362e706e67" srcset="/img/loading.gif" alt="img"></a></p><p>编码器结构中值得提出注意的一个细节是，在每个子层中（Self-attention, FFNN），都有残差连接，并且紧跟着<a href="https://arxiv.org/abs/1607.06450" target="_blank" rel="noopener">layer-normalization</a>。如果我们可视化向量和LayerNorm操作，将如下所示：</p><p><a href="https://camo.githubusercontent.com/09ac8f9634bff9681b191c398e4b943d34f972c3/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313935353731332e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/09ac8f9634bff9681b191c398e4b943d34f972c3/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313935353731332e706e67" srcset="/img/loading.gif" alt="img"></a></p><h4 id="基于预训练语言模型的词表示"><a href="#基于预训练语言模型的词表示" class="headerlink" title="基于预训练语言模型的词表示"></a>基于预训练语言模型的词表示</h4><p>基于预训练语言模型的词表示由于可以建模上下文信息，进而解决传统静态词向量不能建模“一词多义”语言现象的问题。最早提出的ELMo基于两个单向LSTM，将从左到右和从右到左两个方向的隐藏层向量表示拼接学习上下文词嵌入。而GPT用Transformer代替LSTM作为编码器，首先进行了语言模型预训练，然后在下游任务微调模型参数。但GPT由于仅使用了单向语言模型，因此难以建模上下文信息。为了解决以上问题，研究者们提出了BERT，BERT模型结构如下图所示，它是一个基于Transformer的多层Encoder，通过执行一系列预训练，进而得到深层的上下文表示。</p><p><a href="https://camo.githubusercontent.com/f5297c1c8c1e71180cb62aca463503d21122e911/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313331363136372e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/f5297c1c8c1e71180cb62aca463503d21122e911/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313331363136372e706e67" srcset="/img/loading.gif" alt="bert_elmo"></a></p><p>ELMo论文题目中Deep是指双向双层LSTM，而更关键的在于context。传统方法生成的单词映射表的形式，即先为每个单词生成一个静态的词向量，之后这个单词的表示就被固定住了，不会跟着上下文的变化而做出改变。事实上，由于一词多义的语言现象，静态词向量是有很大的弊端的。以bank为例，如果训练语料的足够大，事先学好的词向量中混杂着所有的语义。而当下游应用时，即使在新句子中，bank的上下文里包含money等词，我们基本可以确定bank是“银行”的语义而不是在其他上下文中的“河床”的语义，但是由于静态词向量不能跟随上下文而进行变化，所以bank的表示中还是混杂着多种语义。为了解决这一问题，ELMo首先进行了语言模型预训练，然后在下游任务中动态调整Word Embedding，因此最后输出的词表示能够充分表达单词在上下文中的特定语义，进而解决一词多义的问题。</p><p>GPT来自于openai，是一种生成式预训练模型。GPT 除了将ELMo中的LSTM替换为Transformer 的Encoder外，更开创了NLP界基于预训练-微调的新范式。尽管GPT采用的也是和ELMo相同的两阶段模式，但GPT在第一个阶段并没有采取ELMo中使用两个单向双层LSTM拼接的结构，而是采用基于自回归式的单向语言模型。</p><p>Google在NAACL 2018发表的论文中提出了BERT，与GPT相同，BERT也采用了预训练-微调这一两阶段模式。但在模型结构方面，BERT采用了ELMO的范式，即使用双向语言模型代替GPT中的单向语言模型，但是BERT的作者认为ELMo使用两个单向语言模型拼接的方式太粗暴，因此在第一阶段的预训练过程中，BERT提出掩码语言模型，即类似完形填空的方式，通过上下文来预测单词本身，而不是从右到左或从左到右建模，这允许模型能够自由地编码每个层中来自两个方向的信息。而为了学习句子的词序关系，BERT将Transformer中的三角函数位置表示替换为可学习的参数，其次为了区别单句和双句输入，BERT还引入了句子类型表征。BERT的输入如图所示。此外，为了充分学习句子间的关系，BERT提出了下一个句子预测任务。具体来说，在训练时，句子对中的第二个句子有50％来自与原有的连续句子，而其余50%的句子则是通过在其他句子中随机采样。同时，消融实验也证明，这一预训练任务对句间关系判断任务具有很大的贡献。除了模型结构不同之外，BERT在预训练时使用的无标签数据规模要比GPT大的多。</p><p><a href="https://camo.githubusercontent.com/1fa48883f724ed604556d3bb9d241511012d1972/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313334383435362e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/1fa48883f724ed604556d3bb9d241511012d1972/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313334383435362e706e67" srcset="/img/loading.gif" alt="bert_input"></a></p><p>在第二阶段，与GPT相同，BERT也使用Fine-Tuning模式来微调下游任务。如下图所示，BERT与GPT不同，它极大的减少了改造下游任务的要求，只需在BERT模型的基础上，通过额外添加Linear分类器，就可以完成下游任务。具体来说，对于句间关系判断任务，与GPT类似，只需在句子之间加个分隔符，然后在两端分别加上起始和终止符号。在进行输出时，只需把句子的起始符号[CLS]在BERT最后一层中对应的位置接一个Softmax+Linear分类层即可；对于单句分类问题，也与GPT类似，只需要在句子两段分别增加起始和终止符号，输出部分和句间关系判断任务保持一致即可；对于问答任务，由于需要输出答案在给定段落的起始和终止位置，因此需要先将问题和段落按照句间关系判断任务构造输入，输出只需要在BERT最后一层中第二个句子，即段落的每个单词对应的位置上分别接判断起始和终止位置的分类器；最后，对于NLP中的序列标注问题，输入与单句分类任务一致，不同的是在BERT最后一层中每个单词对应的位置上接分类器即可。</p><p><a href="https://camo.githubusercontent.com/265b6f273c9731886f63f66b7beb2805226cee73/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313430393538322e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/265b6f273c9731886f63f66b7beb2805226cee73/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313430393538322e706e67" srcset="/img/loading.gif" alt="bert_task"></a></p><p>更重要的是，BERT开启了NLP领域“预训练-微调”这种两阶段的全新范式。在第一阶段首先在海量无标注文本上预训练一个双向语言模型，这里特别值得注意的是，将Transformer作为特征提取器在解决并行性和长距离依赖问题上都要领先于传统的RNN或者CNN，通过预训练的方式，可以将训练数据中的词法、句法、语法知识以网络参数的形式提炼到模型当中，在第二阶段使用下游任务的数据Fine-tuning不同层数的BERT模型参数，或者把BERT当作特征提取器生成BERT Embedding，作为新特征引入下游任务。这种两阶段的全新范式尽管是来自于计算机视觉领域，但是在自然语言处理领域一直没有得到很好的运用，而BERT作为近些年NLP突破性进展的集大成者，最大的亮点可以说不仅在于模型性能好，并且几乎所有NLP任务都可以很方便地基于BERT进行改造，进而将预训练学到的语言学知识引入下游任务，进一步提升模型的性能。</p><h3 id="基于Bert的文本分类"><a href="#基于Bert的文本分类" class="headerlink" title="基于Bert的文本分类"></a>基于Bert的文本分类</h3><h4 id="Bert-Pretrain"><a href="#Bert-Pretrain" class="headerlink" title="Bert Pretrain"></a>Bert Pretrain</h4><p>预训练过程使用了Google基于Tensorflow发布的BERT源代码。首先从原始文本中创建训练数据，由于本次比赛的数据都是ID，这里重新建立了词表，并且建立了基于空格的分词器。</p><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WhitespaceTokenizer</span>(<span class="hljs-title">object</span>):</span>    <span class="hljs-string">""</span><span class="hljs-string">"WhitespaceTokenizer with vocab."</span><span class="hljs-string">""</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, vocab_file)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">self</span>.vocab = load_vocab(vocab_file)        <span class="hljs-keyword">self</span>.inv_vocab = &#123;<span class="hljs-symbol">v:</span> k <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.vocab.items()&#125;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tokenize</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, text)</span></span><span class="hljs-symbol">:</span>        split_tokens = whitespace_tokenize(text)        output_tokens = []        <span class="hljs-keyword">for</span> token <span class="hljs-keyword">in</span> <span class="hljs-symbol">split_tokens:</span>            <span class="hljs-keyword">if</span> token <span class="hljs-keyword">in</span> <span class="hljs-keyword">self</span>.<span class="hljs-symbol">vocab:</span>                output_tokens.append(token)            <span class="hljs-symbol">else:</span>                output_tokens.append(<span class="hljs-string">"[UNK]"</span>)        <span class="hljs-keyword">return</span> output_tokens    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert_tokens_to_ids</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, tokens)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">return</span> convert_by_vocab(<span class="hljs-keyword">self</span>.vocab, tokens)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">convert_ids_to_tokens</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, ids)</span></span><span class="hljs-symbol">:</span>        <span class="hljs-keyword">return</span> convert_by_vocab(<span class="hljs-keyword">self</span>.inv_vocab, ids)</code></pre><p>预训练由于去除了NSP预训练任务，因此将文档处理多个最大长度为256的段，如果最后一个段的长度小于256/2则丢弃。每一个段执行按照BERT原文中执行掩码语言模型，然后处理成tfrecord格式。</p><pre><code class="hljs vim">def create_segments_from_document(document, max_segment_length):    <span class="hljs-string">""</span><span class="hljs-string">"Split single document to segments according to max_segment_length."</span><span class="hljs-string">""</span>    assert <span class="hljs-built_in">len</span>(document) == <span class="hljs-number">1</span>    document = document[<span class="hljs-number">0</span>]    document_len = <span class="hljs-built_in">len</span>(document)    <span class="hljs-built_in">index</span> = <span class="hljs-keyword">list</span>(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, document_len, max_segment_length))    other_len = document_len % max_segment_length    <span class="hljs-keyword">if</span> other_len &gt; max_segment_length / <span class="hljs-number">2</span>:        <span class="hljs-built_in">index</span>.<span class="hljs-keyword">append</span>(document_len)    segments = []    <span class="hljs-keyword">for</span> i in <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(<span class="hljs-built_in">index</span>) - <span class="hljs-number">1</span>):        segment = document[<span class="hljs-built_in">index</span>[i]: <span class="hljs-built_in">index</span>[i+<span class="hljs-number">1</span>]]        segments.<span class="hljs-keyword">append</span>(segment)    <span class="hljs-keyword">return</span> segments</code></pre><p>在预训练过程中，也只执行掩码语言模型任务，因此不再计算下一句预测任务的loss。</p><pre><code class="hljs lisp">(<span class="hljs-name">masked_lm_loss</span>, masked_lm_example_loss, masked_lm_log_probs) = get_masked_lm_output(    bert_config, model.get_sequence_output(), model.get_embedding_table(),    masked_lm_positions, masked_lm_ids, masked_lm_weights)total_loss = masked_lm_loss</code></pre><p>为了适配句子的长度，以及减小模型的训练时间，我们采取了BERT-mini模型，详细配置如下。</p><pre><code class="hljs json">&#123;  <span class="hljs-attr">"hidden_size"</span>: <span class="hljs-number">256</span>,  <span class="hljs-attr">"hidden_act"</span>: <span class="hljs-string">"gelu"</span>,  <span class="hljs-attr">"initializer_range"</span>: <span class="hljs-number">0.02</span>,  <span class="hljs-attr">"vocab_size"</span>: <span class="hljs-number">5981</span>,  <span class="hljs-attr">"hidden_dropout_prob"</span>: <span class="hljs-number">0.1</span>,  <span class="hljs-attr">"num_attention_heads"</span>: <span class="hljs-number">4</span>,  <span class="hljs-attr">"type_vocab_size"</span>: <span class="hljs-number">2</span>,  <span class="hljs-attr">"max_position_embeddings"</span>: <span class="hljs-number">256</span>,  <span class="hljs-attr">"num_hidden_layers"</span>: <span class="hljs-number">4</span>,  <span class="hljs-attr">"intermediate_size"</span>: <span class="hljs-number">1024</span>,  <span class="hljs-attr">"attention_probs_dropout_prob"</span>: <span class="hljs-number">0.1</span>&#125;</code></pre><p>由于我们的整体框架使用Pytorch，因此需要将最后一个检查点转换成Pytorch的权重。</p><pre><code class="hljs reasonml">def convert<span class="hljs-constructor">_tf_checkpoint_to_pytorch(<span class="hljs-params">tf_checkpoint_path</span>, <span class="hljs-params">bert_config_file</span>, <span class="hljs-params">pytorch_dump_path</span>)</span>:    # Initialise PyTorch model    config = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">BertConfig</span>.</span></span>from<span class="hljs-constructor">_json_file(<span class="hljs-params">bert_config_file</span>)</span>    print(<span class="hljs-string">"Building PyTorch model from configuration: &#123;&#125;"</span>.format(str(config)))    model = <span class="hljs-constructor">BertForPreTraining(<span class="hljs-params">config</span>)</span>    # Load weights from tf checkpoint    load<span class="hljs-constructor">_tf_weights_in_bert(<span class="hljs-params">model</span>, <span class="hljs-params">config</span>, <span class="hljs-params">tf_checkpoint_path</span>)</span>    # Save pytorch-model    print(<span class="hljs-string">"Save PyTorch model to &#123;&#125;"</span>.format(pytorch_dump_path))    torch.save(model.state<span class="hljs-constructor">_dict()</span>, pytorch_dump_path)</code></pre><p>预训练消耗的资源较大，硬件条件不允许的情况下建议<strong>直接下载开源的模型</strong></p><h4 id="Bert-Finetune"><a href="#Bert-Finetune" class="headerlink" title="Bert Finetune"></a>Bert Finetune</h4><p><a href="https://camo.githubusercontent.com/6ee5331933f1637d5835522efb64f4951f6213ec/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313532363332362e706e67" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/6ee5331933f1637d5835522efb64f4951f6213ec/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303731343231313532363332362e706e67" srcset="/img/loading.gif" alt="experimental) Dynamic Quantization on BERT — PyTorch Tutorials 1.5 ..."></a></p><p>微调将最后一层的第一个token即[CLS]的隐藏向量作为句子的表示，然后输入到softmax层进行分类。</p><pre><code class="hljs nix">sequence_output, <span class="hljs-attr">pooled_output</span> = \    self.bert(<span class="hljs-attr">input_ids=input_ids,</span> <span class="hljs-attr">token_type_ids=token_type_ids)</span><span class="hljs-keyword">if</span> self.pooled:    <span class="hljs-attr">reps</span> = pooled_output<span class="hljs-keyword">else</span>:    <span class="hljs-attr">reps</span> = sequence_output[:, <span class="hljs-number">0</span>, :]  <span class="hljs-comment"># sen_num x 256</span><span class="hljs-keyword">if</span> self.training:    <span class="hljs-attr">reps</span> = self.dropout(reps)</code></pre><h3 id="本章小结-2"><a href="#本章小结-2" class="headerlink" title="本章小结"></a>本章小结</h3><p>本章介绍了Bert的原理和使用，具体包括pretrain和finetune两部分。</p>]]></content>
    
    
    <categories>
      
      <category>自然语言处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>论文阅读2</title>
    <link href="/article/1d82fc97.html"/>
    <url>/article/1d82fc97.html</url>
    
    <content type="html"><![CDATA[<h1 id="1-Prototypical-Networks-for-Few-shot-Learning"><a href="#1-Prototypical-Networks-for-Few-shot-Learning" class="headerlink" title="1.Prototypical Networks for Few-shot Learning"></a>1.Prototypical Networks for Few-shot Learning</h1><p><img src="/article/1d82fc97/image-20200719181649169.png" srcset="/img/loading.gif" alt="image-20200719181649169"></p><p><img src="/article/1d82fc97/image-20200719181614391.png" srcset="/img/loading.gif" alt="image-20200719181614391"></p><h1 id="2-Transferrable-Prototypical-Networks-for-Unsupervised-Domain-Adaptation"><a href="#2-Transferrable-Prototypical-Networks-for-Unsupervised-Domain-Adaptation" class="headerlink" title="2.Transferrable Prototypical Networks for Unsupervised Domain Adaptation"></a>2.Transferrable Prototypical Networks for Unsupervised Domain Adaptation</h1><p><img src="/article/1d82fc97/tempsnip.png" srcset="/img/loading.gif" alt="tempsnip"></p><p><strong>motivation:</strong></p><p><img src="/article/1d82fc97/image-20200720103101415.png" srcset="/img/loading.gif" alt="image-20200720103101415"></p><p><strong>design:</strong></p><p><img src="/article/1d82fc97/image-20200720103210812.png" srcset="/img/loading.gif" alt="image-20200720103210812"></p><p><img src="/article/1d82fc97/image-20200720103352834.png" srcset="/img/loading.gif" alt="image-20200720103352834"></p><p><img src="/article/1d82fc97/image-20200720103521702.png" srcset="/img/loading.gif" alt="image-20200720103521702"></p><p>相较于域级别而言，类级别的MMD更加地细粒度(fine-grained更细致)。</p><p><img src="/article/1d82fc97/image-20200720104021744.png" srcset="/img/loading.gif" alt="image-20200720104021744"></p><p><strong>motivation:</strong></p><p><img src="/article/1d82fc97/image-20200720104121465.png" srcset="/img/loading.gif" alt="image-20200720104121465"></p><p><strong>design:</strong></p><p><img src="/article/1d82fc97/image-20200720104403499.png" srcset="/img/loading.gif" alt="image-20200720104403499"></p><p><img src="/article/1d82fc97/image-20200720104647122.png" srcset="/img/loading.gif" alt="image-20200720104647122"></p><p>不同于单独匹配不同域之间的每个类的prototype，task-specific adaptation同时匹配所有类的prototypes。力求每个样本的类分布的score distributions相似.</p><p><img src="/article/1d82fc97/image-20200720105117126.png" srcset="/img/loading.gif" alt="image-20200720105117126"></p><p><strong>Optimization:</strong><br>源域上的监督学习</p><p><img src="/article/1d82fc97/image-20200720105431189.png" srcset="/img/loading.gif" alt="image-20200720105431189"></p><p><img src="/article/1d82fc97/image-20200720105531478.png" srcset="/img/loading.gif" alt="image-20200720105531478"></p><p><strong>Training Procedure:</strong></p><p><img src="/article/1d82fc97/image-20200720105706495.png" srcset="/img/loading.gif" alt="image-20200720105706495"></p><p><strong>推理阶段(测试阶段)：</strong></p><p><img src="/article/1d82fc97/image-20200720110755325.png" srcset="/img/loading.gif" alt="image-20200720110755325"></p><h1 id="3-Distant-Supervised-Centroid-Shift-A-Sample-and-Efficient-Approach-to-Visual-Domain-Adaptation"><a href="#3-Distant-Supervised-Centroid-Shift-A-Sample-and-Efficient-Approach-to-Visual-Domain-Adaptation" class="headerlink" title="3.Distant Supervised Centroid Shift: A Sample and Efficient Approach to Visual Domain Adaptation"></a>3.Distant Supervised Centroid Shift: A Sample and Efficient Approach to Visual Domain Adaptation</h1><p><strong>问题定义：</strong></p><p><img src="/article/1d82fc97/image-20200720140545581.png" srcset="/img/loading.gif" alt="image-20200720140545581"></p><p><strong>Method：</strong></p><p><img src="/article/1d82fc97/image-20200720141255925.png" srcset="/img/loading.gif" alt="image-20200720141255925"></p><p><strong>(1) 类内散度最小化(Source Domain)：</strong></p><p><img src="/article/1d82fc97/image-20200720141722664.png" srcset="/img/loading.gif" alt="image-20200720141722664"></p><p><img src="/article/1d82fc97/image-20200720142301426.png" srcset="/img/loading.gif" alt="image-20200720142301426"></p><p><strong>类内散度最小化(Target Domain)：</strong></p><p><img src="/article/1d82fc97/image-20200720142652395.png" srcset="/img/loading.gif" alt="image-20200720142652395"></p><p>目标域不存在标签，采用最近邻中心的分类器，同时force Target类中心和对应的Source类中心靠近。<br>就是把Source类中心加上一个偏移量视为Target类中心，同时最小化此偏移量。<br><strong>总体目标如下：</strong></p><p><img src="/article/1d82fc97/image-20200720143112960.png" srcset="/img/loading.gif" alt="image-20200720143112960"></p><p><img src="/article/1d82fc97/image-20200720145649943.png" srcset="/img/loading.gif" alt="image-20200720145649943"></p><p><strong>relaxed trace-ratio objective：</strong></p><p><img src="/article/1d82fc97/image-20200720150033777.png" srcset="/img/loading.gif" alt="image-20200720150033777"></p><p><img src="/article/1d82fc97/image-20200720171415765.png" srcset="/img/loading.gif" alt="image-20200720171415765"></p><p><strong>Optimization(具体流程)：</strong><br>利用GEVD求解：</p><p><img src="/article/1d82fc97/image-20200720173504331.png" srcset="/img/loading.gif" alt="image-20200720173504331"></p><p><span style="color:red">这里需要再看看</span></p><p><img src="/article/1d82fc97/tempsnip2.png" srcset="/img/loading.gif" alt="tempsnip2"></p><p><img src="/article/1d82fc97/image-20200720180603912.png" srcset="/img/loading.gif" alt="image-20200720180603912"></p><p><img src="/article/1d82fc97/image-20200720180940704.png" srcset="/img/loading.gif" alt="image-20200720180940704"></p><p><img src="/article/1d82fc97/image-20200720181003000.png" srcset="/img/loading.gif" alt="image-20200720181003000"></p><h1 id="4-Adaptive-Cross-Modal-Few-shot-Learning"><a href="#4-Adaptive-Cross-Modal-Few-shot-Learning" class="headerlink" title="4. Adaptive Cross-Modal Few-shot Learning"></a>4. Adaptive Cross-Modal Few-shot Learning</h1><p><strong>背景知识：</strong></p><p><img src="/article/1d82fc97/image-20200720235811934.png" srcset="/img/loading.gif" alt="image-20200720235811934"></p><p><a href="# 1.Prototypical Networks for Few-shot Learning">第一篇</a>写了，这里就不赘述了。</p><p><img src="/article/1d82fc97/image-20200720235846044.png" srcset="/img/loading.gif" alt="image-20200720235846044"></p><p><strong>motivation:</strong></p><p><img src="/article/1d82fc97/tempsnip3.png" srcset="/img/loading.gif" alt="tempsnip3"></p><p><img src="/article/1d82fc97/image-20200720235727709.png" srcset="/img/loading.gif" alt="image-20200720235727709"></p><p><strong>方法Formulation：</strong></p><p><img src="/article/1d82fc97/image-20200721001159311.png" srcset="/img/loading.gif" alt="image-20200721001159311"></p>]]></content>
    
    
    <categories>
      
      <category>linc实验室</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode200-岛屿数量</title>
    <link href="/article/708439c3.html"/>
    <url>/article/708439c3.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>深度优先搜索，广度优先搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode127-单词接龙</title>
    <link href="/article/1c7950e9.html"/>
    <url>/article/1c7950e9.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>深度优先搜索，广度优先搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode126-单词接龙II</title>
    <link href="/article/25dd8b3e.html"/>
    <url>/article/25dd8b3e.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>深度优先搜索，广度优先搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode22-括号生成</title>
    <link href="/article/68fd8ba2.html"/>
    <url>/article/68fd8ba2.html</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode20-括号生成"><a href="#leetcode20-括号生成" class="headerlink" title="leetcode20.括号生成"></a>leetcode20.括号生成</h1><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例：</strong></p><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span>输出：[       <span class="hljs-string">"((()))"</span>,       <span class="hljs-string">"(()())"</span>,       <span class="hljs-string">"(())()"</span>,       <span class="hljs-string">"()(())"</span>,       <span class="hljs-string">"()()()"</span>     ]</code></pre><h2 id="一：暴力法"><a href="#一：暴力法" class="headerlink" title="一：暴力法"></a>一：暴力法</h2><p><strong>思路</strong></p><p>我们可以生成所有 $2^{2n}$ 个 <code>&#39;(&#39;</code> 和 <code>&#39;)&#39;</code> 字符构成的序列，然后我们检查每一个是否有效即可。</p><p><strong>算法</strong></p><p>为了生成所有序列，我们可以使用递归。长度为 <code>n</code> 的序列就是在长度为 <code>n-1</code> 的序列前加一个 <code>&#39;(&#39;</code> 或 <code>&#39;)&#39;</code>。</p><p>为了检查序列是否有效，我们遍历这个序列，并使用一个变量 <code>balance</code> 表示左括号的数量减去右括号的数量。如果在遍历过程中 <code>balance</code> 的值小于零，或者结束时 <code>balance</code> 的值不为零，那么该序列就是无效的，否则它是有效的。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(self, n: int)</span> -&gt; List[str]:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate</span><span class="hljs-params">(A)</span>:</span>            <span class="hljs-keyword">if</span> len(A) == <span class="hljs-number">2</span>*n:                <span class="hljs-keyword">if</span> valid(A):                    ans.append(<span class="hljs-string">""</span>.join(A))            <span class="hljs-keyword">else</span>:                A.append(<span class="hljs-string">'('</span>)                generate(A)                A.pop()                A.append(<span class="hljs-string">')'</span>)                generate(A)                A.pop()        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">valid</span><span class="hljs-params">(A)</span>:</span>            bal = <span class="hljs-number">0</span>            <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> A:                <span class="hljs-keyword">if</span> c == <span class="hljs-string">'('</span>: bal += <span class="hljs-number">1</span>                <span class="hljs-keyword">else</span>: bal -= <span class="hljs-number">1</span>                <span class="hljs-keyword">if</span> bal &lt; <span class="hljs-number">0</span>: <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">return</span> bal == <span class="hljs-number">0</span>        ans = []        generate([])        <span class="hljs-keyword">return</span> ans</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(2^{2n}n)$，对于 $2^{2n}$ 个序列中的每一个，我们用于建立和验证该序列的复杂度为 $O(n)$。</li></ul><p>空间复杂度：$O(n)$，除了答案数组之外，我们所需要的空间取决于递归栈的深度，每一层递归函数需要 $O(1)$ 的空间，最多递归 $2n$ 层，因此空间复杂度为 $O(n)$。</p><h2 id="方法二：回溯法"><a href="#方法二：回溯法" class="headerlink" title="方法二：回溯法"></a>方法二：回溯法</h2><p><strong>思路和算法</strong></p><p>方法一还有改进的余地，可以只在序列仍然保持有效时添加 <code>&#39;(&#39;</code> or <code>&#39;)&#39;</code>，而不是像 <a href="#方法一：暴力法">方法一</a> 那样每次添加。我们可以通过跟踪到目前为止放置的左括号和右括号的数目来做到这一点。<br>如果左括号数量不大于 $n$，可以放一个左括号。如果右括号数量小于左括号的数量，我们可以放一个右括号。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(self, n)</span>:</span>        ans = []        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(S, left, right)</span>:</span>            <span class="hljs-keyword">if</span> len(S) == <span class="hljs-number">2</span> * n:                ans.append(<span class="hljs-string">''</span>.join(S))                <span class="hljs-keyword">return</span>            <span class="hljs-keyword">if</span> left &lt; n:                S.append(<span class="hljs-string">'('</span>)                backtrack(S, left+<span class="hljs-number">1</span>, right)                S.pop()            <span class="hljs-keyword">if</span> right &lt; left:                S.append(<span class="hljs-string">')'</span>)                backtrack(S, left, right+<span class="hljs-number">1</span>)                S.pop()        backtrack([], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> ans</code></pre><p><strong>复杂度分析</strong></p><p>复杂度分析依赖于理解 <code>generateParenthesis(n)</code> 中有多少个元素。事实证明这是第 $n$ 个卡特兰数 $\dfrac{1}{n+1}\dbinom{2n}{n}$ ，这是由 $\dfrac{4^n}{n\sqrt{n}}$ 渐近界定的。</p><ul><li>时间复杂度：时间复杂度：$O(\dfrac{4^n}{\sqrt{n}})$，在回溯过程中，每个答案需要 $O(n)$ 的时间复制到答案数组中。</li><li>空间复杂度：$O(n)$，除了答案数组之外，我们所需要的空间取决于递归栈的深度，每一层递归函数需要 $O(1)$ 的空间，最多递归 $2n$ 层，因此空间复杂度为 $O(n)$。</li></ul><h2 id="方法三：按括号序列的长度递归"><a href="#方法三：按括号序列的长度递归" class="headerlink" title="方法三：按括号序列的长度递归"></a>方法三：按括号序列的长度递归</h2><p><strong>思路与算法</strong></p><p>任何一个括号序列都一定是由 <code>(</code> 开头，并且第一个 <code>(</code> 一定有一个唯一与之对应的 <code>)</code>。这样一来，每一个括号序列可以用 <code>(a)b</code> 来表示，其中 <code>a</code> 与 <code>b</code> 分别是一个合法的括号序列（可以为空）。</p><p>那么，要生成所有长度为 <code>2 * n</code> 的括号序列，我们定义一个函数 <code>generate(n)</code> 来返回所有可能的括号序列。那么在函数 <code>generate(n)</code> 的过程中：</p><p>我们需要枚举与第一个 <code>(</code> 对应的 ) 的位置 <code>2 * i + 1</code>；<br>递归调用 <code>generate(i)</code> 即可计算 a 的所有可能性；<br>递归调用 <code>generate(n - i - 1)</code> 即可计算 b 的所有可能性；<br>遍历 <code>a</code> 与 <code>b</code> 的所有可能性并拼接，即可得到所有长度为 <code>2 * n</code> 的括号序列。<br>为了节省计算时间，我们在每次 <code>generate(i)</code> 函数返回之前，把返回值存储起来，下次再调用 <code>generate(i)</code> 时可以直接返回，不需要再递归计算。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-meta">    @lru_cache(None)</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(self, n: int)</span> -&gt; List[str]:</span>        <span class="hljs-keyword">if</span> n == <span class="hljs-number">0</span>:            <span class="hljs-keyword">return</span> [<span class="hljs-string">''</span>]        ans = []        <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(n):            <span class="hljs-keyword">for</span> left <span class="hljs-keyword">in</span> self.generateParenthesis(c):                <span class="hljs-keyword">for</span> right <span class="hljs-keyword">in</span> self.generateParenthesis(n<span class="hljs-number">-1</span>-c):                    ans.append(<span class="hljs-string">'(&#123;&#125;)&#123;&#125;'</span>.format(left, right))        <span class="hljs-keyword">return</span> ans</code></pre><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：$O(\dfrac{4^n}{\sqrt{n}})$，该分析与 方法二 类似。</p></li><li><p>空间复杂度：$O(\dfrac{4^n}{\sqrt{n}})$，此方法除答案数组外，中间过程中会存储与答案数组同样数量级的临时数组，是我们所需要的空间复杂度。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>深度优先搜索，广度优先搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode433-最小基因变化</title>
    <link href="/article/e3f6d653.html"/>
    <url>/article/e3f6d653.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>深度优先搜索，广度优先搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>nlp</title>
    <link href="/article/6b3bc2e7.html"/>
    <url>/article/6b3bc2e7.html</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">You must enter the password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="80f20397b22cf838dc793b6245d26df9b83197b349949ce5fc455021b02a6807">b85d65bd5cb71f9298fd63e227595d840402da5a2c650b99eda8f9791145ce419313381dc16ed82315d6e2dbdb7fdf16fcf807fc0f28e6f11b9d4098674e623b268aac62adbb6aecbd580f1f74b2c6c14771f0193d91bb07b826ce17bd2cfca980db04f2cdbbe44f59af61c7c146857e6bb005e2567e823d91c6e1aa92b39fb3f543b720c3e0e9eaec708eeeef34da639a88d821a951ee7d7d08d5ad8d84e0d7374a8ad207446af1cf9484bdc0fdcc5a61ce71a3c0743d4a75c0e0bb66947d7eb187d9159c421e4d028da05f1ef1b81d0fa046e39e85a786936bec3c00543a2513d3c4ec6ee3af3b87adea1bce51b0862ac28bb3172568614f48b4d89364600927f6772d3eda6125813e95b4ba2dd8d9037d953ac1b32f8fd2b2f8281493459daf7781d111bb225bad1f43ec91df68e10202332faca6a04eb0d63e217abcd9296f147f06f2b82b8dbf0ef6063198a68e164af050bc82edaa7bbf0e78d6f7ed37bb8c2bba47bbc28b75ba8d194a1ead762d1b3d877c986e37244404891de095ed80c6279c80b78462c3fd6ec6bef383b64f8beab2b5872ed7dbd71c20812e1376d3f0a0cbbcd2b13e25e1b9b49fce681a1283b37f00f3446c09faef61ca076939a30fa071e5d8af25e2988d5d73e81b88b4f87bc8880bcddb99c026b6d1603a88219f3e072bcf22e557ed7364692bf6bbc1f16c6736efc670b537358bd0f09272560b7b632827b6b77dbbcd015e65c2472a1930afcea8e7808d9c83e3e85ce88fcf5e9fd4bf02deb8da96b0009a6af69585daa0f1c3a55096939bda872025ddba36166041a159874e8e94715d5fa5a36a266500e8c4e09d920d12cd82bb12238366b0285a62db977606e376fc140d7c06dcd44f4b948f1a36d1c0a665a58756301fb779b2810c84dc04f5688cf835b4d021d61afd5e5d9e58f552ea28afee2f73624f440c3822395627d830e204f4f355fe248db5b044d2110444415e433d2858d336ced03a941b114a4324751da66daf087bc63a20d7dd8e94992734615ae450bc8024b3c1baf186ca11f235c20ad8bb4b91caad8f86da6317f252e04021b023d023f5d8acc4d7668fc09a27238de961ac2f0adfbcd6df4b3fa82db795c9ead450828bb54b989172bafddf03d3f6787f0fe792aa9d6da52cd37800a121f99bf34edad8d467401a068bf190994884572b11e9220821b0b8afc92c467aac7ba071c1a8a5ee44b91e4d309df7369ee641d5bb687ec54fb7fbf5def0dacafcfdc87776143b12a1eb801a217a1e62f9ac3b5ff1a1bbcdcde3b3e077e3f97316c596b542a7cb9c7cf236a67def31f37853d7c80bd079b043906adcb2f0965029be59b8c2fdee508c6f330c5759905a7790b15ac13c209efd22c56c3d732c8c47f1b2dea86f9971778920e5858fdda115bf1123c08d06f7fa5b6142b1ec9ba28b6794a74c16c78e645e3df0c5093e1d489fd212d8b9d26a6af2a412d13802d6fd07adaa947bc73ccb04a75d4dd15bf597f91ced635a69eb1943be06ae6f571a5c7cc63ea288acbf05145059b8b1d930b3cfc55bbc431bcba333e62e75966ea721b58799c7295d40f993aea6e5a7caec01e33924b7708569e9c2501279786b398239a5d1c8a27686fca8d7a37390e27723601704e62b2a62d39b225620e04fe5eba7eafc86691bed1d609ebd8d3e80b67d665d3334ec6aa10564e09fc0d428bf9f7ee0e24337ad09ef3cef4e2d689c7f493ee5c733bd04203fab63e5f434a38a90cb2847cf318579988532c3e10f31aafcbb91b9d30ec5ad44223f5565fa6af4e206de3d7e904662f7369bc2c570dd1f6c2e7728661f9e83efa3767f494d62160d5be1ea71a0a52945e70b82a9542b441cf193722cfb264bd64ff0ad98f94ea82401fdb2a07c684e87732a99413f0999f050cbbc86bcbe56a69b81e214aad49a5aab91ae3786af6d6a04144c4d9a4c1069c4669daef0e1391b8b2134f7f2ffdf835468ef66a293b5a99c4b5411286402785845d0427bb3baf85bcad8ccc97ca0874102f167c1b3020f4bb1205d1cd92020e5ae649c6cefee48ac625c65db388f910fa62b806a0fb4f6e3de19598fc1f1c95d5eaaa4334c078cf6768b16c4c53464fa6dfc24ccb962ebd1379c1e694266951938245d27aa0e1f200fa6f9b60bfa1f939a3b1e4130b33e6f5620236390561e050a5e53d7cdf9ee4fe39a974c8551f316e442107a63807a7a1d568d6e5d1cb7e26a44c2296f2d90a44d93edfe8f1191f2c16a7978e95013c05ba6aa7f533a2be900745ac79ea54735efe4be631161182a1622f07904b5cba14b71b8b91ebef8ec20b0b14bd552c55ecb907b95ba68d7b054392c0c728d1818d55615a53f62191314717d7d996ee4116ee71f6645f80724f1c4734f4212c043edd56ec149631956c720d45141906c4a47b807e5301f3d0651e16694004ec0f354cc22bbf81f228a4c0c3c403d4aa5310f6b3e9bd120254605e23ccb4405549c60961a7c682c75bce1bc5674c834a94f2f175e865c45f8ae8748cd2327623689d7c0ba1ff569e6784b77f966ea97e288bf0d7ef21140485c7ee2bdadfe8fdbbee0dee55f2bd6d4a011b2bea6e633f38bdedefc530f1a41d7dd1acc1784b907446fee0d09a8189d5981d91f2d680b07b943eb2c93d26c0eb183b3fc129422c540df2ba1a02bbc8d41e094595465392f8698226b2c94127371d3b9edba6946d2fb068cac81235ac939ef493f5e2b5b0b8eb1ce4a334b03cb22d111f98a552b66f4260d4133198d248e461275298cc0d557b157f459bdd94f6ffb68194c5b531b36110d53e084578d1697507b12eafc360224da1d84c9c9af78e48640fa32f7e75ed7fccb027e49a5c3c9297706293f71b72e34529076b9b067c533fa4e667dc8aa767de52f03c9c5275260c5a8fa3ffb5b94334a0c8f5d0edd3666ed53e1716c63306581e87c0ccf92ea4d604e628de7e009c20c2721ff3b690eb6ca74965f7e9ebd2ec16226a13da6be438601360ca7f68d461cb8f6892475d174c88194054b2b22a6200db6e5d5018655a14b7828856847d30a76c49beb7b595f49bcd9d4c63a5d6416a9b595a8e9e29bb065883fe8e4dff3388dfbc9515a4e76d676b58952d1fcdb8533ed5b85f34b02181d15ece2241bb89e1d0a91262b766b003bffbb2a469bd588ff717bde43940c9e7718405b4b36e0136720297a7c24487ea3c66f594b8570b88f6e1901db8f1587dbf99f82662cfb3188d04da732455aeb0ef7cefc4903ca9b0035484b44ac6b580b1338f8e0adcad6bcfe46b553dacb6184af8c85fe41c7aa573f3d5423265f28aa7505ad48c398deee74feaaa7bfde26872d14c80df4b865037106c301776128d5d5ed3e352f716f5e3e8c85a0ca286c8c87c02affc30a2231d988ccb2b87cef4792c9c230b3b8d6ca8056d2fca50778d36be8c1374398f09d1ae56d11bdbc598c9d1c3bf2fa21f01763b785c5799c9aedd6bac6424f9845734a0b70941a4a5d4c52c6806c51b5771d6ca12d24a14ab73c483a0ad2e0f3b0573887d17f7316e1bff113cea4048afa73fc973ffe44e3c81e10ea787b85dd20a5073ae4d8b3aefdae53fb2c190a3f2fa7bf775f72112758e8379325df1d34ddf8391d9c0ab727929affad2cf5d08f2012a4d61100f4f0378082737d70d15106a844741a0d818d5561744b6dab7fcd8caf7de50f66b9a4309b1ef49bde6f3cae789cf65d3389250649b67e487c88e13ac4c20b3a2df6bd24f003cf36c7f7028d13aae55a8707e4240416125b29ccdbe43fe4331d00d83e00cc9cb9a85378888ba2cdb44e7913efdf5ad9faa9c9148283818354fc098d6d45f2f0833637de731f68faf4911513f3d21e6d4e712d352d68e76ab9d0389fd24a7f8215e08697959e6a59bfc7d2fc5a70b9af831033245e100a8f194234b2869fb7eafbdc239299dffab7829f147ef63203d7bddd0584cd03299033d3bd5e60509d4cf1b17c2d89c8af002957353dbcac0b12dbfe068c264dc6696d379be2bfca2c0f94418c6210202d49336e61b1495df4db57280aaea3ce3981b1369b942876e7eb2bc29a0dd79fe56545e1c3daabd744f7124a49f669e9b44a4d37edea76c5308308869e91b6e14f9bd35e2ce2e02a173d1c14c6ae1990492f719d383762e83135822b4a5e50dafb33d78cc822890d7b52b65c14023983bb385916485d5ce568e3cf3ba1941fe87f4f054801fd3d3bd6e424938e00502d6a105749530ad5243a8d125515d307244bff10e3f8f975796035233fccce5f223e31173e6969e8f810e68451be23523de939b76dfd4ed4d6308c416bf4afd40bd130ee2cdd2ab8ab9d2ab2e04e158684ba48c6a1fc6aa3a3301e8862f9ee9f1cb52c5723959dea4b61e45df84cac0832ce410ef7294d367bf0d861e6cacd82974524c30fd68d71a74b49ba5ccd32249cd8c94f6cd3545242148261af45b73876ebf9c1919787ae9d561b3d0ede435103d99be0d6df544cbf27a13b601ccb0e15159567a35c8a19d5136d7ce05ee154e307284d5bbbcf3cc910e6ce877089ebbaf274a9525e8c1b504ca03330b8b133f4bed99145ba0efc4680b99a58a76e3f68543ebf9fa040e8864cae202593915f3172f89e9298d216e6eb264c837622523f56f76d1d375e97a250ae73b3cff9de27f42cea6a6250cf3f553312b17195dcd7be4bb3ec0a9223c650b6047a233af10a7c2c11b036d2c994961ff7912c47c458f30c33cd683de465ccef60404fa42165831b04fe952c546d849e5f5ebc79f247e4e6c6ed6bc78e9ee67b58c4321fd67979a5785371bd742c2ab7d6fd88916a7cd2722d25c0e08d4b8f75c91e9275ceff31338937f1b00122fb26bc3aa416ac865013f4cf54d7e47f15e24966d851999c871bb5914b5f490ea1152b2c8bc8e9fd2cdb7346219464d1bf91bd18c8f6e73e655be734ceda1736009394cfe9d1d4666d72c3fad8de86a5537d696161c035a6e647c1a4e7bd2ff49a0afeb9dea59c3f4d4093389c8f3521288a36aa8b3eb94b728253fb11828948783f4e07ffed103b36dd2ddc91847c9a7c71c05ebb55a12574a6f8d186254087a86972fb9803ef76e82c72c6270da62ccfcc7c9a28434318ca8d6f944dbbd287068924c14e479b591760c15be9155f6a0e2b0312594186ce0aafccfafac3b955fabe1ede7f1e5ea3e2cf1c0a46ff2a8f37aabeed3215214cfa17fab718216c524d43cc930ab05125c254c250b62b29548825395dc9a9e6b439628f7b19f2093a2e342606188e56fcb83b9a80ce48db5c20c0207a64d9c9d70f2a20f9e605ac18e51a840441e3e37039f5d30e809f276b2c93e14604d15166408e2e318996bb5e7ebc8e26c9f2a53a2290820ba6c86effe362cb6ca143f466c35183f9bb5a7b06b30d9ed0d25f33b33a150b3d4c57e64b88991767cd932057a59dd2a0c26f21f249a4aec8936f7768571bdcdf20c5aa6f32e2f5d24061347c7f4d0cd28eaf90c31e7494cef9a42733ed1ddc5b0b89f535a70ed626ed9a0a2cda0b04c4dc79f0404ae91cf045c4659e9a331dd407210d97627b499dd1e1867be8e953748816990830802aef70583fa669b10c49713ae08ba208269d510a690bb6625618a70dddf0f3cb3128580904df6b6caa56b24e88282b9a91349c2eb9113d76a1e9c5f6f9b638cb081ab038e7a1ecf28df5635c65597bf69e4ed498c77438765280608fb5ac3ddb98799ed74dcddf8d5119ac4cbfaf8ec88da3ad5a913013b72f51cc11f67c702c62aa929d5c4a8833fc34980a996bf7dc18f025cadc02ef07428015ff3da5aa744c92fd011652857f7b6b0470dff7bdf0ef4edcdfeeb7b3f5f866df1d499ea07b9f60e3b5fb77bb638db98991e2bfed5236240f0184b630e5268e0550cb18877f6af1f8f6e99f51b16d0fc064b0711c35708b357d8d89fce2630851c5caf2ab50a57b8de1ada93ab1fea38e0f72ed0e1424005d52226a776b132d425ed7636ba1bcb89eba7d6ecf7246fa6ba6acf3f4aeac97ef268497da41054bfb126d5f09c8db7ef929c7c406aca79c033166b404c675bd9aee6332f051754e504736935e582582a085709cfb20ff866e6cc64b54a6c21df123732a788943110a579d35784f461c28906e6a156565c48790d4a672cc3c4589944e44708b84d77587a10455f5fa59f4c07d6b1ca5191f5594cea7b78c94289c05535eeaf94cc4166e086dc41e2deebe76fec952b3b686c0c8d212514a416e993ce84d8257304e6d42757baa3a9cc592444d6aed0dd1e631319d7e6087c69801823a86838fbf6c9e5195ad30983a20c1b5e809bdfdf8ef31da3ce6541f1f006644b7e1b1d4fc3d5d4ed0da5689671ad706dbdafc31c570ad635e9e4f487fdae6c3a92d6063ed6d6aeb904e718bd03e6f30d54c83a0ecc11a0a3f63b27a86ec1c3e6687ea26b46ef44d745b1ca7e15bf731c2e9463480a973aa2cf1b347f310e24c5bfcdc3d83f3a8addfc6caba54cf0780ad12667f11ad4755c60b6bfdc689397363128f1c58ea77936c70dbf5075e1dcabab8fb28b02556da3162aa80fde21e50871f25399b24b96ffbea2c3d86ba556c9051db8dd97e04d8666b02d1050227754632a455d3c2680ceee95672347922832e505123c1fe725eebc8b5366878510ca1cdf3e6da58d3d498363e11c632b5373a927a46347ccea8c7bd7b3e3fc3fdd28ac7b4a65b21fbcc7c26a2c3f87ef705706a2a6fdd242f3f75336abef606093790e1bd162ed4db9e16d6e32fb00cc6159c9134d7973693ccfebcf7ee20715f4d0f3bf28c17442f4751003a0eca7e44a56cb1d4d6a0f03c8e203744f2d119a6bbb40fe982b8a82573e1497ebad836cc739150b8f3f09bb7cf8149462317a3c6ec596e9a4da0360ce10a857c951a9ea1cd030dce5d65d88c22d3e2199d0689ba633ac0f4f67bc7dab85f2851ca353ad99b4a081fc3bc4c9853c14c8b603e0ada12aacc588e4162bf134029745d843bdac14490a204ce41b53edd7409cc0f60140d833d415189decf600d5e34a67a4b4c6cb06e4f5d2a369c711b48a78421a9a62ae7b9d6139f6a3016b9b2132b2a2ee454e749d2ee71f74bf6e3c170c2952fb9255efe757dc8103bbf82464c9ecad17b451f38b485e8b50e9458d0a5f167f90a5f016d1d45b68a1ea91e4d11f064290f873b2e2f106ff15ccb6d267e30f5fbd24efd39f9a63dad8df2c8e308b11678aeef796a104baa3ac901f4d16b2ee69c1df05c02455b870558d688997df171a9e05e5d2ba11307f83e1f59591241da852dd5d8328e88544c87ea4091fc0d46a8d549663908ad825e36a80c7116db16903f3a756b85710e08591f616188094a80302ec026df347022ff923365d9e556524c4a0d40d668e98394cc7b8c30c8bbf7d6b1a59174857ccd89d9d64ff68b5a8fd38eb813179e0c072bf9d97d6b0b9e8488c0eda020df3bccb4a8e06ab8b66e004e081ac262f320ed572aca144e0baf09d6a55fd9a609ab98972bbb3b10e5ff3b2e63673def41fd570c6e083cbe5f03de9dbe2ef585485e2c8a2f21b8aad3f55f5c567df1c8f7d5531facf84ea770b57a8cf3378d1b15b839c65bd2ad5b75834c26a669e568da24e95a87610c6bd6717aa98ad5c7385b95aa89eaeaf229e65d19c18fbc91600a31b6bd1bb153e75e8f0642be8d93f13b6e589abd61133fd813e3ba3e1562452e99d7f3b20b6737fa71911774fcfcf5cb64794e4202949ba1288f9b815d7a78585dcad99dc67a450661fb6537b3b1d5d502f6e7818fcdb02b230ecd26de6912df4ed14437ecc0b0b97f5dd88173c2c45dfeb26b7bc9b3f3fddd4146fdd35ec42590a3723e7e9329d076282451dcd9f1cddba3e3884924aa0258ba751c30f31e06b3cc57ec35e27c7dc3b056e816d01c42b6d2cf84d7b9c6f20ba3ec4529eb3a0d217375418415e7228d553f466a791683502c87fe53d7b6738a8805dd9fa7007d6ea27bd8b24f9787f67f07b8e06ac7dc9ff70c5c58720b1bbad0716d7f39c4cae0b01a346dbcb50ed90e5001768c7200f72d828876973d3c5f0d81574413da19e6580a9fb254d4aa98942b18158aa1cb90c84c03fd18b963a4805e89313189786241e97dbe7d1504ea8d69e96c32c561c64f028a72ea62ccc9306b35d23bf49d1e8bb22c73783943efdedbde8a02e39bfca88259280e75a6f0055d9ed86790d615ef2a5f26a29894228df6422fc5c4c0ff64f4525fdebbfe78331530b3d57d41f74f777574d7489a5c8e1f41571706a7c1b378c5102e6c65d08d97f04b97a54b3fc2f5c49b655f5eea6084a97244541b1a81a85efdd4763a1f86099dff38a3c21743edda3ef696dc4eac4fca01a39a45b8de47e0ef6a80f942b828d72cbeb4c0bb0c449111b8862c65072cf25dece547a8743e6286be8073620d7d4599858dc9a1c37310ea13b660d5601327427e5fbca78e1a6d781ee739041ce6798076bed86e849ec744809804636494db5c18374098c8f4d69196e1e32d8857c92c3e2569ef0ae9ec38be17c52958547bc5771eb9b690936bc663bb982d3e2ee3d6262296173e55ebc3844499af103a6dcb6205c69c9573a8a59d652fc934c685585f73edc8e075c84a06a5a471ad2fc398f67a576b6365ce7f44f03303d0caf61530f42209302a92ec1d687052a6587a13903c0c40f62eda3a0a76f782d8370642c95be5ff6f872ed09f78e3869fbb55a7da4e2606f6e388afe868ebf3b6b8b0487e4b698fa28be08a0648d0a9bab528a19f6e6293c2ae82879d2f8b4e23d16c2b41a52855cb144e225b02f8f040d581b735254be2d8cda471b5b42c4088e4b36da333e762c5829ba0735894ec44f8fa43fea3b2f6e8f3416beb5519ecaaca7ae3ec8a7c34ebf51f62c14b4ee15730c9b12c5ae1123b7c78c82f63172bd1212760c5915553832ca70f6ed4711c221f508b167869daffbaef223fcaaa869a96b3daf5eea36e1f65e84e4909222b262a470e55c068ffa6ae0a2e6b28993d065fcda79f708f4d51a944d8a2c71a00d2e9bd7d8bb484a08b33b5ca97addbd0a8713ccd7edd172aa6c08030d1a5a8db8703d8d30707bdc883ddd0243459bd7989aa68ac00109b4251f4493266066e13f57b23da0133cfbf701daf8fc2ea559120733465b5f8f45d0082b2c11e02f353a36556291bcf83dd514afa4431c175b9ec81230dfcc00e38e1725e705a68231085ce7961153c23b78c99053836f30b6ab8f63f29ea6d9e0434990e5a36f067b858b5d08ca00bbc885a5f7bde4d7d9d714ca35e801b9cabe141609b747cdea2462ef8fb875c8add51ac24deb976ce81bffdec9906ba7634ca1b72d5e465c76df924f1867db929cc8651b7660373387c683a33df22d6434dda6252760274793f94f9afcbf04a9ecc69bdb295a3a52b69d0254fd3e0197be8d4d8e3614b7f223fd96f378b3c3e7e0b4b1752dcb29d21c35412d77dec907dbfc08f0c072106b4e6d79b2b0f0d9e9bc10ce8e8c4e6ee38beda8983f784e78bb5f2b32d2477589a0659d2fec8e2d3c45855b289aadb658a7f4b3e228abc0d5a4fdb7788f34a87ed755b2a8e191ef154df63066d1206deba0a8d3689c0be13e5fd738b030818318077f4008415254150d8c561806ecefe0a2b3c78d3671ff1382e5b101b99ee737c97d935dbfdde51d52199a288ad2d92ad9f1c0a004d774437f4d0e0b359fb9abb48eb6738d03e4b90319eb709b539b4933ed9486338445d59a0522fe86b1a88d8ad5ecccba80ccd2e465b8a5441f3448591f59069a6f3d8e092d8a6ef1ffbd9dce6749f9527fe23f02469a8f6a640c66c17518056fcbd9e0495510420b0dbc030c1c3f3f0c75bb625a8b0911f5732cc5d068721144fbc676f603146d60cb7f0c9153909da20c1a4b8ff571779c2e96d7c28ad74211bd73ddbc7ca1c68ffedf22a4b049571dcab395a6649e760583f4af122b2fcc70d386f5dc4dca18a6c260fae9b6f11ca2f8e196874f819cce9e084aa30888f588c7c9ca1651631df2c1fdaa1377ae2bfa1db087bd6ea518286f82063657b641fd8ed6734167e56db5a85c1c01300a0d441cb12699a59f01bacf8ce8db88890cdf23fa820bc0d05225e8ea87a2ac29e10bc1d33871312442263ec1a35278d370907c462709c34a96db89527346885d62c927a85efa4a304566f941b70bff2b16f64c271a04d1192ea439f46359773c0e5947a3dcb43e15fdf0c7bcdec0afd66cc4b1c0e9707e189514705db13af981903f4075de99e350bb276eef0e6185e52ffcbc72e11265ce33455ac816a56056e349892e7ff7a96200289c41354ab833ea8fb69738ad592743ccaba511186c5e88fe85bf682816961a4a4e296991a76377a101cdee92091e650c6afc41e7ca288e603d3cff0a0d992db7f639ca91b12be609b4e0f26fab36749b8d7f7d0bdea3a9a217fe9b9423c50fbc9736361bccc886a079e302270a201a84ec820bb9d6b3b97e05151b020d3d7fa1f594df715ae11f6fce76334490bb18b6c8a59048f1b6226729a3991e64ddc34ddd8e6f7fa2b6760f2ce57214419cc2a43afc9b9d538097c4a560690d1b50c7060f9c1eeefe838bdf3209337b7bb07fdb0cf774bc69822ffa1ba4fbb93b1fb52089eef46f2b9b88fbadc64dcad9f00d27d060974cca8bd0d4239fd3f7c6b35b34056de37d95adff9c5659bb1c614a94ab277d2787b2b24c9143bc163be1826c6adfc49ee1769af128d4d2117cd33f742c679e92c3fc35d90a9866be44e21a1ea5bec2bc1944e6bbae04f76d25b1f2b48376c3a9bdedcd71608d1f12eb54c97ebcab554d3f11b3e718d8a696e8ce08e44861e70842099dbc8c24a63e6427229c4231f186100ccf4d52d991d224d86d3ffabc92570b52e52dd806d5d152ffadd623c635d0764a7ef1c4e93fe14493f2f2269cab19cb3bbc3aa6d6db8d5fb280443a421323a7916f0db4088106493b9e451c112e968998a09cb85f6d2b52517b9977494226ab31228bd118e776dba080abeab07394ec98336c1ef3afcedf920ca3f2243c9a7dd3de87923e24ad5fbf80ff6be441025651b311cb3c312da8bb391a86af5da0285e59afa9a77eeecf46268c08a1b8c5ce6d473f8869cbd69fcc42bcda961a07b172efa0e637665078a7405f163e0a04f2e2b1d93ad466cd14b279bf807b34d5905805ce9a6e2efce01933c0899348700a6cf7a483dcb022986122c75ea27b38cf3d226730297bf470980ddbeb642e6ded6a56dd6f2904e54908e0f33ea3c1a5ecc0b2ae59eb27735e725a56dd5e65807aa17fd9b4e98b24b17ef7d499f0d898ead686304b21245e34293c63880e77dfd2a71954a8f7761c5cba455ed78e98d87c6ee850114b7353e7dd9ddd5d8ec75c05f5291e2e7107045ba943b95c9c9b7d646d50a6d6df56a54f4693faf900a4df3520aa43fa2fc8b8bbed8766196ba0994f8ce36cfce1eca21c9eb9cd562ff0bab3120ed51267636d591a606bc9a14488a63df8b6edf34ea7eb0d1c3a6a0cc0ac99586f5bef0e2238d4f741868836a2d4f1fc671891e65273f83c3715b579f2905e924b7d8f3218c2d3decd87e5c2fb81a5966aebb63fc6bffd2967f9508c1d5f070e8034525e7acdd6771c99e13ab2d8a26295cfc8d3d0750e8c6875a72e61601554c05bc5b65f84da99fcb7424bd473d54c8a6ae91c2e83175e1bccad358ccdb36042ac276db14a86e4459f7f53ff2b1e12fef16a33e9d8b9eff240ae5de4f3d71aa0ff7a5c8705f8024d478de233748d27c4d73eb1d458b2521ceb98858d93d61a76ec043e2c36855584bbf44a5a0d2fc1f2055f189661e49994483996d5d0ff999c04d22b23e05c3fbdbc713294cbb5ad838316ab545fde0d8a1aa78fe3a92538e28526c75611d93b373d48dbec712d25ededc4da60049c87fcdd079c2a0c6b0402cbfea0b6514ed76b861df3bef37e317a4f62a39d4fa36d3f0f4a84eecbd4593d8100f1624eaaa4dbd9a48a9bf12709b961be61f8b1517b2fa1d8f50461bc9d5c6e1e6672db5222155899ef9006f84319eaf57c21ad597ae358cbd0d9370e66b17fa2e59e29ed0397c25f6853204c0c8f0692b542aeebe5238d1a1dd24f9c331b884fa47d11d14ffcf4ea1c425f170944935b9a0931f16665c4398d6c3cf803fc4395dc372bf10a1cfb810c43ec2551f5d6e03c8b2deea89c9b66949be910184a024618dac73b50252db3121b19b8d3e4acce7b97d0b7d9d55206c55a800921786de19828aaef76a9d53ee5059aa571093f2173d18b85f3d6754710e64ffaf7f31443c24295445f82824a276e23824f559c4bb423236dd0eb80b9290c45dec30bc29d5b2fa2ee18389a8fb02fe1331e86f09d40cd03b4a831a45a586fb9031a3f6fd33e975b13bc29612ed2938d0e1b0997a9af0c2230df76cd7aa391ccb06fcba47aa63f6976f761590409e97b3391c58821023400612b264fd8852</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>自然语言处理</category>
      
    </categories>
    
    
    <tags>
      
      <tag>自然语言处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-卡特兰数</title>
    <link href="/article/f37649e5.html"/>
    <url>/article/f37649e5.html</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>leetcode785-判断二分图</title>
    <link href="/article/fba1bed.html"/>
    <url>/article/fba1bed.html</url>
    
    <content type="html"><![CDATA[<h1 id="785-判断二分图"><a href="#785-判断二分图" class="headerlink" title="785.判断二分图"></a>785.判断二分图</h1><p>给定一个无向图<code>graph</code>，当这个图为二分图时返回<code>true</code>。</p><p>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。</p><p><code>graph</code>将会以邻接表方式给出，<code>graph[i]</code>表示图中与节点i相连的所有节点。每个节点都是一个在<code>0</code>到<code>graph.length-1</code>之间的整数。这图中没有自环和平行边： <code>graph[i]</code>中不存在<code>i</code>，并且<code>graph[i]</code>中没有重复的值。</p><pre><code class="hljs angelscript">示例 <span class="hljs-number">1</span>:输入: [[<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]]输出: <span class="hljs-literal">true</span>解释: 无向图如下:<span class="hljs-number">0</span>---<span class="hljs-number">-1</span>|    ||    |<span class="hljs-number">3</span>---<span class="hljs-number">-2</span>我们可以将节点分成两组: &#123;<span class="hljs-number">0</span>, <span class="hljs-number">2</span>&#125; 和 &#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;。</code></pre><pre><code class="hljs angelscript">示例 <span class="hljs-number">2</span>:输入: [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]]输出: <span class="hljs-literal">false</span>解释: 无向图如下:<span class="hljs-number">0</span>---<span class="hljs-number">-1</span>| \  ||  \ |<span class="hljs-number">3</span>---<span class="hljs-number">-2</span>我们不能将节点分割成两个独立的子集。</code></pre><p><strong>注意:</strong></p><ul><li><code>graph</code> 的长度范围为 <code>[1, 100]</code>。</li><li><code>graph[i]</code> 中的元素的范围为 <code>[0, graph.length - 1]</code>。</li><li><code>graph[i]</code> 不会包含 <code>i</code> 或者有重复的值。</li><li>图是无向的: 如果<code>j</code> 在 <code>graph[i]</code>里边, 那么 <code>i</code> 也会在 <code>graph[j]</code>里边。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于图中的任意两个节点 $u$ 和 $v$，如果它们之间有一条边直接相连，那么 $u$ 和 $v$ 必须属于不同的集合。</p><p>如果给定的无向图连通，那么我们就可以任选一个节点开始，给它染成红色。随后将该节点直接相连的所有节点染成绿色，表示这些节点不能与起始节点属于同一个集合。我们再将这些绿色节点直接相连的所有节点染成红色，以此类推，直到无向图中的每个节点均被染色。</p><p>如果我们能够成功染色，那么红色和绿色的节点各属于一个集合，这个无向图就是一个二分图；如果我们未能成功染色，即在染色的过程中，某一时刻访问到了一个已经染色的节点，并且它的颜色与我们将要给它染上的颜色不相同(即一条边上两个节点同色)，也就说明这个无向图不是一个二分图。</p><h2 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h2><ul><li><p>我们任选一个节点开始，将其染成红色，并从该节点开始对整个无向图进行遍历；</p></li><li><p>在遍历的过程中，如果我们通过节点 u 遍历到了节点 v（即 u 和 v 在图中有一条边直接相连），那么会有两种情况：</p><ul><li>如果 v 未被染色，那么我们将其染成与 u 不同的颜色，并对 v 直接相连的节点进行遍历；</li><li>如果 v 被染色，并且颜色与 u 相同，那么说明给定的无向图不是二分图。我们可以直接退出遍历并返回 $\text{False}$ 作为答案。</li></ul></li></ul><p>当遍历结束时，说明给定的无向图是二分图，返回 $\text{True}$ 作为答案。</p><p>注意：题目中给定的无向图不一定保证连通，因此我们需要遍历每个节点，直至每一个节点都被染色，或确定答案为False为止。每次遍历开始时，任选一个未被染色的节点，将所有与该节点直接或间接相连的节点进行染色。</p><p>我们可以使用「深度优先搜索」或「广度优先搜索」对无向图进行遍历。</p><h2 id="方法一：深度优先搜索"><a href="#方法一：深度优先搜索" class="headerlink" title="方法一：深度优先搜索"></a>方法一：深度优先搜索</h2><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(self, graph: List[List[int]])</span> -&gt; bool:</span>        <span class="hljs-comment"># 方法一 深度优先搜索</span>        n = len(graph)        uncolored, red, green = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>        color = [<span class="hljs-number">0</span>] * n        valid = <span class="hljs-literal">True</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(curr, c)</span>:</span>            <span class="hljs-keyword">nonlocal</span> valid            color[curr] = c            ncolor = green <span class="hljs-keyword">if</span> color[curr] == red <span class="hljs-keyword">else</span> red            <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[curr]:                <span class="hljs-keyword">if</span> color[neighbor] == uncolored:                    dfs(neighbor, ncolor)                    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> valid:                        <span class="hljs-keyword">return</span>                <span class="hljs-keyword">elif</span> color[neighbor] != ncolor:                    valid = <span class="hljs-literal">False</span>                    <span class="hljs-keyword">return</span>            <span class="hljs-keyword">return</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):            <span class="hljs-keyword">if</span> color[i] == uncolored:                dfs(i, red)                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> valid:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre><h2 id="方法二：广度优先搜索"><a href="#方法二：广度优先搜索" class="headerlink" title="方法二：广度优先搜索"></a>方法二：广度优先搜索</h2><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(self, graph: List[List[int]])</span> -&gt; bool:</span>        <span class="hljs-comment"># 方法二 广度优先搜索        </span>        n = len(graph)        uncolored, red, green = <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>        color = [<span class="hljs-number">0</span>] * n        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n):            <span class="hljs-keyword">if</span> color[i] == uncolored:                color[i] = red                queue = collections.deque([i])                <span class="hljs-keyword">while</span> queue:                    curr = queue.popleft()                    ncolor = green <span class="hljs-keyword">if</span> color[curr] == red <span class="hljs-keyword">else</span> red                    <span class="hljs-keyword">for</span> neighbor <span class="hljs-keyword">in</span> graph[curr]:                        <span class="hljs-keyword">if</span> color[neighbor] == uncolored:                            color[neighbor] = ncolor                            queue.append(neighbor)                        <span class="hljs-keyword">elif</span> color[neighbor] != ncolor:                            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span>  <span class="hljs-literal">True</span></code></pre><h2 id="方法三：并查集"><a href="#方法三：并查集" class="headerlink" title="方法三：并查集"></a>方法三：并查集</h2><p>二分图中，每个顶点的所有邻接点都应该属于同一个集合，且捕鱼顶点处于同一个集合，所以可以使用并查集解决这个问题。遍历图中每个顶点，将当前顶点的所有邻接点进行合并，并判断这些邻接点中是否存在某一邻接点意见与当前顶点处于同一个集合中，若是，则说明此无向图不是二分图。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UFS</span>:</span>    <span class="hljs-comment"># 初始化p数组记录父节点，rank数组记录节点深度</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, length)</span>:</span>        self.p = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(length)]        self.rank = [<span class="hljs-number">0</span>] * length    <span class="hljs-comment"># 查找根节点</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(self, x)</span>:</span>        <span class="hljs-keyword">if</span> self.p[x] != x:            self.p[x] = self.find(self.p[x])        <span class="hljs-keyword">return</span> self.p[x]        <span class="hljs-comment"># 合并两个节点</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">union</span><span class="hljs-params">(self, x, y)</span>:</span>        rx, ry = self.find(x), self.finx(y)        <span class="hljs-keyword">if</span> self.rank[rx] &lt; self.rank[ry]:            self.p[rx] = ry        <span class="hljs-keyword">elif</span> self.rank[rx] &gt; self.rank[ry]:            self.p[ry] = rx        <span class="hljs-keyword">else</span>:            self.p[rx] = ry            self.rank[ry] += <span class="hljs-number">1</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(self, graph)</span>:</span>        ufs = UFS(len(graph))        <span class="hljs-keyword">for</span> i, g <span class="hljs-keyword">in</span> enumerate(graph):            root = ufs.find(i)            <span class="hljs-comment"># 若对面节点的根节点和当前节点根节点相同，返回False</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(len(g)):                <span class="hljs-keyword">if</span> root == ufs.find(g[j]):                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-comment"># 否则就把对面节点都合并起来</span>            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, len(g)):                ufs.union(g[j<span class="hljs-number">-1</span>],g[j])        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre><p>无rank版本</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">isBipartite</span><span class="hljs-params">(self, graph)</span>:</span><span class="hljs-comment"># 第二种并查集</span>        n=len(graph)        boss=[i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n)]        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find</span><span class="hljs-params">(x)</span>:</span>            <span class="hljs-keyword">nonlocal</span> boss            <span class="hljs-keyword">if</span> boss[x]!=x:                boss[x]=find(boss[x])            <span class="hljs-keyword">return</span> boss[x]        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span><span class="hljs-params">(x,y)</span>:</span>            bx=find(x)            by=find(y)            boss[bx]=by        <span class="hljs-keyword">for</span> i, e <span class="hljs-keyword">in</span> enumerate(graph):            fi=find(i)            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> e:                <span class="hljs-keyword">if</span> find(j)==fi:                    <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>            <span class="hljs-keyword">if</span> e:                b=e[<span class="hljs-number">0</span>]                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> e[<span class="hljs-number">1</span>:]:                    merge(b,j)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre><p><strong>补充：</strong><br><span style="color:blue">非局部变量用于未定义局部作用域的嵌套函数。这意味着变量(nonlocal x)既不能在局部作用域内，也不能在全局作用域内(就是说只能在嵌套函数里使用)。<br>我们使用非局部关键字(nonlocal)来创建非局部变量。</span></p><blockquote><p><strong>Note</strong> : If we change the value of a nonlocal variable, the changes appear in the local variable.<br>注意:如果我们改变一个非局部变量的值，这些改变会出现在局部变量中。（nonlocal 表示将变量声明为外层变量（外层函数的局部变量，而且不能是全局变量）。）</p></blockquote><p>详细内容参考<a href="https://blog.csdn.net/HappyRocking/article/details/80115241" target="_blank" rel="noopener">python中global,nonlocal的区别</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/is-graph-bipartite/solution/pan-duan-er-fen-tu-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://leetcode-cn.com/problems/is-graph-bipartite/solution/bfs-dfs-bing-cha-ji-san-chong-fang-fa-pan-duan-er-/" target="_blank" rel="noopener">BFS+DFS+并查集</a></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>深度优先搜索，广度优先搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linc-论文阅读1</title>
    <link href="/article/359b1a5e.html"/>
    <url>/article/359b1a5e.html</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">You must enter the password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="f2327b937692dd6410a4186a19f51c5448c34be475a0e3acf2fec0b64d9ddb0c">027b1835e3f265975ce03807829efe4a5a025edf8a1a7a38211872262a3b0079a6061bff3276c65ab13d9480f26d8bd9fad987866a1239f3f288046b7b6f40bd75e53b1471623589df5c4f9dca63cddc4b8e9351cd8ea2c9a6e3be2f1e29584b08d1ff45633358a6f694eae656255c40fe1e96be977f7da2a0348999abb0f4fd78f16900f47844ccf72faef1351d57daac940db11d5a1eaf74c5e00da3362e72f41c990c583054234c7af7e2e9ae46d9f29c7d4245f3ce185934b6d4af58b9a65fab75a0f54d8cd038fb71cbe70e6c31a78d778a10806e2a2136e7697184f27dec8ab3b4928897b70ed3cd58642e7381a1953155d9dbb454b2acae266a9cf113c8419399e36363eca01b76533fafeea7530c86027e814ea52a8a7cefe340441d2d12091270448e68bf1188a461d3dfa4ab7a53050118dfe20da89c839e6f54d1a854fdbc5f98feefa312617d2577632656c94a3bd0d772c2f5f932d02ccf7c808676b64676b2c4eb7cd66a5281e853d2366e471e8697dfeec29d2fd3d0e3219dab2ef56c3635466c01cd9578fab83f76b37511c65323b71d4befd01093f3a5a58ef9d0fd9caed2de4c3c8446b0c1c3e8b3daee254f677025f44fa914e56a3e3242f39ea312fb35ecc543549cff82617215e9af4225405452af3b11a59f6961f04480f49c7de16acbc40fab195c308a5b05d218d8b26cd0fea6fe5eb596e39622b98bf223a4a279bf2adb8092468fe96ab2b064b97c4f52c3855e68138bcd0ff1a2412a832762dece2417cb3b851e5d7bff4a8ea66e26c93c64f02790e0feefc5157e92b743f2b0ee4b08308cab893a7dad72ba2a340543d23c4d40b34de6d63be0e93f059a07cd886019d0e3f837d83e34c5d5d465f4647d96f8040730746edd7891fbf295f064f12f7491416b1e3323973cf387c0a4077ef0ab663dcc42222d032707aa10cd351b31fde5a6f6911a787bbed7e3f18bc023f9e8f6fd5783ad061370cb0960d2e4ea62ead33ff4542eedd2543f2432b577cda2fb604c9ac135e1a55b3dc3c67ee6b3c0903da1a92a069bd53fd89bca9d10b9879523ecbe89b368210e8a9fa485507e2e28eecb959ff254005de58dae69f00460c193a299690b87dc38f879320b5471d7fc16da1ae361686d79bae79a9cbae292e634ab2eaacc65fdff74b9c1ab2afe91ad1b11ceb81b9e7c8803a4c5d9f997d64b8175c247bd30d14efdc02a07bdcdd75fe2d9b805b5cfeef41f420fd0cc01a8aa48d8933e161aa1346da49d8dcdd7eb13633adea911e11865d4f975e540d93514deac6c4acf6c95ab29c4177df928d9a988c91bffe7144315abfe0649575bc5007579d77f394664f1cb296415f8f8fc3881e9ce2783be5d82f5180a577a07150a4f9b278bd752b9a716dcc7e9dc75f9d76fd036beea8cdfe402bf6ea69edadbfe16ccba5a8d0d5a444d9904fee75d409c36cc13631ee3565cfea25e73d571f8e18f87799cc8304809438de2841913b1fd0c94550cf452c93dcc956f361c76055c33f5045144afa62d5639abb873668021fccf733ee3791b2cac0bfa15db9d95395adbf48b9d7edd1ba6e521bd09489a24e6b26d9e9957eed5b35c1a876780f8622fba5c09a95f6ce081a0188b83fb5a2eb5dd82825b07dcf790689a7b7e184ab020c6d836de1b40df83ecde531b9f370f6ce96a973645edd3e6d5c3b8556f718b33aea8124afe1f269d9f8ac48b30a4a06a0d6ac953f6d75b0a0677289fd8c3c823dd68900049f93b0c8e6a2d7d2f2a136c8106a793a65e2092e87e217af39cd829ac20f35776d6b2be78cd6370816f69eaaf8d1919920d50e14b02fac4a9742071a8aefc6b56975c3ce6c69ad541ee7634ed220d06aba713e76f4c150f2b405b37ed082967b0cb366af40781a4f65aa8b9bb9e52f9a56e264d6be25ff7d3ec459090e3ec48992c5fa03bbc36ecd3939332037b2eaaf55e316cbbb4801b18c0355183363f6b7d750cbf3bbf22303d8f12f1a3063d98e7e2999f352bdfb8d3e34433fa058d6aa666792f9e66861d5680e84add438b683319c5cd421bfba5f3dc3ae418a4a5d7d66cb0c3d6742dfba857ef754f71fd395c6789270bab56e79657efbb2b196425fb88f51a4c4f4a7a3e5639434b32efbe53222ba2417b040f8d46ad18ae779154037b9c4eb0486b4b82adfdbe04b93cc36ad287090460e1b099ed2e87d83ef6c95ce36e72d93d540eaec67af94cecbd372b8c914a5267424a301b331abcea4939f0cc151ab44d3f297018da4dce86bd4e27199a3ad5bf9a73ad68fb7ea819e8d57c3707210bc38d7b847b21a34c3e31c74cf66a32b8f25276bba1c6c582757ec9b945ac93cd75fdc00ecfe5282a56a1444a978538856b94709190479546d22583cb778953e1955e06962748d6cbd44ccf43f5fc9ed7de0a4777f37d8ccc6f45e809963b2037ff619d798f65e966cdc8a9f14f3310169dc6fae07803967973a3f42b54821131fcbedf4165de54f33c5d7f28b3499e37118e9bc9ba7c57cbdf14a84972b9c9d45a02fbc8aab5712b222b19e8e3261325179f84328ebbf1e38792f68522600ae3161dfa01e3ce8800df7059a827c2e8c66d1c411eee8ca5a232711851786bf054d5d5e14f7c51e57e204fcebb6a8859980558c642c7536795e3053be21a017f4bc90d92b381ab9a45f7ee44c3729cc472f39047469f08935b01b029907487d781a72675023156b9ee7e9c34519aeb7c50b85ad37284c30d2f70bd6b327d53f0492c3d0b702c6396c71375bdc7fb66aa349a4ce2d14b7f8f4f633ddefb88a0c6ff079ef6f280e181b4e5b74e811e3d4f56ad433c5c3206ad11435d3002f96a3bca71dccfd40fc082da61c780656b1ff8e59c1f6ffbacb1cbeadba93e11d5cde90ef58501fafab965ab1f3ad501b36d3435496e4ad396ec473e4b5c2ddc05e646fc382f51f19d84aebdd555bd5e3d09647fe9236c15279edc6a6c7a5107e13faecf91c073c8401f60c4b584862ce753713edb3830c79ca916ddc5ed8f1009ad52a14368e663c1da376a4189e6fd872d75a7b8477668df5ce2d2ba52edb7e63c566111f42fa9777195af90fa0f40589d9bc48176785095873a55d26df5f1338d8abf5aba16e5184c72b50d5960360d05ba8e075f85e1f63a6f78c67d469f603e01146dfce955bba7dd1acb97b58f6b2d673d7750bfbfc7cc7a3e6bde677c0548f0d6d501e822de956ee9d661e17d6b8ba56b62e3e2d662bc0004297cc5f749b714f31423ef2990a8becf6ade740f093bd301e6500b6c8d2ab55cbc4e29cd449ebbccdf5d8dcca14d59633914bb77ed7a75d5eba444e5ed508c550647173bb41c3291e5dd244f1eebada5cb0c9cee921b79f450c9db77d0dc5256b88a8fb925ac0b6b0b2e91e9f39f068dfb8b77488de7f8da4b05f1b276bf47b1b81bfbb584367e29bb9dc0f650f14f373270ae33f1e34d081ecccd3ac862b0f5630c21106d25154625aecf7f483ca9344f86c8fa790ff546fd5cf7c772c29d1801ac6fe925b64b76422bd1f43fe12f94299ac5b2c02af01623d24c962e9d54fdd233563001a2fbf9752777c93fe9ce4d20405689f52962ad18fec02784378304a602e1983e01d6b68e25c0d7aa3f9a565202b7acc6c8c67c1bc206a8db4456b46410963c71c7b0e5794e4ee87a51d95cd6bb43d87b45b149df6788bcb51ff10d29b06240580ee0af06d7c4f170ad76faf8d4b48d6a651b57a51a34fd4044b4fa9f12a21cd72f9950520875f89127293b77aeeb4fbe978bbc5dfff928898902dd8b0a689ed89fbd2210cbee17e65f2b1804a0c2df99162dcd0131f16da9ff25d604f253814c8e056bef60c9032dfcf11fefbc408b9740c5be6752bd54b07496f1a559e5f39a6dd18e0e2418a103dc34f3be849e3c1036ef7e9933cc94d3f671308b0b86bf7169d67d69d365e7e4b6fa8e47af896ea23c58f5e4281e713d29cadb2ba97e9dbdc4c83604ddb76a6542f94e8871817fbb884cba2e7097c70a2794e4d691c3aa9717bad7215b86870f82493d2f229e0ea3c5fd18ddfde3c9dd42144d28d3b40a7129cdce3eab7efca0da5581df3baaa88735987fc0d254ecdc8bd62472c355ec263c35f0e15d0c730b7ab30aca22e7b62db43596da97fb88dae8f61ad7364be7e01c8b98636f8bad33c5ae65c937f2a5545071743cbd51f65890d14c8ef0bf1afe6ad3210737ecf4148a8ae039606842a9145f1856d1d18d94a5f92ac0814cdd1d2732f0fc2d7b477b863028cfaf7b1852f94fc3b722b9a1a8bea5ebb30d33135be7bb8a315af9d93426e33628dbb17b62ef7d94837799881eadac3ed0ec59f0c6312e05652b28f9151271abe9377d05e82e6be8d093d0c669e1f13545ce08dcf77b661df6463a9e3c208ceef87266494a72e11e364203e1c7ba4a65015343e97bd5bcae390fcc8c98b7b92ed218676f73da0b1079da28657ceeb53f2793e347ce1c5192dbb2e5b3629855fddb2f085cea97728b0843fb316b785c601094ff5066929b0fc8fbc3497ff6b837e66a79c8c0ccc176a15e1361982cb676e5c713246b8d1850a3682eabab7f4fe3fff8ec39fd062264ceb180f7c2f11a461ae882b9499c49c6f35d0e4ba1f513855c7226b54f95814aade175d9d7ac1b4ad4182d8bcbc4d560a1452be491f173298f368c2bdc268df43ab0273564c5c3a90c135d46cc4e42bda5e19d066ed7925ce6e3e99fb67c1554b09eb45dd2fe1f0ee847b16b965b6169dbce2d753cc916a2ee017cf0c1ee7fd48971b7f35e29523f7f2a74d62cbd77412dde5db1a1445590e7aa442dc79ca5eab1b46c398894ace318b22dd1126ec4c59d36e064a23528bc41ef9b6a0b6d3b8c41dcdb905b62ff3092dbfd317979b83ee954df1a61db6d852f03419eb2220381d91cae754d86261605ef5ea2121b5cbf585df2a09305dd37b2055b98ba1f60c38fe447a080441d3ffb0b6697bbd9cf10be140a11ca16e500085f5a6f2e673b42e7ff41bb4a4361ced89bfa314c35b517c1a2097ff3d777399d6c5999ae902813f57361245ff0175e3e6086cc67ebabfa3a5a7ca6b0ca6bcd1deefb7a799268c790ef6ca00b8a5f85d57aecd593bfb5c0cb1ce733828a3fc336b049f93452f52c722889f38de24e67a4f079f3047fea1d97f6e3981671924672a317869a4ed5cb7dbd9204b577c9e2aeb44da781c7815e4e2fc3c84457e391d3c548bd4eaa1b30be00845ddcfb25d60604c4669df009dd334e69949ef077f13a188fb729b69b1d36fd5c7d3831487f06fa0e1fc18b550d3cd665325bfd0a775687359fd09361a385b71a3b1e065a9bf9a2ef781a63c4934efe06366b81798e26516413a2739f3ed58eb29780e05fff908606d6296592813025ec2bb5a692e115dd128bb71bed104308a7648281f469588a13808ec99421f70b9adab23c7577a851987a066bfef9976095d15270ae136a2396424c989bc7ff5b50d036afffb804f6833c9dae2e7009ba15b6958661dfadcf29799c13a73e7c8737f979fcc66092094b7ce255b5a4a8ab2849c73413a6af50f122db0b0e95e258c641ea19424c557ba38a33b65e5a1adca5f8451f6d919411e397ca8896aac105ca5a2b5b1797e224498ee47baecedb265476eb2930c7e81ead649e883ab69f4fc1d81d5d16a2db6201376195c5e5b085d7c75339b5d45d9fc1c721d5bb346e5a19ce401728d4b152763310e59b0394590e2f1c01a80e07f5e6c3235586e3bfa11b67649c2301ea3f043dcb77b22a3cc6e350ef634e0d6d3b4da3e6c4d518be3c8217be0eb741dd636d0ed9cd84237004df6da0eb9691e1ddccc8c9883e5f0033d84bc173131a20a7a7499dc3c1c4541cab3fb3384016de3c7f8c391b49cd6b9be651ee4926092264b240f34b922de9b081de259c1016e41b4f6d249f414ac519a46e0112a298edb0e60a8f92f4c46ce506c44fae451540cacc599e1f00ff7d8827f3a1cbb757e0542766d29742eff0aff5577065bcd04fc7bf4b4aa5c9879fffdbbf7ca7e6aa366e6b165835b7473a3a1f95568e5f908047e995f7705c2b04f2482564dc3231b40c0ef6623e64f19ec2675b8d602c2659c2b7a01339a9ec95bf6b6a20e40a679ac526649635fb52ac194c3256a11bb97b3bc2d814ca29926dcf985e6ee46686278db81114683acb828dd7b8185c3ec541d333c569926af20b32971cc51a46e5139335f835579ec84a355646669c7e3357fdd6cf1488c87846636c70e6eedf4d4cbd56e7e74e372901b7e416c24d8254e31b89afb682759917c395145aa63712afb6e45d08ac487b714597b87ae0f4ab2691e8c81ede2a9efeba8fbf24fa7fe0457fbfc946b301645aa281d519a7af9da405ef3e416c8c361a17b0cf15222be22fa87bbc02ea31db18f71cb99cdf27ad38b2a11947a0eea88b0484f585e41d4b87fe2343c6c4975823318efde80fea66a8a41bcedbbad69ce1bcd0a12d275e1847a8e47ba179e68001abe7e156d992ccb1215aa9ed49ad25cbd80c21c00ac24129f8615ac4556930c1807826a9295ef2abd5b1502bec77347a7aa87b02563c02767dd56cc36156174d0066b50b9f8b30152652e4a0259cf3dbd264603ddcacc81090423a672854b5bbfe6e547089aadb55efd1465ca7e89cb0aa8d0e48b916e94dd280ff39dc01408def8b97bcb77bd5c08cd33601690dd984db6275074aa288fbe9820b27d492c72fa0422e5880d62c9e962b9e599e49d677ea722586dcba009e4c626a6e589b98498f8dfe7c9ef23530c330d8fb4bf8757e2a1d207227e08c4051159d2614baec811abd83eff5464055f3d2a6a29c22227388b03a26860a05f06779564cd2c03e52d17962b42632ba17615f0b92fdc3622dbce31199e5d021658a29015fbe8de0f793e8831b39178f361040b472748fbd2f70e291a4466deeba1d8b0ad2c038a5f53a5eff34a86f7531bb5b480d3a094a4a2962ac3c9d28da0898a4c623f547c493eec41cd8498882df4cb314326a10d1f89b516d9d7fc6b6e66bf65f585e3fb7f9145c4462bcdfa1128d640cf72a5fe7d43f64715f3f5808e4e8c8782f4b8567693b09b98955e3302f855f474c7966496f17557a6e4288768a35258108cc4f19b8ff7dccd4b731f8a11007e623fd3d81329e59625c70707e94ade1023fd086f43007b9f638eda6ae9dddf29cb1729272f6f98ebb9055ef38e6801e1aeccf978f4a42be4644cd50a3d8b15e25c27386524abc839edcbd7460de4db85d2e4831660fe1ce57725f285d25e52787cb5ecd2021d1d7f483c6e0c1a308ff421d2e5044a892307bd45a5f83d6b363bf91fc8146e90a9b74e7b82f63d710cacf19ed4545457a976ea3877710898a860699d6b48106418f55406e3296623bfb6ced44532e5ac578397c12a475c8d68c9a80ecded8ba0b5915e9bcd7fa119e89da68bb687ea5bf496814127b5f66f9c854bf0d2a6ba3608ed4c69ea7344ff057d773978e3818019ac006ac67a1739000614dfaf638d09c401c03c585e4d6e644d50f77a3492ca0574881714c0b876d3a2208a44a83a39f8cda499037ad4dfaa6e9caf76b9c9eece59fd68897ab6b03cc7ad80c7c3fd3ba75a8c82357f6b8ced173e7396f6faca934ba4cfd0d394bdeff7cb3f64357e2d4bc4a7b986361cb86bdb9977a6ee36fc9dcd2a2a0b40923c9f656d9aee6780924059b93d57283d2d2d9821dd3036b1d52fc8fc882f4e3d7700bbb1dd8e57f2a540cd521f48537738681d4f0a34bd8923fef2dc9308372d85c43068b7b6293093e928989fa77a8db2e2dcbbe85f0ec892c0c5796b755cb1343c7fd05be9c40c3665c6a6e0d034b4b66769889cc77331a41fd36c2a0e017fe7e690ddf93087d40e1446d3920e7bda7fc6ba5</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>linc实验室</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文阅读</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode102-二叉树的层序遍历</title>
    <link href="/article/e784d9f0.html"/>
    <url>/article/e784d9f0.html</url>
    
    <content type="html"><![CDATA[<h1 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102.二叉树的层序遍历"></a>102.二叉树的层序遍历</h1><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p><pre><code class="hljs angelscript">  <span class="hljs-number">3</span> / \<span class="hljs-number">9</span>  <span class="hljs-number">20</span>  /  \ <span class="hljs-number">15</span>   <span class="hljs-number">7</span></code></pre><p>返回其层次遍历结果：</p><pre><code class="hljs json">[  [<span class="hljs-number">3</span>],  [<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]]</code></pre><h2 id="方法一：广度优先搜索"><a href="#方法一：广度优先搜索" class="headerlink" title="方法一：广度优先搜索"></a>方法一：广度优先搜索</h2><p><strong>思路</strong></p><p>层序遍历就是把二叉树分层，然后每一层从左到右遍历：</p><p><img src="/article/e784d9f0/层次遍历.jpg" srcset="/img/loading.gif" alt="二叉树的层序遍历"></p><p>层序遍历要求的输出结果和BFS是不同的。层序遍历要求我们区分每一层，也就是返回二维数组。BFS遍历结果是一个一维数组，无法区分每一层。</p><p><img src="/article/e784d9f0/输出结果对比.jpg" srcset="/img/loading.gif" alt="输出结果对比"></p><p><strong>如何给BFS遍历结果分层？</strong>首先观察BFS遍历过程，结合进队列和出队列的过程：</p><p><img src="/article/e784d9f0/BFS.gif" srcset="/img/loading.gif" alt="BFS"></p><p>截取BFS遍历过程中的某个时刻：</p><p><img src="/article/e784d9f0/时刻图.jpg" srcset="/img/loading.gif" alt="时刻图"></p><p>此时队列中的结点是 3、4、5，分别来自第 1 层和第 2 层。这个时候，第 1 层的结点还没处理结束，第 2 层的结点就压入队列中，导致两层的结点在队列中紧挨在一起，无法区分队列中的结点来自哪一层。</p><p>因此，<span style="color:blue">在每一层遍历开始前，先记录队列中的结点数量 $n$ (也就是这一层的结点数量)</span>，然后处理这一层的 $n$ 个结点：将 $n$个节点的值放入结果集中，将 $n$个节点的孩子放入队列中。</p><p><strong>算法</strong></p><p>广度优先搜索简直和这道题完美适配~</p><ul><li>首先根元素入队</li><li>当队列不为空时<ul><li>求当前队列的长度$s_i$</li><li>依次从队列中取$s_i$个元素进行拓展，结束后进入下一次迭代</li></ul></li></ul><p>这样做正确的理由：参考<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p><p>它和 BFS 的区别在于 BFS 每次只取一个元素拓展，而这里每次取 $s_i$  个元素。在上述过程中的第 $i$ 次迭代就得到了二叉树的第 $i$ 层的 $s_i$  个元素。</p><p><strong>复杂度分析</strong></p><p>记树上所有节点的个数为 $n$。</p><ul><li>时间复杂度： $O(n)$。每个点进队出队各一次，故渐进时间复杂度为$O(n)$。</li><li>空间复杂度：$O(n)$。队列中元素的个数不超过 n<em>n</em> 个，故渐进空间复杂度为 $O(n)$。</li></ul><p><strong>代码</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:            <span class="hljs-keyword">return</span> []        res = []        cur_level = [root]        <span class="hljs-keyword">while</span> cur_level:            tmp = []            next_level = []            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> cur_level:                tmp.append(node.val)                <span class="hljs-keyword">if</span> node.left:                    next_level.append(node.left)                <span class="hljs-keyword">if</span> node.right:                    next_level.append(node.right)            res.append(tmp)            cur_level = next_level        <span class="hljs-keyword">return</span> re</code></pre><p>使用双端队列：</p><pre><code class="hljs python"><span class="hljs-comment"># Definition for a binary tree node.</span><span class="hljs-comment"># class TreeNode:</span><span class="hljs-comment">#     def __init__(self, x):</span><span class="hljs-comment">#         self.val = x</span><span class="hljs-comment">#         self.left = None</span><span class="hljs-comment">#         self.right = None</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">(self, root: TreeNode)</span> -&gt; List[List[int]]:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> root:<span class="hljs-keyword">return</span> []        ans = []        q = deque()        q.append(root)        <span class="hljs-keyword">while</span> len(q):            size = len(q)            res = []            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(size):                t = q.popleft()                res.append(t.val)                <span class="hljs-keyword">if</span> t.left:q.append(t.left)                <span class="hljs-keyword">if</span> t.right:q.append(t.right)            ans.append(res)        <span class="hljs-keyword">return</span> ans</code></pre><h2 id="方法二：深度优先搜索"><a href="#方法二：深度优先搜索" class="headerlink" title="方法二：深度优先搜索"></a>方法二：深度优先搜索</h2><p>用dfs做这道题。就是每层带一个level属性。参考<a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/die-dai-di-gui-duo-tu-yan-shi-102er-cha-shu-de-cen/" target="_blank" rel="noopener">bfs/dfs</a></p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$</li><li>空间复杂度：$O(h)$，$h$ 是树的高度</li></ul><p>今天小苏喝了三碗汤。都是算法题，汤浓度有点点低~ 明天要看论文，修改之前的文章啦~</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/bfs-de-shi-yong-chang-jing-zong-jie-ceng-xu-bian-l/" target="_blank" rel="noopener">BFS 的使用场景总结：层序遍历、最短路径问题(强烈推荐)</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/er-cha-shu-de-ceng-xu-bian-li-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/solution/die-dai-di-gui-duo-tu-yan-shi-102er-cha-shu-de-cen/" target="_blank" rel="noopener">bfs/dfs</a></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>深度优先搜索，广度优先搜索</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深度优先搜索和广度优先搜索</title>
    <link href="/article/9fa9df3c.html"/>
    <url>/article/9fa9df3c.html</url>
    
    <content type="html"><![CDATA[<h1 id="遍历搜索"><a href="#遍历搜索" class="headerlink" title="遍历搜索"></a>遍历搜索</h1><p>在树（图/状态集）中寻找特定结点(Node)</p><p><img src="/article/9fa9df3c/image-20200715200703764.png" srcset="/img/loading.gif" alt="image-20200715200703764"></p><h2 id="Node节点示例代码"><a href="#Node节点示例代码" class="headerlink" title="Node节点示例代码"></a>Node节点示例代码</h2><p><strong>Python</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, val)</span>:</span>        self.val = val        self.left, self.right = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span></code></pre><p><strong>C++</strong></p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span>    <span class="hljs-keyword">int</span> val;    TreeNode *left;    TreeNode *right;    TreeNode(<span class="hljs-keyword">int</span> x): val(x), left(<span class="hljs-literal">NULL</span>),right(<span class="hljs-literal">NULL</span>)&#123;&#125;&#125;</code></pre><p><strong>Java</strong></p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span></span>&#123;    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> val;    <span class="hljs-keyword">public</span> TreeNode left, right;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span></span>&#123;        <span class="hljs-keyword">this</span>.val = val;        <span class="hljs-keyword">this</span>.left = <span class="hljs-keyword">null</span>;        <span class="hljs-keyword">this</span>.right = <span class="hljs-keyword">null</span>;    &#125;&#125;</code></pre><h1 id="搜索-遍历"><a href="#搜索-遍历" class="headerlink" title="搜索-遍历"></a>搜索-遍历</h1><ul><li>每个节点都要访问一次</li><li>每个节点仅仅要访问一次</li><li>对于节点访问顺序不限<ul><li>深度优先：depth first search</li><li>广度优先：breadth first search</li></ul></li></ul><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node)</span>:</span><span class="hljs-keyword">if</span> node <span class="hljs-keyword">in</span> visited:        <span class="hljs-comment"># already visited</span>        <span class="hljs-keyword">return</span>    visited.add(node)        <span class="hljs-comment"># process current node</span>    <span class="hljs-comment"># ... # logic here</span>    dfs(node.left)    dfs(node.right)</code></pre><h1 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索(Depth-First-Search)"></a>深度优先搜索(Depth-First-Search)</h1><p><strong>遍历顺序</strong></p><p><img src="/article/9fa9df3c/image-20200715203020928.png" srcset="/img/loading.gif" alt="image-20200715203020928"></p><p><img src="/article/9fa9df3c/image-20200715203054856.png" srcset="/img/loading.gif" alt="image-20200715203054856"></p><p><strong>DFS代码-递归写法</strong></p><pre><code class="hljs python">visited = set()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dfs</span><span class="hljs-params">(node, visited)</span>:</span>    <span class="hljs-keyword">if</span> node <span class="hljs-keyword">in</span> visited: <span class="hljs-comment"># terminator</span>        <span class="hljs-comment"># already visited</span>        <span class="hljs-keyword">return</span>        visited.add(node)        <span class="hljs-comment"># process current node here.</span>    ...    <span class="hljs-keyword">for</span> next_node <span class="hljs-keyword">in</span> node.children():        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> next_node <span class="hljs-keyword">in</span> visited:            dfs(next_node, visited)</code></pre><p><strong>DFS代码-非递归写法</strong></p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">DFS</span><span class="hljs-params">(self, tree)</span>:</span>    <span class="hljs-keyword">if</span> tree.root <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        <span class="hljs-keyword">return</span> []        visited, stack = [], [tree.root]        <span class="hljs-keyword">while</span> stack:        node = stack.pop()        visited.add(node)                process(node)        nodes = generate_related_nodes(node)        stack.push(nodes)    <span class="hljs-comment"># other processing work</span>    ...</code></pre><p><span style="color:blue">栈：[根节点]-&gt;[子节点1，子节点2]-&gt;[子节点1，子节点21，子节点22]</span></p><h1 id="广度优先搜索-Breadth-First-Search"><a href="#广度优先搜索-Breadth-First-Search" class="headerlink" title="广度优先搜索(Breadth-First-Search)"></a>广度优先搜索(Breadth-First-Search)</h1><p><strong>遍历顺序</strong></p><p><img src="/article/9fa9df3c/image-20200715204551937.png" srcset="/img/loading.gif" alt="image-20200715204551937"></p><p><strong>DFS和BFS遍历对比</strong></p><p><img src="/article/9fa9df3c/image-20200715204646407.png" srcset="/img/loading.gif" alt="image-20200715204646407"></p><p><strong>BFS代码</strong></p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">BFS</span><span class="hljs-params">(graph, start, end)</span>:</span>queue = []    queue.append([start])    visited.add(start)        <span class="hljs-keyword">while</span> queue:        node = queue.pop()        visited.add(node)                process(node)        nodes = generate_related_nodes(node)        queue.push(nodes)            <span class="hljs-comment">#other processing work</span>    ...</code></pre><p><span style="color:blue">递归遍历代码比非递归代码简洁。这是因为递归的方式隐含地使用了系统的 栈，所以此时我们不需要自己维护一个数据结构。</span></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode96-不同的二叉搜索树</title>
    <link href="/article/e617005.html"/>
    <url>/article/e617005.html</url>
    
    <content type="html"><![CDATA[<h1 id="96-不同的二叉搜索树"><a href="#96-不同的二叉搜索树" class="headerlink" title="96.不同的二叉搜索树"></a>96.不同的二叉搜索树</h1><p>给定一个整数 <em>n</em>，求以 1 … <em>n</em> 为节点组成的二叉搜索树有多少种？</p><p><strong>示例:</strong></p><pre><code class="hljs angelscript">输入: <span class="hljs-number">3</span> 输出: <span class="hljs-number">5</span> 解释:给定 n = <span class="hljs-number">3</span>, 一共有 <span class="hljs-number">5</span> 种不同结构的二叉搜索树:   <span class="hljs-number">1</span>         <span class="hljs-number">3</span>     <span class="hljs-number">3</span>      <span class="hljs-number">2</span>      <span class="hljs-number">1</span>    \       /     /      / \      \     <span class="hljs-number">3</span>     <span class="hljs-number">2</span>     <span class="hljs-number">1</span>      <span class="hljs-number">1</span>   <span class="hljs-number">3</span>      <span class="hljs-number">2</span>    /     /       \                 \   <span class="hljs-number">2</span>     <span class="hljs-number">1</span>         <span class="hljs-number">2</span>                 <span class="hljs-number">3</span></code></pre><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p><strong>思路</strong><br>给定一个有序序列 $1 \cdots n$，为了构建出一颗二叉搜索树，遍历每个数字 $i$，将 $1 \cdots (i-1)$ 序列作为左子树，将 $(i+1) \cdots n$序列作为右子树，按照同样的方式递归构建左子树和右子树。<br><span style="color:blue">在上述构建的过程中，由于根的值不同，因此我们能保证每棵二叉搜索树是唯一的。</span><br>由此可见，原问题可以分解成规模较小的两个子问题，且子问题的解可以复用。动态规划很适合啦~<br><strong>算法</strong><br>题目要求是计算不同二叉搜索树的个数。为此，我们可以定义两个函数：</p><p><span style="color:blue">$G(n)$: 长度为 $n$ 的序列能构成的不同二叉搜索树的个数。</span><br><span style="color:blue">$F(i, n)$: 以 $i$ 为根、序列长度为 $n$ 的不同二叉搜索树个数 $(1 \leq i \leq n)$。</span></p><p>可见，$G(n)$ 是我们求解需要的函数。<br>$G(n)$可以从 $F(i, n)$ 得到，而 $F(i, n)$ 又会递归地依赖于 $G(n)$。<br><strong>首先，不同的二叉搜索树的总数 $G(n)$，是对遍历所有 $ i (1 \le i \le n)$ 的 $F(i, n)$ 之和</strong>。换言之：</p><script type="math/tex; mode=display">G(n) = \sum_{i=1}^{n} F(i, n)\qquad \qquad (1)</script><p>对于边界情况，当序列长度为 $1$（只有根）或为 $0$（空树）时，只有一种情况，即：</p><script type="math/tex; mode=display">G(0) = 1, \qquad G(1) = 1</script><p><strong>给定序列 $1 \cdots n$，我们选择数字 $i$ 作为根，则根为 $i$ 的所有二叉搜索树的集合是左子树集合和右子树集合的</strong><span style="color:blue">笛卡尔积(其实就是左子树的种类数乘以右子树的种类数，列举所有的可能性)</span>，对于笛卡尔积中的每个元素，加上根节点之后形成完整的二叉搜索树，如下图所示：</p><p><img src="/article/e617005/96_fig1.png" srcset="/img/loading.gif" alt="fig1"></p><p>举例而言，创建以 3 为根、长度为 7 的不同二叉搜索树，整个序列是 [1,2,3,4,5,6,7]，我们需要从左子序列 [1,2] 构建左子树，从右子序列 [4,5,6,7] 构建右子树，然后将它们组合（即笛卡尔积）。<br><strong>公式化：</strong>不同二叉搜索树的个数表示为 $F(3, 7)$。我们将 $[1,2]$ 构建不同左子树的数量表示为 $G(2)$, 从 $[4,5,6,7]$ 构建不同右子树的数量表示为 $G(4)$，<span style="color:blue">注意： $G(n)$ 和序列的内容无关，只和序列的长度有关。</span>于是，$F(3,7) = G(2) \cdot G(4)$。 因此，我们可以得到以下公式：</p><script type="math/tex; mode=display">F(i, n) = G(i-1) \cdot G(n-i) \qquad  \qquad (2)</script><p>将公式 $(1)$，$(2)$ 结合，可以得到 $G(n)$ 的递归表达式：</p><script type="math/tex; mode=display">G(n) = \sum_{i=1}^{n}G(i-1) \cdot G(n-i) \qquad  \qquad (3)</script><p>至此，我们从小到大计算 $G$ 函数即可，因为 $G(n)$ 的值依赖于 $G(0) \cdots G(n-1)$。</p><p><strong>代码</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(self, n)</span>:</span>        <span class="hljs-string">"""</span><span class="hljs-string">        :type n: int</span><span class="hljs-string">        :rtype: int</span><span class="hljs-string">        """</span>        G = [<span class="hljs-number">0</span>] * (n+<span class="hljs-number">1</span>)        G[<span class="hljs-number">0</span>], G[<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>, <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>, n+<span class="hljs-number">1</span>):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, i+<span class="hljs-number">1</span>):                G[i] += G[j<span class="hljs-number">-1</span>] * G[i-j]<span class="hljs-keyword">return</span> G[n]</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度 : $O(n^2)$，其中 $n$ 表示二叉搜索树的节点个数。$G(n)$ 函数一共有 $n$ 个值需要求解，每次求解需要 $O(n)$ 的时间复杂度，因此总时间复杂度为 $O(n^2)$。</li></ul><p>空间复杂度 : $O(n)$。我们需要 $O(n)$ 的空间存储 $G$ 数组。</p><h2 id="方法二：数学"><a href="#方法二：数学" class="headerlink" title="方法二：数学"></a>方法二：数学</h2><p><strong>思路与算法</strong><br>事实上我们在方法一中推导出的 G(n)函数的值在数学上被称为<a href="https://baike.baidu.com/item/catalan/7605685?fr=aladdin" target="_blank" rel="noopener">卡塔兰数</a> C_n。卡塔兰数更便于计算的定义如下:<br>C_0 = 1, \qquad C_{n+1} = \frac{2(2n+1)}{n+2}C_n<br>C0=1,Cn+1=n+22(2n+1)Cn<br>证明过程可以参考上述文献，此处不再赘述。</p><p><strong>代码</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(self, n)</span>:</span>        C = <span class="hljs-number">1</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">0</span>, n):            C = C * <span class="hljs-number">2</span> * (<span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>)/(i+<span class="hljs-number">2</span>)        <span class="hljs-keyword">return</span> int(C)</code></pre><p><strong>复杂度分析</strong></p><p>时间复杂度 : $O(n)$，其中 $n$ 表示二叉搜索树的节点个数。我们只需要循环遍历一次即可。<br>空间复杂度 : $O(1)$。我们只需要常数空间存放若干变量。</p><p>今天的小菜鸡喝到汤啦~</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>银行营销策略分析</title>
    <link href="/article/a0f63eb7.html"/>
    <url>/article/a0f63eb7.html</url>
    
    <content type="html"><![CDATA[<h1 id="1、数据说明与预处理"><a href="#1、数据说明与预处理" class="headerlink" title="1、数据说明与预处理"></a>1、数据说明与预处理</h1><p>本文选取的数据集来自于葡萄牙银行机构的营销活动，是以电话访谈的形式，根据访谈结果整合而成的。而电话访谈的最终目的，则是判断该用户是否会认购银行的产品——定期存款（term deposit）。因此，与该数据集对应的任务是分类任务，而分类目标是预测客户是(yes)否(no)认购定期存款，对应了数据集中的特征 <code>y</code> 。</p><p>数据集一共包含了41188个样例和17个特征，它们的含义如下表所示。</p><ul><li><strong>I.客户个人信息</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">列名</th><th style="text-align:center">含义说明</th></tr></thead><tbody><tr><td style="text-align:center">age</td><td style="text-align:center">年龄</td></tr><tr><td style="text-align:center">job</td><td style="text-align:center">工作</td></tr><tr><td style="text-align:center">marital</td><td style="text-align:center">婚姻状况</td></tr><tr><td style="text-align:center">education</td><td style="text-align:center">受教育程度</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">是否有违约记录</td></tr><tr><td style="text-align:center">housing</td><td style="text-align:center">是否有住房贷款</td></tr><tr><td style="text-align:center">loan</td><td style="text-align:center">是否有个人贷款</td></tr><tr><td style="text-align:center">balance</td><td style="text-align:center">个人存款余额</td></tr></tbody></table></div><ul><li><strong>II.上一次电话营销的记录</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">列名</th><th style="text-align:center">含义说明</th></tr></thead><tbody><tr><td style="text-align:center">contact</td><td style="text-align:center">联系途径</td></tr><tr><td style="text-align:center">month</td><td style="text-align:center">月份</td></tr><tr><td style="text-align:center">day</td><td style="text-align:center">日期</td></tr><tr><td style="text-align:center">duration</td><td style="text-align:center">持续时间</td></tr></tbody></table></div><ul><li><strong>III.其他记录</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">列名</th><th style="text-align:center">含义说明</th></tr></thead><tbody><tr><td style="text-align:center">campaign</td><td style="text-align:center">在本次营销周期内与该客户的总通话次数</td></tr><tr><td style="text-align:center">pdays</td><td style="text-align:center">距离上一次通话的时间</td></tr><tr><td style="text-align:center">previous</td><td style="text-align:center">在过去的营销活动中与该客户的总通话次数</td></tr><tr><td style="text-align:center">poutcome</td><td style="text-align:center">上一次营销活动是否成功</td></tr></tbody></table></div><ul><li><strong>IV.目标特征</strong></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">列名</th><th style="text-align:center">含义说明</th></tr></thead><tbody><tr><td style="text-align:center">y</td><td style="text-align:center">是否认购定期存款</td></tr></tbody></table></div><p>引入包。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> snsplt.rcParams[<span class="hljs-string">'font.sans-serif'</span>]=[<span class="hljs-string">'SimHei'</span>]<span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler, OneHotEncoder, LabelEncoder<span class="hljs-keyword">from</span> sklearn.base <span class="hljs-keyword">import</span> BaseEstimator, TransformerMixin<span class="hljs-keyword">from</span> sklearn.utils <span class="hljs-keyword">import</span> check_array<span class="hljs-keyword">from</span> sklearn.pipeline <span class="hljs-keyword">import</span> Pipeline, FeatureUnion<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split,cross_val_score,cross_val_predict<span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler, LabelEncoder<span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC<span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> tree<span class="hljs-keyword">from</span> sklearn.neural_network <span class="hljs-keyword">import</span> MLPClassifier<span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> GradientBoostingClassifier<span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> GaussianNB<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> roc_curve,roc_auc_score,confusion_matrix<span class="hljs-keyword">import</span> time<span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> sparse<span class="hljs-comment"># init_notebook_mode(connected=True)</span></code></pre><p>导入数据集，将包含所有数据的数据集命令为bank，通过前五行数据简要查看数据构成。</p><pre><code class="hljs python">bank = pd.read_csv(<span class="hljs-string">'./data/bank-full.csv'</span>,sep=<span class="hljs-string">';'</span>)bank.head()</code></pre><p>输出：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:right">age</th><th style="text-align:right">job</th><th style="text-align:right">marital</th><th style="text-align:right">education</th><th style="text-align:right">default</th><th style="text-align:right">balance</th><th style="text-align:right">housing</th><th style="text-align:right">loan</th><th style="text-align:right">contact</th><th style="text-align:right">day</th><th style="text-align:right">month</th><th style="text-align:right">duration</th><th style="text-align:right">campaign</th><th style="text-align:right">pdays</th><th style="text-align:right">previous</th><th style="text-align:right">poutcome</th><th style="text-align:right">y</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:right">58</td><td style="text-align:right">management</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">2143</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">261</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td></tr><tr><td style="text-align:left">1</td><td style="text-align:right">44</td><td style="text-align:right">technician</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">29</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">151</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td></tr><tr><td style="text-align:left">2</td><td style="text-align:right">33</td><td style="text-align:right">entrepreneur</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">2</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">76</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td></tr><tr><td style="text-align:left">3</td><td style="text-align:right">47</td><td style="text-align:right">blue-collar</td><td style="text-align:right">married</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td><td style="text-align:right">1506</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">92</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td></tr><tr><td style="text-align:left">4</td><td style="text-align:right">33</td><td style="text-align:right">unknown</td><td style="text-align:right">single</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td><td style="text-align:right">1</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">198</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td></tr></tbody></table></div><p>接下来我们通过 describe() 和 info() 函数查看各列数据的分布情况。 这里我们首先用 describe() 函数分别观察数值型（numeric）特征的分布和类别型（categorical）特征的分布。 下边是数值型（numeric）特征的分布。</p><pre><code class="hljs python">bank.describe() <span class="hljs-comment">#数值型（numeric）特征数据分布</span></code></pre><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:right">age</th><th style="text-align:right">balance</th><th style="text-align:right">day</th><th style="text-align:right">duration</th><th style="text-align:right">campaign</th><th style="text-align:right">pdays</th><th>previous</th></tr></thead><tbody><tr><td style="text-align:left">count</td><td style="text-align:right">45211.000000</td><td style="text-align:right">45211.000000</td><td style="text-align:right">45211.000000</td><td style="text-align:right">45211.000000</td><td style="text-align:right">45211.000000</td><td style="text-align:right">45211.000000</td><td>45211.000000</td></tr><tr><td style="text-align:left">mean</td><td style="text-align:right">40.936210</td><td style="text-align:right">1362.272058</td><td style="text-align:right">15.806419</td><td style="text-align:right">258.163080</td><td style="text-align:right">2.763841</td><td style="text-align:right">40.197828</td><td>0.580323</td></tr><tr><td style="text-align:left">std</td><td style="text-align:right">10.618762</td><td style="text-align:right">3044.765829</td><td style="text-align:right">8.322476</td><td style="text-align:right">257.527812</td><td style="text-align:right">3.098021</td><td style="text-align:right">100.128746</td><td>2.303441</td></tr><tr><td style="text-align:left">min</td><td style="text-align:right">18.000000</td><td style="text-align:right">-8019.000000</td><td style="text-align:right">1.000000</td><td style="text-align:right">0.000000</td><td style="text-align:right">1.000000</td><td style="text-align:right">-1.000000</td><td>0.000000</td></tr><tr><td style="text-align:left">25%</td><td style="text-align:right">33.000000</td><td style="text-align:right">72.000000</td><td style="text-align:right">8.000000</td><td style="text-align:right">103.000000</td><td style="text-align:right">1.000000</td><td style="text-align:right">-1.000000</td><td>0.000000</td></tr><tr><td style="text-align:left">50%</td><td style="text-align:right">39.000000</td><td style="text-align:right">448.000000</td><td style="text-align:right">16.000000</td><td style="text-align:right">180.000000</td><td style="text-align:right">2.000000</td><td style="text-align:right">-1.000000</td><td>0.000000</td></tr><tr><td style="text-align:left">75%</td><td style="text-align:right">48.000000</td><td style="text-align:right">1428.000000</td><td style="text-align:right">21.000000</td><td style="text-align:right">319.000000</td><td style="text-align:right">3.000000</td><td style="text-align:right">-1.000000</td><td>0.000000</td></tr><tr><td style="text-align:left">max</td><td style="text-align:right">95.000000</td><td style="text-align:right">102127.000000</td><td style="text-align:right">31.000000</td><td style="text-align:right">4918.000000</td><td style="text-align:right">63.000000</td><td style="text-align:right">871.000000</td><td>275.000000</td></tr></tbody></table></div><p>接着我们观察类别型（categorical）特征的分布.</p><pre><code class="hljs python">bank.describe(include=[<span class="hljs-string">'O'</span>]) <span class="hljs-comment">#类别型（categorical）特征数据分布</span></code></pre><p>输出：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:right">job</th><th style="text-align:right">marital</th><th style="text-align:right">education</th><th style="text-align:right">default</th><th style="text-align:right">housing</th><th style="text-align:right">loan</th><th style="text-align:right">contact</th><th style="text-align:right">month</th><th style="text-align:right">poutcome</th><th style="text-align:right">y</th></tr></thead><tbody><tr><td style="text-align:left">count</td><td style="text-align:right">45211</td><td style="text-align:right">45211</td><td style="text-align:right">45211</td><td style="text-align:right">45211</td><td style="text-align:right">45211</td><td style="text-align:right">45211</td><td style="text-align:right">45211</td><td style="text-align:right">45211</td><td style="text-align:right">45211</td><td style="text-align:right">45211</td></tr><tr><td style="text-align:left">unique</td><td style="text-align:right">12</td><td style="text-align:right">3</td><td style="text-align:right">4</td><td style="text-align:right">2</td><td style="text-align:right">2</td><td style="text-align:right">2</td><td style="text-align:right">3</td><td style="text-align:right">12</td><td style="text-align:right">4</td><td style="text-align:right">2</td></tr><tr><td style="text-align:left">top</td><td style="text-align:right">blue-collar</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">may</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td></tr><tr><td style="text-align:left">freq</td><td style="text-align:right">9732</td><td style="text-align:right">27214</td><td style="text-align:right">23202</td><td style="text-align:right">44396</td><td style="text-align:right">25130</td><td style="text-align:right">37967</td><td style="text-align:right">29285</td><td style="text-align:right">13766</td><td style="text-align:right">36959</td><td style="text-align:right">39922</td></tr></tbody></table></div><p>下面用info()观察缺失值的情况。</p><pre><code class="hljs python">bank.info()</code></pre><p>输出：</p><pre><code class="hljs scala">&lt;<span class="hljs-class"><span class="hljs-keyword">class</span> '<span class="hljs-title">pandas</span>.<span class="hljs-title">core</span>.<span class="hljs-title">frame</span>.<span class="hljs-title">DataFrame</span>'<span class="hljs-title">&gt;</span></span><span class="hljs-class"><span class="hljs-title">RangeIndex</span></span>: <span class="hljs-number">45211</span> entries, <span class="hljs-number">0</span> to <span class="hljs-number">45210</span><span class="hljs-type">Data</span> columns (total <span class="hljs-number">17</span> columns):age          <span class="hljs-number">45211</span> non-<span class="hljs-literal">null</span> int64job          <span class="hljs-number">45211</span> non-<span class="hljs-literal">null</span> <span class="hljs-class"><span class="hljs-keyword">object</span></span><span class="hljs-class"><span class="hljs-title">marital</span>      45211 <span class="hljs-title">non-null</span> <span class="hljs-title">object</span></span><span class="hljs-class"><span class="hljs-title">education</span>    45211 <span class="hljs-title">non-null</span> <span class="hljs-title">object</span></span><span class="hljs-class"><span class="hljs-title">default</span>      45211 <span class="hljs-title">non-null</span> <span class="hljs-title">object</span></span><span class="hljs-class"><span class="hljs-title">balance</span>      45211 <span class="hljs-title">non-null</span> <span class="hljs-title">int64</span></span><span class="hljs-class"><span class="hljs-title">housing</span>      45211 <span class="hljs-title">non-null</span> <span class="hljs-title">object</span></span><span class="hljs-class"><span class="hljs-title">loan</span>         45211 <span class="hljs-title">non-null</span> <span class="hljs-title">object</span></span><span class="hljs-class"><span class="hljs-title">contact</span>      45211 <span class="hljs-title">non-null</span> <span class="hljs-title">object</span></span><span class="hljs-class"><span class="hljs-title">day</span>          45211 <span class="hljs-title">non-null</span> <span class="hljs-title">int64</span></span><span class="hljs-class"><span class="hljs-title">month</span>        45211 <span class="hljs-title">non-null</span> <span class="hljs-title">object</span></span><span class="hljs-class"><span class="hljs-title">duration</span>     45211 <span class="hljs-title">non-null</span> <span class="hljs-title">int64</span></span><span class="hljs-class"><span class="hljs-title">campaign</span>     45211 <span class="hljs-title">non-null</span> <span class="hljs-title">int64</span></span><span class="hljs-class"><span class="hljs-title">pdays</span>        45211 <span class="hljs-title">non-null</span> <span class="hljs-title">int64</span></span><span class="hljs-class"><span class="hljs-title">previous</span>     45211 <span class="hljs-title">non-null</span> <span class="hljs-title">int64</span></span><span class="hljs-class"><span class="hljs-title">poutcome</span>     45211 <span class="hljs-title">non-null</span> <span class="hljs-title">object</span></span><span class="hljs-class"><span class="hljs-title">y</span>            45211 <span class="hljs-title">non-null</span> <span class="hljs-title">object</span></span><span class="hljs-class"><span class="hljs-title">dtypes</span></span>: int64(<span class="hljs-number">7</span>), <span class="hljs-class"><span class="hljs-keyword">object</span>(<span class="hljs-params">10</span>)</span><span class="hljs-class"><span class="hljs-title">memory</span> <span class="hljs-title">usage</span></span>: <span class="hljs-number">5.9</span>+ <span class="hljs-type">MB</span></code></pre><p>通过观察 info() 函数给我们的结果，我们可以看出数据集中不存在缺失值。但是在此数据表中，部分数据以字符串 ‘unknown’ 形式存在于类别型特征里。使用如下代码查看类别型特征中 ‘unknown’ 的个数。</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> bank.select_dtypes(include=[<span class="hljs-string">'object'</span>]).columns:  <span class="hljs-comment">#筛选类型为object型数据，统计'unknown'个数</span>    print(col+<span class="hljs-string">':'</span>,bank[bank[col]==<span class="hljs-string">'unknown'</span>][col].count())</code></pre><p>输出：</p><pre><code class="hljs yaml"><span class="hljs-attr">job:</span> <span class="hljs-number">288</span><span class="hljs-attr">marital:</span> <span class="hljs-number">0</span><span class="hljs-attr">education:</span> <span class="hljs-number">1857</span><span class="hljs-attr">default:</span> <span class="hljs-number">0</span><span class="hljs-attr">housing:</span> <span class="hljs-number">0</span><span class="hljs-attr">loan:</span> <span class="hljs-number">0</span><span class="hljs-attr">contact:</span> <span class="hljs-number">13020</span><span class="hljs-attr">month:</span> <span class="hljs-number">0</span><span class="hljs-attr">poutcome:</span> <span class="hljs-number">36959</span><span class="hljs-attr">y:</span> <span class="hljs-number">0</span></code></pre><p>对于 ‘unknown’ 值的处理，我们会在3.1进行分析。<br>我们接下来查看样本类别分布情况。</p><pre><code class="hljs python">bank[<span class="hljs-string">'y'</span>].value_counts()</code></pre><p>输出：</p><pre><code class="hljs yaml"><span class="hljs-literal">no</span>     <span class="hljs-number">39922</span><span class="hljs-literal">yes</span>     <span class="hljs-number">5289</span><span class="hljs-attr">Name:</span> <span class="hljs-string">y,</span> <span class="hljs-attr">dtype:</span> <span class="hljs-string">int64</span></code></pre><pre><code class="hljs python">f, ax = plt.subplots(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, figsize=(<span class="hljs-number">4</span>,<span class="hljs-number">4</span>))colors = [<span class="hljs-string">"#FA5858"</span>, <span class="hljs-string">"#64FE2E"</span>]labels =<span class="hljs-string">"no"</span>, <span class="hljs-string">"yes"</span>ax.set_title(<span class="hljs-string">'是否认购定期存款'</span>, fontsize=<span class="hljs-number">16</span>)bank[<span class="hljs-string">"y"</span>].value_counts().plot.pie(explode=[<span class="hljs-number">0</span>,<span class="hljs-number">0.25</span>], autopct=<span class="hljs-string">'%1.2f%%'</span>, ax=ax, shadow=<span class="hljs-literal">True</span>, colors=colors,labels=labels, fontsize=<span class="hljs-number">14</span>, startangle=<span class="hljs-number">25</span>)plt.axis(<span class="hljs-string">'off'</span>)plt.show()</code></pre><h1 id="2、探索性分析"><a href="#2、探索性分析" class="headerlink" title="2、探索性分析"></a>2、探索性分析</h1><h2 id="2-1-数值型特征的分布情况"><a href="#2-1-数值型特征的分布情况" class="headerlink" title="2.1 数值型特征的分布情况"></a>2.1 数值型特征的分布情况</h2><p>我们首先通过DataFrame的 <code>hist()</code> 函数查看每个数值型特征的分布情况。值得一提的是，虽然我们是对整个数据表调用 <code>hist()</code> 函数，但是由于程序本身无法直观的理解类别型特征（因为它们以str形式存储），所以它们不会显示。</p><pre><code class="hljs python">bank.hist(bins=<span class="hljs-number">25</span>, figsize=(<span class="hljs-number">14</span>,<span class="hljs-number">10</span>))plt.show()</code></pre><p><img src="/article/a0f63eb7/输出1.png" srcset="/img/loading.gif" alt="输出1"></p><h2 id="2-2-类别型特征对结果的影响"><a href="#2-2-类别型特征对结果的影响" class="headerlink" title="2.2 类别型特征对结果的影响"></a>2.2 类别型特征对结果的影响</h2><p>接下来我们查看正负样本点的不同之处。我们首先通过调用 <code>barplot()</code> 函数查看受教育程度 <code>education</code> 对结果（是否会定期存款）的影响。观察下图我们可以看出，受过高等教育（tertiary）和中等教育（secondary）的人群比只接受过初等教育的人更容易认购定期存款。</p><pre><code class="hljs python">f, ax = plt.subplots(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>, figsize=(<span class="hljs-number">9</span>,<span class="hljs-number">7</span>))palette = [<span class="hljs-string">"#64FE2E"</span>, <span class="hljs-string">"#FA5858"</span>]sns.barplot(x=<span class="hljs-string">"education"</span>, y=<span class="hljs-string">"balance"</span>, hue=<span class="hljs-string">"y"</span>, data=bank, palette=palette, estimator=<span class="hljs-keyword">lambda</span> x: len(x) / len(bank) * <span class="hljs-number">100</span>)<span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> ax.patches:    ax.annotate(<span class="hljs-string">'&#123;:.2f&#125;%'</span>.format(p.get_height()),(p.get_x() * <span class="hljs-number">1.02</span>, p.get_height() * <span class="hljs-number">1.02</span>),fontsize=<span class="hljs-number">12</span>)    ax.set_xticklabels(bank[<span class="hljs-string">"education"</span>].unique(), rotation=<span class="hljs-number">0</span>, rotation_mode=<span class="hljs-string">"anchor"</span>,fontsize=<span class="hljs-number">15</span>)ax.set_title(<span class="hljs-string">"受教育程度与结果（是否认购定期存款）的关系"</span>,fontsize=<span class="hljs-number">20</span>)ax.set_xlabel(<span class="hljs-string">"受教育程度"</span>,fontsize=<span class="hljs-number">15</span>)ax.set_ylabel(<span class="hljs-string">"(%)"</span>,fontsize=<span class="hljs-number">15</span>)plt.show()</code></pre><p><img src="/article/a0f63eb7/输出2.png" srcset="/img/loading.gif" alt="输出2"></p><p>观察年龄随职业的分布，可以看出职业为 retired、self-employed两类左右两侧的分布有较明显的差别。在退休人群(retired)中，年龄越大的人越容易购买产品；个体经营(self-employed)群体中，年轻化的人更容易购买产品；观察年龄岁婚姻状况的分布，可以看出结婚的人(married)、离婚的人(divorced)相对于单身的人在是否会认购定期存款方面分布有明显的差异，前两类群体在高龄中越容易购买产品。</p><h2 id="2-3-特征间的相关性"><a href="#2-3-特征间的相关性" class="headerlink" title="2.3 特征间的相关性"></a>2.3 特征间的相关性</h2><p>接下来我们通过关系矩阵查看各特征之间的关系，如下图所示。</p><pre><code class="hljs python">fig, ax = plt.subplots(figsize=(<span class="hljs-number">12</span>, <span class="hljs-number">8</span>))bank[<span class="hljs-string">'y'</span>] = LabelEncoder().fit_transform(bank[<span class="hljs-string">'y'</span>])numeric_bank = bank.select_dtypes(exclude=<span class="hljs-string">"object"</span>)corr_numeric = numeric_bank.corr()<span class="hljs-comment">#关系矩阵，以矩阵形式存储</span>sns.heatmap(corr_numeric, annot=<span class="hljs-literal">True</span>, vmax=<span class="hljs-number">1</span>, vmin=<span class="hljs-number">-1</span>, cmap=<span class="hljs-string">"Blues"</span>,annot_kws=&#123;<span class="hljs-string">"size"</span>:<span class="hljs-number">15</span>&#125;)<span class="hljs-comment">#热力图，即关系矩阵</span>ax.set_title(<span class="hljs-string">"Correlation Matrix"</span>, fontsize=<span class="hljs-number">24</span>)ax.tick_params(axis=<span class="hljs-string">'y'</span>,labelsize=<span class="hljs-number">11.5</span>)ax.tick_params(axis=<span class="hljs-string">'x'</span>,labelsize=<span class="hljs-number">11.5</span>)plt.show()</code></pre><p><img src="/article/a0f63eb7/输出3.png" srcset="/img/loading.gif" alt="输出3"></p><p>观察上图我们可以看出通话时长（ <code>duration</code> ）与结果（ <code>y</code> ）相关性很高。这也可以很通俗地理解，如果通话时长 = 0，则y =0；如果通话时长越长，则客户越有可能接受银行的营销活动而认购定期存款（如下图所示）。</p><p>但是在实际中，这样做会有一个很大的问题，因为在执行通话之前你并不知道 <code>duration</code> 会是多久。但是，在通话结束后，显然你就会知道客户的意愿是认购还是拒绝。因此，应在模型训练前将这一特征删除。在下图，我们把 <code>duration</code> 按<strong>低于或高于其平均值</strong>分成了 <strong>below_average</strong> 和 <strong>over_average</strong> 两类，探究这两种情况下人们购买意愿的差异。根据我们的假设，属于 <strong>below_average</strong> 的人群中大多数人不会认购定期存款，属于 <strong>over_average</strong> 的人群中大多数人会选择认购定期存款。下方的代码生成的图像验证了我们的猜想。</p><pre><code class="hljs python">sns.set(rc=&#123;<span class="hljs-string">'figure.figsize'</span>:(<span class="hljs-number">11.7</span>,<span class="hljs-number">8.27</span>)&#125;)sns.set_style(<span class="hljs-string">'whitegrid'</span>)avg_duration = bank[<span class="hljs-string">'duration'</span>].mean()<span class="hljs-comment">#建立一个新特征以区分大于duration平均值的duration和小于均值的duration</span>bank[<span class="hljs-string">"duration_status"</span>] = np.nanlst = [bank]<span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> lst:    col.loc[col[<span class="hljs-string">"duration"</span>] &lt; avg_duration, <span class="hljs-string">"duration_status"</span>] = <span class="hljs-string">"below_average"</span>    col.loc[col[<span class="hljs-string">"duration"</span>] &gt; avg_duration, <span class="hljs-string">"duration_status"</span>] = <span class="hljs-string">"above_average"</span><span class="hljs-comment">#pd.crosstab另外一种分析双变量的方式,通过它可以得到两个变量之间的交叉信息，并作图。</span>pct_term = pd.crosstab(bank[<span class="hljs-string">'duration_status'</span>], bank[<span class="hljs-string">'y'</span>]).apply(<span class="hljs-keyword">lambda</span> r: round(r/r.sum(), <span class="hljs-number">2</span>) * <span class="hljs-number">100</span>, axis=<span class="hljs-number">1</span>)ax = pct_term.plot(kind=<span class="hljs-string">'bar'</span>, stacked=<span class="hljs-literal">False</span>, cmap=<span class="hljs-string">'RdBu'</span>)ax.set_xticklabels([<span class="hljs-string">'below_average'</span>,<span class="hljs-string">'over_average'</span>], rotation=<span class="hljs-number">0</span>, rotation_mode=<span class="hljs-string">"anchor"</span>,fontsize=<span class="hljs-number">18</span>)plt.title(<span class="hljs-string">"The Influence of Duration"</span>, fontsize=<span class="hljs-number">18</span>)plt.xlabel(<span class="hljs-string">"Duration Status"</span>, fontsize=<span class="hljs-number">18</span>);plt.ylabel(<span class="hljs-string">"Percentage (%)"</span>, fontsize=<span class="hljs-number">18</span>)<span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> ax.patches:    ax.annotate(<span class="hljs-string">'&#123;:.2f&#125;%'</span>.format(p.get_height()), (p.get_x() , p.get_height() * <span class="hljs-number">1.02</span>))plt.show()bank.drop([<span class="hljs-string">'duration_status'</span>], axis=<span class="hljs-number">1</span>, inplace=<span class="hljs-literal">True</span>)</code></pre><p><img src="/article/a0f63eb7/输出4.png" srcset="/img/loading.gif" alt="输出4"></p><p>确实， <strong>over_average</strong> 的情况下就已经有95%的人选择认购定期存款了，这印证了我们的猜想。但是在本例中，我们不对<code>duration</code>做删除处理。大家可以尝试删除此特征执行同样的步骤，根据<a href="#5、总结">总结</a>中最后一段提出的分别应用这两个模型进行预测的策略，应用到实际情况中。</p><h1 id="3、数据预处理与特征工程"><a href="#3、数据预处理与特征工程" class="headerlink" title="3、数据预处理与特征工程"></a>3、数据预处理与特征工程</h1><h2 id="3-1-缺失值处理"><a href="#3-1-缺失值处理" class="headerlink" title="3.1 缺失值处理"></a>3.1 缺失值处理</h2><p>在本文的开始我们提到过，虽然对所有数值型特征不存在缺失值，但是类别型特征中有以 <code>&#39;unknown&#39;</code> 形式存在的值，它们的统计结果如下，代码已在文章开头给出。</p><div class="table-container"><table><thead><tr><th style="text-align:center">列名</th><th style="text-align:center">unknown值个数</th></tr></thead><tbody><tr><td style="text-align:center">job</td><td style="text-align:center">288</td></tr><tr><td style="text-align:center">marital</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">education</td><td style="text-align:center">1857</td></tr><tr><td style="text-align:center">default</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">housing</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">loan</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">contact</td><td style="text-align:center">13020</td></tr><tr><td style="text-align:center">month</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">poutcom</td><td style="text-align:center">36959</td></tr><tr><td style="text-align:center">y</td><td style="text-align:center">0</td></tr></tbody></table></div><p>缺失值处理通常有如下的方法：</p><ol><li>对于 <code>&#39;unknown&#39;</code> 值数量较少的特征，包括<code>job</code>和<code>education</code>，删除这些特征是缺失值(<code>&#39;unknown&#39;</code>)的行；</li><li>如果预计该特征对于学习模型效果影响不大，而且在此例中缺失值都是类别型数据，可以对(<code>&#39;unknown&#39;</code>)值赋众数；</li><li>可以使用数据完整的行作为训练集，以此来预测缺失值，特征<code>concact</code>，<code>poutcome</code>的缺失值可以采取此法；</li><li>我们也可以不处理它，使其保留 <code>&#39;unknown&#39;</code> 的形式作为该特征的一种可能取值。</li></ol><p>这里我们采取策略4，不进行处理。原因可以参考下一行代码，例如上一次营销活动的结果(<code>poutcome</code>)这一特征，大部分都是 <code>&#39;unknown&#39;</code> 值，其原因可以归结于这些客户没有经历上一次营销活动，是第一次参加本活动。当然，我们也可以结合策略1、3进行处理。</p><pre><code class="hljs python">bank[<span class="hljs-string">'poutcome'</span>].value_counts()</code></pre><p>输出：</p><pre><code class="hljs subunit">unknown    36959<span class="hljs-keyword">failure     </span>4901other       1840<span class="hljs-keyword">success     </span>1511Name: poutcome, dtype: int64</code></pre><h2 id="3-2-类型转换"><a href="#3-2-类型转换" class="headerlink" title="3.2 类型转换"></a>3.2 类型转换</h2><p>我们知道原数据表中有数值型和类别型两种数据类型，但是机器学习模型只能读取数值型数据，因此我们需要进行类型的转换。通常我们可以先通过 <code>LabelEncoder</code> 再通过 <code>OneHotEncoder</code> 将str型数据转换成OneHot编码。但是这样每次只能操作一个类别型数据，函数写起来会比较麻烦。</p><p>在最新的开发者版本sklearn中提供了 <code>CategoricalEncoder</code>，它的好处是可以直接转换多列类别型数据。虽然当前版本没有提供，但是下面的代码块中供 了 <code>CategoricalEncoder</code> 的方法，只需要运行即可。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CategoricalEncoder</span><span class="hljs-params">(BaseEstimator, TransformerMixin)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, encoding=<span class="hljs-string">'onehot'</span>, categories=<span class="hljs-string">'auto'</span>, dtype=np.float64,</span></span><span class="hljs-function"><span class="hljs-params">                 handle_unknown=<span class="hljs-string">'error'</span>)</span>:</span>        self.encoding = encoding        self.categories = categories        self.dtype = dtype        self.handle_unknown = handle_unknown    <span class="hljs-comment">#fit方法与其他Encoder的使用方法一样</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span><span class="hljs-params">(self, X, y=None)</span>:</span>        <span class="hljs-string">"""Fit the CategoricalEncoder to X.</span><span class="hljs-string">        Parameters</span><span class="hljs-string">        ----------</span><span class="hljs-string">        X : array-like, shape [n_samples, n_feature]</span><span class="hljs-string">            The data to determine the categories of each feature.</span><span class="hljs-string">        Returns</span><span class="hljs-string">        -------</span><span class="hljs-string">        self</span><span class="hljs-string">        """</span>        <span class="hljs-comment">#编码有三种方式，按顺序分别为稀疏形式的独热编码，独热编码和序列编码。</span>        <span class="hljs-keyword">if</span> self.encoding <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">'onehot'</span>, <span class="hljs-string">'onehot-dense'</span>, <span class="hljs-string">'ordinal'</span>]:            template = (<span class="hljs-string">"encoding should be either 'onehot', 'onehot-dense' "</span>                        <span class="hljs-string">"or 'ordinal', got %s"</span>)            <span class="hljs-keyword">raise</span> ValueError(template % self.handle_unknown)        <span class="hljs-keyword">if</span> self.handle_unknown <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> [<span class="hljs-string">'error'</span>, <span class="hljs-string">'ignore'</span>]:            template = (<span class="hljs-string">"handle_unknown should be either 'error' or "</span>                        <span class="hljs-string">"'ignore', got %s"</span>)            <span class="hljs-keyword">raise</span> ValueError(template % self.handle_unknown)        <span class="hljs-keyword">if</span> self.encoding == <span class="hljs-string">'ordinal'</span> <span class="hljs-keyword">and</span> self.handle_unknown == <span class="hljs-string">'ignore'</span>:            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">"handle_unknown='ignore' is not supported for"</span>                             <span class="hljs-string">" encoding='ordinal'"</span>)        <span class="hljs-comment">#处理特征</span>        X = check_array(X, dtype=np.object, accept_sparse=<span class="hljs-string">'csc'</span>, copy=<span class="hljs-literal">True</span>)        n_samples, n_features = X.shape        self._label_encoders_ = [LabelEncoder() <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n_features)]        <span class="hljs-comment">#CategoricalEncoder的具体思路如下：</span>        <span class="hljs-comment">#先用LabelEncoder()转换成序列数据，再用OneHotEncoder()增添新的列转换成独热编码</span>        <span class="hljs-comment">#在fit阶段，只提取每一列的类别信息，为transform阶段做准备。</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n_features):            le = self._label_encoders_[i]            Xi = X[:, i]            <span class="hljs-keyword">if</span> self.categories == <span class="hljs-string">'auto'</span>:                le.fit(Xi)            <span class="hljs-keyword">else</span>:                valid_mask = np.in1d(Xi, self.categories[i])                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> np.all(valid_mask):                    <span class="hljs-keyword">if</span> self.handle_unknown == <span class="hljs-string">'error'</span>:                        diff = np.unique(Xi[~valid_mask])                        msg = (<span class="hljs-string">"Found unknown categories &#123;0&#125; in column &#123;1&#125;"</span>                               <span class="hljs-string">" during fit"</span>.format(diff, i))                        <span class="hljs-keyword">raise</span> ValueError(msg)                le.classes_ = np.array(np.sort(self.categories[i]))        self.categories_ = [le.classes_ <span class="hljs-keyword">for</span> le <span class="hljs-keyword">in</span> self._label_encoders_]        <span class="hljs-keyword">return</span> self    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transform</span><span class="hljs-params">(self, X)</span>:</span>        <span class="hljs-string">"""Transform X using one-hot encoding.</span><span class="hljs-string">        Parameters</span><span class="hljs-string">        ----------</span><span class="hljs-string">        X : array-like, shape [n_samples, n_features]</span><span class="hljs-string">            The data to encode.</span><span class="hljs-string">        Returns</span><span class="hljs-string">        -------</span><span class="hljs-string">        X_out : sparse matrix or a 2-d array</span><span class="hljs-string">            Transformed input.</span><span class="hljs-string">        """</span>        <span class="hljs-comment">#处理特征</span>        X = check_array(X, accept_sparse=<span class="hljs-string">'csc'</span>, dtype=np.object, copy=<span class="hljs-literal">True</span>)        n_samples, n_features = X.shape        X_int = np.zeros_like(X, dtype=np.int)        X_mask = np.ones_like(X, dtype=np.bool)        <span class="hljs-comment">#转换类别型变量到独热编码的步骤</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(n_features):            valid_mask = np.in1d(X[:, i], self.categories_[i])            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> np.all(valid_mask):                <span class="hljs-keyword">if</span> self.handle_unknown == <span class="hljs-string">'error'</span>:                    diff = np.unique(X[~valid_mask, i])                    msg = (<span class="hljs-string">"Found unknown categories &#123;0&#125; in column &#123;1&#125;"</span>                           <span class="hljs-string">" during transform"</span>.format(diff, i))                    <span class="hljs-keyword">raise</span> ValueError(msg)                <span class="hljs-keyword">else</span>:                    <span class="hljs-comment"># Set the problematic rows to an acceptable value and</span>                    <span class="hljs-comment"># continue `The rows are marked `X_mask` and will be</span>                    <span class="hljs-comment"># removed later.</span>                    X_mask[:, i] = valid_mask                    X[:, i][~valid_mask] = self.categories_[i][<span class="hljs-number">0</span>]            X_int[:, i] = self._label_encoders_[i].transform(X[:, i])        <span class="hljs-comment">#对于序列编码，直接处理后返回</span>        <span class="hljs-keyword">if</span> self.encoding == <span class="hljs-string">'ordinal'</span>:            <span class="hljs-keyword">return</span> X_int.astype(self.dtype, copy=<span class="hljs-literal">False</span>)        <span class="hljs-comment">#以下是处理类别型数据的步骤</span>        mask = X_mask.ravel()        n_values = [cats.shape[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> cats <span class="hljs-keyword">in</span> self.categories_]        n_values = np.array([<span class="hljs-number">0</span>] + n_values)        indices = np.cumsum(n_values)        column_indices = (X_int + indices[:<span class="hljs-number">-1</span>]).ravel()[mask]        row_indices = np.repeat(np.arange(n_samples, dtype=np.int32),                                n_features)[mask]        data = np.ones(n_samples * n_features)[mask]        <span class="hljs-comment">#默认是以稀疏矩阵的形式输出，节约内存</span>        out = sparse.csc_matrix((data, (row_indices, column_indices)),                                shape=(n_samples, indices[<span class="hljs-number">-1</span>]),                                dtype=self.dtype).tocsr()        <span class="hljs-comment">#将稀疏矩阵转换成普通矩阵</span>        <span class="hljs-keyword">if</span> self.encoding == <span class="hljs-string">'onehot-dense'</span>:            <span class="hljs-keyword">return</span> out.toarray()        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> out</code></pre><pre><code class="hljs python">bank[[<span class="hljs-string">'job'</span>,<span class="hljs-string">'marital'</span>]].head(<span class="hljs-number">5</span>)</code></pre><p>输出：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:right">job</th><th style="text-align:right">marital</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:right">management</td><td style="text-align:right">married</td></tr><tr><td style="text-align:left">1</td><td style="text-align:right">technician</td><td style="text-align:right">single</td></tr><tr><td style="text-align:left">2</td><td style="text-align:right">entrepreneur</td><td style="text-align:right">married</td></tr><tr><td style="text-align:left">3</td><td style="text-align:right">blue-collar</td><td style="text-align:right">married</td></tr><tr><td style="text-align:left">4</td><td style="text-align:right">unknown</td><td style="text-align:right">single</td></tr></tbody></table></div><pre><code class="hljs python">a = CategoricalEncoder().fit_transform(bank[[<span class="hljs-string">'job'</span>,<span class="hljs-string">'marital'</span>]])a.toarray()</code></pre><p>输出：</p><pre><code class="hljs angelscript"><span class="hljs-built_in">array</span>([[<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, ..., <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>],       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, ..., <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>],       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, ..., <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>],       ...,       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, ..., <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>],       [<span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>, ..., <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>],       [<span class="hljs-number">0.</span>, <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, ..., <span class="hljs-number">0.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">0.</span>]])</code></pre><pre><code class="hljs python">a.shape</code></pre><p>输出：</p><pre><code class="hljs angelscript">(<span class="hljs-number">45211</span>, <span class="hljs-number">15</span>)</code></pre><pre><code class="hljs python">print(bank)</code></pre><p>输出：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:right">age</th><th style="text-align:right">job</th><th style="text-align:right">marital</th><th style="text-align:right">education</th><th style="text-align:right">default</th><th style="text-align:right">balance</th><th style="text-align:right">housing</th><th style="text-align:right">loan</th><th style="text-align:right">contact</th><th style="text-align:right">day</th><th style="text-align:right">month</th><th style="text-align:right">duration</th><th style="text-align:right">campaign</th><th style="text-align:right">pdays</th><th style="text-align:right">previous</th><th style="text-align:right">poutcome</th><th>y</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:right">58</td><td style="text-align:right">management</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">2143</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">261</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">1</td><td style="text-align:right">44</td><td style="text-align:right">technician</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">29</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">151</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">2</td><td style="text-align:right">33</td><td style="text-align:right">entrepreneur</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">2</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">76</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">3</td><td style="text-align:right">47</td><td style="text-align:right">blue-collar</td><td style="text-align:right">married</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td><td style="text-align:right">1506</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">92</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">4</td><td style="text-align:right">33</td><td style="text-align:right">unknown</td><td style="text-align:right">single</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td><td style="text-align:right">1</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">198</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">5</td><td style="text-align:right">35</td><td style="text-align:right">management</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">231</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">139</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">6</td><td style="text-align:right">28</td><td style="text-align:right">management</td><td style="text-align:right">single</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">447</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">217</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">7</td><td style="text-align:right">42</td><td style="text-align:right">entrepreneur</td><td style="text-align:right">divorced</td><td style="text-align:right">tertiary</td><td style="text-align:right">yes</td><td style="text-align:right">2</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">380</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">8</td><td style="text-align:right">58</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">primary</td><td style="text-align:right">no</td><td style="text-align:right">121</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">50</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">9</td><td style="text-align:right">43</td><td style="text-align:right">technician</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">593</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">55</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">10</td><td style="text-align:right">41</td><td style="text-align:right">admin.</td><td style="text-align:right">divorced</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">270</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">222</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">11</td><td style="text-align:right">29</td><td style="text-align:right">admin.</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">390</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">137</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">12</td><td style="text-align:right">53</td><td style="text-align:right">technician</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">6</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">517</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">13</td><td style="text-align:right">58</td><td style="text-align:right">technician</td><td style="text-align:right">married</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td><td style="text-align:right">71</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">71</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">14</td><td style="text-align:right">57</td><td style="text-align:right">services</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">162</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">174</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">15</td><td style="text-align:right">51</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">primary</td><td style="text-align:right">no</td><td style="text-align:right">229</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">353</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">16</td><td style="text-align:right">45</td><td style="text-align:right">admin.</td><td style="text-align:right">single</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td><td style="text-align:right">13</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">98</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">17</td><td style="text-align:right">57</td><td style="text-align:right">blue-collar</td><td style="text-align:right">married</td><td style="text-align:right">primary</td><td style="text-align:right">no</td><td style="text-align:right">52</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">38</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">18</td><td style="text-align:right">60</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">primary</td><td style="text-align:right">no</td><td style="text-align:right">60</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">219</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">19</td><td style="text-align:right">33</td><td style="text-align:right">services</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">0</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">54</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">20</td><td style="text-align:right">28</td><td style="text-align:right">blue-collar</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">723</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">262</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">21</td><td style="text-align:right">56</td><td style="text-align:right">management</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">779</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">164</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">22</td><td style="text-align:right">32</td><td style="text-align:right">blue-collar</td><td style="text-align:right">single</td><td style="text-align:right">primary</td><td style="text-align:right">no</td><td style="text-align:right">23</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">160</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">23</td><td style="text-align:right">25</td><td style="text-align:right">services</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">50</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">342</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">24</td><td style="text-align:right">40</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">primary</td><td style="text-align:right">no</td><td style="text-align:right">0</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">181</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">25</td><td style="text-align:right">44</td><td style="text-align:right">admin.</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">-372</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">172</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">26</td><td style="text-align:right">39</td><td style="text-align:right">management</td><td style="text-align:right">single</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">255</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">296</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">27</td><td style="text-align:right">52</td><td style="text-align:right">entrepreneur</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">113</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">127</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">28</td><td style="text-align:right">46</td><td style="text-align:right">management</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">-246</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">255</td><td style="text-align:right">2</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">29</td><td style="text-align:right">36</td><td style="text-align:right">technician</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">265</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">348</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td>…</td></tr><tr><td style="text-align:left">45181</td><td style="text-align:right">46</td><td style="text-align:right">blue-collar</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">6879</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">15</td><td style="text-align:right">nov</td><td style="text-align:right">74</td><td style="text-align:right">2</td><td style="text-align:right">118</td><td style="text-align:right">3</td><td style="text-align:right">failure</td><td>0</td></tr><tr><td style="text-align:left">45182</td><td style="text-align:right">34</td><td style="text-align:right">technician</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">133</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">15</td><td style="text-align:right">nov</td><td style="text-align:right">401</td><td style="text-align:right">2</td><td style="text-align:right">187</td><td style="text-align:right">5</td><td style="text-align:right">success</td><td>1</td></tr><tr><td style="text-align:left">45183</td><td style="text-align:right">70</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">primary</td><td style="text-align:right">no</td><td style="text-align:right">324</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">15</td><td style="text-align:right">nov</td><td style="text-align:right">78</td><td style="text-align:right">1</td><td style="text-align:right">96</td><td style="text-align:right">7</td><td style="text-align:right">success</td><td>0</td></tr><tr><td style="text-align:left">45184</td><td style="text-align:right">63</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">1495</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">138</td><td style="text-align:right">1</td><td style="text-align:right">22</td><td style="text-align:right">5</td><td style="text-align:right">success</td><td>0</td></tr><tr><td style="text-align:left">45185</td><td style="text-align:right">60</td><td style="text-align:right">services</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">4256</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">200</td><td style="text-align:right">1</td><td style="text-align:right">92</td><td style="text-align:right">4</td><td style="text-align:right">success</td><td>1</td></tr><tr><td style="text-align:left">45186</td><td style="text-align:right">59</td><td style="text-align:right">unknown</td><td style="text-align:right">married</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td><td style="text-align:right">1500</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">280</td><td style="text-align:right">1</td><td style="text-align:right">104</td><td style="text-align:right">2</td><td style="text-align:right">failure</td><td>0</td></tr><tr><td style="text-align:left">45187</td><td style="text-align:right">32</td><td style="text-align:right">services</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">1168</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">411</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>1</td></tr><tr><td style="text-align:left">45188</td><td style="text-align:right">29</td><td style="text-align:right">management</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">703</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">236</td><td style="text-align:right">1</td><td style="text-align:right">550</td><td style="text-align:right">2</td><td style="text-align:right">success</td><td>1</td></tr><tr><td style="text-align:left">45189</td><td style="text-align:right">25</td><td style="text-align:right">services</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">199</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">173</td><td style="text-align:right">1</td><td style="text-align:right">92</td><td style="text-align:right">5</td><td style="text-align:right">failure</td><td>0</td></tr><tr><td style="text-align:left">45190</td><td style="text-align:right">32</td><td style="text-align:right">blue-collar</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">136</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">206</td><td style="text-align:right">1</td><td style="text-align:right">188</td><td style="text-align:right">3</td><td style="text-align:right">success</td><td>1</td></tr><tr><td style="text-align:left">45191</td><td style="text-align:right">75</td><td style="text-align:right">retired</td><td style="text-align:right">divorced</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">3810</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">262</td><td style="text-align:right">1</td><td style="text-align:right">183</td><td style="text-align:right">1</td><td style="text-align:right">failure</td><td>1</td></tr><tr><td style="text-align:left">45192</td><td style="text-align:right">29</td><td style="text-align:right">management</td><td style="text-align:right">single</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">765</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">238</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>1</td></tr><tr><td style="text-align:left">45193</td><td style="text-align:right">28</td><td style="text-align:right">self-employed</td><td style="text-align:right">single</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">159</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">449</td><td style="text-align:right">2</td><td style="text-align:right">33</td><td style="text-align:right">4</td><td style="text-align:right">success</td><td>1</td></tr><tr><td style="text-align:left">45194</td><td style="text-align:right">59</td><td style="text-align:right">management</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">138</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">162</td><td style="text-align:right">2</td><td style="text-align:right">187</td><td style="text-align:right">5</td><td style="text-align:right">failure</td><td>0</td></tr><tr><td style="text-align:left">45195</td><td style="text-align:right">68</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">1146</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">212</td><td style="text-align:right">1</td><td style="text-align:right">187</td><td style="text-align:right">6</td><td style="text-align:right">success</td><td>1</td></tr><tr><td style="text-align:left">45196</td><td style="text-align:right">25</td><td style="text-align:right">student</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">358</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">330</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>1</td></tr><tr><td style="text-align:left">45197</td><td style="text-align:right">36</td><td style="text-align:right">management</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">1511</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">270</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>1</td></tr><tr><td style="text-align:left">45198</td><td style="text-align:right">37</td><td style="text-align:right">management</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">1428</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">333</td><td style="text-align:right">2</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">45199</td><td style="text-align:right">34</td><td style="text-align:right">blue-collar</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">1475</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">1166</td><td style="text-align:right">3</td><td style="text-align:right">530</td><td style="text-align:right">12</td><td style="text-align:right">other</td><td>0</td></tr><tr><td style="text-align:left">45200</td><td style="text-align:right">38</td><td style="text-align:right">technician</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">557</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">1556</td><td style="text-align:right">4</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>1</td></tr><tr><td style="text-align:left">45201</td><td style="text-align:right">53</td><td style="text-align:right">management</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">583</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">226</td><td style="text-align:right">1</td><td style="text-align:right">184</td><td style="text-align:right">4</td><td style="text-align:right">success</td><td>1</td></tr><tr><td style="text-align:left">45202</td><td style="text-align:right">34</td><td style="text-align:right">admin.</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">557</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">224</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>1</td></tr><tr><td style="text-align:left">45203</td><td style="text-align:right">23</td><td style="text-align:right">student</td><td style="text-align:right">single</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">113</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">266</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>1</td></tr><tr><td style="text-align:left">45204</td><td style="text-align:right">73</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">2850</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">300</td><td style="text-align:right">1</td><td style="text-align:right">40</td><td style="text-align:right">8</td><td style="text-align:right">failure</td><td>1</td></tr><tr><td style="text-align:left">45205</td><td style="text-align:right">25</td><td style="text-align:right">technician</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">505</td><td style="text-align:right">no</td><td style="text-align:right">yes</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">386</td><td style="text-align:right">2</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>1</td></tr><tr><td style="text-align:left">45206</td><td style="text-align:right">51</td><td style="text-align:right">technician</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">825</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">977</td><td style="text-align:right">3</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>1</td></tr><tr><td style="text-align:left">45207</td><td style="text-align:right">71</td><td style="text-align:right">retired</td><td style="text-align:right">divorced</td><td style="text-align:right">primary</td><td style="text-align:right">no</td><td style="text-align:right">1729</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">456</td><td style="text-align:right">2</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>1</td></tr><tr><td style="text-align:left">45208</td><td style="text-align:right">72</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">5715</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">1127</td><td style="text-align:right">5</td><td style="text-align:right">184</td><td style="text-align:right">3</td><td style="text-align:right">success</td><td>1</td></tr><tr><td style="text-align:left">45209</td><td style="text-align:right">57</td><td style="text-align:right">blue-collar</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">668</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">telephone</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">508</td><td style="text-align:right">4</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td>0</td></tr><tr><td style="text-align:left">45210</td><td style="text-align:right">37</td><td style="text-align:right">entrepreneur</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">2971</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">361</td><td style="text-align:right">2</td><td style="text-align:right">188</td><td style="text-align:right">11</td><td style="text-align:right">other</td><td>0</td></tr></tbody></table></div><p>45211 rows × 17 columns</p><pre><code class="hljs python"><span class="hljs-comment">#DataFrameSelector类的作用是从DataFrame中选取特定的列，以便后续pipeline的便捷性。</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataFrameSelector</span><span class="hljs-params">(BaseEstimator, TransformerMixin)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, attribute_names)</span>:</span>        self.attribute_names = attribute_names    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span><span class="hljs-params">(self, X, y=None)</span>:</span>        <span class="hljs-keyword">return</span> self    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transform</span><span class="hljs-params">(self, X)</span>:</span>        <span class="hljs-keyword">return</span> X[self.attribute_names]</code></pre><p>Python的 <code>sklearn.pipeline.Pipeline()</code> 函数可以把多个“处理数据的节点”按顺序打包在一起，数据在前一个节点处理之后的结果，转到下一个节点处理。当训练样本数据送进 <code>Pipeline</code> 进行处理时， 它会逐个调用节点的 <code>fit()</code> 和 <code>transform()</code> 方法，然后用最后一个节点的 <code>fit()</code> 方法来拟合数据。</p><p>对于数值型特征，我们对它用 <code>StandardScaler()</code> 进行标准化，对于类别型特征，我们用 <code>CategoricalEncoder(encoding=&#39;onehot-dense&#39;)</code> 进行OneHot编码。</p><pre><code class="hljs python"><span class="hljs-comment"># 制作管道</span><span class="hljs-comment"># #对数值型特征处理</span>numerical_pipeline = Pipeline([    (<span class="hljs-string">"select_numeric"</span>, DataFrameSelector([<span class="hljs-string">"age"</span>, <span class="hljs-string">"balance"</span>, <span class="hljs-string">"day"</span>, <span class="hljs-string">"campaign"</span>, <span class="hljs-string">"pdays"</span>, <span class="hljs-string">"previous"</span>,<span class="hljs-string">"duration"</span>])),    (<span class="hljs-string">"std_scaler"</span>, StandardScaler()),])<span class="hljs-comment">#对类别型特征处理</span>categorical_pipeline = Pipeline([    (<span class="hljs-string">"select_cat"</span>, DataFrameSelector([<span class="hljs-string">"job"</span>, <span class="hljs-string">"education"</span>, <span class="hljs-string">"marital"</span>, <span class="hljs-string">"default"</span>, <span class="hljs-string">"housing"</span>, <span class="hljs-string">"loan"</span>, <span class="hljs-string">"contact"</span>, <span class="hljs-string">"month"</span>,<span class="hljs-string">"poutcome"</span>])),    (<span class="hljs-string">"cat_encoder"</span>, CategoricalEncoder(encoding=<span class="hljs-string">'onehot-dense'</span>))])<span class="hljs-comment">#统一管道</span>preprocess_pipeline = FeatureUnion(transformer_list=[        (<span class="hljs-string">"numerical_pipeline"</span>, numerical_pipeline),        (<span class="hljs-string">"categorical_pipeline"</span>, categorical_pipeline),    ])</code></pre><h1 id="4、模型训练"><a href="#4、模型训练" class="headerlink" title="4、模型训练"></a>4、模型训练</h1><h2 id="4-1-数据集划分"><a href="#4-1-数据集划分" class="headerlink" title="4.1 数据集划分"></a>4.1 数据集划分</h2><pre><code class="hljs python"><span class="hljs-comment"># 划分X和y，以及训练集与测试集</span>X=bank.drop([<span class="hljs-string">'y'</span>], axis=<span class="hljs-number">1</span>)y=bank[<span class="hljs-string">'y'</span>]print(X)</code></pre><p>输出：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:right">age</th><th style="text-align:right">job</th><th style="text-align:right">marital</th><th style="text-align:right">education</th><th style="text-align:right">default</th><th style="text-align:right">balance</th><th style="text-align:right">housing</th><th style="text-align:right">loan</th><th style="text-align:right">contact</th><th style="text-align:right">day</th><th style="text-align:right">month</th><th style="text-align:right">duration</th><th style="text-align:right">campaign</th><th style="text-align:right">pdays</th><th style="text-align:right">previous</th><th>poutcome</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:right">58</td><td style="text-align:right">management</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">2143</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">261</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">1</td><td style="text-align:right">44</td><td style="text-align:right">technician</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">29</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">151</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">2</td><td style="text-align:right">33</td><td style="text-align:right">entrepreneur</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">2</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">76</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">3</td><td style="text-align:right">47</td><td style="text-align:right">blue-collar</td><td style="text-align:right">married</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td><td style="text-align:right">1506</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">92</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">4</td><td style="text-align:right">33</td><td style="text-align:right">unknown</td><td style="text-align:right">single</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td><td style="text-align:right">1</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">198</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">5</td><td style="text-align:right">35</td><td style="text-align:right">management</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">231</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">139</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">6</td><td style="text-align:right">28</td><td style="text-align:right">management</td><td style="text-align:right">single</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">447</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">217</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">7</td><td style="text-align:right">42</td><td style="text-align:right">entrepreneur</td><td style="text-align:right">divorced</td><td style="text-align:right">tertiary</td><td style="text-align:right">yes</td><td style="text-align:right">2</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">380</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">8</td><td style="text-align:right">58</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">primary</td><td style="text-align:right">no</td><td style="text-align:right">121</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">50</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">9</td><td style="text-align:right">43</td><td style="text-align:right">technician</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">593</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">55</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">10</td><td style="text-align:right">41</td><td style="text-align:right">admin.</td><td style="text-align:right">divorced</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">270</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">222</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">11</td><td style="text-align:right">29</td><td style="text-align:right">admin.</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">390</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">137</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">12</td><td style="text-align:right">53</td><td style="text-align:right">technician</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">6</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">517</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">13</td><td style="text-align:right">58</td><td style="text-align:right">technician</td><td style="text-align:right">married</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td><td style="text-align:right">71</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">71</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">14</td><td style="text-align:right">57</td><td style="text-align:right">services</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">162</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">174</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">15</td><td style="text-align:right">51</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">primary</td><td style="text-align:right">no</td><td style="text-align:right">229</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">353</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">16</td><td style="text-align:right">45</td><td style="text-align:right">admin.</td><td style="text-align:right">single</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td><td style="text-align:right">13</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">98</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">17</td><td style="text-align:right">57</td><td style="text-align:right">blue-collar</td><td style="text-align:right">married</td><td style="text-align:right">primary</td><td style="text-align:right">no</td><td style="text-align:right">52</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">38</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">18</td><td style="text-align:right">60</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">primary</td><td style="text-align:right">no</td><td style="text-align:right">60</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">219</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">19</td><td style="text-align:right">33</td><td style="text-align:right">services</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">0</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">54</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">20</td><td style="text-align:right">28</td><td style="text-align:right">blue-collar</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">723</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">262</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">21</td><td style="text-align:right">56</td><td style="text-align:right">management</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">779</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">164</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">22</td><td style="text-align:right">32</td><td style="text-align:right">blue-collar</td><td style="text-align:right">single</td><td style="text-align:right">primary</td><td style="text-align:right">no</td><td style="text-align:right">23</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">160</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">23</td><td style="text-align:right">25</td><td style="text-align:right">services</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">50</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">342</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">24</td><td style="text-align:right">40</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">primary</td><td style="text-align:right">no</td><td style="text-align:right">0</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">181</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">25</td><td style="text-align:right">44</td><td style="text-align:right">admin.</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">-372</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">172</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">26</td><td style="text-align:right">39</td><td style="text-align:right">management</td><td style="text-align:right">single</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">255</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">296</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">27</td><td style="text-align:right">52</td><td style="text-align:right">entrepreneur</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">113</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">127</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">28</td><td style="text-align:right">46</td><td style="text-align:right">management</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">-246</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">255</td><td style="text-align:right">2</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">29</td><td style="text-align:right">36</td><td style="text-align:right">technician</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">265</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">348</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td style="text-align:right">…</td><td>…</td></tr><tr><td style="text-align:left">45181</td><td style="text-align:right">46</td><td style="text-align:right">blue-collar</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">6879</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">15</td><td style="text-align:right">nov</td><td style="text-align:right">74</td><td style="text-align:right">2</td><td style="text-align:right">118</td><td style="text-align:right">3</td><td>failure</td></tr><tr><td style="text-align:left">45182</td><td style="text-align:right">34</td><td style="text-align:right">technician</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">133</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">15</td><td style="text-align:right">nov</td><td style="text-align:right">401</td><td style="text-align:right">2</td><td style="text-align:right">187</td><td style="text-align:right">5</td><td>success</td></tr><tr><td style="text-align:left">45183</td><td style="text-align:right">70</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">primary</td><td style="text-align:right">no</td><td style="text-align:right">324</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">15</td><td style="text-align:right">nov</td><td style="text-align:right">78</td><td style="text-align:right">1</td><td style="text-align:right">96</td><td style="text-align:right">7</td><td>success</td></tr><tr><td style="text-align:left">45184</td><td style="text-align:right">63</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">1495</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">138</td><td style="text-align:right">1</td><td style="text-align:right">22</td><td style="text-align:right">5</td><td>success</td></tr><tr><td style="text-align:left">45185</td><td style="text-align:right">60</td><td style="text-align:right">services</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">4256</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">200</td><td style="text-align:right">1</td><td style="text-align:right">92</td><td style="text-align:right">4</td><td>success</td></tr><tr><td style="text-align:left">45186</td><td style="text-align:right">59</td><td style="text-align:right">unknown</td><td style="text-align:right">married</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td><td style="text-align:right">1500</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">280</td><td style="text-align:right">1</td><td style="text-align:right">104</td><td style="text-align:right">2</td><td>failure</td></tr><tr><td style="text-align:left">45187</td><td style="text-align:right">32</td><td style="text-align:right">services</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">1168</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">411</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">45188</td><td style="text-align:right">29</td><td style="text-align:right">management</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">703</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">236</td><td style="text-align:right">1</td><td style="text-align:right">550</td><td style="text-align:right">2</td><td>success</td></tr><tr><td style="text-align:left">45189</td><td style="text-align:right">25</td><td style="text-align:right">services</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">199</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">173</td><td style="text-align:right">1</td><td style="text-align:right">92</td><td style="text-align:right">5</td><td>failure</td></tr><tr><td style="text-align:left">45190</td><td style="text-align:right">32</td><td style="text-align:right">blue-collar</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">136</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">206</td><td style="text-align:right">1</td><td style="text-align:right">188</td><td style="text-align:right">3</td><td>success</td></tr><tr><td style="text-align:left">45191</td><td style="text-align:right">75</td><td style="text-align:right">retired</td><td style="text-align:right">divorced</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">3810</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">262</td><td style="text-align:right">1</td><td style="text-align:right">183</td><td style="text-align:right">1</td><td>failure</td></tr><tr><td style="text-align:left">45192</td><td style="text-align:right">29</td><td style="text-align:right">management</td><td style="text-align:right">single</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">765</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">238</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">45193</td><td style="text-align:right">28</td><td style="text-align:right">self-employed</td><td style="text-align:right">single</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">159</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">449</td><td style="text-align:right">2</td><td style="text-align:right">33</td><td style="text-align:right">4</td><td>success</td></tr><tr><td style="text-align:left">45194</td><td style="text-align:right">59</td><td style="text-align:right">management</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">138</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">162</td><td style="text-align:right">2</td><td style="text-align:right">187</td><td style="text-align:right">5</td><td>failure</td></tr><tr><td style="text-align:left">45195</td><td style="text-align:right">68</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">1146</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">212</td><td style="text-align:right">1</td><td style="text-align:right">187</td><td style="text-align:right">6</td><td>success</td></tr><tr><td style="text-align:left">45196</td><td style="text-align:right">25</td><td style="text-align:right">student</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">358</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">330</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">45197</td><td style="text-align:right">36</td><td style="text-align:right">management</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">1511</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">270</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">45198</td><td style="text-align:right">37</td><td style="text-align:right">management</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">1428</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">333</td><td style="text-align:right">2</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">45199</td><td style="text-align:right">34</td><td style="text-align:right">blue-collar</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">1475</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">1166</td><td style="text-align:right">3</td><td style="text-align:right">530</td><td style="text-align:right">12</td><td>other</td></tr><tr><td style="text-align:left">45200</td><td style="text-align:right">38</td><td style="text-align:right">technician</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">557</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">16</td><td style="text-align:right">nov</td><td style="text-align:right">1556</td><td style="text-align:right">4</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">45201</td><td style="text-align:right">53</td><td style="text-align:right">management</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">583</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">226</td><td style="text-align:right">1</td><td style="text-align:right">184</td><td style="text-align:right">4</td><td>success</td></tr><tr><td style="text-align:left">45202</td><td style="text-align:right">34</td><td style="text-align:right">admin.</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">557</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">224</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">45203</td><td style="text-align:right">23</td><td style="text-align:right">student</td><td style="text-align:right">single</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">113</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">266</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">45204</td><td style="text-align:right">73</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">2850</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">300</td><td style="text-align:right">1</td><td style="text-align:right">40</td><td style="text-align:right">8</td><td>failure</td></tr><tr><td style="text-align:left">45205</td><td style="text-align:right">25</td><td style="text-align:right">technician</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">505</td><td style="text-align:right">no</td><td style="text-align:right">yes</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">386</td><td style="text-align:right">2</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">45206</td><td style="text-align:right">51</td><td style="text-align:right">technician</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">825</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">977</td><td style="text-align:right">3</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">45207</td><td style="text-align:right">71</td><td style="text-align:right">retired</td><td style="text-align:right">divorced</td><td style="text-align:right">primary</td><td style="text-align:right">no</td><td style="text-align:right">1729</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">456</td><td style="text-align:right">2</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">45208</td><td style="text-align:right">72</td><td style="text-align:right">retired</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">5715</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">1127</td><td style="text-align:right">5</td><td style="text-align:right">184</td><td style="text-align:right">3</td><td>success</td></tr><tr><td style="text-align:left">45209</td><td style="text-align:right">57</td><td style="text-align:right">blue-collar</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">668</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">telephone</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">508</td><td style="text-align:right">4</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td>unknown</td></tr><tr><td style="text-align:left">45210</td><td style="text-align:right">37</td><td style="text-align:right">entrepreneur</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">2971</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">cellular</td><td style="text-align:right">17</td><td style="text-align:right">nov</td><td style="text-align:right">361</td><td style="text-align:right">2</td><td style="text-align:right">188</td><td style="text-align:right">11</td><td>other</td></tr></tbody></table></div><p>45211 rows × 16 columns</p><pre><code class="hljs python">X = preprocess_pipeline.fit_transform(X)X_train,X_test,y_train,y_test=train_test_split(X,y,test_size=<span class="hljs-number">0.2</span>, random_state=<span class="hljs-number">44</span>)print(X)</code></pre><p>输出：</p><pre><code class="hljs angelscript"><span class="hljs-built_in">array</span>([[ <span class="hljs-number">1.60696496</span>,  <span class="hljs-number">0.25641925</span>, <span class="hljs-number">-1.29847633</span>, ...,  <span class="hljs-number">0.</span>        ,         <span class="hljs-number">0.</span>        ,  <span class="hljs-number">1.</span>        ],       [ <span class="hljs-number">0.28852927</span>, <span class="hljs-number">-0.43789469</span>, <span class="hljs-number">-1.29847633</span>, ...,  <span class="hljs-number">0.</span>        ,         <span class="hljs-number">0.</span>        ,  <span class="hljs-number">1.</span>        ],       [<span class="hljs-number">-0.74738448</span>, <span class="hljs-number">-0.44676247</span>, <span class="hljs-number">-1.29847633</span>, ...,  <span class="hljs-number">0.</span>        ,         <span class="hljs-number">0.</span>        ,  <span class="hljs-number">1.</span>        ],       ...,       [ <span class="hljs-number">2.92540065</span>,  <span class="hljs-number">1.42959305</span>,  <span class="hljs-number">0.14341818</span>, ...,  <span class="hljs-number">0.</span>        ,         <span class="hljs-number">1.</span>        ,  <span class="hljs-number">0.</span>        ],       [ <span class="hljs-number">1.51279098</span>, <span class="hljs-number">-0.22802402</span>,  <span class="hljs-number">0.14341818</span>, ...,  <span class="hljs-number">0.</span>        ,         <span class="hljs-number">0.</span>        ,  <span class="hljs-number">1.</span>        ],       [<span class="hljs-number">-0.37068857</span>,  <span class="hljs-number">0.52836436</span>,  <span class="hljs-number">0.14341818</span>, ...,  <span class="hljs-number">1.</span>        ,         <span class="hljs-number">0.</span>        ,  <span class="hljs-number">0.</span>        ]])</code></pre><pre><code class="hljs python">preprocess_bank = pd.DataFrame(X)preprocess_bank.head(<span class="hljs-number">5</span>)</code></pre><p>输出：</p><div class="table-container"><table><thead><tr><th style="text-align:left">0</th><th style="text-align:right">1</th><th style="text-align:right">2</th><th style="text-align:right">3</th><th style="text-align:right">4</th><th style="text-align:right">5</th><th style="text-align:right">6</th><th style="text-align:right">7</th><th style="text-align:right">8</th><th style="text-align:right">9</th><th style="text-align:right">…</th><th style="text-align:right">41</th><th style="text-align:right">42</th><th style="text-align:right">43</th><th style="text-align:right">44</th><th style="text-align:right">45</th><th style="text-align:right">46</th><th style="text-align:right">47</th><th style="text-align:right">48</th><th style="text-align:right">49</th><th style="text-align:right">50</th><th></th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:right">1.606965</td><td style="text-align:right">0.256419</td><td style="text-align:right">-1.298476</td><td style="text-align:right">-0.569351</td><td style="text-align:right">-0.411453</td><td style="text-align:right">-0.25194</td><td style="text-align:right">0.011016</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">…</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">1.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td>1.0</td></tr><tr><td style="text-align:left">1</td><td style="text-align:right">0.288529</td><td style="text-align:right">-0.437895</td><td style="text-align:right">-1.298476</td><td style="text-align:right">-0.569351</td><td style="text-align:right">-0.411453</td><td style="text-align:right">-0.25194</td><td style="text-align:right">-0.416127</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">…</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">1.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td>1.0</td></tr><tr><td style="text-align:left">2</td><td style="text-align:right">-0.747384</td><td style="text-align:right">-0.446762</td><td style="text-align:right">-1.298476</td><td style="text-align:right">-0.569351</td><td style="text-align:right">-0.411453</td><td style="text-align:right">-0.25194</td><td style="text-align:right">-0.707361</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">1.0</td><td style="text-align:right">…</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">1.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td>1.0</td></tr><tr><td style="text-align:left">3</td><td style="text-align:right">0.571051</td><td style="text-align:right">0.047205</td><td style="text-align:right">-1.298476</td><td style="text-align:right">-0.569351</td><td style="text-align:right">-0.411453</td><td style="text-align:right">-0.25194</td><td style="text-align:right">-0.645231</td><td style="text-align:right">0.0</td><td style="text-align:right">1.0</td><td style="text-align:right">0.0</td><td style="text-align:right">…</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">1.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td>1.0</td></tr><tr><td style="text-align:left">4</td><td style="text-align:right">-0.747384</td><td style="text-align:right">-0.447091</td><td style="text-align:right">-1.298476</td><td style="text-align:right">-0.569351</td><td style="text-align:right">-0.411453</td><td style="text-align:right">-0.25194</td><td style="text-align:right">-0.233620</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">…</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">1.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td style="text-align:right">0.0</td><td>1.0</td></tr></tbody></table></div><p>5 rows × 51 columns</p><pre><code class="hljs python">bank.head(<span class="hljs-number">5</span>)</code></pre><p>输出：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:right">age</th><th style="text-align:right">job</th><th style="text-align:right">marital</th><th style="text-align:right">education</th><th style="text-align:right">default</th><th style="text-align:right">balance</th><th style="text-align:right">housing</th><th style="text-align:right">loan</th><th style="text-align:right">contact</th><th style="text-align:right">day</th><th style="text-align:right">month</th><th style="text-align:right">duration</th><th style="text-align:right">campaign</th><th style="text-align:right">pdays</th><th style="text-align:right">previous</th><th style="text-align:right">poutcome</th><th style="text-align:right">y</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:right">58</td><td style="text-align:right">management</td><td style="text-align:right">married</td><td style="text-align:right">tertiary</td><td style="text-align:right">no</td><td style="text-align:right">2143</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">261</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td style="text-align:right">0</td></tr><tr><td style="text-align:left">1</td><td style="text-align:right">44</td><td style="text-align:right">technician</td><td style="text-align:right">single</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">29</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">151</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td style="text-align:right">0</td></tr><tr><td style="text-align:left">2</td><td style="text-align:right">33</td><td style="text-align:right">entrepreneur</td><td style="text-align:right">married</td><td style="text-align:right">secondary</td><td style="text-align:right">no</td><td style="text-align:right">2</td><td style="text-align:right">yes</td><td style="text-align:right">yes</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">76</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td style="text-align:right">0</td></tr><tr><td style="text-align:left">3</td><td style="text-align:right">47</td><td style="text-align:right">blue-collar</td><td style="text-align:right">married</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td><td style="text-align:right">1506</td><td style="text-align:right">yes</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">92</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td style="text-align:right">0</td></tr><tr><td style="text-align:left">4</td><td style="text-align:right">33</td><td style="text-align:right">unknown</td><td style="text-align:right">single</td><td style="text-align:right">unknown</td><td style="text-align:right">no</td><td style="text-align:right">1</td><td style="text-align:right">no</td><td style="text-align:right">no</td><td style="text-align:right">unknown</td><td style="text-align:right">5</td><td style="text-align:right">may</td><td style="text-align:right">198</td><td style="text-align:right">1</td><td style="text-align:right">-1</td><td style="text-align:right">0</td><td style="text-align:right">unknown</td><td style="text-align:right">0</td></tr></tbody></table></div><h2 id="4-2-模型构建"><a href="#4-2-模型构建" class="headerlink" title="4.2 模型构建"></a>4.2 模型构建</h2><p>t_diff=[]</p><h3 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h3><p>log_reg = LogisticRegression()<br>t_start = time.clock()#通过time记录<br>log_scores = cross_val_score(log_reg, X_train, y_train, cv=3, scoring=’roc_auc’)<br>t_end = time.clock()<br>t_diff.append((t_end - t_start))<br>log_reg_mean = log_scores.mean()</p><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><p>svc_clf = SVC()<br>t_start = time.clock()<br>svc_scores = cross_val_score(svc_clf, X_train, y_train, cv=3, scoring=’roc_auc’)<br>t_end = time.clock()<br>t_diff.append((t_end - t_start))<br>svc_mean = svc_scores.mean()</p><h3 id="k邻近"><a href="#k邻近" class="headerlink" title="k邻近"></a>k邻近</h3><p>knn_clf = KNeighborsClassifier()<br>t_start = time.clock()<br>knn_scores = cross_val_score(knn_clf, X_train, y_train, cv=3, scoring=’roc_auc’)<br>t_end = time.clock()<br>t_diff.append((t_end - t_start))<br>knn_mean = knn_scores.mean()</p><h3 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h3><p>tree_clf = tree.DecisionTreeClassifier()<br>t_start = time.clock()<br>tree_scores = cross_val_score(tree_clf, X_train, y_train, cv=3, scoring=’roc_auc’)<br>t_end = time.clock()<br>t_diff.append((t_end - t_start))<br>tree_mean = tree_scores.mean()</p><h3 id="梯度提升树"><a href="#梯度提升树" class="headerlink" title="梯度提升树"></a>梯度提升树</h3><p>grad_clf = GradientBoostingClassifier()<br>t_start = time.clock()<br>grad_scores = cross_val_score(grad_clf, X_train, y_train, cv=3, scoring=’roc_auc’)<br>t_end = time.clock()<br>t_diff.append((t_end - t_start))<br>grad_mean = grad_scores.mean()</p><h3 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h3><p>rand_clf = RandomForestClassifier()<br>t_start = time.clock()<br>rand_scores = cross_val_score(rand_clf, X_train, y_train, cv=3, scoring=’roc_auc’)<br>t_end = time.clock()<br>t_diff.append((t_end - t_start))<br>rand_mean = rand_scores.mean()</p><h3 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h3><p>neural_clf = MLPClassifier(alpha=0.01)<br>t_start = time.clock()<br>neural_scores = cross_val_score(neural_clf, X_train, y_train, cv=3, scoring=’roc_auc’)<br>t_end = time.clock()<br>t_diff.append((t_end - t_start))<br>neural_mean = neural_scores.mean()</p><h3 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h3><pre><code class="hljs python">nav_clf = GaussianNB()t_start = time.clock()nav_scores = cross_val_score(nav_clf, X_train, y_train, cv=<span class="hljs-number">3</span>, scoring=<span class="hljs-string">'roc_auc'</span>)t_end = time.clock()t_diff.append((t_end - t_start))nav_mean = neural_scores.mean()d = &#123;<span class="hljs-string">'Classifiers'</span>: [<span class="hljs-string">'Logistic Reg.'</span>, <span class="hljs-string">'SVC'</span>, <span class="hljs-string">'KNN'</span>, <span class="hljs-string">'Dec Tree'</span>, <span class="hljs-string">'Grad B CLF'</span>, <span class="hljs-string">'Rand FC'</span>, <span class="hljs-string">'Neural Classifier'</span>, <span class="hljs-string">'Naives Bayes'</span>],     <span class="hljs-string">'Crossval Mean Scores'</span>: [log_reg_mean, svc_mean, knn_mean, tree_mean, grad_mean, rand_mean, neural_mean, nav_mean],    <span class="hljs-string">'time'</span>:t_diff&#125;result_df = pd.DataFrame(d)result_df = result_df.sort_values(by=[<span class="hljs-string">'Crossval Mean Scores'</span>], ascending=<span class="hljs-literal">False</span>)result_df</code></pre><p>输出：</p><div class="table-container"><table><thead><tr><th style="text-align:left"></th><th style="text-align:right">Classifiers</th><th style="text-align:right">Crossval Mean Scores</th><th style="text-align:right">time</th></tr></thead><tbody><tr><td style="text-align:left">4</td><td style="text-align:right">Grad B CLF</td><td style="text-align:right">0.925765</td><td style="text-align:right">26.047404</td></tr><tr><td style="text-align:left">6</td><td style="text-align:right">Neural Classifier</td><td style="text-align:right">0.919359</td><td style="text-align:right">82.371689</td></tr><tr><td style="text-align:left">7</td><td style="text-align:right">Naives Bayes</td><td style="text-align:right">0.919359</td><td style="text-align:right">0.207923</td></tr><tr><td style="text-align:left">1</td><td style="text-align:right">SVC</td><td style="text-align:right">0.907706</td><td style="text-align:right">71.862459</td></tr><tr><td style="text-align:left">0</td><td style="text-align:right">Logistic Reg.</td><td style="text-align:right">0.905835</td><td style="text-align:right">0.742473</td></tr><tr><td style="text-align:left">5</td><td style="text-align:right">Rand FC</td><td style="text-align:right">0.886541</td><td style="text-align:right">1.250071</td></tr><tr><td style="text-align:left">2</td><td style="text-align:right">KNN</td><td style="text-align:right">0.829659</td><td style="text-align:right">68.490700</td></tr><tr><td style="text-align:left">3</td><td style="text-align:right">Dec Tree</td><td style="text-align:right">0.701087</td><td style="text-align:right">1.155549</td></tr></tbody></table></div><h2 id="4-3-模型评价"><a href="#4-3-模型评价" class="headerlink" title="4.3 模型评价"></a>4.3 模型评价</h2><p>由上表可以看出，在这8种分类器里面，梯度提升树（Gradient Boosting）、神经网络（Neural Classifier）、朴素贝叶斯（Naive Bayes）表现位于前三名。在后续的步骤中，我们可以对它们进行调参以获得更好的结果，相信大家一定会调参，所以调参不是本文关注的重点，本文的重点在于各个模型的比较。</p><p>虽然决策树位列最后一名，但是集成树（梯度提升树与随机森林）表现可以远远好于单棵决策树。这是由于集成模型的泛化性能非常好，不太需要调参就可以取得很好的效果。</p><p>而在耗时方面，k邻近算法由于要同时计算所有点与某点的距离，因此耗时最多，而且效果也一般（倒数第二）。集成模型虽然需要训练上百个弱分类器，但是由于可以并行计算的原因，随机森林与单棵决策树的速度相差无几；而根据梯度提升树的原理，它只可以分步计算，所以速度稍慢。但是最慢的还是神经网络，最快的模型是决策树。</p><pre><code class="hljs python"><span class="hljs-comment">#通过该函数获得一个分类器的AUC值与ROC曲线的参数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_auc</span><span class="hljs-params">(clf)</span>:</span>    clf=clf.fit(X_train, y_train)    prob=clf.predict_proba(X_test)    prob=prob[:, <span class="hljs-number">1</span>]    <span class="hljs-keyword">return</span> roc_auc_score(y_test, prob),roc_curve(y_test, prob)</code></pre><p>通过测试集数据画出ROC曲线并标注AUC值。</p><pre><code class="hljs python">grad_roc_scores,grad_roc_curve = get_auc(grad_clf)neural_roc_scores,neural_roc_curve = get_auc(neural_clf)naives_roc_scores,naives_roc_curve = get_auc(nav_clf)grd_fpr, grd_tpr, grd_thresold = grad_roc_curveneu_fpr, neu_tpr, neu_threshold = neural_roc_curvenav_fpr, nav_tpr, nav_threshold = naives_roc_curve<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">graph_roc_curve_multiple</span><span class="hljs-params">(grd_fpr, grd_tpr, neu_fpr, neu_tpr, nav_fpr, nav_tpr)</span>:</span>    plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">6</span>))    plt.title(<span class="hljs-string">'ROC Curve \n Top 3 Classifiers'</span>, fontsize=<span class="hljs-number">18</span>)    plt.plot(grd_fpr, grd_tpr, label=<span class="hljs-string">'Gradient Boosting Classifier (Score = &#123;:.2%&#125;)'</span>.format(grad_roc_scores))    plt.plot(neu_fpr, neu_tpr, label=<span class="hljs-string">'Neural Classifier (Score = &#123;:.2%&#125;)'</span>.format(neural_roc_scores))    plt.plot(nav_fpr, nav_tpr, label=<span class="hljs-string">'Naives Bayes Classifier (Score = &#123;:.2%&#125;)'</span>.format(naives_roc_scores))    plt.plot([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], <span class="hljs-string">'k--'</span>)<span class="hljs-comment">#指定x,y轴的坐标在0，1之间</span>    plt.axis([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>])    plt.xlabel(<span class="hljs-string">'False Positive Rate'</span>, fontsize=<span class="hljs-number">16</span>)    plt.ylabel(<span class="hljs-string">'True Positive Rate'</span>, fontsize=<span class="hljs-number">16</span>)    plt.annotate(<span class="hljs-string">'Minimum ROC Score of 50% \n (This is the minimum score to get)'</span>, xy=(<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>), xytext=(<span class="hljs-number">0.6</span>, <span class="hljs-number">0.3</span>), arrowprops=dict(facecolor=<span class="hljs-string">'#6E726D'</span>, shrink=<span class="hljs-number">0.05</span>),)    plt.legend()<span class="hljs-comment">#显示图例</span>    graph_roc_curve_multiple(grd_fpr, grd_tpr, neu_fpr, neu_tpr, nav_fpr, nav_tpr)plt.show()</code></pre><p><img src="/article/a0f63eb7/输出5.png" srcset="/img/loading.gif" alt="输出5"></p><p>由上图可见，在测试集中朴素贝叶斯模型只得到了80.84%的AUC值了，说明它存在过拟合现象，需要进一步调参。而梯度提升树（Gradient Boosting）与神经网络（Neural Classifier）的得分与训练集的结果保持一致，说明模型拟合地很好，因此它们也是我们可以采纳的模型。</p><h1 id="5、总结"><a href="#5、总结" class="headerlink" title="5、总结"></a>5、总结</h1><p>首先，在营销活动次数的选择上，对同一个客户打电话的次数不应超过三次，这样不仅可以节约时间，把精力投入到新客户中。如果给同一个客户打电话多次，一定会引起客户的反感，从而降低客户的购买产品的欲望。</p><p>其次，在客户年龄段的选择上，银行应集中于20岁左右和60岁左右的人群，他们分别有超过60%的可能性购买营销产品。</p><p>再其次，对于不同的职业来说，学生与退休的人也是最容易购买营销产品的人，这与年龄段的现象保持了一致。对于退休的人而言，他们有很多的存款却不敢随便花钱，而定期存款大多期限短收益高，因而成为他们所热衷购买的产品。而对于学生党来说，他们会珍惜自己有限的存款，而同时他们花钱的机会比较少，所以他们会选择定期存款。</p><p>而对于住房贷款和存款余额来说，正如本文中的结果所能看到的一样，有贷款的人需要每月按时还款，因而不太可能还会去购买定期存款（定期存款的利息肯定不及贷款利息）。同时，存款多的人自然倾向于去购买定期存款以让自己获得更多利息。</p><p>最后一点，专注于那些通话时间长的客户，正如在关系矩阵中所看到的一样，通话时间越长客户越有可能购买营销产品，而且可能性非常之高。</p><p>综上所述，对于银行而言，想要推广它的营销产品，一个简要的策略是：首先先通过客户的基本信息，使用训练好的机器学习模型（不含<code>duration</code>）进行预测，然后对这些客户进行电话营销。根据电话营销的结果，再用含有<code>duration</code>的模型再一次进行预测，找出那些可能性大的客户，如果他们没有在第一次营销后购买理财产品的话，那么再对这些人进行第二次电话营销。之后，视情况进行第三次营销，或者把精力放在发展新客户上面。通过这样的策略，银行下一次营销活动的可能结果会比上一次更好。</p><p>跟着教程走了一遍，原来如此~</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一些脑残行为引发的车祸现场及补救</title>
    <link href="/article/2f0ca801.html"/>
    <url>/article/2f0ca801.html</url>
    
    <content type="html"><![CDATA[<h2 id="取消SSH私钥密码"><a href="#取消SSH私钥密码" class="headerlink" title="取消SSH私钥密码"></a>取消SSH私钥密码</h2><p>6月24号开了博客，刚开始用next主题， 后来被Fluid颜值吸引。当然这些都不是重点。重点是当时设置ssh私钥访问，我选择了设置密码。wtf，天知道这是多么愚蠢的行为。每次push都要输密码。<br>怎么办？当然选择解决它。首先想的是重新生成密钥，设置为空。然后发现leancloud要不要改，coding.net要不要改…嗯~ o(<em>￣▽￣</em>)o好像有丢丢麻烦，赶紧google，今天特别幸运，点到了第一个就阔以解决。</p><p>参考博客：<a href="https://woodenrobot.me/2018/01/30/%E5%8F%96%E6%B6%88-SSH-%E7%A7%81%E9%92%A5%E5%AF%86%E7%A0%81/" target="_blank" rel="noopener">取消SSH私钥密码</a></p><p><strong>方法一</strong><br>使用 ssh-keygen 命令更改 SSH Key 密码，进入秘钥所在到的文件夹内（一般为<code>~/.ssh</code>）,执行下列命令：</p><pre><code class="hljs cmd">ssh-keygen -f id_rsa -p</code></pre><p>执行命令后，会让你先输入旧密码，然后输入两次新密码，新密码为空则为没有密码。</p><pre><code class="hljs powershell">C:\Users\susu\.ssh&gt;ssh<span class="hljs-literal">-keygen</span> <span class="hljs-operator">-f</span> id_rsa <span class="hljs-literal">-p</span>Enter old passphrase:Key has comment <span class="hljs-string">'xxxxxxxxxx@xx.com'</span>Enter new passphrase (empty <span class="hljs-keyword">for</span> no passphrase):Enter same passphrase again:Your identification has been saved with the new passphrase.</code></pre><h2 id="使用HTML插入表格"><a href="#使用HTML插入表格" class="headerlink" title="使用HTML插入表格"></a>使用HTML插入表格</h2><p>参考博客：<a href="https://3nice.cc/2018/10/01/markdowntable/" target="_blank" rel="noopener">解决在Markdown中的表格单元格合并的问题</a></p><h2 id="论博客的颜值问题"><a href="#论博客的颜值问题" class="headerlink" title="论博客的颜值问题"></a>论博客的颜值问题</h2><!--刚开始用的next，优化做了一两天，偶然看到fluid，页面显示的很美观。加上next有些优化，我还没做完善，就果断换了。换了之后呢，前一两周美滋滋，真的漂亮，然后这周各种不顺，它太年轻了，好多修改都查无此法。sad(；′⌒`)。而且我发现我被颜值绑架了。为了好看的颜值，一篇博客里调整杂七杂八的图片，公式大小，又要浪费一小时，太太太可惜了（刷b站不香嘛）。博客分享还是更注重质量（也没几个人看O(∩_∩)O），颜值什么的等我变强了再说把(秃头警告)。--><!--总之，还是要基本功打扎实，别整天净整些有的没的。（丑丑的next，我又肥来啦~）--><p>博客的颜值就像外貌，我的要求就是整洁，小清新~(然而并不是，整天整些花里胡哨的)。so我立flag！这两个月就内容输出就好了，排版整整就好了，优化这两个月积累一下，有重要的优化再搜再改，不然不碰(花太多时间了，（T_T）orz..)。</p><h2 id="更改jupyter-notebook的主题颜色-theme"><a href="#更改jupyter-notebook的主题颜色-theme" class="headerlink" title="更改jupyter notebook的主题颜色(theme)"></a>更改jupyter notebook的主题颜色(theme)</h2><p>白色看久了，确实有丢丢疲劳。改黑色。</p><p>jupyter-themes里包含了一些样式。安装如下：<br>在控制台(cmd/shell)下用pip安装jupyter-themes</p><pre><code class="hljs shell">pip install --upgrade jupyterthemes</code></pre><p>查看所有可用的主题：</p><pre><code class="hljs groovy"><span class="hljs-string">C:</span>\Users\susu&gt;jt -lAvailable <span class="hljs-string">Themes:</span>   chesterish   grade3   gruvboxd   gruvboxl   monokai   oceans16   onedork   solarizedd   solarizedl</code></pre><p>以下命令选择要用的主题：</p><pre><code class="hljs shell">jt -t 主题名称</code></pre><p><span style="color:blue">注意：如果选择暗背景，输出图表的时候字体可能还是黑色的。</span><br>使用如下命令(以oceans16为例)，可以把图表背景设置为白色，解决字体黑色在暗色背景下显示不明显问题。</p><pre><code class="hljs shell">jt -t oceans16 -T -N</code></pre><p>恢复默认：</p><pre><code class="hljs shell">jt -r</code></pre><p>参考链接：<a href="https://blog.csdn.net/Jinlong_Xu/article/details/79221943?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight" target="_blank" rel="noopener">jupyter notebook更换主题 步骤详解</a>里面还有其他一些参数详解。</p><h2 id="Hexo-Git部署警告”warning：-LF-will-be-replaced-by-CRLF”"><a href="#Hexo-Git部署警告”warning：-LF-will-be-replaced-by-CRLF”" class="headerlink" title="Hexo Git部署警告”warning： LF will be replaced by CRLF”"></a>Hexo Git部署警告”warning： LF will be replaced by CRLF”</h2><p>Windows下在使用<code>hexo d</code>命令部署博客时，会出现下面这个警告：</p><pre><code class="hljs shell">The file will have its original line endings in your working directory.warning: LF will be replaced by CRLF in index.html.</code></pre><p>这个警告的意思很直接，就是Git会把<code>LF</code>替换为<code>CRLF</code>，不过这是无关紧要的，完全可以禁用此功能，这样还可以避免这个警告信息刷屏。<br>设置禁用：在MinGW窗口中输入以下命令即可</p><pre><code class="hljs shell">git config --global core.autocrlf false</code></pre><p>参考链接：<a href="https://gaomf.cn/2017/01/13/Hexo_Git_CRLF/" target="_blank" rel="noopener">Hexo Git部署警告”warning： LF will be replaced by CRLF”的去除方法</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode174-地下城游戏</title>
    <link href="/article/a6c99a24.html"/>
    <url>/article/a6c99a24.html</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">没写完，凌乱的很~The article is available after a week or enter the password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="cb897dbac00dde259ba373973fe90816ba5e509f79873055485542945214e740">dff0aecbdb650398cd133bdee50169cd3f1aee3ece73b0ea840df87ea1e8e72931cef7398e2153f51123c7f96ba3c2fc610f07efd6940ca8184dfea191340068387d9fc22b56fbfe156690b0cc7628f42a6daca22fb7faf37efa02f26c02a2e5fbb14d09fb0fbf442ed2f90716b7bd6546f6264d8d62325811dd87f10ef388f00d0f77621b2ed4f46265b0b7b3f343833ceec43d7f42cc0c0511ca0007a7505697c72386afb28469da861356c7597571cd261ba8208851833b0baddf063cd618d127a47863fda68f95ea13c4912341e84b0e6900b5b15ad53cd93dd3f2b56aa5807af40a02e56ff21d269a4146b3790e897cfc9a6bab67b12ef816c23c6a057a05733c8bba78984f8b2e7a3bded30e9fec962e4c9349d8070f6d39c5634d9abe690ba7f96d4609565a823481acb06d6e441345dcd64d4b7b7832d7eaad8931eab724ddfcd1e47b2b2c2e2038640da7e56a961a9bd0277c2cab59230289be4a1b90dbdfad8bf153f09cfce110352bc593c36cd36eeb54c622db6e7be797c20afe1538255873605b938e1febc35cf90823f404aa418cb3df7fd13a3ef2222c69f2d3878cfe225133da5c577efaa660f08fed112a08686f7a3b16179dbf6d6dc4577aaf4e05f7f05180747d66380c4e4297c1d14ed1520c201f7015d9cfe95a0570f45e05742139065d92d03489f774bcb3999c1b26c8caa11c5f517c76dee8b1be398da38289089257c146a5a2560a63595b9ee1a9a2f62f0679e60f679cfe5aba0f5916fc414367722912571ecae6d66e3a596061e812cdcbd783ae268ba56aa12836e6e44dd9f21f72990903360e9ad732e05b58559506920c18ea78c27c39c70146dc9f8ad63b2b260fdab81eb55e6d079a7b783d7e4583ed1b94c83aee6bdebe3b03032d3bcadb406ba1a1cafb607c87c997932accaf858695b9678b92941dca2d9b2d31b20d6963b1f178e4a7bfd118a33522e228de056ed4ee8abb268c74b21fc748779fe5fb9384e736f3d6d59754a3ca09aa6a21438929fdf6b8362dd976f659427462a3da8fa5af544749b45dcd558ab9628cf2f87bf023b0b97715feaf7af4a2ecfb7a82e1f80b33f5f667331f91950cbea4e064e46b048fda2db8a8bf4b3e23f3788566a51c1bc429ede1e961e0e58ab10b413a0fa4e2b15e16a9f8f1d683a17b96ff9e90bcebd0e9d80e6768a4331e6be8150d7fbb71867591f054245be9a18a49dfeef6a019159f0c5d5f2e198684e075757bc0983624b912d1f9e9b43ae040fc7cb85eedaa6601b72d4ab14bb98ec78cec73d90d23aa22aabd4e8d90b1ab7fa6558cb3ff7bdc1f5b80225665bf74cf8212c8677ff54ee3122ea1bae3c64763598c128ab471bfe665bab5ceec193af74cd0a23eaa2d8eedd1163a1b4a5ad9d9d6cc67ae94492954173f40fcf604712e52d6c31546c83da644df43aa8adbe5ba6831ee81cd797eb495e9e089890907d04581cca1b1c85738842dc2030515c839aca2c5b32fbab9ab2c6b9e9a41506e099f36f10a39ac29d1250ca8aba5fb9d716152aedc3652576aa7cea25807936888e73489bfb3f69c7db84e7b19ab6f0a93727e86f62b25f19827546781a04606a7c78b2719a844a7ddb9c09e81d797cd3e48bbb0f45b7e6a8b6b4529751309c23bafd5ce3a58ede684f4560b693b6c1f3505af8e68772ec23faeecdbfba5876210e918399d59459393a33125c9d7cbb24bbf6e7ef561604d3f844076a2282444f0b148cfdbd33f767593c9c0ff1552791396f22a5503c6c737ad37f567ca88e2fc5f3bdf6e575e8feb05ad11d4ae51880307efae0b1eb35361dba0f72302fb235cc7c5feb013567601801f9a4226ba0f110848d940c7008d484b5ca1fb7adda999afae3a2faff82d92372846580e4cd7fef5d4ab8f41024825a4a9b5c4d814f56daf926e90f454e8b502b1cceadb6bce8cc71d66168cc84caa8af56cd6e5afc5e4860265478bf7217844d9825e0bf26618a75820ff1fda9db5bf7a1942633251058c5c03f28409f9105911667876996afe9bf1c9a60d30262b833d61afff3ade784123d947883c361a167b4eb8f3398f279f97f02ab14efe0e8f48cedab319e66fc07a970bda316e82ddf88ab36cd98732efe0909405ee1c860da86b952d760cd04c42e6fabbdf933d1a5697a687f3ec894de66249a17a844f6947d5954bc11cf40e1ca22c3ad6e14469b55a45073954dfaaf2df68da81b5b70e9b5f8bec5569b8bdf678e43387df11381f732e01f939acc5a08be9564976a7b40494c2dec06d86e0fa891908aa3b084866c5aaf06e4cfa310998a4407a380bddf9f2671ddd55f282ce6f78af945577a3f5c450fb333519abf357b1fe9e9a688ad644ff72e767b16cce5398d275efebf2233dd895d3cf1a0b1ecb2ed1ac837f58b2a377b1cdd1239688155e5899ea244e57fe257b178326dede9bcb02123688d5855ce4771b93ad542972452ee95fa14d39cf10b537d606eff942f171062bb3305b36a621165d9c006eec4c1fe90a60aa4f5b8ac18c9ffba7dc74cd9b67e46b1f45bd794f7592e855339b9d71abcad0936c1ff7ee9955f62fdbbd4c4013ba894af850bc4a3c85b7ea80c1a38e3efdaa6ea59ec8264656456e6f1fe6920efe1df12c72c12186d44ff718debc882e550874870f964e87e28444b0fe560c66f7fc8988d21df1b70d55c6a4bebfe03b866fe7cda0819d804d093a5c5b68e5423b3310159e8428162b4396f4fbfd334f5bc8847b2edfb38b42c9d63ddad0a5b71aeba72886</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>latex常用语法</title>
    <link href="/article/a097ae97.html"/>
    <url>/article/a097ae97.html</url>
    
    <content type="html"><![CDATA[<h1 id="Latex常用语法"><a href="#Latex常用语法" class="headerlink" title="Latex常用语法"></a>Latex常用语法</h1><p>因为每次都要找，不如总结下来。网页端又显示不正常了，哎，有空闲再调把~</p><h2 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h2><div class="table-container"><table><thead><tr><th>两个quad空格</th><th>a \qquad b</th><th><img src="/article/a097ae97/e505263bc9c94f673c580f3a36a7f08a.png" srcset="/img/loading.gif" alt="a \qquad b"></th><th>两个<em>m</em>的宽度</th></tr></thead><tbody><tr><td>quad空格</td><td>a \quad b</td><td><img src="/article/a097ae97/da8c1d9effa4501fd80c054e59ad917d.png" srcset="/img/loading.gif" alt="a \quad b"></td><td>一个<strong>m</strong>的宽度</td></tr><tr><td>大空格</td><td>a\ b</td><td><img src="/article/a097ae97/692d4bffca8e84ffb45cf9d5facf31d6.png" srcset="/img/loading.gif" alt="a\ b"></td><td>1/3<strong>m</strong>宽度</td></tr><tr><td>中等空格</td><td>a\;b</td><td><img src="/article/a097ae97/b5ade5d5393fd7727bf77fa44ec8b564.png" srcset="/img/loading.gif" alt="a\;b"></td><td>2/7<strong>m</strong>宽度</td></tr><tr><td>小空格</td><td>a\,b</td><td><img src="/article/a097ae97/7bea99aed60ba5e1fe8a134ab43fa85f.png" srcset="/img/loading.gif" alt="a\,b"></td><td>1/6<strong>m</strong>宽度</td></tr><tr><td>没有空格</td><td>ab</td><td><img src="/article/a097ae97/b6bd9dba2ebfca24731ae6dc3913e625.png" srcset="/img/loading.gif" alt="ab\,"></td><td></td></tr><tr><td>紧贴</td><td>a!b</td><td><img src="/article/a097ae97/0fbcad5fadb912e8afa6d113a75c83e4.png" srcset="/img/loading.gif" alt="a\!b"></td><td>缩进1/6<em>m*</em>宽度</td></tr></tbody></table></div><h2 id="空格-1"><a href="#空格-1" class="headerlink" title="空格"></a>空格</h2><p>注意<em>T<strong>E</strong>X</em>能够自动处理大多数的空格，但是您有时候需要自己来控制。</p><div class="table-container"><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">语法</th><th style="text-align:left">显示</th><th style="text-align:left">宽度</th></tr></thead><tbody><tr><td style="text-align:left">2个quad空格</td><td style="text-align:left"><code>\alpha\qquad\beta</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/4/3/b/43ba5910626e8cdd1e7c87f87457bc68.png" srcset="/img/loading.gif" alt="\alpha\qquad\beta"></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/d/8/a/d8a3700be4ced531e5618e8bebfece25.png" srcset="/img/loading.gif" alt="2m\ "></td></tr><tr><td style="text-align:left">quad空格</td><td style="text-align:left"><code>\alpha\quad\beta</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/b/d/b/bdbaa56ab92dbec191da654efcf15f31.png" srcset="/img/loading.gif" alt="\alpha\quad\beta"></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/d/4/8/d482d61667a2a8f3a40b25f2626b6d16.png" srcset="/img/loading.gif" alt="m\ "></td></tr><tr><td style="text-align:left">大空格</td><td style="text-align:left"><code>\alpha\ \beta</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/8/c/c/8cc37fcc9fc3729b33095484307b65e9.png" srcset="/img/loading.gif" alt="\alpha\ \beta"></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/8/b/d/8bd0331723b650fa4e57c0c97ea74bdb.png" srcset="/img/loading.gif" alt="\frac{m}{3}"></td></tr><tr><td style="text-align:left">中等空格</td><td style="text-align:left"><code>\alpha\;\beta</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/1/9/a/19aad8cbec4cda349710592cddcbae8a.png" srcset="/img/loading.gif" alt="\alpha\;\beta"></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/d/8/6/d86c7e706d3844153628c5344a0d43c3.png" srcset="/img/loading.gif" alt="\frac{2m}{7}"></td></tr><tr><td style="text-align:left">小空格</td><td style="text-align:left"><code>\alpha\,\beta</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/5/8/0/580e640ac8bd1b0b421e62a48f9d4815.png" srcset="/img/loading.gif" alt="\alpha\,\beta"></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/2/b/2/2b25f9317e1ebccefa69c899bb87f655.png" srcset="/img/loading.gif" alt="\frac{m}{6}"></td></tr><tr><td style="text-align:left">没有空格</td><td style="text-align:left"><code>\alpha\beta</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/c/7/6/c761464c4ea7b0a18e7bd830bc80fc62.png" srcset="/img/loading.gif" alt="\alpha\beta\ "></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/5/7/1/571e19a3fb35a2f712cd608e89b85dc5.png" srcset="/img/loading.gif" alt="0\ "></td></tr><tr><td style="text-align:left">紧贴</td><td style="text-align:left"><code>\alpha\!\beta</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/6/d/3/6d331458bfd8a10d0639514187a1eb42.png" srcset="/img/loading.gif" alt="\alpha\!\beta"></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/1/a/4/1a40f481cfa743830b2c80b87a4acccc.png" srcset="/img/loading.gif" alt="-\frac{m}{6}"></td></tr></tbody></table></div><h2 id="声调"><a href="#声调" class="headerlink" title="声调"></a>声调</h2><div class="table-container"><table><thead><tr><th style="text-align:left">语法</th><th style="text-align:left">效果</th><th style="text-align:left">语法</th><th style="text-align:left">效果</th><th style="text-align:left">语法</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left">\bar{x}</td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/c/9/4/c947a5bcc06592f37f6b1c4f2ed57dea.png" srcset="/img/loading.gif" alt="\bar{x}"></td><td style="text-align:left">\acute{\eta}</td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/8/f/f/8ff055145396a2ffefacea0b18ec3fda.png" srcset="/img/loading.gif" alt="\acute{\eta}"></td><td style="text-align:left">\check{\alpha}</td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/a/c/4/ac4a31ee5874dc5044590eedae7a48c4.png" srcset="/img/loading.gif" alt="\check{\alpha}"></td></tr><tr><td style="text-align:left">\grave{\eta}</td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/9/1/f/91f1cf98709ee5bd4380b05d04ce260a.png" srcset="/img/loading.gif" alt="\grave{\eta}"></td><td style="text-align:left">\breve{a}</td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/5/8/5/58565c69fa6e895ea11e57ffdbe7d4cd.png" srcset="/img/loading.gif" alt="\breve{a}"></td><td style="text-align:left">\ddot{y}</td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/5/8/7/58779ff5e3932c43545a8d8114384dd6.png" srcset="/img/loading.gif" alt="\ddot{y}"></td></tr><tr><td style="text-align:left">\dot{x}</td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/5/8/4/584bdd6bbf3b22901631c94c12f09332.png" srcset="/img/loading.gif" alt="\dot{x}"></td><td style="text-align:left">\hat{\alpha}</td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/3/f/e/3fe9b211473065676e1b8048e21b9743.png" srcset="/img/loading.gif" alt="\hat{\alpha}"></td><td style="text-align:left">\tilde{\iota}</td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/5/d/b/5db129ecac03423d19e453d9ada8a0e8.png" srcset="/img/loading.gif" alt="\tilde{\iota}"></td></tr></tbody></table></div><h2 id="微分"><a href="#微分" class="headerlink" title="微分"></a>微分</h2><div class="table-container"><table><thead><tr><th style="text-align:left">语法</th><th style="text-align:left">效果</th><th style="text-align:left">语法</th><th style="text-align:left">效果</th><th style="text-align:left">语法</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left">\nabla</td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/f/e/3/fe3a83e41074834731743ab803cd4936.png" srcset="/img/loading.gif" alt="\nabla"></td><td style="text-align:left">\partial x</td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/2/8/d/28ddb3e82115d069796faf6356e2dbf6.png" srcset="/img/loading.gif" alt="\partial x"></td><td style="text-align:left">\mathrm{d}x</td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/3/d/7/3d7524d2b2372a1188d73b20b9ba4b31.png" srcset="/img/loading.gif" alt="\mathrm{d}x\ "></td></tr><tr><td style="text-align:left">\dot x</td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/3/a/b/3abf2ac2fcc14362b32b0411d43cbf48.png" srcset="/img/loading.gif" alt="\dot x"></td><td style="text-align:left">\ddot y</td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/0/d/2/0d23f3a6391ae79fac3f4b30ec914a84.png" srcset="/img/loading.gif" alt="\ddot y"></td><td style="text-align:left"></td></tr></tbody></table></div><h2 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h2><div class="table-container"><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">语法</th><th style="text-align:left">显示</th></tr></thead><tbody><tr><td style="text-align:left">不好看</td><td style="text-align:left">( \frac{1}{2} )</td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/4/0/a/40ad9d3d1fc9a61e16d22d7e3f854fec.png" srcset="/img/loading.gif" alt="( \frac{1}{2} )"></td></tr><tr><td style="text-align:left">好看了</td><td style="text-align:left">\left( \frac{1}{2} \right)</td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/2/8/b/28bcd5b82ce0e92b25e8a0b4bd5be215.png" srcset="/img/loading.gif" alt="\left ( \frac{1}{2} \right )"></td></tr></tbody></table></div><p>您可以使用 <code>\left</code> 和 <code>\right</code> 来显示不同的括号：</p><div class="table-container"><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">语法</th><th style="text-align:left">显示</th></tr></thead><tbody><tr><td style="text-align:left">圆括号，小括号</td><td style="text-align:left"><code>\left( \frac{a}{b} \right)</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/2/9/0/2905969500b40b2f2c7078206e7e0e81.png" srcset="/img/loading.gif" alt="\left( \frac{a}{b} \right)"></td></tr><tr><td style="text-align:left">方括号，中括号</td><td style="text-align:left"><code>\left[ \frac{a}{b} \right]</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/8/5/8/8585c96f355f7e301fd5143bea32efaf.png" srcset="/img/loading.gif" alt="\left[ \frac{a}{b} \right]"></td></tr><tr><td style="text-align:left">花括号，大括号</td><td style="text-align:left"><code>\left\{ \frac{a}{b} \right\}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/c/4/d/c4d4af6bab9a0e6532dddd50e7d27158.png" srcset="/img/loading.gif" alt="\left\{ \frac{a}{b} \right\}"></td></tr><tr><td style="text-align:left">角括号</td><td style="text-align:left"><code>\left \langle \frac{a}{b} \right \rangle</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/d/0/6/d06e733ce705ed26a7e048dbd2945371.png" srcset="/img/loading.gif" alt="\left\langle \frac{a}{b} \right \rangle"></td></tr><tr><td style="text-align:left">单竖线，绝对值</td><td style="text-align:left">`\left\</td><td style="text-align:left">\frac{a}{b} \right\</td><td>`</td><td>![\left\</td><td>\frac{a}{b} \right\</td><td>](<a href="http://upload.wikimedia.org/wikipedia/zh/math/4/0/d/40d6c8253b08e8801a01b3f6e5069a62.png" target="_blank" rel="noopener">http://upload.wikimedia.org/wikipedia/zh/math/4/0/d/40d6c8253b08e8801a01b3f6e5069a62.png</a>)</td></tr><tr><td style="text-align:left">双竖线，范</td><td style="text-align:left">`\left \</td><td style="text-align:left">\frac{a}{b} \right \</td><td>`</td><td>![\left \</td><td>\frac{a}{b} \right \</td><td>](<a href="http://upload.wikimedia.org/wikipedia/zh/math/f/3/0/f30a5c412d1e4b4e7c6195ff5d47e947.png" target="_blank" rel="noopener">http://upload.wikimedia.org/wikipedia/zh/math/f/3/0/f30a5c412d1e4b4e7c6195ff5d47e947.png</a>)</td></tr><tr><td style="text-align:left">取整函数 （Floor function）</td><td style="text-align:left"><code>\left \lfloor \frac{a}{b} \right \rfloor</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/c/0/7/c07e1fc7c0150828e55da4efe37e8a3f.png" srcset="/img/loading.gif" alt="\left \lfloor \frac{a}{b} \right \rfloor"></td></tr><tr><td style="text-align:left">取顶函数 （Ceiling function)</td><td style="text-align:left"><code>\left \lceil \frac{c}{d} \right \rceil</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/8/6/8/868c1e52c339e01204aa1a77d44e3c71.png" srcset="/img/loading.gif" alt="\left \lceil \frac{c}{d} \right \rceil"></td></tr><tr><td style="text-align:left">斜线与反斜线</td><td style="text-align:left"><code>\left / \frac{a}{b} \right \backslash</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/2/f/3/2f3c5907c0a4fc4fda69eb71890ce952.png" srcset="/img/loading.gif" alt="\left / \frac{a}{b} \right \backslash "></td></tr><tr><td style="text-align:left"><span style="color:blue">上下箭头</span></td><td style="text-align:left"><code>\left \uparrow \frac{a}{b} \right \downarrow</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/b/f/8/bf8dd6b753cb6aeb801ea23de51ad5bc.png" srcset="/img/loading.gif" alt="\pagecolor{White}\left \uparrow \frac{a}{b} \right \downarrow "></td></tr><tr><td style="text-align:left"><span style="color:blue">上下箭头</span></td><td style="text-align:left"><code>\left \Uparrow \frac{a}{b} \right \Downarrow</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/3/d/e/3de7822465115ade10b47634c22b6b7d.png" srcset="/img/loading.gif" alt="\pagecolor{White}\left \Uparrow \frac{a}{b} \right \Downarrow "></td></tr><tr><td style="text-align:left"><span style="color:blue">上下箭头</span></td><td style="text-align:left"><code>\left \updownarrow \frac{a}{b} \right\Updownarrow</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/0/6/b/06b15cbba4d935fe84a1a503603e4eb0.png" srcset="/img/loading.gif" alt="\pagecolor{White}\left \updownarrow \frac{a}{b} \right \Updownarrow"></td></tr><tr><td style="text-align:left">混合括号</td><td style="text-align:left">`\left [ 0,1 \right ) \left \langle \psi \right \</td><td style="text-align:left">`</td><td><img src="http://upload.wikimedia.org/wikipedia/zh/math/a/3/8/a38771eae1778d0e214f6596a8dc1337.png" srcset="/img/loading.gif" alt="混合括号"> ![\left \langle \psi \right \</td><td>](<a href="http://upload.wikimedia.org/wikipedia/zh/math/d/a/2/da25fc177fd4c53a2c3399c25685dd4c.png" target="_blank" rel="noopener">http://upload.wikimedia.org/wikipedia/zh/math/d/a/2/da25fc177fd4c53a2c3399c25685dd4c.png</a>)</td></tr><tr><td style="text-align:left">单左括号</td><td style="text-align:left"><code>\left \{ \frac{a}{b} \right .</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/c/e/d/ced2a2fb558fe49fa56018b9f8fd69d5.png" srcset="/img/loading.gif" alt="\left \{ \frac{a}{b} \right ."></td></tr><tr><td style="text-align:left">单右括号</td><td style="text-align:left"><code>\left . \frac{a}{b} \right \}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/9/a/c/9ac9b3c6d21c56f5b2b474b0ea1c4b8a.png" srcset="/img/loading.gif" alt="\left . \frac{a}{b} \right \}"></td></tr></tbody></table></div><p>$\left [ 0,1 \right ) \left \langle \psi \right |$</p><table>    <tr>        <td>功能</td>        <td>语法</td>        <td>显示</td>    </tr>    <tr>        <td>圆括号，小括号</td>        <td>\left( \frac{a}{b} \right)</td>        <td><img src="http://upload.wikimedia.org/wikipedia/zh/math/2/9/0/2905969500b40b2f2c7078206e7e0e81.png" srcset="/img/loading.gif" < td>    </td></tr>    <tr>        <td>方括号，中括号</td>        <td>`\left[ \frac{a}{b} \right]`</td>        <td>![\left[ \frac{a}{b} \right]](http://upload.wikimedia.org/wikipedia/zh/math/8/5/8/8585c96f355f7e301fd5143bea32efaf.png)</td>    </tr>    <tr>        <td>花括号，大括号</td>        <td>`\left\{ \frac{a}{b} \right\}`</td>        <td>![\left\{ \frac{a}{b} \right\}](http://upload.wikimedia.org/wikipedia/zh/math/c/4/d/c4d4af6bab9a0e6532dddd50e7d27158.png)</td>    </tr>    <tr>        <td>角括号</td>        <td>`\left \langle \frac{a}{b} \right \rangle`</td>        <td>![\left\langle \frac{a}{b} \right \rangle](http://upload.wikimedia.org/wikipedia/zh/math/d/0/6/d06e733ce705ed26a7e048dbd2945371.png)</td>    </tr>    <tr>        <td>单竖线，绝对值</td>        <td>`\left\| \frac{a}{b} \right\|`</td>        <td>![\left\| \frac{a}{b} \right\|](http://upload.wikimedia.org/wikipedia/zh/math/4/0/d/40d6c8253b08e8801a01b3f6e5069a62.png)</td>    </tr>    <tr>        <td>双竖线，范</td>        <td>`\left \| \frac{a}{b} \right \|`</td>        <td>![\left \| \frac{a}{b} \right \|](http://upload.wikimedia.org/wikipedia/zh/math/f/3/0/f30a5c412d1e4b4e7c6195ff5d47e947.png)</td>    </tr>    <tr>        <td>取整函数 （Floor function）</td>        <td>`\left \lfloor \frac{a}{b} \right \rfloor`</td>        <td>![\left \lfloor \frac{a}{b} \right \rfloor](http://upload.wikimedia.org/wikipedia/zh/math/c/0/7/c07e1fc7c0150828e55da4efe37e8a3f.png)</td>    </tr>    <tr>        <td>取顶函数 （Ceiling function)</td>        <td>`\left \lceil \frac{c}{d} \right \rceil`</td>        <td>![\left \lceil \frac{c}{d} \right \rceil](http://upload.wikimedia.org/wikipedia/zh/math/8/6/8/868c1e52c339e01204aa1a77d44e3c71.png)</td>    </tr>    <tr>        <td>斜线与反斜线</td>        <td>`\left / \frac{a}{b} \right \backslash`</td>        <td>![\left / \frac{a}{b} \right \backslash ](http://upload.wikimedia.org/wikipedia/zh/math/2/f/3/2f3c5907c0a4fc4fda69eb71890ce952.png)</td>    </tr>    <tr>        <td>&lt;span style='color:blue'&gt;上下箭头&lt;/span&gt;</td>        <td>`\left \uparrow \frac{a}{b} \right \downarrow`</td>        <td>![\pagecolor{White}\left \uparrow \frac{a}{b} \right \downarrow ](http://upload.wikimedia.org/wikipedia/zh/math/b/f/8/bf8dd6b753cb6aeb801ea23de51ad5bc.png)</td>    </tr>    <tr>        <td>&lt;span style='color:blue'&gt;上下箭头&lt;/span&gt;</td>        <td>`\left \Uparrow \frac{a}{b} \right \Downarrow`</td>        <td>![\pagecolor{White}\left \Uparrow \frac{a}{b} \right \Downarrow ](http://upload.wikimedia.org/wikipedia/zh/math/3/d/e/3de7822465115ade10b47634c22b6b7d.png)</td>    </tr>    <tr>        <td>&lt;span style='color:blue'&gt;上下箭头&lt;/span&gt;</td>        <td>`\left \updownarrow \frac{a}{b} \right\Updownarrow`</td>        <td>![\pagecolor{White}\left \updownarrow \frac{a}{b} \right \Updownarrow](http://upload.wikimedia.org/wikipedia/zh/math/0/6/b/06b15cbba4d935fe84a1a503603e4eb0.png)</td>    </tr>    <tr>        <td>混合括号</td>        <td>`\left [ 0,1 \right ) \left \langle \psi \right \|`</td>        <td>![混合括号](http://upload.wikimedia.org/wikipedia/zh/math/a/3/8/a38771eae1778d0e214f6596a8dc1337.png) ![\left \langle \psi \right \|](http://upload.wikimedia.org/wikipedia/zh/math/d/a/2/da25fc177fd4c53a2c3399c25685dd4c.png)</td>    </tr>    <tr>        <td>单左括号</td>        <td>`\left \{ \frac{a}{b} \right .`</td>        <td>![\left \{ \frac{a}{b} \right .](http://upload.wikimedia.org/wikipedia/zh/math/c/e/d/ced2a2fb558fe49fa56018b9f8fd69d5.png)</td>    </tr>    <tr>        <td>单右括号</td>        <td>`\left . \frac{a}{b} \right \}`</td>        <td>![\left . \frac{a}{b} \right \}](http://upload.wikimedia.org/wikipedia/zh/math/9/a/c/9ac9b3c6d21c56f5b2b474b0ea1c4b8a.png)</td>    </tr></table><h2 id="上标、下标及积分等"><a href="#上标、下标及积分等" class="headerlink" title="上标、下标及积分等"></a>上标、下标及<a href="http://zh.wikipedia.org/wiki/积分" target="_blank" rel="noopener">积分</a>等</h2><div class="table-container"><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">语法</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left">上标</td><td style="text-align:left"><code>a^2</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/f/1/d/f1d0a7eeee296f457681b906e2cdacac.png" srcset="/img/loading.gif" alt="\pagecolor{White} a^2"></td></tr><tr><td style="text-align:left">下标</td><td style="text-align:left"><code>a_2</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/8/e/2/8e2d2291a5593af94e996a65b6f726f8.png" srcset="/img/loading.gif" alt="\pagecolor{White} a_2"></td></tr><tr><td style="text-align:left"><span style="color:blue">组合</span></td><td style="text-align:left"><code>a^{2+2}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/0/6/8/0683bba81494fa4172f1052cec9f2eed.png" srcset="/img/loading.gif" alt="\pagecolor{White} a^{2+2}"></td></tr><tr><td style="text-align:left"><span style="color:blue">组合</span></td><td style="text-align:left"><code>a_{i,j}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/b/d/9/bd93d6a6976568f768d4ef2a91bb2151.png" srcset="/img/loading.gif" alt="\pagecolor{White} a_{i,j}"></td></tr><tr><td style="text-align:left">结合上下标</td><td style="text-align:left"><code>x_2^3</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/f/7/f/f7ffd853543b9b2461e72eb28f8dec3c.png" srcset="/img/loading.gif" alt="\pagecolor{White} x_2^3"></td></tr><tr><td style="text-align:left">前置上下标</td><td style="text-align:left"><code>{}_1^2\!X_3^4</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/2/4/9/2491f82bb48b549a2aaf289dbb3a7bed.png" srcset="/img/loading.gif" alt="\pagecolor{White} {}_1^2\!X_3^4"></td></tr><tr><td style="text-align:left"><a href="http://zh.wikipedia.org/wiki/导数" target="_blank" rel="noopener">导数</a> （<strong>HTML</strong>）</td><td style="text-align:left"><code>x&#39;</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/2/1/e/21ef9651f881246acc18a8b92368aabf.png" srcset="/img/loading.gif" alt="\pagecolor{White} x&#39;"></td></tr><tr><td style="text-align:left">导数 （<strong>PNG</strong>）</td><td style="text-align:left"><code>x^\prime</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/e/3/d/e3dbdd462fde1f1fb890aed48df66440.png" srcset="/img/loading.gif" alt="\pagecolor{White} x^\prime"></td></tr><tr><td style="text-align:left">导数 （<strong>错误</strong>）</td><td style="text-align:left"><code>x\prime</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/e/5/2/e5269181cb3851f57f684d621a9f1fca.png" srcset="/img/loading.gif" alt="\pagecolor{White} x\prime"></td></tr><tr><td style="text-align:left"><span style="color:green">导数点</span></td><td style="text-align:left"><code>\dot{x}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/7/3/3/733b0ff044f2e2cfdb524078740878b1.png" srcset="/img/loading.gif" alt="\pagecolor{White} \dot{x}"></td></tr><tr><td style="text-align:left"><span style="color:green">导数点</span></td><td style="text-align:left"><code>\ddot{y}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/e/6/f/e6f6b45ec0ee15db8c4caa3f1fe88fdf.png" srcset="/img/loading.gif" alt="\pagecolor{White} \ddot{y}"></td></tr><tr><td style="text-align:left"><span style="color:blue"><a href="http://zh.wikipedia.org/wiki/向量" target="_blank" rel="noopener">向量</a></span></td><td style="text-align:left"><code>\vec{c}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/3/1/f/31fc19819196b91156e13edc6cb3358c.png" srcset="/img/loading.gif" alt="\pagecolor{White} \vec{c}"></td></tr><tr><td style="text-align:left"><span style="color:blue"><a href="http://zh.wikipedia.org/wiki/向量" target="_blank" rel="noopener">向量</a></span></td><td style="text-align:left"><code>\overleftarrow{a b}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/d/9/4/d948738bbfeb127b134f549321c789ff.png" srcset="/img/loading.gif" alt="\pagecolor{White} \overleftarrow{a b}"></td></tr><tr><td style="text-align:left"><span style="color:blue"><a href="http://zh.wikipedia.org/wiki/向量" target="_blank" rel="noopener">向量</a></span></td><td style="text-align:left"><code>\overrightarrow{c d}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/3/c/1/3c115f32f746e2c73d59f1a8cfbe36a2.png" srcset="/img/loading.gif" alt="\pagecolor{White} \overrightarrow{c d}"></td></tr><tr><td style="text-align:left"><span style="color:blue"><a href="http://zh.wikipedia.org/wiki/向量" target="_blank" rel="noopener">向量</a></span></td><td style="text-align:left"><code>\widehat{e f g}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/4/c/b/4cba1e79deac23bb500a8aa203d9a111.png" srcset="/img/loading.gif" alt="\pagecolor{White} \widehat{e f g}"></td></tr><tr><td style="text-align:left">上弧</td><td style="text-align:left"><code>\overset{\frown} {AB}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/b/4/0/b40456c21e931270a803c1d538d863f2.png" srcset="/img/loading.gif" alt="\pagecolor{White} \overset{\frown} {AB}"></td></tr><tr><td style="text-align:left">上划线</td><td style="text-align:left"><code>\overline{h i j}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/5/b/1/5b143339bea2ab5becbbb7a3bdaba555.png" srcset="/img/loading.gif" alt="\pagecolor{White} \overline{h i j}"></td></tr><tr><td style="text-align:left">下划线</td><td style="text-align:left"><code>\underline{k l m}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/1/4/7/147943fe9e7a222b850132ddd7882dce.png" srcset="/img/loading.gif" alt="\pagecolor{White} \underline{k l m}"></td></tr><tr><td style="text-align:left"><span style="color:red">上括号</span></td><td style="text-align:left"><code>\overbrace{1+2+\cdots+100}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/e/9/9/e997df92fcd3679c1935cd73f5fa1a73.png" srcset="/img/loading.gif" alt="\pagecolor{White} \overbrace{1+2+\cdots+100}"></td></tr><tr><td style="text-align:left"><span style="color:red">上括号</span></td><td style="text-align:left"><code>\begin{matrix} 5050 \\ \overbrace{ 1+2+\cdots+100 }\end{matrix}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/7/3/c/73c0e4b49730d106b752a7c3715b0c3d.png" srcset="/img/loading.gif" alt="\pagecolor{White} \begin{matrix} 5050 \\ \overbrace{ 1+2+\cdots+100 } \end{matrix}"></td></tr><tr><td style="text-align:left"><span style="color:purple">下括号</span></td><td style="text-align:left"><code>\underbrace{a+b+\cdots+z}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/d/7/9/d793da2820a7de9b0c645ac746da79ef.png" srcset="/img/loading.gif" alt="\pagecolor{White} \underbrace{a+b+\cdots+z}"></td></tr><tr><td style="text-align:left"><span style="color:purple">下括号</span></td><td style="text-align:left"><code>\begin{matrix} \underbrace{ a+b+\cdots+z } \\ 26\end{matrix}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/b/c/9/bc9dd69fffd702f4846f73579620c811.png" srcset="/img/loading.gif" alt="\pagecolor{White} \begin{matrix} \underbrace{ a+b+\cdots+z } \\ 26 \end{matrix}"></td></tr><tr><td style="text-align:left"><span style="color:orange">求和</span></td><td style="text-align:left"><code>\sum_{k=1}^N k^2</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/6/a/4/6a4791650b77862a6d6bf83f286d9f0c.png" srcset="/img/loading.gif" alt="\pagecolor{White} \sum_{k=1}^N k^2"></td></tr><tr><td style="text-align:left"><span style="color:orange">求和</span></td><td style="text-align:left"><code>\begin{matrix} \sum_{k=1}^N k^2 \end{matrix}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/3/9/c/39cf5eb70e03dff6ed87382baeca9291.png" srcset="/img/loading.gif" alt="\pagecolor{White} \begin{matrix} \sum_{k=1}^N k^2 \end{matrix}"></td></tr><tr><td style="text-align:left"><span style="color:blue">求积</span></td><td style="text-align:left"><code>\prod_{i=1}^N x_i</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/0/9/f/09f3d0f277e7d0da504ca31e5f546988.png" srcset="/img/loading.gif" alt="\pagecolor{White} \prod_{i=1}^N x_i"></td></tr><tr><td style="text-align:left"><span style="color:blue">求积</span></td><td style="text-align:left"><code>\begin{matrix} \prod_{i=1}^N x_i \end{matrix}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/5/f/0/5f06b9aa7b4eba60f3e886bcadde28f0.png" srcset="/img/loading.gif" alt="\pagecolor{White} \begin{matrix} \prod_{i=1}^N x_i \end{matrix}"></td></tr><tr><td style="text-align:left"><span style="color:green">上积</span></td><td style="text-align:left"><code>\coprod_{i=1}^N x_i</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/6/4/c/64c84feef576affcd4a7bdeb785a943c.png" srcset="/img/loading.gif" alt="\pagecolor{White} \coprod_{i=1}^N x_i"></td></tr><tr><td style="text-align:left"><span style="color:green">上积</span></td><td style="text-align:left"><code>\begin{matrix} \coprod_{i=1}^N x_i\end{matrix}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/e/5/6/e56db83ea5ba72537c2d85ed8f013276.png" srcset="/img/loading.gif" alt="\pagecolor{White} \begin{matrix} \coprod_{i=1}^N x_i \end{matrix}"></td></tr><tr><td style="text-align:left"><a href="http://zh.wikipedia.org/wiki/极限" target="_blank" rel="noopener">极限</a></td><td style="text-align:left"><code>\lim_{n \to \infty}x_n</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/7/9/5/7950c79f217c0a89607656e58d4296fd.png" srcset="/img/loading.gif" alt="\pagecolor{White} \lim_{n \to \infty}x_n"></td></tr><tr><td style="text-align:left"><a href="http://zh.wikipedia.org/wiki/极限" target="_blank" rel="noopener">极限</a></td><td style="text-align:left"><code>\begin{matrix} \lim_{n \to \infty}x_n\end{matrix}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/e/7/c/e7ccfef303615810c06213be8a676484.png" srcset="/img/loading.gif" alt="\pagecolor{White} \begin{matrix} \lim_{n \to \infty}x_n \end{matrix}"></td></tr><tr><td style="text-align:left"><a href="http://zh.wikipedia.org/wiki/积分" target="_blank" rel="noopener">积分</a></td><td style="text-align:left"><code>\int_{-N}^{N} e^x\, dx</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/7/4/9/7491e901a36ceb13bbbe943759b14dc8.png" srcset="/img/loading.gif" alt="\pagecolor{White} \int_{-N}^{N} e^x\, dx"></td></tr><tr><td style="text-align:left"><a href="http://zh.wikipedia.org/wiki/积分" target="_blank" rel="noopener">积分</a></td><td style="text-align:left"><code>\begin{matrix} \int_{-N}^{N} e^x\, dx\end{matrix}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/5/f/6/5f6531acbd059619af09d3b52039ede5.png" srcset="/img/loading.gif" alt="\pagecolor{White} \begin{matrix} \int_{-N}^{N} e^x\, dx \end{matrix}"></td></tr><tr><td style="text-align:left"><a href="http://zh.wikipedia.org/wiki/双重积分" target="_blank" rel="noopener">双重积分</a></td><td style="text-align:left"><code>\iint_{D}^{W} \, dx\,dy</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/4/4/e/44e3f99f1f29b9ee5de871e820cec5f3.png" srcset="/img/loading.gif" alt="\pagecolor{White} \iint_{D}^{W} \, dx\,dy"></td></tr><tr><td style="text-align:left">三重积分</td><td style="text-align:left"><code>\iiint_{E}^{V} \, dx\,dy\,dz</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/8/c/0/8c050c5bd1690dd42a9f175ec124cb97.png" srcset="/img/loading.gif" alt="\pagecolor{White} \iiint_{E}^{V} \, dx\,dy\,dz"></td></tr><tr><td style="text-align:left">四重积分</td><td style="text-align:left"><code>\iiiint_{F}^{U} \, dx\,dy\,dz\,dt</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/d/b/5/db51c71f79d301a689b3231927a0dfaa.png" srcset="/img/loading.gif" alt="\pagecolor{White} \iiiint_{F}^{U} \, dx\,dy\,dz\,dt"></td></tr><tr><td style="text-align:left">闭合的<a href="http://zh.wikipedia.org/wiki/路径积分" target="_blank" rel="noopener">曲线</a>、<a href="http://zh.wikipedia.org/wiki/曲面积分" target="_blank" rel="noopener">曲面积分</a></td><td style="text-align:left"><code>\oint_{C} x^3\, dx + 4y^2\, dy</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/e/5/7/e5791a184359ab19ff7e372b15ec0d1b.png" srcset="/img/loading.gif" alt="\pagecolor{White} \oint_{C} x^3\, dx + 4y^2\, dy"></td></tr><tr><td style="text-align:left"><a href="http://zh.wikipedia.org/wiki/交集" target="_blank" rel="noopener">交集</a></td><td style="text-align:left"><code>\bigcap_1^{n} p</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/4/6/3/463d4e4bd315c0c6030354a540d85829.png" srcset="/img/loading.gif" alt="\pagecolor{White} \bigcap_1^{n} p"></td></tr><tr><td style="text-align:left"><a href="http://zh.wikipedia.org/wiki/并集" target="_blank" rel="noopener">并集</a></td><td style="text-align:left"><code>\bigcup_1^{k} p</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/8/0/0/80059f454f87af13803b327c202dcec1.png" srcset="/img/loading.gif" alt="\pagecolor{White} \bigcup_1^{k} p"></td></tr></tbody></table></div><p><span style="color:red">上弧 (注: 正确应该用 \overarc, 但在这里行不通。要用建议的语法作为解决办法)</span></p><h2 id="分数、矩阵和多行列式"><a href="#分数、矩阵和多行列式" class="headerlink" title="分数、矩阵和多行列式"></a><a href="http://zh.wikipedia.org/wiki/分数" target="_blank" rel="noopener">分数</a>、<a href="http://zh.wikipedia.org/wiki/矩阵" target="_blank" rel="noopener">矩阵</a>和多行列式</h2><div class="table-container"><table><thead><tr><th style="text-align:left">功能</th><th style="text-align:left">语法</th><th style="text-align:left">效果</th></tr></thead><tbody><tr><td style="text-align:left">分数</td><td style="text-align:left"><code>\frac{2}{4}=0.5</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/4/6/d/46dc0b34e0ab4e944a437720a4431d6c.png" srcset="/img/loading.gif" alt="\frac{2}{4}=0.5"></td></tr><tr><td style="text-align:left">小型分数</td><td style="text-align:left"><code>\tfrac{2}{4} = 0.5</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/2/8/4/284667fc4a92790093aa59b61b3667a0.png" srcset="/img/loading.gif" alt="\tfrac{2}{4} = 0.5"></td></tr><tr><td style="text-align:left">大型分数（嵌套）</td><td style="text-align:left"><code>\cfrac{2}{c + \cfrac{2}{d + \cfrac{2}{4}}} =a</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/6/d/0/6d099c02b3faf73f9320656217415906.png" srcset="/img/loading.gif" alt="\cfrac{2}{c + \cfrac{2}{d + \cfrac{2}{4}}} = a"></td></tr><tr><td style="text-align:left">大型分数（不嵌套）</td><td style="text-align:left"><code>\dfrac{2}{4} = 0.5 \qquad \dfrac{2}{c + \dfrac{2}{d +\dfrac{2}{4}}} = a</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/5/a/3/5a37ae94a95c7dd603c20cd4fbe8d9e9.png" srcset="/img/loading.gif" alt="\dfrac{2}{4} = 0.5 \qquad \dfrac{2}{c + \dfrac{2}{d + \dfrac{2}{4}}} = a"></td></tr><tr><td style="text-align:left"><a href="http://zh.wikipedia.org/wiki/二项式" target="_blank" rel="noopener">二项式</a>系数</td><td style="text-align:left"><code>\dbinom{n}{r}=\binom{n}{n-r}=C^n_r=C^n_{n-r}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/6/a/5/6a5373cd8c6503567a3c2a69deda71f3.png" srcset="/img/loading.gif" alt="\dbinom{n}{r}=\binom{n}{n-r}=C^n_r=C^n_{n-r}"></td></tr><tr><td style="text-align:left">小型<a href="http://zh.wikipedia.org/wiki/二项式" target="_blank" rel="noopener">二项式</a>系数</td><td style="text-align:left"><code>\tbinom{n}{r}=\tbinom{n}{n-r}=C^n_r=C^n_{n-r}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/0/b/1/0b1188af9ee1a12bc62ca56cf83f268c.png" srcset="/img/loading.gif" alt="\tbinom{n}{r}=\tbinom{n}{n-r}=C^n_r=C^n_{n-r}"></td></tr><tr><td style="text-align:left">大型<a href="http://zh.wikipedia.org/wiki/二项式" target="_blank" rel="noopener">二项式</a>系数</td><td style="text-align:left"><code>\binom{n}{r}=\dbinom{n}{n-r}=C^n_r=C^n_{n-r}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/b/6/9/b69b21e3b047a91cd1127a498b3267f6.png" srcset="/img/loading.gif" alt="\binom{n}{r}=\dbinom{n}{n-r}=C^n_r=C^n_{n-r}"></td></tr><tr><td style="text-align:left"><span style="color:blue">矩阵</span></td><td style="text-align:left"><code>\begin{matrix} x &amp; y \\ z &amp; v \end{matrix}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/b/9/9/b99890966e1b997497211428f8e3419d.png" srcset="/img/loading.gif" alt="\begin{matrix} x &amp; y \\ z &amp; v \end{matrix}"></td></tr><tr><td style="text-align:left"><span style="color:blue">矩阵</span></td><td style="text-align:left"><code>\begin{vmatrix} x &amp; y \\ z &amp; v \end{vmatrix}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/9/2/b/92b8f0e57848a80b4babd2ba93775370.png" srcset="/img/loading.gif" alt="\begin{vmatrix} x &amp; y \\ z &amp; v \end{vmatrix}"></td></tr><tr><td style="text-align:left"><span style="color:blue">矩阵</span></td><td style="text-align:left"><code>\begin{Vmatrix} x &amp; y \\ z &amp; v \end{Vmatrix}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/b/b/a/bba5bfd11057dbb202307584eed8f2dc.png" srcset="/img/loading.gif" alt="\begin{Vmatrix} x &amp; y \\ z &amp; v \end{Vmatrix}"></td></tr><tr><td style="text-align:left"><span style="color:blue">矩阵</span></td><td style="text-align:left"><code>\begin{bmatrix} 0      &amp; \cdots &amp; 0      \\ \vdots &amp; \ddots &amp; \vdots \\ 0      &amp; \cdots &amp; 0 \end{bmatrix}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/8/1/a/81a12a09ac84853e3d25323b8643c630.png" srcset="/img/loading.gif" alt="\begin{bmatrix} 0 &amp; \cdots &amp; 0 \\ \vdots &amp; \ddots &amp; \vdots \\ 0 &amp; \cdots &amp; 0\end{bmatrix} "></td></tr><tr><td style="text-align:left"><span style="color:blue">矩阵</span></td><td style="text-align:left"><code>\begin{Bmatrix} x &amp; y \\ z &amp; v \end{Bmatrix}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/b/f/7/bf7244e2842c8a7d55892e229560d5c1.png" srcset="/img/loading.gif" alt="\begin{Bmatrix} x &amp; y \\ z &amp; v \end{Bmatrix}"></td></tr><tr><td style="text-align:left"><span style="color:blue">矩阵</span></td><td style="text-align:left"><code>\begin{pmatrix} x &amp; y \\ z &amp; v \end{pmatrix}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/4/4/4/444df88e616def4e275b4e920c7b872e.png" srcset="/img/loading.gif" alt="\begin{pmatrix} x &amp; y \\ z &amp; v \end{pmatrix}"></td></tr><tr><td style="text-align:left"><span style="color:blue">矩阵</span></td><td style="text-align:left"><code>\bigl( \begin{smallmatrix} a&amp;b\\ c&amp;d \end{smallmatrix} \bigr)</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/c/d/4/cd49bbc188dce0f93fef57312af5a106.png" srcset="/img/loading.gif" alt=" \bigl( \begin{smallmatrix} a&amp;b\\ c&amp;d \end{smallmatrix} \bigr) "></td></tr><tr><td style="text-align:left">条件定义</td><td style="text-align:left"><code>f(n) = \begin{cases}  n/2,  &amp; \mbox{if }n\mbox{ is even} \\ 3n+1, &amp; \mbox{if }n\mbox{ is odd} \end{cases}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/e/3/a/e3aebe50364cfe498fa9ca99c0036010.png" srcset="/img/loading.gif" alt="f(n) = \begin{cases} n/2, &amp; \mbox{if }n\mbox{ is even} \ 3n+1, &amp; \mbox{if }n\mbox{ is odd} \end{cases} "></td></tr><tr><td style="text-align:left"><span style="color:green">多行等式</span></td><td style="text-align:left"><code>\begin{align} f(x) &amp; = (m+n)^2 \\ &amp; = m^2+2mn+n^2 \\ \end{align}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/1/d/9/1d9f576360e949d08e0fac7cacbbd25c.png" srcset="/img/loading.gif" alt=" \begin{align} f(x) &amp; = (m+n)^2 \ &amp; = m^2+2mn+n^2 \ \end{align} "></td></tr><tr><td style="text-align:left"><span style="color:green">多行等式</span></td><td style="text-align:left"><code>\begin{alignat}{2} f(x) &amp; = (m-n)^2 \\ f(x) &amp; = (-m+n)^2 \\ &amp; = m^2-2mn+n^2 \\ \end{alignat}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/1/8/d/18d4bad0865b57fc1d5b383abe2da1b0.png" srcset="/img/loading.gif" alt=" \begin{alignat}{2} f(x) &amp; = (m-n)^2 \ f(x) &amp; = (-m+n)^2 \ &amp; = m^2-2mn+n^2 \ \end{alignat} "></td></tr><tr><td style="text-align:left">多行等式（左对齐）</td><td style="text-align:left"><code>\begin{array}{lcl} z        &amp; = &amp; a \\ f(x,y,z) &amp; = &amp; x + y + z  \end{array}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/9/b/f/9bf19115bb27237fa997ca93b94ad217.png" srcset="/img/loading.gif" alt="\begin{array}{lcl} z &amp; = &amp; a \ f(x,y,z) &amp; = &amp; x + y + z \end{array}"></td></tr><tr><td style="text-align:left">多行等式（右对齐）</td><td style="text-align:left"><code>\begin{array}{lcr} z        &amp; = &amp; a \\ f(x,y,z) &amp; = &amp; x + y + z     \end{array}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/0/2/a/02ae32735e1e21ba3b05984289fd2763.png" srcset="/img/loading.gif" alt="\begin{array}{lcr} z &amp; = &amp; a \ f(x,y,z) &amp; = &amp; x + y + z \end{array}"></td></tr><tr><td style="text-align:left">长公式换行</td><td style="text-align:left"><code>&lt;math&gt;f(x) \,\!&lt;/math&gt; &lt;math&gt;= \sum_{n=0}^\infty a_n x^n &lt;/math&gt; &lt;math&gt;= a_0+a_1x+a_2x^2+\cdots&lt;/math&gt;</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/8/d/f/8dfae20000a042d8e9047aad1d7e171e.png" srcset="/img/loading.gif" alt="f(x) \,\!"><img src="http://upload.wikimedia.org/wikipedia/zh/math/6/6/3/6633d51d63b35281d030755a6b0aebb1.png" srcset="/img/loading.gif" alt="= \sum_{n=0}^\infty a_n x^n "><img src="http://upload.wikimedia.org/wikipedia/zh/math/f/e/3/fe3e268382fd486e8572daf895bd4c9d.png" srcset="/img/loading.gif" alt="= a_0 +a_1x+a_2x^2+\cdots"></td></tr><tr><td style="text-align:left"><a href="http://zh.wikipedia.org/wiki/方程组" target="_blank" rel="noopener">方程组</a></td><td style="text-align:left"><code>\begin{cases} 3x + 5y +  z \\ 7x - 2y + 4z \\ -6x + 3y + 2z \end{cases}</code></td><td style="text-align:left"><img src="http://upload.wikimedia.org/wikipedia/zh/math/6/3/4/6349be04b3562fc215c7a4e130422a96.png" srcset="/img/loading.gif" alt="\begin{cases} 3x + 5y + z \\ 7x - 2y + 4z \\ -6x + 3y + 2z \end{cases}"></td></tr><tr><td style="text-align:left">数组</td><td style="text-align:left">`\begin{array}{</td><td style="text-align:left">c</td><td>c</td><td></td><td>c</td><td>} a &amp; b &amp; S \\ \hline 0&amp;0&amp;1\\ 0&amp;1&amp;1\\ 1&amp;0&amp;1\\ 1&amp;1&amp;0\\ \end{array} `</td><td>![ \begin{array}{\</td><td>c\</td><td>c\</td><td>\</td><td>c\</td><td>} a &amp; b &amp; S \ \hline 0&amp;0&amp;1\ 0&amp;1&amp;1\ 1&amp;0&amp;1\ 1&amp;1&amp;0\ \end{array} ](<a href="http://upload.wikimedia.org/wikipedia/zh/math/9/1/5/9151e94ef2bb52c18176dbe4c11921ed.png" target="_blank" rel="noopener">http://upload.wikimedia.org/wikipedia/zh/math/9/1/5/9151e94ef2bb52c18176dbe4c11921ed.png</a>)</td></tr></tbody></table></div><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.tablesgenerator.com/html_tables" target="_blank" rel="noopener">自动生成latex, html…类型表格(单个表格插入很方便)</a></p><p><a href="https://blog.csdn.net/garfielder007/article/details/51646604" target="_blank" rel="noopener">latex公式非常非常全面</a></p><p><a href="https://tableconvert.com/?import=example&amp;output=html" target="_blank" rel="noopener">Excel、URL、Markdown、HTML、JSON、CSV/TSV各种表格形式转换</a></p><p><a href="https://segmentfault.com/a/1190000020155896" target="_blank" rel="noopener">上个链接的使用说明</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习-集成学习</title>
    <link href="/article/2bebfb2a.html"/>
    <url>/article/2bebfb2a.html</url>
    
    <content type="html"><![CDATA[<h1 id="集成学习-Ensemble-Learning-introduction"><a href="#集成学习-Ensemble-Learning-introduction" class="headerlink" title="集成学习(Ensemble Learning introduction)"></a>集成学习(Ensemble Learning introduction)</h1><p>如果聚合一组预测器(比如分类器或回归器)的预测，得到的预测结果也比最好的单个预测器要好。这样的一组预测器，我们称为集成。这种技术，也被称为集成学习，而一个集成学习的算法则被称为集成方法。</p><ul><li>voting(投票)</li><li>Bagging<ul><li>随机森林(RandomForest)</li></ul></li><li>Boosting<ul><li>AdaBoost</li><li>提升树</li><li>XGboost</li></ul></li><li>stacking</li></ul><h2 id="voting-投票"><a href="#voting-投票" class="headerlink" title="voting(投票)"></a>voting(投票)</h2><p>1、硬投票分类器(Hard Voting)</p><p><img src="/article/2bebfb2a/hard_voting.png" srcset="/img/loading.gif" alt="hard_voting"></p><p>分类结果是01分类，即选择一种结果(跟hard label类似)。</p><p>2、软投票分类器(Soft Voting)<br>分类器能够估算出类别的概率。把概率取平均，取平均概率最高的类别作为预测标签(跟soft label类似)。被称为软投票法。通常来说比硬投票法表现更优，因为它给予那些高度自信的投票更高的权重。</p><p><strong>硬投票表决(sklearn代码简单实现)：</strong></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> VotingClassifier<span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier<span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> make_moons<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-comment"># 使用Sklearn中moon数据集</span>X,y = make_moons(n_samples=<span class="hljs-number">7000</span>,noise=<span class="hljs-number">0.1</span>)plt.scatter(X[:,<span class="hljs-number">0</span>],X[:,<span class="hljs-number">1</span>])</code></pre><p><img src="/article/2bebfb2a/输入.png" srcset="/img/loading.gif" alt="输入"></p><pre><code class="hljs python"><span class="hljs-comment"># 数据集分割</span>X_train, X_test, y_train, y_test = train_test_split(X, y , test_size=<span class="hljs-number">0.25</span>, random_state=<span class="hljs-number">42</span>)<span class="hljs-comment"># 定义三个基分类器</span><span class="hljs-comment"># -逻辑回归</span><span class="hljs-comment"># -决策树</span><span class="hljs-comment"># -SVM</span>lr = LogisticRegression()dt = DecisionTreeClassifier()svm = SVC()<span class="hljs-comment"># 定义投票分类器</span>voting = VotingClassifier(    estimators=[(<span class="hljs-string">'lr'</span>,lr),(<span class="hljs-string">'dt'</span>,dt),(<span class="hljs-string">'svm'</span>,svm)],    voting=<span class="hljs-string">'hard'</span>)<span class="hljs-comment"># 输出各个分类器的准确率</span><span class="hljs-keyword">for</span> clf <span class="hljs-keyword">in</span> (lr,dt,svm,voting):    clf.fit(X_train,y_train)    y_hat = clf.predict(X_test)    print(clf.__class__.__name__,<span class="hljs-string">'='</span>,accuracy_score(y_test,y_hat))</code></pre><p>输出：</p><pre><code class="hljs ini"><span class="hljs-attr">LogisticRegression</span> = <span class="hljs-number">0.8862857142857142</span><span class="hljs-attr">DecisionTreeClassifier</span> = <span class="hljs-number">0.996</span><span class="hljs-attr">SVC</span> = <span class="hljs-number">0.9988571428571429</span><span class="hljs-attr">VotingClassifier</span> = <span class="hljs-number">0.9977142857142857</span></code></pre><p><strong>软投票表决(跟上面的代码只有一些些不同)：</strong></p><pre><code class="hljs python"><span class="hljs-comment"># 数据集加载是一致的</span><span class="hljs-comment"># 定义三个基分类器</span>lr = LogisticRegression()dt = DecisionTreeClassifier()svm = SVC(probability=<span class="hljs-literal">True</span>) <span class="hljs-comment"># probability设置为True，概率形式的预测结果输入到votingClassifier中</span><span class="hljs-comment"># 定义投票分类器</span>voting = VotingClassifier(    estimators=[(<span class="hljs-string">'lr'</span>,lr),(<span class="hljs-string">'rf'</span>,dt),(<span class="hljs-string">'svc'</span>,svm)],    voting=<span class="hljs-string">'soft'</span> <span class="hljs-comment"># 设置为soft</span>)<span class="hljs-comment"># 输出各个分类器的准确率</span><span class="hljs-keyword">for</span> clf <span class="hljs-keyword">in</span> (lr,dt,svm,voting):    clf.fit(X_train,y_train)    y_hat = clf.predict(X_test)    print(clf.__class__.__name__,<span class="hljs-string">'='</span>,accuracy_score(y_test,y_hat))</code></pre><p>输出：</p><pre><code class="hljs ini"><span class="hljs-attr">LogisticRegression</span> = <span class="hljs-number">0.88</span><span class="hljs-attr">DecisionTreeClassifier</span> = <span class="hljs-number">0.9994285714285714</span><span class="hljs-attr">SVC</span> = <span class="hljs-number">0.9994285714285714</span><span class="hljs-attr">VotingClassifier</span> = <span class="hljs-number">0.9994285714285714</span></code></pre><h2 id="Bagging-并行"><a href="#Bagging-并行" class="headerlink" title="Bagging(并行)"></a>Bagging(并行)</h2><p>bagging和pasting<br>每个预测器使用的算法相同，但是在不同的训练集(随机子集)上进行训练。采样时如果将样本放回，这汇总方法叫做bagging(bootstrap aggregating，自举汇聚法)。采样时样本不放回，这种方法叫做pasting。<br>(实际应用中bagging更加常用。这里就着重介绍bagging)</p><p><img src="/article/2bebfb2a/image-20200713004236379.png" srcset="/img/loading.gif" alt="image-20200713004236379"></p><h3 id="随机森林-Random-Forest"><a href="#随机森林-Random-Forest" class="headerlink" title="随机森林(Random Forest)"></a>随机森林(Random Forest)</h3><p>随机森林是决策树的集成，通常用bagging(有时也可能是pasting)方法训练。除了先构建一个BaggingClassifier然后将结果传输到DecisionTreeClassifier，还有一种方法就是使用RandomForestClassifier类。</p><p>大概有63.2%样本会被抽到，用作训练集。未抽到的37.8%样本(out of bag简称oob)作为测试集。<br>证明：假设进行N次抽样，未抽到的概率为 $1-(1-\frac{1}{N})^N=1-[(1+\frac{1}{-N})^{-N}]^{-1}$，当N趋于无穷大时，上式趋于$1-e^{-1}=63.2\%$。</p><p><strong>代码：</strong></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> BaggingClassifier<span class="hljs-keyword">from</span> sklearn.svm <span class="hljs-keyword">import</span> SVC<span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npiris = load_iris()X = iris.datay = iris.target<span class="hljs-comment"># bootstrap = True 为bagging，bootstrap=False为pasting</span><span class="hljs-comment"># max_samples设置为整数表示的就是采样的样本数，设置为浮点数表示的是max_samples*x.shape[0]</span><span class="hljs-comment"># oob_score=True表示未抽到的样本作为测试集</span><span class="hljs-comment"># n_estimators基本分类器的数量</span>bag_clf = BaggingClassifier(    SVC(),    n_estimators=<span class="hljs-number">500</span>, max_samples=<span class="hljs-number">1.0</span>, bootstrap=<span class="hljs-literal">True</span>, n_jobs=<span class="hljs-number">-1</span>     ,oob_score=<span class="hljs-literal">True</span>)bag_clf.fit(X,y)<span class="hljs-comment"># oob_score默认为False时进行下列预测</span><span class="hljs-comment"># y_hat = bag_clf.predict(X)</span><span class="hljs-comment"># print(bag_clf.__class__.__name__,'=',accuracy_score(y,y_hat))</span><span class="hljs-comment"># BaggingClassifier = 0.9733333333333334</span>print(bag_clf.oob_score_)</code></pre><p>输出：</p><pre><code class="hljs angelscript"><span class="hljs-number">0.9666666666666667</span></code></pre><p>如果基本分类器是决策树，那么集成后的分类器就是随机森林</p><pre><code class="hljs python">bag_clf = BaggingClassifier(    DecisionTreeClassifier(splitter=<span class="hljs-string">"random"</span>, max_leaf_nodes=<span class="hljs-number">16</span>),    n_estimators=<span class="hljs-number">500</span>, max_samples=<span class="hljs-number">1.0</span>, bootstrap=<span class="hljs-literal">True</span>, n_jobs=<span class="hljs-number">-1</span>)bag_clf.fit(X,y)y_hat = bag_clf.predict(X)print(bag_clf.__class__.__name__,<span class="hljs-string">'='</span>,accuracy_score(y,y_hat))</code></pre><p>输出：</p><pre><code class="hljs ini"><span class="hljs-attr">BaggingClassifier</span> = <span class="hljs-number">1.0</span></code></pre><p>Sklearn也提供了直接实现随机森林的API</p><pre><code class="hljs PYTHON">rnd_clf = RandomForestClassifier(n_estimators=<span class="hljs-number">500</span>, n_jobs=<span class="hljs-number">-1</span>)rnd_clf.fit(X, y)print(rnd_clf.__class__.__name__, <span class="hljs-string">'='</span>, accuracy_score(y, y_hat))</code></pre><p>输出：</p><pre><code class="hljs ini"><span class="hljs-attr">RandomForestClassifier</span> = <span class="hljs-number">1.0</span></code></pre><h2 id="Boosting-串行"><a href="#Boosting-串行" class="headerlink" title="Boosting(串行)"></a>Boosting(串行)</h2><p>将几个弱学习器结合成一个强学习器的集成方法。大多数提升法的总体思想是循环训练预测器，每一次都对其前序做出一些改正。</p><ul><li>AdaBoost</li><li>GBDT</li><li>XGBoost</li></ul><h3 id="AdaBoost基本原理"><a href="#AdaBoost基本原理" class="headerlink" title="AdaBoost基本原理"></a>AdaBoost基本原理</h3><ul><li><p>AdaBoost：从弱学习算法出发，反复学习得到一系列弱分类器(又称基本分类器)，然后组合这些弱分类器构成一个强分类器。</p></li><li><p>要解决的两个问题：</p><p>1、每一轮如何改变训练数据的权值或概率分布：提高那些被前一轮错误分类样本的权值，降低那些被正确分类样本的权值。<br>2、如何将弱分类器组合成强分类器：加大分类误差小的弱分类器权值，减小分类误差率大的弱分类器权值。</p></li></ul><h3 id="AdaBoost算法流程"><a href="#AdaBoost算法流程" class="headerlink" title="AdaBoost算法流程"></a>AdaBoost算法流程</h3><p>（1）初始化训练数据权值分布  $D_1=(w_{11},\ldots,w_{1i},\ldots,w_{1m}),\quad w_{1i}=\frac{1}{m}$<br>（2）对于每一轮训练t=1,2,…,T<br>&emsp;&emsp;(a)使用具有权值分布<span style="color:blue">Dt</span>的训练数据集进行学习，得到基本分类器<span style="color:blue">$G_t(x)$</span><br>&emsp;&emsp;(b)计算$G_t(x)$在训练数据集上的分类误差率：</p><script type="math/tex; mode=display">e_t=\sum_{i=1}^{m}P(G_t(x^{(i)})\neq y^{(i)})=\sum_{i=1}^{m}w_{ti}I(G_t(x^{(i)}) \neq y^{(i)})</script><p>&emsp;&emsp;(c)计算$G_t(x)$的权重系数  $\alpha_t = \frac{1}{2}\log{\frac{1-e_t}{e_t}}$<br>&emsp;&emsp;(d)更新训练数据集的权重分布  $D_{t+1}=(w_{t+1,1},\ldots,w_{t+1,i},\ldots,w_{t+1,m})$<br>（3）构建基本分类器的线性组合  $w_{t+1,i}=\frac{w_{ti}}{Z_t}\exp{(-\alpha_t y^{(i)} G_t(x^{(i)}))}$，其中$Z_t$是归一化因子，$Z_t=\sum_{i=1}^{m}w_{ti}\exp{(-\alpha_t y^{(i)}) G_t(x^{(i)})}$<br>&emsp;&emsp;            $f(x)=\sum_{i=1}^{T} \alpha_t G_t(x)$   得到最终分类器   $G(x)=sign(f(x))=sign(\sum_{t=1}^{T} \alpha_t G_t(x))$</p><p><img src="/article/2bebfb2a/image-20200713150853956.png" srcset="/img/loading.gif" alt="image-20200713150853956"></p><p><img src="/article/2bebfb2a/image-20200713153247630.png" srcset="/img/loading.gif" alt="image-20200713153247630"></p><p><img src="/article/2bebfb2a/image-20200713153314897.png" srcset="/img/loading.gif" alt="image-20200713153314897"></p><h3 id="AdaBoost代码-Sklearn实现"><a href="#AdaBoost代码-Sklearn实现" class="headerlink" title="AdaBoost代码(Sklearn实现)"></a>AdaBoost代码(Sklearn实现)</h3><p><strong>代码(参数明细见<a href="https://www.cnblogs.com/pinard/p/6136914.html" target="_blank" rel="noopener">scikit-learn Adaboost类库使用小结</a>)：</strong></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeClassifier<span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> AdaBoostClassifier<span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_iris<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npdata = np.loadtxt(<span class="hljs-string">'data/wine.data'</span>,delimiter=<span class="hljs-string">','</span>)X = data[:,<span class="hljs-number">1</span>:]y = data[:,<span class="hljs-number">0</span>:<span class="hljs-number">1</span>]<span class="hljs-comment"># 对于决策树而言，归一化作用不明显，对于逻辑回归而言，归一化是比较有用的~</span><span class="hljs-comment"># from sklearn.preprocessing import StandardScaler</span><span class="hljs-comment"># X = StandardScaler().fit_transform(X)</span><span class="hljs-comment"># from sklearn.linear_model import LogisticRegression</span><span class="hljs-comment"># rf = LogisticRegression()</span>X_train,X_test,y_train,y_test = train_test_split(X,y.ravel(),train_size=<span class="hljs-number">0.8</span>,random_state=<span class="hljs-number">0</span>)<span class="hljs-comment"># 定义弱(基)分类器</span>rf = DecisionTreeClassifier()<span class="hljs-comment"># 定义AdaBoost分类器</span>model = AdaBoostClassifier(base_estimator=rf,n_estimators=<span class="hljs-number">50</span>,algorithm=<span class="hljs-string">"SAMME.R"</span>, learning_rate=<span class="hljs-number">0.5</span>)model.fit(X_train,y_train)<span class="hljs-comment">#AdaBoostClassifier(algorithm='SAMME.R',</span><span class="hljs-comment">#                   base_estimator=DecisionTreeClassifier(ccp_alpha=0.0,</span><span class="hljs-comment">#                                                         class_weight=None,</span><span class="hljs-comment">#                                                         criterion='gini',</span><span class="hljs-comment">#                                                         max_depth=None,</span><span class="hljs-comment">#                                                         max_features=None,</span><span class="hljs-comment">#                                                         max_leaf_nodes=None,</span><span class="hljs-comment">#                                                         min_impurity_decrease=0.0,</span><span class="hljs-comment">#                                                         min_impurity_split=None,</span><span class="hljs-comment">#                                                         min_samples_leaf=1,</span><span class="hljs-comment">#                                                         min_samples_split=2,</span><span class="hljs-comment">#                                                         min_weight_fraction_leaf=0.0,</span><span class="hljs-comment">#                                                         presort='deprecated',</span><span class="hljs-comment">#                                                         random_state=None,</span><span class="hljs-comment">#                                                         splitter='best'),</span><span class="hljs-comment">#                   learning_rate=0.5, n_estimators=50, random_state=None)</span>y_train_hat = model.predict(X_train)print(<span class="hljs-string">"train accuarcy:"</span>,accuracy_score(y_train,y_train_hat))y_test_hat = model.predict(X_test)print(<span class="hljs-string">"test accuarcy:"</span>, accuracy_score(y_test, y_test_hat))</code></pre><p>输出：</p><pre><code class="hljs subunit">train accuarcy: 1.0<span class="hljs-keyword">test </span>accuarcy: 0.9722222222222222</code></pre><hr><h3 id="梯度提升-Gradient-Boosting-Tree"><a href="#梯度提升-Gradient-Boosting-Tree" class="headerlink" title="梯度提升(Gradient Boosting Tree)"></a>梯度提升(Gradient Boosting Tree)</h3><p>与AdaBoost类似，梯度提升也是逐步在集成中添加预测器，与AdaBoost类似，梯度提升也是在继承中添加预测器，每一个都对其前序做出改正。不同之处在于，它不是像AdaBoost那样在每个迭代中调整实例权重，而是<strong>让新的预测器针对前一个预测器的残差进行拟合</strong>。</p><p>提升树种每一颗树学的是之前所有树结论累积的残差。残差就是真实值和预测值的差值。如A的真实年龄是18，第一棵树预测年龄是12岁，则残差值为6.接下来在第二颗树把A的年龄当初6岁去学习，如果第二棵树能把A分到6岁的叶子节点，那累加两颗树的结论就是A的真实年龄；如果第二棵树的结论是5岁，则A仍然存在1岁的残差，第三棵树把A的年龄当成1岁，继续学。最后，所有树的累加值就是最终预测值。<br>提升树算法<br>（1）初始化$f_0(x)=0$<br>（2）对m=1,2,…,M<br>&emsp;&emsp;(a) 计算残差  $r_{mi}=y_i-f_{m-1}(x_i)$<br>&emsp;&emsp;(b) 拟合残差 $r_{mi}$ 学习一个回归树 $T(x;\Theta_m)$<br>&emsp;&emsp;(c) 更新  $f_m(x)=f_{m-1}(x)+T(x;\Theta_m)$<br>（3）得到提升树   $f_M(x)=\sum_{i=1}^{M}T(x;\Theta_m)$</p><p><strong>代码(预测一维数据的结果)：</strong></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.tree <span class="hljs-keyword">import</span> DecisionTreeRegressor<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> GradientBoostingRegressor<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loaddata</span><span class="hljs-params">()</span>:</span>    data = np.loadtxt(<span class="hljs-string">'data/data.txt'</span>,delimiter=<span class="hljs-string">','</span>)    n = data.shape[<span class="hljs-number">1</span>]<span class="hljs-number">-1</span> <span class="hljs-comment">#特征数</span>    X = data[:,<span class="hljs-number">0</span>:n]    y = data[:,<span class="hljs-number">-1</span>].reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)    <span class="hljs-keyword">return</span> X,yX,y = loaddata()plt.scatter(X,y)</code></pre><p><img src="/article/2bebfb2a/输出1.png" srcset="/img/loading.gif" alt="输出1"></p><p>1）根据算法原理手动实现(使用决策树回归DesicionTreeRegressor)</p><pre><code class="hljs python"><span class="hljs-comment"># 1、定义第一课树(最大深度设定为5)，并进行训练</span>tree_reg1 = DecisionTreeRegressor(max_depth=<span class="hljs-number">5</span>)tree_reg1.fit(X, y)<span class="hljs-comment">#DecisionTreeRegressor(criterion='mse', max_depth=5, max_features=None,</span><span class="hljs-comment">#                      max_leaf_nodes=None, min_impurity_decrease=0.0,</span><span class="hljs-comment">#                      min_impurity_split=None, min_samples_leaf=1,</span><span class="hljs-comment">#                      min_samples_split=2, min_weight_fraction_leaf=0.0,</span><span class="hljs-comment">#                      presort=False, random_state=None, splitter='best')</span><span class="hljs-comment"># 2、计算残差，并把残差当做目标值训练第二棵树(最大深度设定为5)</span>y2 = y - tree_reg1.predict(X).reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)tree_reg2 = DecisionTreeRegressor(max_depth=<span class="hljs-number">5</span>)tree_reg2.fit(X, y2)<span class="hljs-comment"># 3、继续计算残差，并把残差当做目标值训练第三棵树(最大深度设定为5)</span>y3 = y2 - tree_reg2.predict(X).reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)tree_reg3 = DecisionTreeRegressor(max_depth=<span class="hljs-number">5</span>)tree_reg3.fit(X, y3)<span class="hljs-comment"># 4、测试</span><span class="hljs-comment"># 取训练集前5条数据，并对前5条数据做预测</span>X_new = X[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>,]y_pred = sum(tree.predict(X_new) <span class="hljs-keyword">for</span> tree <span class="hljs-keyword">in</span> (tree_reg1, tree_reg2, tree_reg3))print(y_pred)</code></pre><p>输出;</p><pre><code class="hljs angelscript">[<span class="hljs-number">17.61560196</span>  <span class="hljs-number">9.15380196</span> <span class="hljs-number">12.831</span>       <span class="hljs-number">4.57199973</span>  <span class="hljs-number">6.68971688</span>]</code></pre><p>2）直接使用sklearn提供的GradientBoostingRegressor</p><pre><code class="hljs python">gbrt = GradientBoostingRegressor(max_depth=<span class="hljs-number">5</span>, n_estimators=<span class="hljs-number">3</span>, learning_rate=<span class="hljs-number">1.0</span>)gbrt.fit(X, y)print(gbrt.predict(X_new))</code></pre><p>输出：</p><pre><code class="hljs angelscript">[<span class="hljs-number">17.61560196</span>  <span class="hljs-number">9.15380196</span> <span class="hljs-number">12.831</span>       <span class="hljs-number">4.57199973</span>  <span class="hljs-number">6.68971688</span>]</code></pre><h3 id="梯度提升树-Gradient-Boosting-Tree"><a href="#梯度提升树-Gradient-Boosting-Tree" class="headerlink" title="梯度提升树(Gradient Boosting Tree)"></a>梯度提升树(Gradient Boosting Tree)</h3><p>上例中使用的平方损失：$L(y, f_t(x))=\frac{1}{2}(y-f_t(x))^2$<br>其负梯度为：$-\frac{\partial L(y,f_t(x))}{\partial f_t(x)}=y-f_t(x)$该负梯度就是残差。</p><ul><li>平方损失拟合残差值</li><li>非平方损失拟合负梯度值</li></ul><p><span style="color:blue">GBDT：其关键是利用损失函数的负梯度作为提升树算法中要拟合的值。</span></p><h3 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h3><p><img src="/article/2bebfb2a/image-20200713173830276.png" srcset="/img/loading.gif" alt="image-20200713173830276"></p><p>q表示树结构，q把每一个样本点x映射到某一个叶子节点。<br>T是叶子节点的数量<br>w是叶子节点的权值(实际就是预测值)<br>$f_k$表示第k个树，该树的结构由q表示，预测值由w表示。<br>预测值表示为：</p><center><img src="/article/2bebfb2a/image-20200713174532589.png" srcset="/img/loading.gif" width="400" hight="200"></center><p>或：</p><center><img src="/article/2bebfb2a/image-20200713174835308.png" srcset="/img/loading.gif" width="400" hight="200"></center><h4 id="XGBoost损失函数-Loss-function-of-XGBoost"><a href="#XGBoost损失函数-Loss-function-of-XGBoost" class="headerlink" title="XGBoost损失函数(Loss function of XGBoost)"></a>XGBoost损失函数(Loss function of XGBoost)</h4><center><img src="/article/2bebfb2a/image-20200713174532589.png" srcset="/img/loading.gif" width="400" hight="200"></center><p>假设损失函数是平方损失，则初值可取所有样本的平均数。</p><left><img src="/article/2bebfb2a/image-20200713175405736.png" srcset="/img/loading.gif" width="400" hight="450"></left><p>因此损失函数可写为：</p><center><img src="/article/2bebfb2a/image-20200713180755125.png" srcset="/img/loading.gif" width="400" hight="200"></center><p>橙框中为正则项，C为常数项。</p><center><img src="/article/2bebfb2a/image-20200713181458963.png" srcset="/img/loading.gif"></center><p>例子：</p><p><img src="/article/2bebfb2a/image-20200713181511123.png" srcset="/img/loading.gif" alt="image-20200713181511123"></p><p>其中$\Omega=\gamma \times 3 + \frac{1}{2} \lambda (4+0.01 + 1)$</p><h4 id="XGBoost求解-XGBoost-solution"><a href="#XGBoost求解-XGBoost-solution" class="headerlink" title="XGBoost求解(XGBoost solution)"></a>XGBoost求解(XGBoost solution)</h4><p>目标函数：</p><center><img src="/article/2bebfb2a/image-20200713213336955.png" srcset="/img/loading.gif" width="400" hight="200"></center><p>根据Taylor公式：</p><center><img src="/article/2bebfb2a/image-20200713215352667.png" srcset="/img/loading.gif" width="400" hight="200"></center><p>令：</p><center><img src="/article/2bebfb2a/image-20200713215517498.png" srcset="/img/loading.gif" width="400" hight="200"></center><p>得：</p><center><img src="/article/2bebfb2a/image-20200713215547591.png" srcset="/img/loading.gif" width="500" hight="250"></center><p>对上式求解：</p><center><img src="/article/2bebfb2a/image-20200713215739357.png" srcset="/img/loading.gif" width="550" hight="300"></center><p>对于</p><center><img src="/article/2bebfb2a/image-20200713222203209.png" srcset="/img/loading.gif" width="450" hight="250"></center><p>令：</p><center><img src="/article/2bebfb2a/image-20200713222403711.png" srcset="/img/loading.gif" width="250" hight="250"></center><p>得：</p><center><img src="/article/2bebfb2a/image-20200713222517216.png" srcset="/img/loading.gif" width="350" hight="250"></center><p>对w求偏导：</p><center><img src="/article/2bebfb2a/image-20200713222611532.png" srcset="/img/loading.gif" width="400" hight="250"></center><p>代入上一步的目标函数$J(f_t)$得：</p><center><img src="/article/2bebfb2a/image-20200713222949320.png" srcset="/img/loading.gif" width="250" hight="250"></center><h4 id="XGBoost中树结构的生成"><a href="#XGBoost中树结构的生成" class="headerlink" title="XGBoost中树结构的生成"></a>XGBoost中树结构的生成</h4><p><img src="/article/2bebfb2a/image-20200713224002458.png" srcset="/img/loading.gif" alt="image-20200713224002458"></p><ul><li>构造决策树的结构：枚举可行的分割点，选择增益最大的划分</li></ul><p><img src="/article/2bebfb2a/image-20200713224803648.png" srcset="/img/loading.gif" alt="image-20200713224803648"></p><h5 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h5><p>sklearn并没有集成xgboost，使用前需安装 命令:pip install xgboost</p><h6 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h6><p>XGBoost中数据形式可以是libsvm的，libsvm作用是对稀疏特征进行优化，看个例子：<br>1 101:1.2 102:0.03<br>0 1:2.1 10001:300 10002:400<br>0 2:1.2 1212:21 7777:2<br>每行表示一个样本，每行开头0，1表示标签，而后面的则是特征索引：数值，其他未表示都是0.</p><p>我们以判断蘑菇是否有毒为例子来做后续的训练。数据集来自：<a href="http://archive.ics.uci.edu/ml/machine-learning-databases/mushroom/" target="_blank" rel="noopener">http://archive.ics.uci.edu/ml/machine-learning-databases/mushroom/</a> ，其中蘑菇有22个属性，将这些原始的特征加工后得到126维特征，并保存为libsvm格式，标签是表示蘑菇是否有毒。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> xgboost <span class="hljs-keyword">as</span> xgbdata_train = xgb.DMatrix(<span class="hljs-string">'data/agaricus.txt.train'</span>)data_test = xgb.DMatrix(<span class="hljs-string">'data/agaricus.txt.test'</span>)</code></pre><h6 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h6><ul><li><p>eta：可看成学习率learning_rate。典型值一般设置为：0.01-0.2</p></li><li><p>gamma：分裂节点时，损失函数减小值只有大于等于gamma才分裂，gamma值越大，算法越保守，越不容易过拟合，但性能就不一定能保证，需要平衡。</p></li><li><p>objective</p><ul><li>reg:linear：线性回归</li><li>reg:logistic：逻辑回归</li><li>binary:logistic 二分类的逻辑回归，返回预测的概率</li><li>binary:logitraw：二分类逻辑回归，输出是逻辑为0/1的前一步的分数</li><li>multi:softmax：用于Xgboost 做多分类问题，需要设置num_class（分类的个数）</li><li>multi:softprob：和softmax一样，但是返回的是每个数据属于各个类别的概率。</li><li>rank:pairwise：让Xgboost 做排名任务，通过最小化(Learn to rank的一种方法)</li></ul></li><li><p>max_depth：决策树最大深度</p></li><li><p>silent：0 (silent), 1 (warning), 2 (info), 3 (debug)</p><p>更多参数参见：<a href="https://xgboost.readthedocs.io/en/latest/parameter.html" target="_blank" rel="noopener">https://xgboost.readthedocs.io/en/latest/parameter.html</a></p></li></ul><pre><code class="hljs python">param = &#123;<span class="hljs-string">'max_depth'</span>: <span class="hljs-number">3</span>, <span class="hljs-string">'eta'</span>: <span class="hljs-number">0.3</span>, <span class="hljs-string">'objective'</span>: <span class="hljs-string">'binary:logistic'</span>&#125;watchlist = [(data_test, <span class="hljs-string">'eval'</span>), (data_train, <span class="hljs-string">'train'</span>)]n_round = <span class="hljs-number">6</span>model = xgb.train(param, data_train, num_boost_round=n_round, evals=watchlist)</code></pre><h6 id="计算准确率"><a href="#计算准确率" class="headerlink" title="计算准确率"></a>计算准确率</h6><pre><code class="hljs python">y_hat = model.predict(data_test)y_pred = y_hat.copy()y_pred[y_hat&gt;=<span class="hljs-number">0.5</span>]=<span class="hljs-number">1</span>y_pred[y_hat&lt;<span class="hljs-number">0.5</span>]=<span class="hljs-number">0</span>y = data_test.get_label()<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_scoreprint(<span class="hljs-string">'accuracy_score='</span>,accuracy_score(y,y_pred))</code></pre><p>输出：</p><pre><code class="hljs ini"><span class="hljs-attr">accuracy_score</span>= <span class="hljs-number">1.0</span></code></pre><h6 id="查看-0-5-颗决策树"><a href="#查看-0-5-颗决策树" class="headerlink" title="查看[0-5]颗决策树"></a>查看[0-5]颗决策树</h6><pre><code class="hljs python"><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot<span class="hljs-keyword">import</span> graphvizxgb.to_graphviz(model, num_trees=<span class="hljs-number">1</span>) <span class="hljs-comment"># 以第二颗为例</span></code></pre><p><img src="/article/2bebfb2a/输出2.png" srcset="/img/loading.gif" alt></p><h5 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h5><p>(写法不同)</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> xgboost <span class="hljs-keyword">as</span> xgb<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-comment"># 读取数据(把libsvm格式读取成以前我们常用的二维数组形式)</span><span class="hljs-keyword">from</span> sklearn.datasets <span class="hljs-keyword">import</span> load_svmlight_file<span class="hljs-comment">#data_train = xgb.DMatrix('data/agaricus.txt.train')</span><span class="hljs-comment">#data_test = xgb.DMatrix('data/agaricus.txt.test')</span>X_train,y_train = load_svmlight_file(<span class="hljs-string">'data/agaricus.txt.train'</span>)X_test,y_test = load_svmlight_file(<span class="hljs-string">'data/agaricus.txt.test'</span>)<span class="hljs-comment"># 把稀疏数组转换为稠密数组</span>X_train.toarray().shape<span class="hljs-comment"># (6513, 126)</span><span class="hljs-comment"># 设置参数</span>model =xgb.XGBClassifier(max_depth=<span class="hljs-number">2</span>, learning_rate=<span class="hljs-number">1</span>, n_estimators=<span class="hljs-number">6</span>, objective=<span class="hljs-string">'binary:logistic'</span>)model.fit(X_train, y_train)<span class="hljs-comment"># 计算准确率</span><span class="hljs-comment"># 训练集上准确率</span>train_preds = model.predict(X_train)train_predictions = [round(value) <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> train_preds]train_accuracy = accuracy_score(y_train, train_predictions)<span class="hljs-keyword">print</span> (<span class="hljs-string">"Train Accuary: %.2f%%"</span> % (train_accuracy * <span class="hljs-number">100.0</span>))<span class="hljs-comment"># 测试集上准确率</span><span class="hljs-comment"># make prediction</span>preds = model.predict(X_test)predictions = [round(value) <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> preds]test_accuracy = accuracy_score(y_test, predictions)print(<span class="hljs-string">"Test Accuracy: %.2f%%"</span> % (test_accuracy * <span class="hljs-number">100.0</span>))</code></pre><p>输出：</p><pre><code class="hljs subunit">Train Accuary: 99.88%<span class="hljs-keyword">Test </span>Accuracy: 100.00%</code></pre><h6 id="GridSearchcv搜索最优参数"><a href="#GridSearchcv搜索最优参数" class="headerlink" title="GridSearchcv搜索最优参数"></a>GridSearchcv搜索最优参数</h6><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCVmodel = xgb.XGBClassifier(learning_rate=<span class="hljs-number">0.1</span>, objective=<span class="hljs-string">'binary:logistic'</span>)param_grid = &#123; <span class="hljs-string">'n_estimators'</span>: range(<span class="hljs-number">1</span>, <span class="hljs-number">51</span>, <span class="hljs-number">1</span>), <span class="hljs-string">'max_depth'</span>:range(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1</span>)&#125;clf = GridSearchCV(model, param_grid, <span class="hljs-string">"accuracy"</span>,cv=<span class="hljs-number">5</span>)clf.fit(X_train, y_train)print(clf.best_params_, clf.best_score_)</code></pre><p>输出：</p><pre><code class="hljs scheme">(&#123;<span class="hljs-symbol">'max_depth</span><span class="hljs-symbol">':</span> <span class="hljs-number">2</span>, <span class="hljs-symbol">'n_estimators</span><span class="hljs-symbol">':</span> <span class="hljs-number">30</span>&#125;, <span class="hljs-number">0.9841860859908541</span>)</code></pre><h6 id="early-stop"><a href="#early-stop" class="headerlink" title="early-stop"></a>early-stop</h6><p>设置验证valid集，迭代过程中发现在验证集上错误率增加，则提前停止迭代。</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_splitX_train_part, X_validate, y_train_part, y_validate = train_test_split(X_train, y_train, test_size=<span class="hljs-number">0.3</span>,random_state=<span class="hljs-number">0</span>)<span class="hljs-comment"># 设置boosting迭代计算次数</span>num_round = <span class="hljs-number">100</span>bst =xgb.XGBClassifier(max_depth=<span class="hljs-number">2</span>, learning_rate=<span class="hljs-number">0.1</span>, n_estimators=num_round, objective=<span class="hljs-string">'binary:logistic'</span>)eval_set =[(X_validate, y_validate)]<span class="hljs-comment"># early_stopping_rounds：连续x次在验证集的错误率均不变或上升时即停止。</span>bst.fit(X_train_part, y_train_part, early_stopping_rounds=<span class="hljs-number">10</span>, eval_metric=<span class="hljs-string">"error"</span>, eval_set=eval_set, verbose=<span class="hljs-literal">True</span>)</code></pre><p>输出：</p><pre><code class="hljs vbnet">[<span class="hljs-number">0</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.04862</span>Will train <span class="hljs-keyword">until</span> validation_0-<span class="hljs-keyword">error</span> hasn<span class="hljs-comment">'t improved in 10 rounds.</span>[<span class="hljs-number">1</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.04299</span>[<span class="hljs-number">2</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.04862</span>[<span class="hljs-number">3</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.04299</span>[<span class="hljs-number">4</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.04862</span>[<span class="hljs-number">5</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.04862</span>[<span class="hljs-number">6</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.04299</span>[<span class="hljs-number">7</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.04299</span>[<span class="hljs-number">8</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.04299</span>[<span class="hljs-number">9</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.04299</span>[<span class="hljs-number">10</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.04299</span>[<span class="hljs-number">11</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.02405</span>[<span class="hljs-number">12</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.02968</span>[<span class="hljs-number">13</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.01945</span>[<span class="hljs-number">14</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.01945</span>[<span class="hljs-number">15</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.01945</span>[<span class="hljs-number">16</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.01945</span>[<span class="hljs-number">17</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.01945</span>[<span class="hljs-number">18</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.01945</span>[<span class="hljs-number">19</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.01945</span>[<span class="hljs-number">20</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.01945</span>[<span class="hljs-number">21</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.02661</span>[<span class="hljs-number">22</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.02354</span>[<span class="hljs-number">23</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.02354</span>Stopping. Best iteration:[<span class="hljs-number">13</span>]validation_0-<span class="hljs-keyword">error</span>:<span class="hljs-number">0.01945</span></code></pre><p>Out[13]:</p><pre><code class="hljs routeros">XGBClassifier(<span class="hljs-attribute">base_score</span>=0.5, <span class="hljs-attribute">booster</span>=<span class="hljs-string">'gbtree'</span>, <span class="hljs-attribute">colsample_bylevel</span>=1,              <span class="hljs-attribute">colsample_bynode</span>=1, <span class="hljs-attribute">colsample_bytree</span>=1, <span class="hljs-attribute">gamma</span>=0, <span class="hljs-attribute">gpu_id</span>=-1,              <span class="hljs-attribute">importance_type</span>=<span class="hljs-string">'gain'</span>, <span class="hljs-attribute">interaction_constraints</span>=<span class="hljs-string">''</span>,              <span class="hljs-attribute">learning_rate</span>=0.1, <span class="hljs-attribute">max_delta_step</span>=0, <span class="hljs-attribute">max_depth</span>=2,              <span class="hljs-attribute">min_child_weight</span>=1, <span class="hljs-attribute">missing</span>=nan, <span class="hljs-attribute">monotone_constraints</span>=<span class="hljs-string">'()'</span>,              <span class="hljs-attribute">n_estimators</span>=100, <span class="hljs-attribute">n_jobs</span>=0, <span class="hljs-attribute">num_parallel_tree</span>=1,              <span class="hljs-attribute">objective</span>=<span class="hljs-string">'binary:logistic'</span>, <span class="hljs-attribute">random_state</span>=0, <span class="hljs-attribute">reg_alpha</span>=0,              <span class="hljs-attribute">reg_lambda</span>=1, <span class="hljs-attribute">scale_pos_weight</span>=1, <span class="hljs-attribute">subsample</span>=1,              <span class="hljs-attribute">tree_method</span>=<span class="hljs-string">'exact'</span>, <span class="hljs-attribute">validate_parameters</span>=1, <span class="hljs-attribute">verbosity</span>=None)</code></pre><p>将错误率可视化，进行更直观的观察。</p><pre><code class="hljs markdown">results = bst.evals_result()epochs = len(results[<span class="hljs-string">'validation_0'</span>][<span class="hljs-symbol">'error'</span>])x_axis = range(0, epochs)<span class="hljs-section"># plot log loss</span>plt.plot(x<span class="hljs-emphasis">_axis, results['validation_</span>0']['error'], label='Test')plt.ylabel('Error')plt.xlabel('Round')plt.title('XGBoost Early Stop')plt.show()</code></pre><p><img src="/article/2bebfb2a/输出3.png" srcset="/img/loading.gif" alt="输出3"></p><h6 id="可视化学习曲线"><a href="#可视化学习曲线" class="headerlink" title="可视化学习曲线"></a>可视化学习曲线</h6><p>训练</p><pre><code class="hljs python"><span class="hljs-comment"># 设置boosting迭代计算次数</span>num_round = <span class="hljs-number">100</span><span class="hljs-comment"># 没有 eraly_stop</span>bst =xgb.XGBClassifier(max_depth=<span class="hljs-number">2</span>, learning_rate=<span class="hljs-number">0.1</span>, n_estimators=num_round, silent=<span class="hljs-literal">True</span>, objective=<span class="hljs-string">'binary:logistic'</span>) eval_set = [(X_train_part, y_train_part), (X_validate, y_validate)]bst.fit(X_train_part, y_train_part, eval_metric=[<span class="hljs-string">"error"</span>, <span class="hljs-string">"logloss"</span>], eval_set=eval_set, verbose=<span class="hljs-literal">True</span>)</code></pre><p>输出：</p><pre><code class="hljs angelscript">[<span class="hljs-number">0</span>]validation_0-error:<span class="hljs-number">0.04562</span>validation_0-logloss:<span class="hljs-number">0.61466</span>validation_1-error:<span class="hljs-number">0.04862</span>validation_1-logloss:<span class="hljs-number">0.61509</span>[<span class="hljs-number">1</span>]validation_0-error:<span class="hljs-number">0.04102</span>validation_0-logloss:<span class="hljs-number">0.55002</span>validation_1-error:<span class="hljs-number">0.04299</span>validation_1-logloss:<span class="hljs-number">0.55021</span>[<span class="hljs-number">2</span>]validation_0-error:<span class="hljs-number">0.04562</span>validation_0-logloss:<span class="hljs-number">0.49553</span>validation_1-error:<span class="hljs-number">0.04862</span>validation_1-logloss:<span class="hljs-number">0.49615</span>[<span class="hljs-number">3</span>]validation_0-error:<span class="hljs-number">0.04102</span>validation_0-logloss:<span class="hljs-number">0.44924</span>validation_1-error:<span class="hljs-number">0.04299</span>validation_1-logloss:<span class="hljs-number">0.44970</span>[<span class="hljs-number">4</span>]validation_0-error:<span class="hljs-number">0.04562</span>validation_0-logloss:<span class="hljs-number">0.40965</span>validation_1-error:<span class="hljs-number">0.04862</span>validation_1-logloss:<span class="hljs-number">0.41051</span>[<span class="hljs-number">5</span>]validation_0-error:<span class="hljs-number">0.04562</span>validation_0-logloss:<span class="hljs-number">0.37502</span>validation_1-error:<span class="hljs-number">0.04862</span>validation_1-logloss:<span class="hljs-number">0.37527</span>[<span class="hljs-number">6</span>]validation_0-error:<span class="hljs-number">0.04102</span>validation_0-logloss:<span class="hljs-number">0.34374</span>validation_1-error:<span class="hljs-number">0.04299</span>validation_1-logloss:<span class="hljs-number">0.34409</span>[<span class="hljs-number">7</span>]validation_0-error:<span class="hljs-number">0.04102</span>validation_0-logloss:<span class="hljs-number">0.31648</span>validation_1-error:<span class="hljs-number">0.04299</span>validation_1-logloss:<span class="hljs-number">0.31680</span>[<span class="hljs-number">8</span>]validation_0-error:<span class="hljs-number">0.04102</span>validation_0-logloss:<span class="hljs-number">0.29229</span>validation_1-error:<span class="hljs-number">0.04299</span>validation_1-logloss:<span class="hljs-number">0.29217</span>[<span class="hljs-number">9</span>]validation_0-error:<span class="hljs-number">0.04102</span>validation_0-logloss:<span class="hljs-number">0.27028</span>validation_1-error:<span class="hljs-number">0.04299</span>validation_1-logloss:<span class="hljs-number">0.27031</span>[<span class="hljs-number">10</span>]validation_0-error:<span class="hljs-number">0.04102</span>validation_0-logloss:<span class="hljs-number">0.25084</span>validation_1-error:<span class="hljs-number">0.04299</span>validation_1-logloss:<span class="hljs-number">0.25075</span>[<span class="hljs-number">11</span>]validation_0-error:<span class="hljs-number">0.02303</span>validation_0-logloss:<span class="hljs-number">0.23349</span>validation_1-error:<span class="hljs-number">0.02405</span>validation_1-logloss:<span class="hljs-number">0.23322</span>[<span class="hljs-number">12</span>]validation_0-error:<span class="hljs-number">0.02895</span>validation_0-logloss:<span class="hljs-number">0.21413</span>validation_1-error:<span class="hljs-number">0.02968</span>validation_1-logloss:<span class="hljs-number">0.21411</span>[<span class="hljs-number">13</span>]validation_0-error:<span class="hljs-number">0.01645</span>validation_0-logloss:<span class="hljs-number">0.19726</span>validation_1-error:<span class="hljs-number">0.01945</span>validation_1-logloss:<span class="hljs-number">0.19747</span>[<span class="hljs-number">14</span>]validation_0-error:<span class="hljs-number">0.01645</span>validation_0-logloss:<span class="hljs-number">0.18254</span>validation_1-error:<span class="hljs-number">0.01945</span>validation_1-logloss:<span class="hljs-number">0.18296</span>[<span class="hljs-number">15</span>]validation_0-error:<span class="hljs-number">0.01645</span>validation_0-logloss:<span class="hljs-number">0.16969</span>validation_1-error:<span class="hljs-number">0.01945</span>validation_1-logloss:<span class="hljs-number">0.17029</span>[<span class="hljs-number">16</span>]validation_0-error:<span class="hljs-number">0.01645</span>validation_0-logloss:<span class="hljs-number">0.15845</span>validation_1-error:<span class="hljs-number">0.01945</span>validation_1-logloss:<span class="hljs-number">0.15923</span>[<span class="hljs-number">17</span>]validation_0-error:<span class="hljs-number">0.01645</span>validation_0-logloss:<span class="hljs-number">0.14999</span>validation_1-error:<span class="hljs-number">0.01945</span>validation_1-logloss:<span class="hljs-number">0.15106</span>[<span class="hljs-number">18</span>]validation_0-error:<span class="hljs-number">0.01645</span>validation_0-logloss:<span class="hljs-number">0.14108</span>validation_1-error:<span class="hljs-number">0.01945</span>validation_1-logloss:<span class="hljs-number">0.14227</span>[<span class="hljs-number">19</span>]validation_0-error:<span class="hljs-number">0.01645</span>validation_0-logloss:<span class="hljs-number">0.13417</span>validation_1-error:<span class="hljs-number">0.01945</span>validation_1-logloss:<span class="hljs-number">0.13544</span>[<span class="hljs-number">20</span>]validation_0-error:<span class="hljs-number">0.01645</span>validation_0-logloss:<span class="hljs-number">0.12691</span>validation_1-error:<span class="hljs-number">0.01945</span>validation_1-logloss:<span class="hljs-number">0.12827</span>[<span class="hljs-number">21</span>]validation_0-error:<span class="hljs-number">0.02500</span>validation_0-logloss:<span class="hljs-number">0.12055</span>validation_1-error:<span class="hljs-number">0.02661</span>validation_1-logloss:<span class="hljs-number">0.12199</span>[<span class="hljs-number">22</span>]validation_0-error:<span class="hljs-number">0.02062</span>validation_0-logloss:<span class="hljs-number">0.11535</span>validation_1-error:<span class="hljs-number">0.02354</span>validation_1-logloss:<span class="hljs-number">0.11683</span>[<span class="hljs-number">23</span>]validation_0-error:<span class="hljs-number">0.02062</span>validation_0-logloss:<span class="hljs-number">0.11015</span>validation_1-error:<span class="hljs-number">0.02354</span>validation_1-logloss:<span class="hljs-number">0.11169</span>[<span class="hljs-number">24</span>]validation_0-error:<span class="hljs-number">0.02062</span>validation_0-logloss:<span class="hljs-number">0.10586</span>validation_1-error:<span class="hljs-number">0.02354</span>validation_1-logloss:<span class="hljs-number">0.10725</span>[<span class="hljs-number">25</span>]validation_0-error:<span class="hljs-number">0.02062</span>validation_0-logloss:<span class="hljs-number">0.10196</span>validation_1-error:<span class="hljs-number">0.02354</span>validation_1-logloss:<span class="hljs-number">0.10337</span>[<span class="hljs-number">26</span>]validation_0-error:<span class="hljs-number">0.02062</span>validation_0-logloss:<span class="hljs-number">0.09799</span>validation_1-error:<span class="hljs-number">0.02354</span>validation_1-logloss:<span class="hljs-number">0.09945</span>[<span class="hljs-number">27</span>]validation_0-error:<span class="hljs-number">0.02062</span>validation_0-logloss:<span class="hljs-number">0.09453</span>validation_1-error:<span class="hljs-number">0.02354</span>validation_1-logloss:<span class="hljs-number">0.09620</span>[<span class="hljs-number">28</span>]validation_0-error:<span class="hljs-number">0.02062</span>validation_0-logloss:<span class="hljs-number">0.09112</span>validation_1-error:<span class="hljs-number">0.02354</span>validation_1-logloss:<span class="hljs-number">0.09283</span>[<span class="hljs-number">29</span>]validation_0-error:<span class="hljs-number">0.02062</span>validation_0-logloss:<span class="hljs-number">0.08809</span>validation_1-error:<span class="hljs-number">0.02354</span>validation_1-logloss:<span class="hljs-number">0.08991</span>[<span class="hljs-number">30</span>]validation_0-error:<span class="hljs-number">0.02062</span>validation_0-logloss:<span class="hljs-number">0.08521</span>validation_1-error:<span class="hljs-number">0.02354</span>validation_1-logloss:<span class="hljs-number">0.08693</span>[<span class="hljs-number">31</span>]validation_0-error:<span class="hljs-number">0.02062</span>validation_0-logloss:<span class="hljs-number">0.08188</span>validation_1-error:<span class="hljs-number">0.02354</span>validation_1-logloss:<span class="hljs-number">0.08324</span>[<span class="hljs-number">32</span>]validation_0-error:<span class="hljs-number">0.02062</span>validation_0-logloss:<span class="hljs-number">0.07883</span>validation_1-error:<span class="hljs-number">0.02354</span>validation_1-logloss:<span class="hljs-number">0.08027</span>[<span class="hljs-number">33</span>]validation_0-error:<span class="hljs-number">0.02062</span>validation_0-logloss:<span class="hljs-number">0.07606</span>validation_1-error:<span class="hljs-number">0.02354</span>validation_1-logloss:<span class="hljs-number">0.07722</span>[<span class="hljs-number">34</span>]validation_0-error:<span class="hljs-number">0.02062</span>validation_0-logloss:<span class="hljs-number">0.07349</span>validation_1-error:<span class="hljs-number">0.02354</span>validation_1-logloss:<span class="hljs-number">0.07491</span>[<span class="hljs-number">35</span>]validation_0-error:<span class="hljs-number">0.02062</span>validation_0-logloss:<span class="hljs-number">0.07078</span>validation_1-error:<span class="hljs-number">0.02354</span>validation_1-logloss:<span class="hljs-number">0.07213</span>[<span class="hljs-number">36</span>]validation_0-error:<span class="hljs-number">0.01470</span>validation_0-logloss:<span class="hljs-number">0.06844</span>validation_1-error:<span class="hljs-number">0.01791</span>validation_1-logloss:<span class="hljs-number">0.06985</span>[<span class="hljs-number">37</span>]validation_0-error:<span class="hljs-number">0.01009</span>validation_0-logloss:<span class="hljs-number">0.06620</span>validation_1-error:<span class="hljs-number">0.01023</span>validation_1-logloss:<span class="hljs-number">0.06742</span>[<span class="hljs-number">38</span>]validation_0-error:<span class="hljs-number">0.01470</span>validation_0-logloss:<span class="hljs-number">0.06400</span>validation_1-error:<span class="hljs-number">0.01791</span>validation_1-logloss:<span class="hljs-number">0.06544</span>[<span class="hljs-number">39</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.06188</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.06349</span>[<span class="hljs-number">40</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.05988</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.06132</span>[<span class="hljs-number">41</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.05798</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.05936</span>[<span class="hljs-number">42</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.05621</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.05774</span>[<span class="hljs-number">43</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.05441</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.05600</span>[<span class="hljs-number">44</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.05274</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.05426</span>[<span class="hljs-number">45</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.05121</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.05266</span>[<span class="hljs-number">46</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.04972</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.05131</span>[<span class="hljs-number">47</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.04820</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.04985</span>[<span class="hljs-number">48</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.04680</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.04838</span>[<span class="hljs-number">49</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.04552</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.04715</span>[<span class="hljs-number">50</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.04423</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.04583</span>[<span class="hljs-number">51</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.04302</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.04456</span>[<span class="hljs-number">52</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.04190</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.04358</span>[<span class="hljs-number">53</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.04072</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.04234</span>[<span class="hljs-number">54</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.03967</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.04134</span>[<span class="hljs-number">55</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.03866</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.04027</span>[<span class="hljs-number">56</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.03766</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.03940</span>[<span class="hljs-number">57</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.03663</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.03849</span>[<span class="hljs-number">58</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.03569</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.03751</span>[<span class="hljs-number">59</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.03482</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.03658</span>[<span class="hljs-number">60</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.03393</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.03581</span>[<span class="hljs-number">61</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.03272</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.03450</span>[<span class="hljs-number">62</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.03192</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.03367</span>[<span class="hljs-number">63</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.03116</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.03295</span>[<span class="hljs-number">64</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.03041</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.03216</span>[<span class="hljs-number">65</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02968</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.03140</span>[<span class="hljs-number">66</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02901</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.03079</span>[<span class="hljs-number">67</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02834</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.03017</span>[<span class="hljs-number">68</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02771</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02948</span>[<span class="hljs-number">69</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02708</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02896</span>[<span class="hljs-number">70</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02646</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02834</span>[<span class="hljs-number">71</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02589</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02773</span>[<span class="hljs-number">72</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02533</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02712</span>[<span class="hljs-number">73</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02479</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02663</span>[<span class="hljs-number">74</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02427</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02600</span>[<span class="hljs-number">75</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02376</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02553</span>[<span class="hljs-number">76</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02327</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02512</span>[<span class="hljs-number">77</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02278</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02461</span>[<span class="hljs-number">78</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02233</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02421</span>[<span class="hljs-number">79</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02186</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02378</span>[<span class="hljs-number">80</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02143</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02330</span>[<span class="hljs-number">81</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02090</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02271</span>[<span class="hljs-number">82</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02050</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02239</span>[<span class="hljs-number">83</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.02009</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02206</span>[<span class="hljs-number">84</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.01969</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02159</span>[<span class="hljs-number">85</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.01931</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02126</span>[<span class="hljs-number">86</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.01895</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02088</span>[<span class="hljs-number">87</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.01837</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.02021</span>[<span class="hljs-number">88</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.01804</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.01992</span>[<span class="hljs-number">89</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.01772</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.01956</span>[<span class="hljs-number">90</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.01741</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.01929</span>[<span class="hljs-number">91</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.01710</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.01897</span>[<span class="hljs-number">92</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.01660</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.01839</span>[<span class="hljs-number">93</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.01602</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.01748</span>[<span class="hljs-number">94</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.01576</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.01721</span>[<span class="hljs-number">95</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.01547</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.01692</span>[<span class="hljs-number">96</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.01520</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.01672</span>[<span class="hljs-number">97</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.01492</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.01640</span>[<span class="hljs-number">98</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.01444</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.01570</span>[<span class="hljs-number">99</span>]validation_0-error:<span class="hljs-number">0.00153</span>validation_0-logloss:<span class="hljs-number">0.01422</span>validation_1-error:<span class="hljs-number">0.00307</span>validation_1-logloss:<span class="hljs-number">0.01543</span>XGBClassifier(base_score=<span class="hljs-number">0.5</span>, booster=<span class="hljs-string">'gbtree'</span>, colsample_bylevel=<span class="hljs-number">1</span>,              colsample_bynode=<span class="hljs-number">1</span>, colsample_bytree=<span class="hljs-number">1</span>, gamma=<span class="hljs-number">0</span>, gpu_id=<span class="hljs-number">-1</span>,              importance_type=<span class="hljs-string">'gain'</span>, <span class="hljs-built_in">int</span>eraction_constraints=<span class="hljs-string">''</span>,              learning_rate=<span class="hljs-number">0.1</span>, max_delta_step=<span class="hljs-number">0</span>, max_depth=<span class="hljs-number">2</span>,              min_child_weight=<span class="hljs-number">1</span>, missing=nan, monotone_constraints=<span class="hljs-string">'()'</span>,              n_estimators=<span class="hljs-number">100</span>, n_jobs=<span class="hljs-number">0</span>, num_parallel_tree=<span class="hljs-number">1</span>,              objective=<span class="hljs-string">'binary:logistic'</span>, random_state=<span class="hljs-number">0</span>, reg_alpha=<span class="hljs-number">0</span>,              reg_lambda=<span class="hljs-number">1</span>, scale_pos_weight=<span class="hljs-number">1</span>, silent=True, subsample=<span class="hljs-number">1</span>,              tree_method=<span class="hljs-string">'exact'</span>, validate_parameters=<span class="hljs-number">1</span>, verbosity=None)</code></pre><p>可视化</p><pre><code class="hljs python"><span class="hljs-comment"># retrieve performance metrics</span>results = bst.evals_result()<span class="hljs-comment">#print(results)</span>epochs = len(results[<span class="hljs-string">'validation_0'</span>][<span class="hljs-string">'error'</span>])x_axis = range(<span class="hljs-number">0</span>, epochs)<span class="hljs-comment"># plot log loss</span>fig, ax = plt.subplots()ax.plot(x_axis, results[<span class="hljs-string">'validation_0'</span>][<span class="hljs-string">'logloss'</span>], label=<span class="hljs-string">'Train'</span>)ax.plot(x_axis, results[<span class="hljs-string">'validation_1'</span>][<span class="hljs-string">'logloss'</span>], label=<span class="hljs-string">'Test'</span>)ax.legend()plt.ylabel(<span class="hljs-string">'Log Loss'</span>)plt.title(<span class="hljs-string">'XGBoost Log Loss'</span>)plt.show()<span class="hljs-comment"># plot classification error</span>fig, ax = plt.subplots()ax.plot(x_axis, results[<span class="hljs-string">'validation_0'</span>][<span class="hljs-string">'error'</span>], label=<span class="hljs-string">'Train'</span>)ax.plot(x_axis, results[<span class="hljs-string">'validation_1'</span>][<span class="hljs-string">'error'</span>], label=<span class="hljs-string">'Test'</span>)ax.legend() <span class="hljs-comment"># 显示标签label</span>plt.ylabel(<span class="hljs-string">'Classification Error'</span>)plt.title(<span class="hljs-string">'XGBoost Classification Error'</span>)plt.show()</code></pre><center class="half">    <img src="/article/2bebfb2a/输出4.png" srcset="/img/loading.gif" width="350" hight="300">    <img src="/article/2bebfb2a/输出5.png" srcset="/img/loading.gif" width="350" hight="300"></center><h2 id="Stacking-堆叠"><a href="#Stacking-堆叠" class="headerlink" title="Stacking(堆叠)"></a>Stacking(堆叠)</h2><h3 id="Stacking原理"><a href="#Stacking原理" class="headerlink" title="Stacking原理"></a>Stacking原理</h3><p><img src="/article/2bebfb2a/image-20200713231126836.png" srcset="/img/loading.gif" alt="image-20200713231126836"></p><h3 id="Stacking代码"><a href="#Stacking代码" class="headerlink" title="Stacking代码"></a>Stacking代码</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<span class="hljs-keyword">from</span> sklearn.naive_bayes <span class="hljs-keyword">import</span> GaussianNB<span class="hljs-keyword">from</span> sklearn.ensemble <span class="hljs-keyword">import</span> RandomForestClassifier<span class="hljs-keyword">from</span> mlxtend.classifier <span class="hljs-keyword">import</span> StackingClassifier<span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npdata = np.loadtxt(<span class="hljs-string">'data/wine.data'</span>, delimiter=<span class="hljs-string">','</span>)X = data[:, <span class="hljs-number">1</span>:]y = data[:, <span class="hljs-number">0</span>:<span class="hljs-number">1</span>]X_train, X_test, y_train, y_test = train_test_split(X, y.ravel(), train_size=<span class="hljs-number">0.8</span>, random_state=<span class="hljs-number">0</span>)<span class="hljs-comment"># 定义基分类器</span>clf1 = KNeighborsClassifier(n_neighbors=<span class="hljs-number">5</span>)clf2 = RandomForestClassifier(random_state=<span class="hljs-number">1</span>)clf3 = GaussianNB()<span class="hljs-comment"># 定义最终使用的逻辑回归分类器</span>lr = LogisticRegression()<span class="hljs-comment"># 使用stacking分类器</span>sclf = StackingClassifier(classifiers=[clf1, clf2, clf3],                          meta_classifier=lr,use_probas=<span class="hljs-literal">True</span>)<span class="hljs-comment"># 对每一个模型分别进行评价</span><span class="hljs-keyword">for</span> model <span class="hljs-keyword">in</span> [clf1,clf2,clf3,lr,sclf]:    model.fit(X_train,y_train)    y_test_hat = model.predict(X_test)    print(model.__class__.__name__,<span class="hljs-string">',test accuarcy:'</span>,accuracy_score(y_test,y_test_hat))</code></pre><p>输出：</p><pre><code class="hljs yaml"><span class="hljs-string">KNeighborsClassifier</span> <span class="hljs-string">,test</span> <span class="hljs-attr">accuarcy:</span> <span class="hljs-number">0.8055555555555556</span><span class="hljs-string">RandomForestClassifier</span> <span class="hljs-string">,test</span> <span class="hljs-attr">accuarcy:</span> <span class="hljs-number">0.9444444444444444</span><span class="hljs-string">GaussianNB</span> <span class="hljs-string">,test</span> <span class="hljs-attr">accuarcy:</span> <span class="hljs-number">0.9166666666666666</span><span class="hljs-string">LogisticRegression</span> <span class="hljs-string">,test</span> <span class="hljs-attr">accuarcy:</span> <span class="hljs-number">0.9444444444444444</span><span class="hljs-string">StackingClassifier</span> <span class="hljs-string">,test</span> <span class="hljs-attr">accuarcy:</span> <span class="hljs-number">0.9722222222222222</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode315</title>
    <link href="/article/ad1c84b5.html"/>
    <url>/article/ad1c84b5.html</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">The article is available after a week or enter the password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="5f139da38f0cecc037efad976e33928f59942b7204d5614e026249798ae433da">019868b553e1c33179f6d650984b476db7d5e33298e7e46c118bd4942344f7778dda14779a9efc85302f32a2a4c9b76767f3ed842248afbb007f670459f71c45374aeebee5d5a3ab0b19c39e370a44a1a472bc3a99ebe0d2b39b8ccdec6ee7c6763128c86f8b804a325edfeca1dd86e03daf70a6c1ac5b9f8ed3c94e7564e36dbf89b0eda6bbbc20af63d7a4574c0dcf555df25e15f9d918cdedc25bc204c0b5f4d02b65f666dbe214b0f5834d5a064cf76be079dc3698a65325ecccecbfcbac7894d59500561d28c4ac07e542f3bf5b322d1232170afec34af2a6e7bb619be638fdb55629d6fa001784c5f49b0a82dc03de3c0ad48c32a4c5267c149170a4e2dc535d59f173379028a6370a55f3ac98e7fde57b763217fdc710e39db177c958cc5286ef39e666c714fca5ca74679a74c8f9ce05a8eeab541a81e536d9f3e403021b4791e3760b7b69c3652f1fad90338634d27b480e462b5ddbda8d0fe3a3d05db176ee20befbd419a29aa3b19e3b569b894ecc5e1b08f48d2658c77ef4988cf70f0437b547d2750e400848e6121dc2dfddf3f3019f1cfe3b54367cc4b657f855cf569bd277f3f6a974731f5cb11d05fb9be6d9268c89e8f3cd838d8e828129dc011c636d1ecf384433c7eec009cbdc054495ea2387a0b16913bfd21677c711621ed588930be487293212ee1aa255b862a7c5c5d8ec35602664958d2e213272a78ed1dc4246734778d4867c9e67d01e91eef10de43f452fe5d57681cab6524ce8fb79cb9c3f9b26628e198f20e55c875b1b65257fc7598c36d099e425d4992674393922bc44693229ee4023ce0f74cfa1fc6da5a0ec0d88dd74452c087db3bd6fe30cbdf06bef318f7c0d56b495db7846896b33d8bde2d709c6bb323261b949bd790e4b23ff042555956a22d681c6a635b3ae4fdad8f442903c9e2239f52ae5479f5b9ed4a89ba44d5d7e49e6791eeff92e98c3ef7120c614f5ebd6c0a235fd461789c2386f7e60d71526f161eabfbe43ea063b165d71241b87c3e54befd0c63f3de81741c47102c7a96aaa859217a08068e1820717546e55b407b894bcea0080efcad9587e0461035f027898915ad0f67ce80fe4219cac69eb891298d5452e5b9e0bb1eea8db85958a4044fe397a8b2a699cacc2ab6f75a508e07a439fca62a3d7f83769ca6a2840dbad6818daf02d0f69e0e1dbba152b40021fc853adce9f752b490d42f8a3d834104ce044d09522def0dc8218e7a1b44ce42276a1e33dc415f209b91c42f4b405ea61162e558331ed7d9c5c19ffd45dc91cc796f600c988740c6dcbd2eae34a398e2c4f8c91f806e8ce7b17356d6d3ce1277bf2a0ab9108509c9538b0c2eac0697f682b1b6be2399834bf1d4edd507becaedbccd9755b7fadded24c6a0b3b000401a5042a62839fc37f969d78bee24944f81a27e168f769a1fa30de09f2825d7133af841d80f247dc3d20ab7f824fe3cee021dcec4e3d8a188619b5d553759824c113df6357a3d5f4997f3a92ed03ddd0c5fd442caafda74b1a5aee3e61cebf1b883b143640a3fe001c54d1af7388ceb1c6449a37116ceb76c1c5c4c20c9f0a8bb91af9d817c2a6a5886806e4c279a45a33c14902507a344880ad106e18a5207ea3b07c508d5353e9a20dacf5d9f3a6c1f99fe06112a85cdef235aa099594b99b2da8402c5e84e45565c2715d64cbec04e1a309046624fd61ce369401d4957dfb2e35a0c683195fa009346e55a8b6a08109c7463bbdfdc26e69ee91a316fa97097ea53983f51b75fea4ed94fd95b54856475cec4e81f3e96d6b77a3625517cd0dee92f8cb32423e9d8253ae2b2acdf874152ff648283008a4642f979b6fa150fde5a152f29fe3c4f2c13949cc6d2e2f04d95163926920e0633f4eaec171e87cc54b44b8f1ff94d2b00ca05b3be9d8a1f98075b643b670029e7f90915593a469bd627b951297345b0f4b9103c4c77e887f4701a9c73840e9eb934b253ba7720200b1c532fc6c170b8b0f4e1f0423bbbd7608d081a438354e4262227008f8da2f249ddadc924ba9a4b45c738e09d05a4b02910e64c2c859c4582887b8db07f03a1c2c84b01fe94142661055d87b7f90a2ab1223b93c083ecb884b37a74c9d0fbdf858c92b6c884369b311fcead14e5a3122d054e1ffdf2932da6aaba9f10cff9d9e969c438bc3d4ecf3a37b5b453e3462433748523f1db3c099b5014d68ce7fc5c0f66544c0f04c6ee1d8e5c0f472c4fadad395e2847f3f67b3accf395259e68a2bbaabc54c4fd579929fc3394583022d9a356c8c2ec1fc405c09b782f602d1ed3030caaf125988c3184d1850517b13ec26bd93b7931d3cddb7aa584fc9d92285525d768f1ac284b220ce44871268a63a5da4ff6330819c9cdd2d9f90666fd63a67ffa6e9e1026e60692a61eecc2ebe0d2eff7a9c0c34f0fa335f574ea858b9f48c7b062a1c792382c2ac05abcca926703bc20c3e27f13e5f7977e52c9698c00d5d6ccbaebadc4b8183a913c20863677d5ceaf998313c3b68e0c04a03421ac937ff5a4b855863957db0dbdfcfc39c15638580378017d5720ca57ba4c7365029a35c0d41d58ca695018265e77ba5d8e845bd34de4c4934037a2eed10b9c24550c531a09ddd8dfd3f0f595355153174afcbd27f701f00bfffe657c0953c87cbfa62b63af834708e85ff44e2f9174daeeeca9edd5609cff99054f685b17a3f3567dbbf3b4c2509b4d7537d6e6a92feb4c4b48b1b57c510e04d19ecbb055d474f9cf097984ab794f84186039d44a11fdeebaf51082c0f297c8463e0105a73fe595424d8413dccfad9073d67dc84305d0015ba1ebb22a1fadde589bd28cafc7ef2b37d2de068e7a5a87278d5cf8aeaba43443234116140a414f690cbc25da342855c8a298180d8b4268f1091fb5f0a8e580eef6abedc677969b3fe75665f104265b201bb3eb1cf0c3ebcdced57c6210cbeed743af13322a2b3b1c310540dc3a82b83d280d13af29519ab33f02a4b2360ee483692f48a360faaa11d037c3bf1ac85696b55651ea8916b4dcfacb8f88405224925f85e62bd735f64f6755570fb724148c51ad2d91b4b0d010c4a1024edd4357214636025bee45842193bc025a6da09a5281aeca9b4facbc7a774d7f85020d34a05881057252350634b5e47f4308bc9bd8150cfbe6c082b5ab868d7438d764f9532b358b94d98177f2fbe9603e7b94fae2e04dab36f3650676c9daa9d2c99efe1c121bddd0131568d44b42d6959160e134fbb92d0794ae6850959690533e5e839c78c51bba4424a2274aa3e92aa28b862a53cf0e43a047890b2786f75199a48853177c780bde74f3e9a7ed5c0fa9cb1e286ab4a7391229be4bd285a3b8f8809ee57c6c93b793cd9c193e3a9aed44670a6245250ceb07040bba2126f9c7f5b67420931e130db78851bea44afaafdc1793e6998a0172e4aa68d226361c05d91e2f783073a459139bfe24fe9fc49a931737819a301f9de117be86f17c7b520616019c9d7474e13dbb199947391316fa1c2392c9f8490e554a18904904e466981a7308e3c85ec4bedefb7d5f61b371c4006b707a0e8f68a62045cb33d377f3659d008e6b92c45401ab281bb76455215b670bfbb5210b6f5107956c59a244654c74818e23263f25c1c7c3464da38697d9c099f839522d518a240238284e0de4e98bbf9dfaf783f09b5297991c5d1585404892ed040143c4552e3232cb28e4b29f43930334ef965393dbdb80d82ddc2c58141c7e99f746ca56f731158ef74dde707dbd45e532ff5bd23cf06f6043a4c5a8ec8d427b8ad37935bac5a62b0ae5d46b6ad651f32023bda0349610bae6bad1687af9b21de22944437321887b5aec3f943512ae546cadea4918a3191642f0ab7a339afc41089eef23b4c88589f79c7da75f9ef1ce62eb0e25ca17d121482bee98d1748da7765c406258c0ab220b57f1d4fc431ac718c557d8da86bc98804f031bda5657350d8ec82b70b0e432258a2df08081789dc7954f56abd516790fe3487d010e740e0b6c2ff2dcea3116236cc003eab855ce2cc64759482de3221d3e4ca0a8cedf5018277cd34a5b9e8ebd301ac1be1764fc61eca16365513851a28bbb19ed6f58fbaa50df632b9588b6b6c365d2e5448c9be0012e199053d9530000f43de5e2de43bf72a3d48de9d68b4ca46d70e18d7e3a287778fc92382b55554c459f848050b43e553a61b2f46706a14120ffaf8a34f0d2d6dbc3b4c94568ce75d7f70d158b6858223956b108e909a3b6e9bdb821a35e56af4d0cb7503e105a6090a44a4f100579a80155993e855a8de021a2ba076c1aa07f5d3fadb4389cb91abe599b87e3a0fb98b8db5ab4b248a7759fc4dbd9a5cb5bba519479622b9f7bb7d36eb67ec97ab6a0ed98850c8bdc5bbad1c94c66d4f8f2fddea6bf6cd9572b072063865a9a8883d33de3745c30bc9efd0487b55eea57e459138d677b06f89b7b966a3ce01017d6eb862cec439e62a0dd3de321934f3fcce55089a99057327f40f01e94af5446e8536612ffad66007f11c4dd28187a342b2567b9b6b6135880376eb5f9f9818ba10028793eb902adc754335ad485831f2831164a4f87712cfd8630d7653ff44366dcdb27e8325a13acc06e7b6c8e0d88721879e6b7d4e450d13e496ce975f0014a5dec588645326f7e71bceb88179829e8744fe5081e6b50cd659718f5b9b9fca79e942e68b62d133478392dad7b160e63ae03ad6eec9847dff81c32638a4226c5497b0db600f1a18622cfbb5688bb538b5811f04a328fa1c90c3413f77d8e491d3ddb5a2d82a591a06cfd804fd8ae8df92271fb003e129618ffbb7f19d2b014fd44ac1de0e8d222eab85256de30fb768a5d57878014527dc905e5ebc6dc3c6a6134de39202e446f89d990c4eff52bae099c11dfdfb485a7cf221ab6281ed6f3a2a0cb7629a32b101e3be2f4e592f095cb4d957dfec1ef54569ebcd1e71e1172fae7535542027c42bd52277c21f3f31e4e78ca4d5b344637cbbe3da55b9e8591eb1c1cda667aeee1882fb90f978229008965cff43dfcca5bb8cada6241c4bc802031b73f53ca20211f27bc8ce0508d918369d6d02894fa91e1cf4a1d7ca9f13ac5930b4955b68f1a143551bebfe5aa0ae10f891d72fb409dece598146b9651755946b404953f3ffdcca186a4fddab26396df2a114786069aefc156668957c8d8a3708fd2ca074df53fd83c9a2c265c36529933d7f643e41e95015c0f42a4241cd1d81a718f45233fc13f5d129557ff72ca2924ba28a2b5eff30887b2bb8ae52aa1bb781cb4dd0154992bf455c11725818c60b573e1ba3ad1a6d9ec68fc0bca29c3178323351c3c5a0ce712176d927f6719d33326427a89c0521bbbf6d800b0792c60ced095eb04fb57eb34f83710af0da3138f4e94a7b021c307e99cd4cee749b7541c0152bf4ff4b34be921ebe95f737910aaf44ba6d58e1a4a7c2987470d839317297c0ad6500d878c8af2f8d4aa8a5c3101cfaf4ecad65f982c8d5da38f2140c80ad751c3087fd8d5f8227a53a8c81d816a4aa3a29e8c981f70c6c8d8183e80fe920eae30d832eddb39d7dc31b4d21513017e8bbab127c675976977adfe0ecaf57c8ed7556502003393e7dcf412079f8491abdfe97a3aa4c3d2d52cffaa270803f14e08a3ccd58e935c10530eba8d9bed300aade0fbb7af7a6363f2936a3ba3846a8330731774c1617a5405c1118b52bfae21cce27f16304cab561d0d50c4a0f25891e2b3124d5f848af52650a682c70ac48617fd037965f0124af359754ffcf3a4d01deb041c9ca4c9008803f9392a20ad17efe7cd674909efb1f7708c47d9969483565934457e6d81112f9bf9085998721120336586205491a6fc275d30b98134fac92f911779ee4b79da1b0aa55eeafa17bf24bbe7c4575e90306e5e6a308b2a06b568cad6ab4b985d89acc1337f492c1f371db63d91d1b1940ee699b7e9609c341cb1cc47b39e33a2b72a5f54f2c41ccdeb116432bb92be8637e14f9aa3141855273a792be75a4fb1fb267fd11b5caf95019df208d2ca68311279aa3566051cb4599789091e77fb6c9fdbe7dfd36b798cd705ec3c04149bb23f10d6d98431d2db230a024bb7975456f5a09817b22c5ed14573bf919ee26b9a160aa7f5a5edb8b84001f40ccb6f547474bac3781f97134cdc1d0331c2d373298580eb526c7636235efb75ce7700d83a8bb0dd0dc95f80fa61a93bc9a375ef594b6442268ec5468bfb6aadb8f65c37cdd20d68e424a30afeb77c783f28a8d10cffd5cba21c7ffd58c9754eab939a7ded5b60af5b335c8024e12a7a7362666cfb81c88b1dbbecdeda9ab58ad8b8578708c4b4895e8fdfa137ca6d92b8836c00d8b4c3962238fbb20eeea59d200159195fc758f7421157c779212c488aa9452aaf8d7d1ebe4145a656913dd796bb29a435569af6917c94368c7fa74daf6458991d586466cee199994e2168dd7d7ef667b4f209c7b117412c71003d6bb8a5f75dfddae3c6e6e3cc012d78875596a2c7b7d73d671f928e72ed8ca1c402cae976ee2cbab011592d26397ad744ef21e2a4fca1e0f6c35a1171603e9ce06aa5648f90a8197bafa8e3383c5ae7d9f00026e9fe059035af1b18149cd5f1dd58d685ac020e13df61ab313059c3a51bd9bce7ff344c9324a4d17ecc647e3015f6b619a7ef5000bf26c7e50c78fe2959719485e6436a650d908cec3fe555db7b4b6e2e3953c031f42a35d8e627cacc2b338f74b3be63837631f2e1099aa1c57260b7cd8117787318b7593299ba36b9538539865998e190b9aa64660f9125cd85819744cb0f9e7a83f44eeea956824840f460c6621926234b966a40cb96b6d0b1c8462584dd8a7f0c88ae35788b33431f69c69a49e4a17aaae294cb30e6b694b85353027fbf82804c969b6bbc3b79f583c6993be417baf5d8a7a511f348ec71671cf275d21499aa0aa89b5f1ee98045423ebe84754af86964227c4ad2c418bab64b5889b0b924409da25ae272211c357c2b58d081da354543e6fd3d3aa465ad9d65098cae81fd125d504b364de7735d51d2c3715f2268ec916b330ff6d2f2ec089e6df8a04c6ee6773715d4c79755a2c60bbfc523337372b800375d8cb020e1f84f823671af19004a47490c2ac8a42298ac81c6a930ddab9844d1b21f5c33db9399e1b6419360d71e69515295054798abbe64a91fcf51923c0d07f40d45c952eba0a81fbb37f0de3d24b5f3c1f158889e8cfac0a30bca220202441e6a735088677d2db1188f1493c12fbdc04c353e2c85b3bd05693d062b7abd22a6ce98cffef1abb729fea3f9ed3225a65b9b8defdee10c6fca7e9fb132c387314c5d201e7a67ed75aa8ed97244986087d8eaf3cf891d45f47491b61d113c671446b8d82d899621e0bce999edc9b046cbb373e13587b7ba628e6bb00724e86abb232dca70f205b385cfb4fb882d1936233ec9e405347384b916e39668ac82b46f5f3a607a982e9d1a24d079d0954ec379937792dfb9a586bbc8917f2fd89ea0b7ffe7df9ab2d803178864ce1ed195b6f1f0a2d4350b1b51d6ceebef6cd2a6b8c29806b4a146fc42d3f030622b614db64649e10e41f08d39aa9d0d4a7d49eb7b50dc26968f812b28ec1890d0ef64e5146330159f6936d7169308acfabc4cd24289a218987f71ee62ece207ec49f3d6d33bf3358f01758c5677d6198df2a21ef7ac06d8c059ce50a46391fbb19ded8ba764c2229738c485d051096b5b976257d9fa06880f691abe1fbbbaadf233737c86f5403fc7cc2fa7a235492ee1adba99639a16fb1f34679131815cf2a0a868b2a1f87ef242aad01b40de1fa5a17e864e9d9bac2c14b1399801d32bbf4d0f8b11281034ce35e1fbec38152d884b2450356797e085098eb8c9f330a47a05288fc18bfbd9ef92021e9033b053262d68d938294adc7a63e94cade47404e05d4e070b3c047f98a8985e89cb6206c2981fc4fcb177c87b0d0f5e2f1af14451ce8a7e6d92b1516b75225764b48235cc958fac5e2983ae84f7c2681be1b7b129b6fc2f550694d06b8b53c757208d6e2933d463596af708ee682c569c1ce89a110a05abfaa7bee98bdbd775925ec5fe3cf4d8b507e339f3186d46541d2c3cbbc4b3e5ae36d08fb86523b9b1c25d333cb908e18bec76be4ac5815502e39485eeadd2ed7bd1ad1d02a45a38f67271e9831de1d1eab406a37acff0f998d748bf60723455384b742c2f2cd717bd47e1fc69d9a6b85796c744bb4f18acc99c896a3421ad4e13a1faf973454dcbb28882f6ce4408ad9622d5c2af5c31aac5e984d946978df613e6e84c809b5f081d3357870431c84d0dcd47fa17418497aa869d985a551333426d250708b3a71c6bd8859a29454fba95ff09658db873eb6f1f76088d394749c94d370f3d6862ea25abc98faa941cb5e86dd9d54ad4f0fc9932476393796ca8f1016130065daf311f08bb031a7fd109160a203af6342ffd6da1121719303b49d68344f0b8b1c3a94945069fd656b6a736d1b8737a75e13eef67b82f075fd77caeea36f50dea2a91e136fe3b8d3331769f08a01e750f7c241b3e376d2ac5ce074a91bd91f0f50622f8fab679dbb5721e31f2307b47dc559104f15f41c863656b673a77e66b5cc4ea2ba73d1a203804ebdc09b8da1059bf4072e6c8b5c8f4fa2bfc1c2210644f1d562a12c5397d56ae4c6e75fc7b62d59556a4bacccb79a9f8d2716d1878a05cacfafa32ee5ad2553e60ac9d885c40d73638b48ea9e325730efef00d56dc0e59cc64d8dd4c6e01f4f7647d913ae3d1b8064cb427d4324d34f786d59011c6ca26035158885b74452fc0dcbdc5490b855e9b565ad6ae22ee47bb6b7aad5cd779f48aa034af892e9cb46cc17091c84bcf9dbf56171c618af0f5384a98653252b6569c6d5a8f0612cfe9dcda977415b22e6fb945ad9c6c7f735068d5cc58225e14e16e58b5ba46db0fc99267ef09436b4d2971cc603f3dffd81e61c40892b0938d8c381e1a2bedf501b6b442577f1c32b67b0988f640086e274d27621f8d90ed7185cfad36189971ce9466f13c38ec9a40fd9939b60e1030128b1a57e5b16b47e275926ec5d90b0e40ca501ca710a4d23a274edafbc921abf7be1c25b379e6a821374bbe34310b891c48f379980054468b9d7ae5810c2bb51a3a449e622c492a95e5a64aa03dcddae5e9706e0b7da4e7dedbb855cee5af51a76c558169d39b7d5df460f5269083d75b05f4bf98071bd96d55ed4da9438b601f8a6cd5a40e1ea0fdc8ef474228848fb0b3340934f62da4350daa27f2c20751d63beb3f1ec8422dad5677dae969b7c88c2af529bb01f88d68f8b063801d9d55da195ba39bb7726fe70b08086a9e9b97b2c8b0a462b988a2617aecbbcccf65059057f4e54620162bc1615d576fb9d79ab9695cc3ca6f295f6bb9d1f819f759aafd991f78f8b34c6d000b032f8b9aaf8fee6eebfc62564672aeccbfd032d073704eff40c4bba4017035e45c0f3bb2e4d3d0b2edd5a8d9272cabc55f234334fc088f2ca4c3fa2ca41e2391079b1a283b97d2ac4d17c02604a851b85aa34624c2285101b46583d6e9262d4af95a1c89ea8a4cfdd3e2c3a301ad6060800f41ad0706157f972265f7fe5c3b8eaaffe7bb6bdddb051a29e853b4ce1c15fdc5e968c8612c21d7a0451ceac0e91d4123bf0a79e1298581a4e0089ea86464c675f25e2f51d3f4d6df3ddda9a91065a7fa2d60c5caf050578ede0a2bfa941d56755a8d36f2215fe9ee286b07fbc5fd8180bbab5a49290c3960d580091217d76bed7db5e6b5e10ecfad250a37019894dd85621e9e85d88f0dfc591aea945d4358dab5fe7dfff5d1fa61f7094365e8cbd95a59bed121c824b9fdc7fb17eeee2bc2a0a8327254ae429313e60c6e8bec9a7de4a537c0345ccde3123d55522ae5f2b8efe932b6ad4130bdac9fa80d280a7fc1c07cb7fd6927b32b9f1923e31f7d03e56450fc8d3d322cb6215a7f908545f8de05605f3bf808acd280af1d7492deaaf57ff48075754c83bb68ee7116a7afb2cea0e8a2bb5049def9db975ef5cb328a7bbec64211b10b48fcdeafd6df129364b6bfaf4429169135d89d16ef0b1e274b830728f335f6ee798be0e3e6bfeefdc8c5ffe2fb7a690e3afa311c48291e868345b6ac400d0005cfca63881989c7d69477e194b98789fcf1ed4dafc070de2c1fa3923593e4001315ce74744b8093dbe1e1265b53d62d2dfe09a105eea4ef35fec09ca60d4cac7a24b74cb82ee0e4cbf0a8f6d6d455327f5da9ee4af1499edcfd54eb9c9f13ae8510a30021ba660dd2cb3386756bc0c4345320fa69b999bf2914c6f3da6618751c7c67ceffe0c59a33d8f9d052b741cf0f00f9ecd2117e51e5877c1ac4c5618ddd6bd560ec6e7915f180477f4df4ee6f3ff88bd6d7acea5e63ea7281a2ed7600f9d763d8f8000b24742929dd5d3d76b879d4ea3902df7ff238faf9473c5a8716c43f58978f20230f5764c37c9da48a9138ed368d176fdb69f30835055ad15dd8b550b8c4ea4340746fd2bda807e9dcff522377ff43f0cca281aec0af59d50d85b873338f420d7188886337328d40de343bb9e7417f75b398a67ccded48a1be5ccf5ff51604909fc380b35e176d0aafa19d11e7441c238630f81892a798a13b5eed0eff730d39e7221b3580ff30b4292c67c86d9502c41930d23c88da462df06e6c6b55eecdb854fc8554a474a6a5099d49fba05f62beca820140b06ac0fbb34386a3aa1b503b86e72379d198224f8237b924bd65915cea81df61adcac85179225963d58832adc67a639dd715ee8abafc46302437695b9d79c6c750cfb89b4d1774d0913a76b7fa390f376f08cb50c8271989a1fb9d54457a36b819481c0f26966ed2c86bead62ed8753628c1216acf87743fba25e4b6bb43a710016bb812ecc52e6708a1fbe75e149fd596ffc7fd4739b66eab4aa75fc2977d93ccaca88fbee27a7f7d65a3303325c1db7d2fea52b3acc56c000522d3147b07c8473e9342252e39651da21944ba2ab0f7cf0eef56d92e8cdf515516856c5ad746ee7a88f56ba268ffd0c46f087e27914cd6d69a9f39406cd72295c394f62b27e4c36f5354512d30dfe98d20a3b1afd795ea195e31c735f07cf64170b61314a18ee8e1dfeed1c92c562f9c2a61266b34765ffc20ca4bf09ede218815418e55fb1a8b12544a18d8e245bbda332e0405baedefc52b1feb9b7c8a158d69fd611cbafb0fa3598a2cbb5d69a691c1a371c2237f78a81afdbf10516717bfd17513aac4e693ed0ace523cc7ec1753592c11d9800b22c63252831bc1eb9e57fd74182ce909c7d97c256e2e2503cc23255906f2646eb57635691700b57b7d10866f35b448489ecfdc31291c94c2eec5fd0a51e652ad06dee299ca22899767e3750fe87e06f4a3a1cda73e4a6e53728b3e6b8111f48cafb5f5dce23307e2368789d671bf251ad99f66faca688f916c361c98a4b2f64fbf46e937cb2b4103788ceb16e2b61df98c8fa6a0c7a46321b1e5b6dbbea6095f47b0ebb75bf0108c76bc7ba21b5988dc13823402e8dd5ffb7a678e5b6a2e82253d1b70a91ca8322600cb347f6dfe96a6a4982c246e2c9d8812edbc790ad0c1535a39cfba953769e117b12327fe60670699d2d26c77e2864c66c3a22f0cfe675c2b2f810c53b8e14409da9179111601bef7d0138aba458112608be18a58cfc96f696781e0f83aecb131797145200058760776dac39564a9163aebcdc5ac4f8c933b11f2e80125a8edcb777c9c76bb6ba54462ee6b42e853f87fe59e5a9d64697257bf1634ca701b0d67a90e37b03af5a1dfad543bffdb7db231fc51ec04bcc315b30bc4c2984b8d7e1369ed21a5760a43d8c570740184be8453b62a2c128dcfc9d594fdf104a45fd1c19c8af6bbd282af8332f7863bf01efacd7670d3f0e5569a48c35061fe24f2feeb7345e99b82b50f1dbfba256660c5feda9ab95ca75c823c47b4740c18ee333b69c711a0c1ef7a12952c467fecb7cbb1bd5de83d8737e4126c12993fcaae345f46b36ea586db3c4bbae3f32eefec1b27e3a13bd2ecd00b633f47b4b095389a3574990f680ac3d8f5627600c9fe037d08aa2cd1f280b30c03a698c57117c580c1890a0e84d7839b334f9cc7832b2e509fa25ca5f5b87ac81afa39c85d5227fecd728ae3b917f0c2482185ae0c5c9ff45228a44ebf85e78e1ce8c3c543c70157faea14a9e45b00efdcd259cbe0fa94bfa1ca2af1be169b586cd6f43129ac6e11b461b50b8739d1d14f93c18d83c83b20685e046a8ed914a756358758f940babea0a2690386eeb07d88ba9c719ead538847baf86a28299a8b681006a34de3a6a7b1ce999305b3c67ce765ee6e8707d6473c2ff80ae1ac6fe0e797c3eced6e8fb78ebdd51f732c8424a20a87a93a39e9d96351ade571d920dcd7441e553aa75f1a2866edfb0dacdd73b05d98d8b741b</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>树状数组,归并排序</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习-主成分分析</title>
    <link href="/article/1998c4ca.html"/>
    <url>/article/1998c4ca.html</url>
    
    <content type="html"><![CDATA[<h2 id="PCA简介"><a href="#PCA简介" class="headerlink" title="PCA简介"></a>PCA简介</h2><ul><li><p>是一种统计方法，通过正交变换将一组可能存在相关性的变量转换为一组线性不相关的变量，转换后的这组变量叫主成分。</p></li><li><p>算法本质是找一些投影方向，使得数据在这些投影方向上方差(投影过后的点到原点的平方和)最大。（投影距离小）</p><center><img src="/article/1998c4ca/image-20200711003413935.png" srcset="/img/loading.gif" width="600"></center><center><img src="/article/1998c4ca/image-20200711003420835.png" srcset="/img/loading.gif" width="600"></center><center><img src="/article/1998c4ca/image-20200711003436312.png" srcset="/img/loading.gif" width="600"></center><p>线性回归：点到直线的误差值(红线)最小。<br>PCA：投影距离(垂线方向：黑线)最小。</p></li></ul><p><img src="/article/1998c4ca/image-20200711004725908.png" srcset="/img/loading.gif" alt="image-20200711004725908"></p><ul><li><p>应用领域：</p><ul><li>降维</li><li>高维数据集的探索与可视化</li><li>数据压缩</li><li>数据预处理</li></ul></li></ul><h2 id="基于协方差矩阵的特征值分解算法-Eigenvalue-Decomposition-Algorithm-based-on-Covariance-Matrix"><a href="#基于协方差矩阵的特征值分解算法-Eigenvalue-Decomposition-Algorithm-based-on-Covariance-Matrix" class="headerlink" title="基于协方差矩阵的特征值分解算法(Eigenvalue Decomposition Algorithm based on Covariance Matrix)"></a>基于协方差矩阵的特征值分解算法(Eigenvalue Decomposition Algorithm based on Covariance Matrix)</h2><p>1、均值归一化。计算各个特征均值，然后令$x_j=x_j-u_j$。如果特征在不同数量级上，还需要将其除以标准差，即$x_j=\frac{x_j-u_j}{\sigma_j}$<br>2、计算协方差矩阵(covariance matrx)$\sum=\frac{1}{m-1}\sum_{i=1}^{m}{X.T*X}$（X为mxn矩阵，m为样本量，n为特征维度）<br>3、计算协方差矩阵$\sum$的特征向量(eigenvactors)：eigenvalues, eigenvectors = np.linalg.eig(sigma)<br>4、取特征向量u的前k维，得到nxk维度的矩阵，用$U_{reduce}$表示，则降维后的数据为    </p><script type="math/tex; mode=display">\begin{aligned}z^{(i)}= & U^{T}_{reduce} \times x^{i} \quad 针对一条数据(即一个向量) \\Z = & X \times U_{reduce} \quad 针对所有数据(即一个矩阵)\end{aligned}</script><p><strong>代码(将二维数据降维为一维数据)：</strong><br>一、导入数据</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loaddata</span><span class="hljs-params">()</span>:</span>    data = np.loadtxt(<span class="hljs-string">'data/pca_data.csv'</span>,delimiter=<span class="hljs-string">','</span>)    <span class="hljs-keyword">return</span> dataX = loaddata()plt.scatter(X[:,<span class="hljs-number">0</span>],X[:,<span class="hljs-number">1</span>])plt.show()</code></pre><p><img src="/article/1998c4ca/输出1.png" srcset="/img/loading.gif" alt="输出1"></p><p>二、特征值归一化及PCA降维</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">featureNormalize</span><span class="hljs-params">(X)</span>:</span>    mu = np.mean(X,axis=<span class="hljs-number">0</span>).reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>)    sigma = np.std(X,axis=<span class="hljs-number">0</span>,ddof=<span class="hljs-number">1</span>).reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>)    X = (X-mu)/sigma    <span class="hljs-keyword">return</span> X,mu,sigma<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pca</span><span class="hljs-params">(X, K)</span>:</span>    m = len(X)    sigma = np.dot(X.T, X)/(m<span class="hljs-number">-1</span>)    <span class="hljs-comment"># 返回的特征向量需是从大到小排序后的，取前k列。</span>    eigenvalues, eigenvectors = np.linalg.eig(sigma)    index = np.argsort(-eigenvalues) <span class="hljs-comment">#特征值从大到小排序</span>    eigenvectors = eigenvectors[:,index] <span class="hljs-comment">#特征向量对应的值</span>    u_reduce = eigenvectors[:,<span class="hljs-number">0</span>:K]    <span class="hljs-keyword">return</span> np.dot(X,u_reduce),eigenvectorsX,mu,sigma = featureNormalize(X)Z,eigenvectors=pca(X,<span class="hljs-number">1</span>)print(Z)</code></pre><p>输出：</p><pre><code class="hljs tex">[[ 1.48127391] [-0.91291229] [ 1.21208656] [ 1.62734009] [ 1.26042409] [-0.96700223] [ 1.25605967] [-2.31794969] [-0.02968998] [-0.77386123] [-0.62532902] [-0.54724542] [-0.08878025] [-0.520569  ] [ 1.548434  ] [-1.89684585] [-0.87788459] [ 0.94646472] [-2.30653955] [-0.4731351 ] [-2.19518524] [ 0.38509662] [-1.76688508] [ 0.0512347 ] [ 1.64838858] [ 0.50302869] [-1.2246766 ] [-1.16020771] [ 0.83375215] [-0.00686207] [-0.22565101] [-1.49788781] [ 1.3252858 ] [-0.58656923] [ 0.67225099] [-1.33938187] [ 1.67053477] [-1.37836539] [ 2.53419743] [-0.27570789] [-0.96695982] [ 0.8792732 ] [ 1.28362916] [-0.97972108] [ 1.79450473] [-0.26923019] [ 3.16088618] [ 1.20080033] [ 0.36423084] [-1.42814204]]</code></pre><p>三、画图（<span style="color:red">recover到了两维上？？</span>）</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recover</span><span class="hljs-params">(Z, U, K)</span>:</span>    U_reduce = U[:,<span class="hljs-number">0</span>:K]    X_rec = np.dot(Z,np.transpose(U_reduce))    <span class="hljs-keyword">return</span> X_rec<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plotData</span><span class="hljs-params">(X_origin, X_rec)</span>:</span>    plt.scatter(X_origin[:,<span class="hljs-number">0</span>], X_origin[:,<span class="hljs-number">1</span>])    plt.scatter(X_rec[:,<span class="hljs-number">0</span>],X_rec[:,<span class="hljs-number">1</span>],c=<span class="hljs-string">'red'</span>)    plt.show()</code></pre><p><img src="/article/1998c4ca/输出2.png" srcset="/img/loading.gif" alt="输出2"></p><h2 id="基于数据矩阵的奇异值分解算法-Singular-Value-Decomposition-Algorithm-based-on-Data-Matrix"><a href="#基于数据矩阵的奇异值分解算法-Singular-Value-Decomposition-Algorithm-based-on-Data-Matrix" class="headerlink" title="基于数据矩阵的奇异值分解算法(Singular Value Decomposition Algorithm based on Data Matrix)"></a>基于数据矩阵的奇异值分解算法(Singular Value Decomposition Algorithm based on Data Matrix)</h2><p>1、均值归一化。计算各个特征均值，然后令$x_j=x_j-u_j$。如果特征在不同数量级上，还需要将其除以标准差，即$x_j=\frac{x_j-u_j}{\sigma_j}$<br>2、对数据矩阵进行SVD分解：$u,s,v^T = np.linalg.svd(X,full_matrices=0)$<br>3、取特征向量$v^T$的前k维，得到kxn维度的矩阵，用$U_{reduce}$表示，则降维后的数据为    </p><script type="math/tex; mode=display">\begin{aligned}z^{(i)}= & v \times x^{i} \quad 针对一条数据(即一个向量) \\Z = & X \times (v^T)^T \quad 针对所有数据(即一个矩阵)\end{aligned}</script><p><strong>解释：</strong><br>奇异值分解如下式所示：</p><script type="math/tex; mode=display">X^{m \times n} = u^{m \times m} {\sum}^{m \times n} (v^T)^{n \times n} \tag{1}</script><p>其中$\sum$特征值矩阵是非常稀疏的，取其特征值前top r列，上式转换为:</p><script type="math/tex; mode=display">X^{m \times n} \approx u^{m \times r} {\sum}^{r \times r} (v^T)^{r \times n} \tag{2}</script><p>(1)式在第2个步骤中分解为$X^{m \times n} \approx u^{m \times n} {\sum}^{n \times n} (v^T)^{n \times n}$，然后根据实际需要，取前r行即可。</p><p><strong>代码(将二维数据降维为一维数据)：</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loaddata</span><span class="hljs-params">()</span>:</span>    data = np.loadtxt(<span class="hljs-string">'data/pca_data.csv'</span>,delimiter=<span class="hljs-string">','</span>)    <span class="hljs-keyword">return</span> dataX = loaddata() <span class="hljs-comment"># 和上一个代码一样的数据，就不展示了</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">featureNormalize</span><span class="hljs-params">(X)</span>:</span>    mu = np.mean(X,axis=<span class="hljs-number">0</span>).reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>)    sigma = np.std(X,axis=<span class="hljs-number">0</span>,ddof=<span class="hljs-number">1</span>).reshape(<span class="hljs-number">1</span>,<span class="hljs-number">-1</span>)    X = (X-mu)/sigma    <span class="hljs-keyword">return</span> X,mu,sigma<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pca</span><span class="hljs-params">(X,K)</span>:</span>    u,s,vT = np.linalg.svd(X, full_matrices=<span class="hljs-number">0</span>)    <span class="hljs-keyword">return</span> X.dot(vT.T[:,<span class="hljs-number">0</span>:K]),u,s,vTX,mu,sigma = featureNormalize(X)Z,u,s,vT = pca(X,<span class="hljs-number">1</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recoverData</span><span class="hljs-params">(Z, vT, K)</span>:</span>    V_reduce = vT[:,<span class="hljs-number">0</span>:K]    X_rec = np.dot(Z,np.transpose(V_reduce))    <span class="hljs-keyword">return</span> X_rec<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plotData</span><span class="hljs-params">(X_orgin,X_rec)</span>:</span>    plt.scatter(X_orgin[:,<span class="hljs-number">0</span>],X_orgin[:,<span class="hljs-number">1</span>])    plt.scatter(X_rec[:, <span class="hljs-number">0</span>], X_rec[:, <span class="hljs-number">1</span>],c=<span class="hljs-string">'red'</span>)    plt.show()X_rec = recoverData(Z,vT,<span class="hljs-number">1</span>)plotData(X,X_rec)</code></pre><p><img src="/article/1998c4ca/输出3.png" srcset="/img/loading.gif" alt="输出3"></p><h2 id="Sklearn实现PCA"><a href="#Sklearn实现PCA" class="headerlink" title="Sklearn实现PCA"></a>Sklearn实现PCA</h2><p>1、如何选取主成分个数(How to choose the num of Principal Component)<br>主成分分析主要是减少投影的平均均方误差，即<br>（1）</p><script type="math/tex; mode=display">\frac{ \frac{1}{m} \sum^{m}_{i=1}{||x^{(i)} - x^{(i)}_{project}||^2} }{ \frac{1}{m} \sum^{m}_{i=1}{||x^{(i)}||^2}}</script><p>值越小越好(例如：等于0.01，表示原数据99%的信息都保留下来)，但此种计算方法耗时大。<br>（2）</p><script type="math/tex; mode=display">\frac{ \sum^{k}_{i=1} S_{ii} }{ \sum^{m}_{i=1} S_{ii} }</script><p>$S_{ii}$是特征值矩阵对角线元素，该值越大越好(如等于0.99，表示元数据99%的信息都保留下来)，此种计算方法耗时小。<br>2、Sklearn实现PCA</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<span class="hljs-keyword">import</span> scipy.io<span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loaddata</span><span class="hljs-params">()</span>:</span>    data = np.loadtxt(<span class="hljs-string">'data/pca_data.csv'</span>,delimiter=<span class="hljs-string">','</span>)    <span class="hljs-keyword">return</span> data<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plotData</span><span class="hljs-params">(X_orgin,X_rec)</span>:</span>    plt.scatter(X_orgin[:,<span class="hljs-number">0</span>],X_orgin[:,<span class="hljs-number">1</span>])    plt.scatter(X_rec[:, <span class="hljs-number">0</span>], X_rec[:, <span class="hljs-number">1</span>],c=<span class="hljs-string">'red'</span>)    plt.show()X = loaddata()model = PCA(n_components=<span class="hljs-number">1</span>) <span class="hljs-comment">#定义PCA</span>Z = model.fit_transform(X) <span class="hljs-comment">#生成降维后数据</span>print(<span class="hljs-string">"主成分个数="</span>,model.n_components)print(<span class="hljs-string">"贡献比="</span>,model.explained_variance_ratio_)print(<span class="hljs-string">"特征的方差="</span>,model.explained_variance_)X_rec = model.inverse_transform(Z) <span class="hljs-comment">#还原数据</span>plotData(X,X_rec)</code></pre><p>输出：</p><pre><code class="hljs tex">主成分个数= 1贡献比= [0.87062385]特征的方差= [2.10987818]</code></pre><p><img src="/article/1998c4ca/输出4.png" srcset="/img/loading.gif" alt="输出4"></p><h2 id="照片压缩"><a href="#照片压缩" class="headerlink" title="照片压缩"></a>照片压缩</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> matplotlib.image <span class="hljs-keyword">as</span> mpimg<span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA<span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<span class="hljs-comment"># 读取照片</span>img=mpimg.imread(<span class="hljs-string">"data/xxx.jpg"</span>)<span class="hljs-comment"># # 显示照片</span><span class="hljs-comment"># plt.imshow(img)</span><span class="hljs-comment"># # 查看照片维度</span><span class="hljs-comment"># print(image.shape) # (800,600,3)</span><span class="hljs-comment"># 把照片转换为二维数组</span>X = img.reshape(<span class="hljs-number">1200</span>,<span class="hljs-number">1200</span>)<span class="hljs-comment"># 数据标准化</span>X = StandardScaler().fit_transform(X) <span class="hljs-comment"># 为了算法快速收敛</span><span class="hljs-comment"># 使用PCA降维</span>model = PCA(n_components=<span class="hljs-number">50</span>)Z = model.fit_transform(X)<span class="hljs-comment"># Z.shape (1200, 50)</span>print(<span class="hljs-string">"贡献比="</span>,np.sum(model.explained_variance_ratio_))<span class="hljs-comment"># 贡献比= 0.9837087238843197</span><span class="hljs-comment"># model.explained_variance_ratio_.shape (50,)</span><span class="hljs-comment"># 数据还原</span>X_rec = model.inverse_transform(Z)X_rec = X_rec.reshape(<span class="hljs-number">800</span>,<span class="hljs-number">600</span>,<span class="hljs-number">3</span>)<span class="hljs-comment"># 显示还原后的照片</span>plt.imshow(X_rec)</code></pre><p>照片还是不放了~大家可以找网上的照片练练手~</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习-聚类</title>
    <link href="/article/c583ae2a.html"/>
    <url>/article/c583ae2a.html</url>
    
    <content type="html"><![CDATA[<h2 id="层次聚类-Hierarchical-Clustering"><a href="#层次聚类-Hierarchical-Clustering" class="headerlink" title="层次聚类(Hierarchical Clustering)"></a>层次聚类(Hierarchical Clustering)</h2><p>1、聚合(agglomerative)或自下而上(bottom-up)聚类<br>2、分裂(divisive)或自上而下(top-down)聚类</p><hr><p><strong>AGNES(Agglomerative Nesting)：凝聚层次聚类</strong>——<strong>自下而上</strong><br>1、构造m个类，每个类包含一个样本<br>2、计算类与类之间的距离$d_{ij}$，记做矩阵$D=[d_{ij}]_{m \times m}$<br>3、合并间距最小的两个类<br>4、若达到聚类数k则退出<br>5、重新计算类之间的距离$d_{ij}$，重复3</p><p>计算类间距离<br>1、最小距离(单连接，single linkage)<br>2、最大距离(完全连接，complete linkage)<br>3、中心/均值距离（计算中心，两个类中心之间的距离）<br>4、平均距离</p><center>        <img src="/article/c583ae2a/image-20200710180744389.png" srcset="/img/loading.gif" width="600"></center><center>        <img src="/article/c583ae2a/image-20200710182415542.png" srcset="/img/loading.gif" width="600"></center><p><strong>代码</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<span class="hljs-keyword">import</span> scripy.io<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> AgglomerativeClustering<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loaddata</span><span class="hljs-params">()</span>:</span>    data = np.loadtxt(<span class="hljs-string">'data/cluster_data.csv'</span>, delimiter=<span class="hljs-string">','</span>)    <span class="hljs-keyword">return</span> dataX = loaddata()<span class="hljs-comment"># linkage可取值：</span><span class="hljs-comment"># -ward:方差</span><span class="hljs-comment"># -complete:最大距离</span><span class="hljs-comment"># -average：平均距离</span><span class="hljs-comment"># -single:最小距离</span>model = AgglomerativeClustering(n_clusters=<span class="hljs-number">3</span>, affinity=<span class="hljs-string">'euclidean'</span>,linkage=<span class="hljs-string">'complete'</span>)<span class="hljs-comment"># AgglomerativeClustering(affinity='euclidean', compute_full_tree='auto',</span><span class="hljs-comment">#                        connectivity=None, distance_threshold=None,</span><span class="hljs-comment">#                        linkage='complete', memory=None, n_clusters=3)</span>model.fit(X)pirnt(<span class="hljs-string">'每个样本所属的簇：'</span>,model.labels_)cm_dark = mpl.colors.ListedColormap([<span class="hljs-string">'g'</span>,<span class="hljs-string">'r'</span>,<span class="hljs-string">'b'</span>])plt.scatter(X[:,<span class="hljs-number">0</span>],X[:,<span class="hljs-number">1</span>], c=model.labels_, cmap=cm_dark, s=<span class="hljs-number">20</span>)plt.show()</code></pre><p>输出：</p><pre><code class="hljs tex">每个样本所属的簇: [1 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 1 1 1 1 1 1 0 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 2 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1]</code></pre><p><img src="/article/c583ae2a/image-20200710211716375.png" srcset="/img/loading.gif" alt="image-20200710211716375"></p><h2 id="密度聚类-Density-based-clustering"><a href="#密度聚类-Density-based-clustering" class="headerlink" title="密度聚类(Density-based clustering)"></a>密度聚类(Density-based clustering)</h2><p>DBSCAN是一种著名的密度聚类方法，给定参数$(\varepsilon,Minpts)$<br>1、$\varepsilon$领域<br>2、核心对象(Core object)<br>3、密度直达(directly density-reachable)<br>4、密度可达(density-reachable)</p><center>        <img src="/article/c583ae2a/image-20200710183926623.png" srcset="/img/loading.gif" width="600"></center><p>若$minPts=3$，则$x_1,x_2$等都是核心对象<br>$x_2$由$x_1$密度直达，$x_3$由$x_1$密度可达</p><p><strong>密度聚类算法过程：</strong><br>1、首先设置$(\varepsilon,Minpts)$参数<br>2、确定核心对象，假设为$\Omega ={x^{(3)},x^{(5)},x^{(6)},x^{(8)},x^{(9)},x^{(13)},x^{(14)},x^{(18)} ,x^{(19)} ,x^{(24)} ,x^{(25)},x^{(28)},x^{(29)}}$<br>3、从$\Omega$中随机选取一个核心对象作为种子(假设为$x^{(8)}$)，找出由它密度可达的所有样本，构成一个聚类簇，假设第一个聚类簇为$C_1 = \{ x^{(6)},x^{(7)},x^{(8)},x^{(10)},x^{(12)},x^{(18)},x^{(19)},x^{(20)},x^{(23)} \}$<br>4、从$\Omega$中去除$C_1$中包含的核心对象后，$\Omega ={x^{(3)},x^{(5)},x^{(9)},x^{(13)},x^{(14)},x^{(24)} ,x^{(25)},x^{(28)},x^{(29)}}$，重复3直至$\Omega$为空。</p><p><strong>代码</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<span class="hljs-keyword">import</span> scripy.io<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> DBSCAN<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">loaddata</span><span class="hljs-params">()</span>:</span>    data = np.loadtxt(<span class="hljs-string">'data/cluster_data.csv'</span>, delimiter=<span class="hljs-string">','</span>)    <span class="hljs-keyword">return</span> dataX = loaddata()model = DBSCAN(eps=<span class="hljs-number">0.5</span>, min_samples=<span class="hljs-number">5</span>, metric=<span class="hljs-string">'euclidean'</span>)model.fit(X)print(<span class="hljs-string">'每个样本所属的簇：'</span>, model.labels_)cm_dark = mpl.colors.ListedColormap([<span class="hljs-string">'g'</span>,<span class="hljs-string">'r'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>])plt.scatter(X[:,<span class="hljs-number">0</span>], X[:,<span class="hljs-number">1</span>], c=model.labels_, cmap=cm_dark, s=<span class="hljs-number">20</span>)</code></pre><p>输出(-1类为离群点)：</p><pre><code class="hljs tex">每个样本所属的簇: [ 0 -1  1  0  0  0  0  0  0  0  0  0  0  0  0  0 -1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 -1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 -1  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0  0 -1  0  0  0  0  0  0  0  0  0  0 -1  0  0  0  0  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2  2 -1  2 -1  2  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1 -1 -1  1  1  1  1  1  1  1  1  1  1  1  1 -1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  1  0]</code></pre><p><img src="/article/c583ae2a/image-20200710214909170.png" srcset="/img/loading.gif" alt="image-20200710214909170"></p><h2 id="高斯混合模型-Gaussian-Mixed-Model"><a href="#高斯混合模型-Gaussian-Mixed-Model" class="headerlink" title="高斯混合模型(Gaussian Mixed Model)"></a>高斯混合模型(Gaussian Mixed Model)</h2><p>高斯模型（$x$为单变量）：</p><center>        <img src="/article/c583ae2a/image-20200710215235437.png" srcset="/img/loading.gif" , width="300"></center><p>均值为0，方差为1的概率密度函数：</p><center>        <img src="/article/c583ae2a/image-20200710215343235.png" srcset="/img/loading.gif"></center><p>高斯模型（$X$为多变量，维度为$n$，$d=n$，$\sum$为$X$的协方差矩阵，大小为$n \times n$，$\overrightarrow{u}=(u_1,u_2,\ldots,u_n)$）：</p><center>        <img src="/article/c583ae2a/image-20200710215425497.png" srcset="/img/loading.gif" , width="500"></center><center>        <img src="/article/c583ae2a/image-20200710215745455.png" srcset="/img/loading.gif"></center><p>为什么要用高斯混合模型：</p><center class="third">        <img src="/article/c583ae2a/image-20200710215954681.png" srcset="/img/loading.gif" width="250">    <img src="/article/c583ae2a/image-20200710220000554.png" srcset="/img/loading.gif" width="250">    <img src="/article/c583ae2a/image-20200710220007667.png" srcset="/img/loading.gif" width="250"></center><p>用单变量高斯模型无法拟合上图所示分布(两类数据的分布)，用高斯混合模型可以较好拟合。</p><center>        <img src="/article/c583ae2a/image-20200710220356090.png" srcset="/img/loading.gif" , width="400"></center><p>其中 $k$ 为类别数，$\pi_k$为第 $k$ 个高斯模型的权重，$N(x|u_k,\sum_k)$为第 $k$ 个高斯模型，$u_k,\sum_k$是第 $k$ 个高斯模型的参数（均值向量，协方差矩阵）。</p><p><strong>高斯混合模型参数计算</strong><br>第 $i$ 个样本属于第k个类别的概率：</p><center>        <img src="/article/c583ae2a/image-20200710230813932.png" srcset="/img/loading.gif" , width="200"></center><center>        <img src="/article/c583ae2a/image-20200710223122317.png" srcset="/img/loading.gif" , width="300"></center><p>交替更新，直至收敛稳定。</p><p><strong>手工代码</strong></p><p>一、生成数据进行实验</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-comment"># 生成一些数据进行实验</span><span class="hljs-comment"># 1.生成均值为1.71，标准差为0.056的男生身高数据</span>np.random.seed(<span class="hljs-number">0</span>)mu_m = <span class="hljs-number">1.71</span> <span class="hljs-comment"># 期望</span>sigma_m = <span class="hljs-number">0.056</span> <span class="hljs-comment"># 标准差</span>num_m = <span class="hljs-number">10000</span> <span class="hljs-comment"># 数据个数为10000</span>random_data_m = np.random.normal(mu_m, sigma_m, num_m) <span class="hljs-comment">#生成数据</span>y_m = np.ones(num_m) <span class="hljs-comment"># 生成标签</span><span class="hljs-comment"># 2.生成均值为1.58，标准差为0.051的女生身高数据</span>np.random.seed(<span class="hljs-number">0</span>)mu_w = <span class="hljs-number">1.58</span>  <span class="hljs-comment">#期望</span>sigma_w = <span class="hljs-number">0.051</span>  <span class="hljs-comment">#标准差数据</span>num_w = <span class="hljs-number">10000</span>  <span class="hljs-comment">#个数为10000</span>rand_data_w = np.random.normal(mu_w, sigma_w, num_w)<span class="hljs-comment">#生成数据</span>y_w = np.zeros(num_m)<span class="hljs-comment">#生成标签</span><span class="hljs-comment"># 3.把男生数据和女生数据合在一起</span>data = np.append(rand_data_m,rand_data_w)data = data.reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)y = np.append(y_m,y_w)print(data)print(y)</code></pre><p>输出：</p><pre><code class="hljs tex">[[1.80878693] [1.7324088 ] [1.76480933] ... [1.60636048] [1.57832104] [1.64620368]][1. 1. 1. ... 0. 0. 0.]</code></pre><p>二、高斯混合模型拟合数据</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> multivariate_normalnum_iter = <span class="hljs-number">1000</span>n, d = data.shape<span class="hljs-comment">#初始化参数</span>mu1 = data.min(axis=<span class="hljs-number">0</span>)mu2 = data.max(axis=<span class="hljs-number">0</span>)sigma1 = np.identity(d)sigma2 = np.identity(d)pi = <span class="hljs-number">0.5</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(num_iter):    <span class="hljs-comment">#计算gamma</span>    norm1 = multivariate_normal(mu1, sigma1)    norm2 = multivariate_normal(mu2, sigma2)    tau1 = pi * norm1.pdf(data)    <span class="hljs-comment"># print('tau1', tau1)</span>    tau2 = (<span class="hljs-number">1</span> - pi) * norm2.pdf(data)    gamma = tau1 / (tau1 + tau2)    <span class="hljs-comment"># print('gamma',gamma)</span>    <span class="hljs-comment">#计算mu1</span>    mu1 = np.dot(gamma, data) / np.sum(gamma)    <span class="hljs-comment"># print("第%d iter: mul=%f" % (i, mu1))</span>    <span class="hljs-comment">#计算mu2</span>    mu2 = np.dot(<span class="hljs-number">1</span>-gamma, data) / np.sum(<span class="hljs-number">1</span> - gamma)    <span class="hljs-comment">#计算sigma1</span>    sigma1 = np.dot(gamma * (data-mu1).T, (data - mu1) ) / np.sum(gamma)    <span class="hljs-comment"># print("第%d iter: sigma1=%f" %(i,sigma1))</span>    <span class="hljs-comment">#计算sigmal2</span>    sigma2 = np.dot((<span class="hljs-number">1</span>-gamma) * (data-mu2).T, (data - mu2)) / np.sum(<span class="hljs-number">1</span> - gamma)    <span class="hljs-comment">#计算pi</span>    <span class="hljs-comment"># print("第%d iter: sigma1=%f" %(i,sigma2))</span>    pi = np.sum(gamma)/nprint(<span class="hljs-string">u'类别概率:\t'</span>, pi)print(<span class="hljs-string">u'均值:\t'</span>, mu1, mu2)print(<span class="hljs-string">u'方差:\n'</span>, sigma1, <span class="hljs-string">'\n\n'</span>, sigma2, <span class="hljs-string">'\n'</span>)</code></pre><p>输出：</p><pre><code class="hljs tex">类别概率: 0.4873884639284559均值: [1.57749047] [1.70726384]方差: [[0.00244834]]  [[0.00315184]]</code></pre><p><strong>sklean实现高斯混合模型</strong></p><p>一、生成实验数据</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-comment"># 生成一些数据进行实验</span><span class="hljs-comment"># 1.生成均值为1.71，标准差为0.056的男生身高数据</span>np.random.seed(<span class="hljs-number">0</span>)mu_m = <span class="hljs-number">1.71</span> <span class="hljs-comment"># 期望</span>sigma_m = <span class="hljs-number">0.056</span> <span class="hljs-comment"># 标准差</span>num_m = <span class="hljs-number">10000</span> <span class="hljs-comment"># 数据个数为10000</span>random_data_m = np.random.normal(mu_m, sigma_m, num_m) <span class="hljs-comment">#生成数据</span>y_m = np.ones(num_m) <span class="hljs-comment"># 生成标签</span><span class="hljs-comment"># 2.生成均值为1.58，标准差为0.051的女生身高数据</span>np.random.seed(<span class="hljs-number">0</span>)mu_w = <span class="hljs-number">1.58</span>  <span class="hljs-comment">#期望</span>sigma_w = <span class="hljs-number">0.051</span>  <span class="hljs-comment">#标准差数据</span>num_w = <span class="hljs-number">10000</span>  <span class="hljs-comment">#个数为10000</span>rand_data_w = np.random.normal(mu_w, sigma_w, num_w)<span class="hljs-comment">#生成数据</span>y_w = np.zeros(num_m)<span class="hljs-comment">#生成标签</span><span class="hljs-comment"># 3.把男生数据和女生数据合在一起</span>data = np.append(rand_data_m,rand_data_w)data = data.reshape(<span class="hljs-number">-1</span>,<span class="hljs-number">1</span>)y = np.append(y_m,y_w)print(data)print(y)</code></pre><p>二、sklean实现高斯混合模型拟合数据</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.mixture <span class="hljs-keyword">import</span> GaussianMixture<span class="hljs-comment"># n_components:类别数 max_iter:迭代次数</span>g = GaussianMixture(n_components=<span class="hljs-number">2</span>, covariance_type=<span class="hljs-string">'full'</span>, tol=<span class="hljs-number">1e-6</span>, max_iter=<span class="hljs-number">1000</span>)g.fit(data)print(<span class="hljs-string">u'类别概率:\t'</span>, g.weights_[<span class="hljs-number">0</span>])print(<span class="hljs-string">u'类别概率:\t'</span>, g.weights_[<span class="hljs-number">1</span>])print(<span class="hljs-string">u'均值:\n'</span>, g.means_, <span class="hljs-string">'\n'</span>)print(<span class="hljs-string">u'方差:\n'</span>, g.covariances_, <span class="hljs-string">'\n'</span>)</code></pre><p>输出：</p><pre><code class="hljs tex">类别概率: 0.4996454306546242类别概率: 0.5003545693453813均值: [[1.57895001] [1.70898537]] 方差: [[[0.00251652]] [[0.00306363]]]</code></pre><p>测试准确率：</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_scorey_hat = g.predict(data)print(accuracy_score(y,y_hat))</code></pre><p>输出（重叠区域不好判断）：</p><pre><code class="hljs python"><span class="hljs-number">0.8891</span></code></pre><h2 id="对亚洲足球队进行聚类分析"><a href="#对亚洲足球队进行聚类分析" class="headerlink" title="对亚洲足球队进行聚类分析"></a>对亚洲足球队进行聚类分析</h2><p><strong>代码</strong><br>导入数据</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> KMeans<span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler <span class="hljs-comment"># 标准归一化</span>df = pd.read_csv(<span class="hljs-string">'data/football_team_data.csv'</span>, index_col=<span class="hljs-string">'国家'</span>)print(df)</code></pre><p>输出：</p><pre><code class="hljs tex">     2019国际排名  2018世界杯  2015亚洲杯国家                                中国            73       40        7日本            60       15        5韩国            61       19        2伊朗            34       18        6沙特            67       26       10伊拉克           91       40        4卡塔尔          101       40       13阿联酋           81       40        6乌兹别克斯坦        88       40        8泰国           122       40       17越南           102       50       17阿曼            87       50       12巴林           116       50       11朝鲜           110       50       14印尼           164       50       17澳洲            40       30        1叙利亚           76       40       17约旦           118       50        9科威特          160       50       15巴勒斯坦          96       50       16</code></pre><p>取出数字列</p><pre><code class="hljs python">X = df.valuesprint(X)</code></pre><p>输出：</p><pre><code class="hljs tex">array([[ 73,  40,   7],       [ 60,  15,   5],       [ 61,  19,   2],       [ 34,  18,   6],       [ 67,  26,  10],       [ 91,  40,   4],       [101,  40,  13],       [ 81,  40,   6],       [ 88,  40,   8],       [122,  40,  17],       [102,  50,  17],       [ 87,  50,  12],       [116,  50,  11],       [110,  50,  14],       [164,  50,  17],       [ 40,  30,   1],       [ 76,  40,  17],       [118,  50,   9],       [160,  50,  15],       [ 96,  50,  16]], dtype=int64)</code></pre><pre><code class="hljs python">X = StandardScaler().fit_transform(X)X</code></pre><p>输出：</p><pre><code class="hljs tex">array([[-0.5842676 ,  0.05223517, -0.64677721],       [-0.97679881, -2.12423024, -1.03291285],       [-0.9466041 , -1.77599577, -1.61211632],       [-1.76186121, -1.86305439, -0.83984503],       [-0.76543585, -1.16658546, -0.06757374],       [-0.04076286,  0.05223517, -1.22598067],       [ 0.26118422,  0.05223517,  0.51162973],       [-0.34270994,  0.05223517, -0.83984503],       [-0.13134698,  0.05223517, -0.45370938],       [ 0.89527309,  0.05223517,  1.28390102],       [ 0.29137893,  0.92282133,  1.28390102],       [-0.16154169,  0.92282133,  0.31856191],       [ 0.71410485,  0.92282133,  0.12549408],       [ 0.5329366 ,  0.92282133,  0.70469755],       [ 2.16345083,  0.92282133,  1.28390102],       [-1.58069297, -0.81835099, -1.80518414],       [-0.49368348,  0.05223517,  1.28390102],       [ 0.77449426,  0.92282133, -0.26064156],       [ 2.042672  ,  0.92282133,  0.89776537],       [ 0.11021068,  0.92282133,  1.0908332 ]])</code></pre><p>使用KMeans聚合数据</p><pre><code class="hljs python">model = KMeans(n_clusters=<span class="hljs-number">3</span>, max_iter=<span class="hljs-number">10</span>)model.fit(X)<span class="hljs-comment">#KMeans(algorithm='auto', copy_x=True, init='k-means++', max_iter=10,</span><span class="hljs-comment">#       n_clusters=3, n_init=10, n_jobs=None, precompute_distances='auto',</span><span class="hljs-comment">#       random_state=None, tol=0.0001, verbose=0)</span>df[<span class="hljs-string">"聚类结果"</span>] = model.labels_print(df)</code></pre><p>输出：</p><pre><code class="hljs tex"> 2019国际排名  2018世界杯  2015亚洲杯  聚类结果国家                                      中国            73       40        7     2日本            60       15        5     0韩国            61       19        2     0伊朗            34       18        6     0沙特            67       26       10     0伊拉克           91       40        4     2卡塔尔          101       40       13     1阿联酋           81       40        6     2乌兹别克斯坦        88       40        8     2泰国           122       40       17     1越南           102       50       17     1阿曼            87       50       12     1巴林           116       50       11     1朝鲜           110       50       14     1印尼           164       50       17     1澳洲            40       30        1     0叙利亚           76       40       17     1约旦           118       50        9     1科威特          160       50       15     1巴勒斯坦          96       50       16     1</code></pre><p>根据结果看出，这些国家分为了三类，结合数据进行分析，亚洲足球队强弱顺序依次是0，2，1.</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode309</title>
    <link href="/article/bdb1f9df.html"/>
    <url>/article/bdb1f9df.html</url>
    
    <content type="html"><![CDATA[<h1 id="309-最佳买卖股票时机含冷冻期"><a href="#309-最佳买卖股票时机含冷冻期" class="headerlink" title="309.最佳买卖股票时机含冷冻期"></a>309.最佳买卖股票时机含冷冻期</h1><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:<br>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。<br>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</p><p><strong>示例:</strong></p><pre><code class="hljs python">输入: [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>]输出: <span class="hljs-number">3</span> 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</code></pre><p>一种常用的方法是将「买入」和「卖出」分开进行考虑：「买入」为负收益，而「卖出」为正收益。在初入股市时，你只有「买入」的权利，只能获得负收益。而当你「买入」之后，你就有了「卖出」的权利，可以获得正收益。显然，我们的目标总是将收益值最大化。因此，我们可以使用动态规划的方法，维护在股市中每一天结束后每种状态可以获得的「累计最大收益」，并以此进行状态转移，得到最终的答案。</p><h2 id="方法一：动态规划"><a href="#方法一：动态规划" class="headerlink" title="方法一：动态规划"></a>方法一：动态规划</h2><p><strong>思路与算法</strong><br>我们用 $f[i]$ 表示<strong>第 $i$ 天结束之后</strong>的「累计最大收益」。根据题目描述，由于我们<strong>最多只能同时买入（持有）一支股票</strong>，并且卖出股票后有冷冻期的限制，因此我们会有三种不同的状态：</p><ul><li><p>我们目前持有一支股票，对应的「累计最大收益」记为 $f[i][0]$；</p></li><li><p>我们目前不持有任何股票，并且处于冷冻期中，对应的「累计最大收益」记为 $f[i][1]$；</p></li><li><p>我们目前不持有任何股票，并且不处于冷冻期中，对应的「累计最大收益」记为 $f[i][2]$。</p></li></ul><blockquote><p>这里的「处于冷冻期」指的是在第 $i$ 天结束之后的状态。也就是说：如果第 $i$ 天结束之后处于冷冻期，那么第 $i+1$ 天无法买入股票。</p></blockquote><p>从第 $i-1$ 天到第 $i$ 天的状态转移：</p><ul><li><p>对于 $f[i][0]$，我们目前持有的这一支股票可以是在第 $i-1$ 天就已经持有的，对应的状态为 $f[i-1][0]$；或者是第 $i$ 天买入的，那么第 $i-1$ 天就不能持有股票并且不处于冷冻期中，对应的状态为 $f[i-1][2]$ 加上买入股票的负收益 ${\it prices}[i]$。因此状态转移方程为：</p><script type="math/tex; mode=display">f[i][0] = \max(f[i-1][0], f[i-1][2] - {\it prices}[i])</script></li><li><p>对于 $f[i][1]$，我们在第 $i$ 天结束之后处于冷冻期的原因是在当天卖出了股票，那么说明在第 i-1i−1 天时我们必须持有一支股票，对应的状态为 $f[i-1][0]$ 加上卖出股票的正收益 ${\it prices}[i]$。因此状态转移方程为：</p><script type="math/tex; mode=display">f[i][1] = f[i-1][0] + {\it prices}[i]</script></li><li><p>对于 $f[i][2]$，我们在第 $i$ 天结束之后不持有任何股票并且不处于冷冻期，说明当天没有进行任何操作，即第 $i-1$ 天时不持有任何股票：如果处于冷冻期，对应的状态为 $f[i-1][1]$；如果不处于冷冻期，对应的状态为 $f[i-1][2]$。因此状态转移方程为：</p><script type="math/tex; mode=display">f[i][2] = \max(f[i-1][1], f[i-1][2])</script></li></ul><p><span style="color:blue">第i天持有股票：前一天持有/今天买股票</span><br><span style="color:blue">第i天冷冻：前一天持有股票，今天卖掉这支股票</span><br><span style="color:blue">第i天空闲：前一天处于冷冻期/前一天空闲</span></p><h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><pre><code class="hljs mermaid">graph LRA[f0] --休息--&gt; A[f0]A[f0] --卖出--&gt; B[f1]B[f1] --解冻--&gt; C[f2]C[f2] --休息--&gt; C[f2]</code></pre><p>最终答案：$\max(f[n-1][0], f[n-1][1], f[n-1][2])$</p><blockquote><p>如果最后一天（第 $n-1$ 天）结束后，持有股票这种状态是无意义的而且肯定不是最优解（毕竟$-{\it prices}[i]$）。</p></blockquote><p>所以最终答案是$f[n-1][1]$和$f[n-1][2]$中的最大值，即$\max(f[n-1][1], f[n-1][2])$。</p><p>动态规划中的边界条件——第 $0$ 天的情况：</p><script type="math/tex; mode=display">\begin{cases}f[0][0] &= -{\it prices}[0] \\f[0][1] &= 0 \\f[0][2] &= 0\end{cases}</script><p>在第 $0$ 天时，如果持有股票，那么只能是在第 $0$ 天买入的，对应负收益 $-{\it prices}[0]$；如果不持有股票，那么收益为零。注意到第 $0$ 天实际上是不存在处于冷冻期的情况的，但我们仍然可以将对应的状态 $f[0][1]$ 置为零，官方：这其中的原因留给读者进行思考(我：不然勒，还能置成啥)。</p><p><strong>代码</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(self, prices: List[int])</span> -&gt; int:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> prices:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>                n = len(prices)        <span class="hljs-comment"># f[i][0]: 手上持有股票的最大收益</span>        <span class="hljs-comment"># f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益</span>        <span class="hljs-comment"># f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益</span>        f = [[-prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>]] + [[<span class="hljs-number">0</span>] * <span class="hljs-number">3</span> <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(n - <span class="hljs-number">1</span>)]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n):            f[i][<span class="hljs-number">0</span>] = max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>] - prices[i])            f[i][<span class="hljs-number">1</span>] = f[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>] + prices[i]            f[i][<span class="hljs-number">2</span>] = max(f[i - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[i - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>])                <span class="hljs-keyword">return</span> max(f[n - <span class="hljs-number">1</span>][<span class="hljs-number">1</span>], f[n - <span class="hljs-number">1</span>][<span class="hljs-number">2</span>])</code></pre><p>空间优化：只需要存储前一天的三个状态即可，不必把每一天的状态都存储下来。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(self, prices: List[int])</span> -&gt; int:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> prices:            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>                n = len(prices)        f0, f1, f2 = -prices[<span class="hljs-number">0</span>], <span class="hljs-number">0</span>, <span class="hljs-number">0</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, n):            newf0 = max(f0, f2 - prices[i])            newf1 = f0 + prices[i]            newf2 = max(f1, f2)            f0, f1, f2 = newf0, newf1, newf2                <span class="hljs-keyword">return</span> max(f1, f2)</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$，其中 $n$ 为数组 ${\it prices}$ 的长度。</li><li>空间复杂度：$O(n)$。我们需要$3n$的空间存储动态规划中的所有状态，对应的空间复杂度为$O(n)$。如果使用空间优化，空间复杂度优化为$O(1)$。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/solution/zui-jia-mai-mai-gu-piao-shi-ji-han-leng-dong-qi-4/" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>动态规划</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>每日一题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode51</title>
    <link href="/article/223c24ff.html"/>
    <url>/article/223c24ff.html</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode51-N皇后"><a href="#leetcode51-N皇后" class="headerlink" title="leetcode51.N皇后"></a>leetcode51.N皇后</h1><p>n 皇后问题研究的是如何将 n 个皇后放置在 n×n 的棋盘上，并且使皇后彼此之间不能相互攻击。</p><p><img src="/article/223c24ff/8-queens.png" srcset="/img/loading.gif" alt="img"></p><p>上图为 8 皇后问题的一种解法。<br>给定一个整数 n，返回所有不同的 n 皇后问题的解决方案。<br>每一种解法包含一个明确的 n 皇后问题的棋子放置方案，该方案中 ‘Q’ 和 ‘.’ 分别代表了皇后和空位。</p><p><strong>示例:</strong></p><pre><code class="hljs python">输入: <span class="hljs-number">4</span>输出: [ [<span class="hljs-string">".Q.."</span>,  // 解法 <span class="hljs-number">1</span>  <span class="hljs-string">"...Q"</span>,  <span class="hljs-string">"Q..."</span>,  <span class="hljs-string">"..Q."</span>], [<span class="hljs-string">"..Q."</span>,  // 解法 <span class="hljs-number">2</span>  <span class="hljs-string">"Q..."</span>,  <span class="hljs-string">"...Q"</span>,  <span class="hljs-string">".Q.."</span>]]解释: <span class="hljs-number">4</span> 皇后问题存在两个不同的解法。</code></pre><p><strong>提示：</strong></p><ul><li>皇后，是国际象棋中的棋子，意味着国王的妻子。皇后只做一件事，那就是“吃子”。当她遇见可以吃的棋子时，就迅速冲上去吃掉棋子。当然，她横、竖、斜都可走一到七步，可进可退。（引用自<a href="https://baike.baidu.com/item/%E7%9A%87%E5%90%8E/15860305?fr=aladdin" target="_blank" rel="noopener">百度百科 - 皇后</a>）</li></ul><blockquote><p>约束编程</p></blockquote><p>基本含义是在放置每个皇后以后增加限制。当在棋盘上放置了一个皇后时，立即排除当前行，列和对应的两个对角线。该过程传递了约束从而有助于减少需要考虑情况数。<br><img src="/article/223c24ff/e67ed217a00038ed292ae8cb89c1a8492c7a49e33ec17f633f41c4ece77d6c2c-51_pic.png" srcset="/img/loading.gif" alt="51_pic.png"></p><blockquote><p>第二种方法叫做回溯法</p></blockquote><p>当在棋盘上放置了几个皇后且不会相互攻击。但是选择的方案不是最优的，因为无法放置下一个皇后。此时我们该怎么做？<strong>回溯。</strong>意思就是回退一步，来改变最后放置皇后的位置并且接着往下放置。如果还是不行，再回溯。</p><p><img src="/article/223c24ff/610377e670ee1d4184c0475edee789139d8fe9ebeb07df267e9c54fbd31c449e-51_backtracking_.png" srcset="/img/loading.gif" alt="51_backtracking_.png"></p><h2 id="方法1：回溯"><a href="#方法1：回溯" class="headerlink" title="方法1：回溯"></a>方法1：回溯</h2><p>在建立算法之前，我们来考虑两个有用的细节。</p><blockquote><p>一行只可能有一个皇后且一列也只可能有一个皇后。</p></blockquote><p>这意味着没有必要在棋盘上考虑所有的方格。只需要按列循环即可。</p><blockquote><p>对于所有的主对角线(蓝线)有<code>行号-列号=常数</code>（一条线上是同一个常数），对于所有的次对角线(红线)有<code>行号+列号=常数</code>（一条线上是同一个常数）。</p></blockquote><p>这可以让我们标记已经在攻击范围下的对角线并且检查一个方格<code>(行号，列号)</code>是否处于攻击位置。</p><p><img src="/article/223c24ff/332b878ebcd261a71f5f85cb4e23685d42b37685112f562e2844079748e63cd0-51_diagonals.png" srcset="/img/loading.gif" alt="51_diagonals.png"></p><p>回溯函数<code>backtrack(row=0)</code>。</p><ul><li>从第一个<code>row=0</code>开始。</li><li>循环列并且试图在每个<code>column</code>中放置皇后。<ul><li>如果方格<code>(row, column)</code>不在攻击范围内<ul><li>在<code>(row, column)</code>方格上放置皇后。</li><li>排除对应行，列和两个对角线的位置</li><li>if 所有的行被考虑过，<code>row == N</code><ul><li>意味着我们找到了一个解</li></ul></li><li>Else<ul><li>继续考虑接下来的皇后放置<code>backtrack(row + 1)</code>。</li></ul></li><li>回溯：将在<code>(row, column)</code>方格的皇后移除。</li></ul></li></ul></li></ul><p><img src="/article/223c24ff/847f5a2861010344bf28836f051c46a5c62bc0f164a02ad152ef98a93e07e208-image.png" srcset="/img/loading.gif" alt="img"></p><p><strong>代码</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solveNQueens</span><span class="hljs-params">(self, n)</span>:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_queen</span><span class="hljs-params">(row, col)</span>:</span>            queens.remove((row, col))            cols[col] = <span class="hljs-number">0</span>            print(<span class="hljs-string">'remove'</span>, row - col + n - <span class="hljs-number">1</span>)            hile_diagonal[row - col + n - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>            dale_diagonal[row + col] = <span class="hljs-number">0</span>                <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">could_place</span><span class="hljs-params">(row, col)</span>:</span>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> (cols[col] + hile_diagonal[row - col + n - <span class="hljs-number">1</span>] + dale_diagonal[row + col])                <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">place_queen</span><span class="hljs-params">(row, col)</span>:</span>            queens.add((row, col))            cols[col] = <span class="hljs-number">1</span>            print(<span class="hljs-string">'hile'</span>, row - col + n - <span class="hljs-number">1</span>)            print(<span class="hljs-string">'dale'</span>, row + col)            hile_diagonal[row - col + n - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>            dale_diagonal[row + col] = <span class="hljs-number">1</span>            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_solution</span><span class="hljs-params">()</span>:</span>            solution = []            <span class="hljs-keyword">for</span> _, col <span class="hljs-keyword">in</span> sorted(queens):                solution.append(<span class="hljs-string">'.'</span> * col + <span class="hljs-string">'Q'</span> + (n<span class="hljs-number">-1</span>-col) * <span class="hljs-string">'.'</span> )            output.append(solution)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(row)</span>:</span>            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(n):                <span class="hljs-keyword">if</span> could_place(row, col):                    place_queen(row, col)                    <span class="hljs-keyword">if</span> row == n - <span class="hljs-number">1</span>:                        add_solution()                    <span class="hljs-keyword">else</span>:                        backtrack(row+<span class="hljs-number">1</span>)                    remove_queen(row, col)        output = []        cols = [<span class="hljs-number">0</span>] * n        hile_diagonal = [<span class="hljs-number">0</span>] * (<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>)        dale_diagonal = [<span class="hljs-number">0</span>] * (<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>)        queens = set()        backtrack(row=<span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> output</code></pre><p>也可以用之前的回溯板子：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">solveNQueens</span><span class="hljs-params">(self, n: int)</span> -&gt; List[List[str]]:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(row)</span>:</span>            <span class="hljs-keyword">if</span> row == n:                output.append([<span class="hljs-string">'.'</span> * col + <span class="hljs-string">'Q'</span> + <span class="hljs-string">'.'</span> * (n - <span class="hljs-number">1</span> - col) <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> queens])                <span class="hljs-keyword">return</span>            <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(n):                <span class="hljs-keyword">if</span> cols[col] <span class="hljs-keyword">and</span> hill_diagonal[row - col + n - <span class="hljs-number">1</span>] <span class="hljs-keyword">and</span> dale_diagonal[row + col]:                    queens.append(col)                    cols[col] = <span class="hljs-number">0</span>                    hill_diagonal[row - col + n - <span class="hljs-number">1</span>] = <span class="hljs-number">0</span>                    dale_diagonal[row + col] = <span class="hljs-number">0</span>                    backtrack(row + <span class="hljs-number">1</span>)                    cols[col] = <span class="hljs-number">1</span>                    hill_diagonal[row - col + n - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>                    dale_diagonal[row + col] = <span class="hljs-number">1</span>                    queens.pop()        output = []        queens = []        cols = [<span class="hljs-number">1</span>] * n        hill_diagonal = [<span class="hljs-number">1</span>] * (<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>)        dale_diagonal = [<span class="hljs-number">1</span>] * (<span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>)        backtrack(row = <span class="hljs-number">0</span>)        <span class="hljs-keyword">return</span> output</code></pre><p>道理是一样的，时间更快了~</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$\mathcal{O}(N!)$. 放置第 1 个皇后有 $N$ 种可能的方法，放置两个皇后的方法不超过 $N(N - 2)$，放置 3 个皇后的方法不超过 $N(N - 2)(N - 4) $，以此类推。总体上，时间复杂度为 $\mathcal{O}(N!)$ .</li><li>空间复杂度：$\mathcal{O}(N)$ . 需要保存对角线和行的信息。</li></ul><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/n-queens/solution/nhuang-hou-by-leetcode/" target="_blank" rel="noopener">官方题解</a></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>分治、回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode17</title>
    <link href="/article/af3344ce.html"/>
    <url>/article/af3344ce.html</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode17-电话号码的字母组合"><a href="#leetcode17-电话号码的字母组合" class="headerlink" title="leetcode17.电话号码的字母组合"></a>leetcode17.电话号码的字母组合</h1><p>给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。<br>给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。</p><p><img src="/article/af3344ce/image-20200709112232223.png" srcset="/img/loading.gif" width="300" hight="300"></p><p><strong>示例:</strong></p><pre><code class="hljs python">输入：<span class="hljs-string">"23"</span>输出：[<span class="hljs-string">"ad"</span>, <span class="hljs-string">"ae"</span>, <span class="hljs-string">"af"</span>, <span class="hljs-string">"bd"</span>, <span class="hljs-string">"be"</span>, <span class="hljs-string">"bf"</span>, <span class="hljs-string">"cd"</span>, <span class="hljs-string">"ce"</span>, <span class="hljs-string">"cf"</span>].</code></pre><p><strong>说明:</strong><br>尽管上面的答案是按字典序排列的，但是你可以任意选择答案输出的顺序。</p><h2 id="方法一：回溯"><a href="#方法一：回溯" class="headerlink" title="方法一：回溯"></a>方法一：回溯</h2><p>回溯是通过穷举所有可能情况来找到所有解的算法。如果一个候选解最后被发现并不是可行解，回溯算法会舍弃它，并在前面的一些步骤做出一些修改，并重新尝试找到可行解。</p><p>给出如下回溯函数<code>backtrack(combination, next_digits)</code>，它将一个目前已经产生的组合<code>combination</code>和接下来准备要输入的数字<code>next_digits</code>作为参数。</p><p>如果没有更多的数字需要被输入，那意味着 当前的组合产生好了。<br>如果还有数字需要被输入：<br>遍历下一个数字所对应的所有映射的字母。<br>将当前的字母添加到组合最后，也就是<code>combination=combination+letter</code>。<br>重复这个过程，输入剩下的数字：<code>backtrack(combination + letter, next_digits[1:])</code>。</p><p><strong>代码</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">letterCombinations</span><span class="hljs-params">(self, digits)</span>:</span>        phone = &#123;            <span class="hljs-string">'2'</span>: [<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>],            <span class="hljs-string">'3'</span>: [<span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>],            <span class="hljs-string">'4'</span>: [<span class="hljs-string">'g'</span>, <span class="hljs-string">'h'</span>, <span class="hljs-string">'i'</span>],            <span class="hljs-string">'5'</span>: [<span class="hljs-string">'j'</span>, <span class="hljs-string">'k'</span>, <span class="hljs-string">'l'</span>],            <span class="hljs-string">'6'</span>:[<span class="hljs-string">'m'</span>,<span class="hljs-string">'n'</span>,<span class="hljs-string">'o'</span>],            <span class="hljs-string">'7'</span>:[<span class="hljs-string">'p'</span>,<span class="hljs-string">'q'</span>,<span class="hljs-string">'r'</span>,<span class="hljs-string">'s'</span>],            <span class="hljs-string">'8'</span>:[<span class="hljs-string">'t'</span>,<span class="hljs-string">'u'</span>,<span class="hljs-string">'v'</span>],            <span class="hljs-string">'9'</span>:[<span class="hljs-string">'w'</span>,<span class="hljs-string">'x'</span>,<span class="hljs-string">'y'</span>,<span class="hljs-string">'z'</span>]        &#125;        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(combination, next_digits)</span>:</span>            <span class="hljs-keyword">if</span> len(next_digits) == <span class="hljs-number">0</span>:                output.append(combination)            <span class="hljs-keyword">else</span>:                print(next_digits)                print(next_digits[<span class="hljs-number">0</span>])                <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> phone[next_digits[<span class="hljs-number">0</span>]]:                    backtrack(combination+i, next_digits[<span class="hljs-number">1</span>:])        output = []        <span class="hljs-keyword">if</span> digits:            backtrack(<span class="hljs-string">""</span>, digits)        <span class="hljs-keyword">return</span> output</code></pre><h2 id="方法二：队列"><a href="#方法二：队列" class="headerlink" title="方法二：队列"></a>方法二：队列</h2><p>我们可以利用队列的先进先出特点，再配合循环完成题目要求。<br>我们先将2对应的字符”a”,”b”,”c”依次放入队列中</p><p><img src="/article/af3344ce/18b4155eb5122b9e177a29c7320de89048b74cc5553632700a45e07aa92057bc-队列-1.jpg" srcset="/img/loading.gif" alt="队列-1.jpg"></p><p>之后再从队列中拿出第一个元素”a”，跟3对应的字符”d”,”e”,”f”挨个拼接</p><p><img src="/article/af3344ce/5d331f111c4bc5439116bc412a57e1271f0e1997b1328009cedce5152bce292f-队列-1.jpg" srcset="/img/loading.gif" alt="队列-1.jpg"></p><p>拼接结束后队列中的存储情况：</p><p><img src="/article/af3344ce/89f52c9185b736edec7e980db7cf1a9897d5efbf1e80e1d19296ee48917fdfb9-队列-3.jpg" srcset="/img/loading.gif" alt="队列-3.jpg"></p><p>按照同样的方式，再将”b”从队列中拿出，再跟3对应的字符”d”,”e”,”f”挨个拼接，放回队列中：</p><p><img src="/article/af3344ce/7fbe1e06dc207dbc539c7f580698eaad845ae5ff913b1b048211355a72fb3bcb-队列-4.jpg" srcset="/img/loading.gif" alt="队列-4.jpg"></p><p>动态演示如下：</p><p><img src="/article/af3344ce/6953e7a27bff1242c37f88c9b66b524975655605d053a9f6ac6a74376582b4c5-队列-动态图.gif" srcset="/img/loading.gif" alt="队列-动态图.gif"></p><p><strong>代码</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span><span class="hljs-params">(object)</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">letterCombinations</span><span class="hljs-params">(self, digits)</span>:</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> digits:            <span class="hljs-keyword">return</span> []        d = [<span class="hljs-string">""</span>,<span class="hljs-string">""</span>,<span class="hljs-string">"abc"</span>,<span class="hljs-string">"def"</span>,<span class="hljs-string">"ghi"</span>,<span class="hljs-string">"jkl"</span>,<span class="hljs-string">"mno"</span>,<span class="hljs-string">"pqrs"</span>,<span class="hljs-string">"tuv"</span>,<span class="hljs-string">"wxyz"</span>]        <span class="hljs-comment"># 队列初始化，放入一个空字符</span>        res = [<span class="hljs-string">""</span>]        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> digits:            size = len(res)            letters = d[ord(i) - <span class="hljs-number">48</span>]            <span class="hljs-comment"># 计算出队列长度后，将队列中的每个元素逐个取出</span>            <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> range(size):                tmp = res.pop(<span class="hljs-number">0</span>)                <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> letters:                    res.append(tmp + j)        <span class="hljs-keyword">return</span> res</code></pre><p>差不多，bfs和dfs的区别把，今日打卡完结~</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href>官方题解</a><br><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/solution/tong-su-yi-dong-dong-hua-yan-shi-17-dian-hua-hao-m/">队列</a></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>分治、回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>schedule</title>
    <link href="/article/5a3811fb.html"/>
    <url>/article/5a3811fb.html</url>
    
    <content type="html"><![CDATA[<div id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <div class="hbe-input-container">  <input type="password" id="hbePass" placeholder="" />    <label for="hbePass">You must enter the password to read.</label>    <div class="bottom-line"></div>  </div>  <script id="hbeData" type="hbeData" data-hmacdigest="6167b0466fadeb4fe37eda5ce96633b94e6209f5eb1773aaedf986c8b1d826a0">068b6e0a10ea8c25d50288086b99a6ad13c9dacc118f60bf5caa9f2fc74ebf26f1ac5b8d91c5d679d0983baf0f3a1e27b5a33a081bc9f305a28360a8cb3092a1b62abb0d3359f9bdf1ec38d2fbed3e094ddca4f2024dd6ed80c73cd89f8277a46a386784c7b9dfe797edae944219d16cabd004fb7d5d4206db11da6553789b95e12080e9738c1449afcf32605e807a9330d8dd79c85de95b31456199355ed7e6541d68c8afb637417f65961666135584ca7de081e14403b4ee387f19d5c562f9788e4e87a791add0a5b731e2d9b534acd951689d6bed547253221e96615f0804d6c12af93c8956b14a92e0523390bc0ded7a168fa191d43f206d606ab9ca3bdac9eccd26fa2888e9b0cdcd44ebf0fd890586cd0ea4342f22d369d52d6030b73c46854d56a1dbaf1937bc46325cc94abb63f5d176200e0684d26179226536749357f16076c18f80d5c67d731cb347aad02ca3684333980249d462f3b1bf3382de865e0e419008868312469fff99a35c8786ba171a61f036f7d17dee23041ebee5b8b66b3be5e77eef5b2819f33f28fedcf7faef34e57d8d07cc9c09220ee2dec2aedcf19897a22c3b880a4aa6d87807e7e87680ff51f5914f1726fb86f212c0270553ca4d11ad95338a607e3d374508f1609b4b7fbf69e834df0efd5d1b0360ff7b261257b2cc76fd9ca7023160cc757b84a78e746442b7eb61ff71df69e05cc63823f494f14874c94e127954a3e65449385d7ff21d0dd7fd44283667c68f1b44f89466f387c26789927b2638596da139b80ae5ef2b3eb69e0c35eb23b04cc686cba193b5e0ed2eccdabd2fe5af85ff1fe45f57997c143d208efefcb1e4fb712d5fbc66bcb2ba756b3d586077f80629b90c866d2c38fd816d0fffbe40a19c97258ec5886f37a549b66d8953c38154eaf258ee816471992804c888f9b0400073764f92bafe865159c7f1cf20015c486095b427562c13d0d9ffbfa28ab3200f7ed740fe83f41a50f11fbc770eda59e95c46944f7bf2981b97bc2e7ca3f7d303701096c740e5111b08a80d78db0ef0573a28fb86a2c550ccb262efcbaf0e7c5d4cb3026386e2393bccea219c12d4f3f7ab19ddcca156583fe8f1571c2b7df36104bb27dc8a34525edc1ee97a026cf110f05594181c2436849ce43d51566d10e216ed240fa58992d674c6e6b4e88bd439b680a762b72f68d3f3000486f89fe7d196ca6828679b8e0506981c26cba9741df6e864ffe8652e339b2ec5d29a52856d20332d82005eb8c94b07fd1ad7cae4060db85909faf15b62bbff8c124750462711ae64db18173a5962d604420f3cdef5a67cdd2d06ee28e54e9ba76615702bf6e9ad4e64cc47df23b97eae26510cf4cc5e99a7dde07d1b14d8ec086a0d327ae24b9b081cea4635eb06115655602b711fcd48908da42fe4a6a92e8614712efc1602cd790288b17073f07f07c502cbd70c663ffd8c397c0b3fdb4ddcc79d016c1fd74e7032da8611591ef42bc5f0e0a7c3fbda9d8b25e7e0c92d1d8ca29a669b6a5cca52f676e89270f43b0b454562c87b7d672932c35863083e95f411119871f5b5d9d0b45cfd03d6cb2363994336122ac14d0668816b7784d1f1dc6540d810042c23c54782d1a8e303b311614a38c4e208f5d2aa2377688ca4ea23ce8b757c42e921c0e001473df12f3783b345ba597977d04a43b5ea9245533ab6d02c476fdf9ca50e4b79cc1a8a39e414a8328de46c51c5862b53cc3342cc974a5eb2cedf3bca34a2a07c869dbbab3720316b14bb0a1f9e0067aef3c87d0251d35d23f3975ac1bcfa48b1872ccdec790ef03336315906b395d1383d70f85511ae9e0498ab3b8599ef634c820326ec7d2b3e91f7e6a9693826a9a109c2b4ffcdd8e6f935d929138a4a140fade8168cf9767dac70edc0a31cabdfcd657b2138618b1b9a76267d17794e6f1201d8eb17651b356241836f184fa15875ad72df47cdeb0cbccf163cd34582f1a5219bca02d2e866fa0e6b1ded6a918573cab62bf4b1efedbf29c6dd03705451ed803fff6cbfca91c21b0691c024c25e00adfa55312480549b0f432014f204f6cea390b050917f30b7a09f7357197f8a03afdc9ad20dce04bc90e66598eb9f808661888793bf149ce0b3e3e482ecf0ca4c04200f66af58b80dfb7cbc2b705e3bbf0120ec6c79306629bed7fbe0286976d49790e11bab758a5ce39cd232072b34c2f49026c6e6204cf1e7c6e74cd86b4a6e211b7328b76c3c2db008e1f7a47ed9cfdbb955c80ac9a1b1f91e9b4e37bd393abde1a34a2ca93c77bdae4b34098f0f29acf9ac711a4f905ba5d11bf1be61772413144fdd3cbef6502f5fb3777a27f028bc786ca0a96f02a852ed4b9b2ae1405a35a3d096d2733cee24d300f675eea6b23ce252129836b08b7b02b8cc33703dd7fc3d82784c6fac866b719cd583d156dd8939c4603851363f609ab87d338455475f33c8ed4a503d66a4f60d9bd524fb861bcd9b0e04ce99c6fa4180b0e6f881dd4a071b03a3dab8b4dc88f68a8cfe3a66f5e98a255e59805062571d90f0964dd6dcc1edb8da59d1928ff148f85950e33581080ce09512a56378748cd0157fdd083bc1ad49f69ca17d2dfa674ca89044a8be65b6eb35fa8f1c63f86528dc873251b0a3ae9c9f258284c354b380747453e785fecdef80fc70ba514c2b9fb9c85bc41989fe190e1b333c6ecd7b68cfa5c82aa19391a2741741e467e5788905f75065a350a18cfbc3966ff5fe6a90a762202bb7efe3d80859b6b0b462b0f0e5d3bf5380ba013731632abe37a780d221dc935d66cea09e467f4fd5b083dab3b69a130a6f712eeae4cfea2a7bc22fdfd673ea3a69afc16b2f1a10ae64e131a8bf29eec242de807bfcdd3f2ed46affa1b248526992e5442b27b696475910515321e61f9d1ab434a64d9238734534abd1c1921e998ef7d1a4fe7be5eb82a0f992d6887f8ed25562386130bf94c04849fcba4ff9dc83b43ba39a43ff24b8e4c25a4cc3a926b9975712395f905e8e4536e03b09c322e7e10ab82f28a8d97f1f74661b6ed2f34edb9ac2b451f734423348c24e4a70710853b779fa316304f0bd4cd540a99ab05dc606957173848630318669f535917fc28db34fc64fa5b1d4800a94874fcafa161abd02a15741f8d40c85f15002b2a5b232efc8007b728fe8a0d6fcefade8162f90cf9f59f5e603582e212ce439de34f84726cd70d5d93d6f329fd27a29773615ddfdd301090911085c1552832414b113541e8e42fcf775c72bf813498a7396ed7b7f9698cded0005ec040971cba6880cd8fbabc55eec9fdaaab76855a40802875688f4e6b330a5f000d5e8e0dad5028095ee793b5d0b2643ce9d005663b54bf64e52243e8b7557f6849f39d0ffdb446f8cc2f2eb9b3e4b66466017f0e58d7ee6d6e6d52bdd75f6cee038c643a2c46c444da68970bcff60e439d653c9bf97024d998625801b34b6dcb3bba4e08c3018e11283d4e5ce3a8209666bf37ebd1a27115a064287b0c00c759eb4e6daba3c5038439024074c86ddc9844a96469753e7530ae9f99a2a95ed801a9dc8c51a462a838416f8fee8383f26a93cb92c9ef5ddc4377a1725b60378a2632660813cb1417dcad941ffef0e622a11e2efc02486d6e507dbfdfbbb9533a059a4ab0daad10ae7ac13787711199acc44f87b7d85628907ca7e70b542ed246be4943e8a6c98b1414aad38d9b7076c73ce0063320c80ae2f06c612d47e814610efca9d3bf11fb41806ef24ba9a271b8af632c0c2ec726e227330a1805a9c1651c339c8f23c793b4a66639335e426b9c0c80080b0d9d755e76307f9b01ce718643c1aee4868f658c480542c13a05b7032ee278d73239f46496886a3bf7a18e6b04ae1dd77311823b04e97da4299ff89ee869a20fd1aa70b2297b5663bfe6ac15f6faebc1b3d047516815ff5a4c4812879d2869723e765ffa630858ac49a185ff614c729a3cab4d974a249551900e2dc825a5e31761e0545fd3910862ecf0282cdd862a7794cb7fe6e34742aa1a09349965808d3f75fb2631f032afa57b9a300e39a2d733ac99db2922014235282a8af828c6a81612b164e30ad8a358e5d5699cef7d8c2fbef75fd5a4b9c05086f885106c9a9201c1df45d7cd3e349ef392e7c2005750bab23557a18a452437374ae620f897a6be923b8f4386c3e97034a5f3f508e0b04b4035dc471dd31dc5c26556a24c738e93820e03ca323ec9412841a5015b6acbe21e5ebc0cad2601e4bae4dbf0af1c5d5b598af4751a4bce2e8cdb5fc465d0ac7bd48afc9698b1ddd7696fe8d6083b3cf13f03bbe1e1d86e66ff083e43c334f6a8aa67d658aa5d9b49d8c44da43fb20a915cb1868dd3eb25eab915b4aedbfa979eef68c7c0c2b8acb8f0c8552c92ed4ecd300090c900220194e0f5c67d0ba46959efbc501557ad830a9623b3be84fe1d2af561e0c217292e3206ce585b7e39265013111e193ebec40e7313104dc7b7630bbde914bdc6661682b7478ffbdbf9e75518c31a5bda879506f3378830821d112e5c28c8a57cb68d5b08ecf4374d8a535261e01b81315d2ed2969cb0a272abc55c7e8714cd8a9f3cf85e814e088ebac87c7b36b685017958fd8dbda7f3de5cbd1a0f414cb3217c64ae25e0978db5b08c2d94aa4be8fe876a1e85c55b930968153fe05b010fafc2d259ef42bac9fe00656e42a42d7fa1d77b9569bc95949cb6b7ac5aad7c944521560103438c406d38552870b1ee1d8f12f0f8cad3080cda3855fa19ba72ed04de23b9c099bc13d56dc2166aeea8e0105eebc4f1a2944de5701892781f1f28719d0dbbc0942861a1877b5eb58e3ebae234d20cc1e81441b8cc09afeeb3cbee84bf96556b35cb8cbe1f845a4b5972d17b8b877ee94fa7ab10222f0c66b74908ee5bd0519b0cedd6097d5eeea183ec1d9748aa820aaef486e6e780f0024bc256aef0b56c4c893e57fe5a55b3a4d2376386756679dc25e36ca2cd00cb010bddef8388f025534e9c917370a0042a172f4f9357f5a0908325e49a8e80c008a2b0100a13f9c64c8d89e372e8fa6db99972f98231384a64ddb66b3e76b0e91fffcbdb04792fad5e536ea472010586f7e7e188894f5153109ee9272a800537e0ad88f28b246859148cd0ee4c01be80b3ca57b59007f3cc34ea8806766a27b1e34410137f71581d1f1dc6379472c182d51a7cefb094c95e3c2a3e7ee0bd480b6dcf262505432cb2c49dd3bf98f98203614440d5a3d6dc88e58d9ab756669eac2dc97f235a8f9d0a2aa7238be7f0fd393a170d8abd6879b57d46ef4395bcf1b530ba87cb6528f1a9b4c5809a5fd5171b031ac21f4cc703a89734344ba8d8308893d638b0d9f1a8e8b6db451b4aaea186bbaf04672634210a9ff55321b38cca2e649ca8b4655d0b0fd75c434b5492263cad5305acd94cc0d8290dad48942b451fa4420e0e28ea215d98a30112caf7e84ecba26e2fe84f10f8228d13b5709801b85e8ee3792daa8ef2da6666008eba4f3b206fa6dd1b42f21d27dba438defffdafcb625934990209b3511e5591b94433b1654da3a67c9b4914c6f4a246b557015e4d91f0392a4131f0441c93cb5715f0e66139da565b3306197ec4108a50656029bdcae3ee0d365963b86088a8181463cc6175ec14ba7a913a42249c33733bbe4c6d8fab58aacd26e581dada84567217a6009f3c1ab3b390722f3b517e7bd4de02c93da7ac69a8b0d2dc4759fb54bb6f1615017488a3344900c7d031d3460b98c64ea5cff0bbedda287a085874c433cc08a9674a695dc781bdb197c2cde318ffaf167033770d28fdc95aec9a55432456b93a85b20a0a773d28993a454c84cbf628d8d913332220ce56719950901a2d1deb44e3e5ebba06ec24b9bb91643ec8a5dae53c7d4901c9b27fa90034ac532691dce29bb9e003d30b2661186e51e554716d27091c28df30bda7bf4ebb05944862e82387178f0a628c67b5b3db772c99ddcbbdbfdaf30250c404e0a0ea846fdb1d83e43189bf23e1b0f9b9bfa6b92c368adaf34552f33834f0255601bff85d9097f020e7f0fff9b3d081d4f0a664b0034273c969778dbed4183a4313d0595b3b9df4568d116ea5268048a3397c68256ac6cd04813285207aa059b6fb1080864d78fe5309760470d23267ea973ed08d1306de7c4d238f7fde954fe54fcd65a77d6905379f5084c722b1f9fce31ab169de0dd73fd871ed6baba36621799522045cca9d73a434f70c4f9372f1a7c31b8d31f4dbd5bd458032a8212f1ff9db7bc06bed550a8e02bfe7672d999d844c10bb3a29292c00b9a8f91269f095c93b385d3610d73596b4b328ed9eedb3bbcb37b8903124f8c0f11c2a7bd26e473d1413af4e4ca01eb9a58f5955c85e59e85b362cf70bd3713e66e7da73118f519e82699637a99ee847b92559c29b4628177654501dfa74965d2a5a53f729102c8da858a5ff55926f8f033709892dcf557dbfcdf1f11b8b7d1876b923222f63bd45356ba7349fa31522b8abb3b005c07f0a2c386efdf618eacaac2dd758f5a49898e8d09400e0f26bed2fc455341498f3b16f49c5874135c5fa73a78a74218894e51def1145abbb6d4d8a06030c34db636c1a610614ff959a69550a7e02ec8d8316adf0d4e6b34b83ef5210e7468353288f537234064cd99e642fc958fba92f0fe2cc9bc8f20da36a3eec424c46407eaf4e4621039c852832a3fc2eb52766e0c3d3080a20585fbbbe66ee36a9e9c48e04c145eb8bb2e3464b939a07c7c1c932858549468fdb47c7462516088386021de63da484d418b8e1e650d93ee9f1568c35727bcf915332b39fdb5939c984004b29586657999b5639f2d8231956cdda05ed1c59914fc728d7fe092453c9adedbb456b496526f2cfb240cb580053a1a144dc9d6ddb7f6bde71cb9e180211a93ad2babf98a21438bab078033ca914525fb9e4d45899fc04f103ed8ad9362914ec092615897a82ebfbae96114860063c72f845ea409f9fef9a3463e12506e98537c0c17f0d870350515558bf3026dae00645bb688c71bf8760f9cc08d6961c92a50ad355e5e5dc070ef2b0e309de682534a8cb233a0fda067dd6edbc087e0b89fbb06d6c6595ede52cf3e888cac76387d6f9c72398c1145104fc27d5b7870ca2ca16bc8acf40f9aaacda813aba5cddc65789de6f5bf62c4ebab20e7b1bc054df4e4a23f8912384157f989851a297d9ffdb3bceae60b365a8f80171b20dace270346b206183403249f0cd746a10d3947d66dbc78febb0b15bf53dc87d892331b86d0effcb45c33c31ce9d7296c22d099aaa86b6c5a4122b81248707869f062b7811200f83c873d11082dd885e579514b4fb55763fe71c40f46b6e9a42b2184f8a9fbce28e275a0ba76651c9a861b0211edb9e452680b9d14a0f42bfcfa4014bbdedfa663804efc98e18cab10c04c5b74b66eaa8870824e3954b78f4df82ecffe43bc67573900e6eb3fe60d9c3004ea1cc9bf5db2e5011ca28eb46a6478a5e15e380b0463d433b48f0461a5e4d5116706f4bed1c72fca64e7bf3ffb44be4a852f06bb9a0f959d4f1e77fb86d97fa5286fb7946556a10fd92a1bb373b784a58dae5b2cf570100409745982618e6979a18fabb3fd50a4dca3ce8d4df79e61aa1b98ae33c1982e84fd437ee8d2d2f75427520985e24515835d40b58da3eec4829a772c735329f162d3686af64f645203f739ca4023cfd4a017d2c45803063bca493814bc279ccaf00761a42b013fec1368eef0576c418c59bb6b439ad12995517f60b8832672ba4d1736715ebf96a9ef4329af8905598e44319278a5bc2590b51dfac1ca9817ec3e7d2897f197957fa5cad7868a526ab1682f25958fd8b2913066b9dd7bb9f6137a41599273a8b27519048e9cb0c65da667c76df16019a378acd3bb9718af88af7208a64304491bb10f3725a19a4f08f168aa11a44881819e7d143dbd01727789d340ad994538</script></div><script src="/lib/blog-encrypt.js"></script><link href="/css/blog-encrypt.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <categories>
      
      <category>日程</category>
      
      <category>7月</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode169</title>
    <link href="/article/e86f8a37.html"/>
    <url>/article/e86f8a37.html</url>
    
    <content type="html"><![CDATA[<h1 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169.多数元素"></a>169.多数元素</h1><p>给定一个大小为 n 的数组，找到其中的多数元素。多数元素是指在数组中出现次数大于$\lfloor \dfrac{n}{2} \rfloor$的元素。<br>你可以假设数组是非空的，并且给定的数组总是存在多数元素。</p><p><strong>示例 1:</strong></p><pre><code class="hljs python">输入: [<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]输出: <span class="hljs-number">3</span></code></pre><p><strong>示例 2:</strong></p><pre><code class="hljs python">输入: [<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>]输出: <span class="hljs-number">2</span></code></pre><p><strong>说明</strong><br>本题题目没有给出数据范围，最简单的暴力方法(枚举数据中的每个元素，再遍历一遍数组统计其出现次数，时间复杂度为$O(N^2)$的算法)，会超出时间限制。<br>我首先想到的就是哈希表。</p><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><p><strong>思路</strong><br>已知出现次数最多的元素大于$\lfloor \dfrac{n}{2} \rfloor$次，可以用哈希表来快速统计每个元素出现的次数。<br><strong>算法</strong><br>使用哈希映射(HashMap)来存储每个元素以及出现的次数。对于哈希映射中的每个键值对，键表示一个元素，值表示该元素出现的次数。<br>用一个循环遍历数组<code>nums</code>并将数组中的每个元素加入哈希映射中。在这之后，遍历哈希映射中的所有键值对，返回值最大的键。同样也可以在遍历数组<code>nums</code>时候使用打擂台的方法，维护最大的值，这样省去了最后对哈希映射的遍历。</p><p><strong>代码</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(self, nums)</span>:</span>        counts = collections.Counter(nums)        <span class="hljs-keyword">return</span> max(counts.keys(), key=counts.get)</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n)$，其中 $n$是数组<code>nums</code> 的长度。我们遍历数组 <code>nums</code> 一次，对于<code>nums</code>中的每一个元素，将其插入哈希表都只需要常数时间。如果在遍历时没有维护最大值，在遍历结束后还需要对哈希表进行遍历，因为哈希表中占用的空间为$O(n)$（可参考下文的空间复杂度分析），那么遍历的时间不会超过$O(n)$。因此总时间复杂度为$O(n)$。</li></ul><ul><li>空间复杂度：$O(n)$。哈希表最多包含$n - \lfloor \dfrac{n}{2} \rfloor$个键值对，所以占用的空间为$O(n)$。这是因为任意一个长度为$n$的数组最多只能包含$n$个不同的值，但题中保证<code>nums</code>一定有一个众数，会占用（最少）$\lfloor \dfrac{n}{2} \rfloor + 1$个数字。因此最多有$n - (\lfloor \dfrac{n}{2} \rfloor + 1)$个不同的其他数字，所以最多有$n - \lfloor \dfrac{n}{2} \rfloor$个不同的元素。</li></ul><h2 id="方法二：排序"><a href="#方法二：排序" class="headerlink" title="方法二：排序"></a>方法二：排序</h2><p><strong>思路</strong><br>如果将数组如果将数组<code>nums</code>中的所有元素按照单调递增或单调递减的顺序排序，那么下标为 $\lfloor \dfrac{n}{2} \rfloor$的元素（下标从 0 开始）一定是众数。</p><p><strong>算法</strong><br>先将<code>nums</code>数组排序，返回$\lfloor \dfrac{n}{2} \rfloor$下标对应的元素。下图解释了这种策略有效的原因，第一个例子是$n$为奇数的情况，第二个例子是$n$为偶数的情况。</p><p><img src="/article/e86f8a37/a70cb9316157ecd7eeffe7900d3ca83849079824964e8a0aaefbcffd4040f175-image.png" srcset="/img/loading.gif" alt="image.png"></p><p>对于每种情况，数组下划线表示众数是数组最小值时覆盖的下标，数组上划线表示众数时数组最大值时覆盖的下标。其他情况，这条线会在这两种极端情况的中间，即下划线右移，上划线左移。两个极端情况会在下标为$\lfloor \dfrac{n}{2} \rfloor$的地方重叠。因此，无论众数时多少，返回$\lfloor \dfrac{n}{2} \rfloor$下标对应的值都是正确的。</p><p><strong>代码</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(self, nums)</span>:</span>        nums.sort()        <span class="hljs-keyword">return</span> nums[len(nums)//<span class="hljs-number">2</span>]</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(nlogn)$。将数组排序的时间复杂度为$O(nlogn)$。</li><li>空间复杂度：$O(nlogn)$。雨果使用语言自带的排序算法，需要使用$O(nlogn)$的栈空间，如果自己编写堆排序，则只需要$O(1)$的额外空间。</li></ul><h2 id="方法三：随机化"><a href="#方法三：随机化" class="headerlink" title="方法三：随机化"></a>方法三：随机化</h2><p><strong>思路</strong><br>因为超过$\lfloor \dfrac{n}{2} \rfloor$的数组下标被众数占据了，这样我们随机挑选一个下标对应的元素并验证，有很大的概率能找到众数。</p><p><strong>算法</strong><br>由于一个给定的下标对应的数字很有可能是众数，随机挑选一个下标，检查它是否是众数，如果是就返回，否则继续随机挑选。</p><p><strong>代码</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> random<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(self, nums)</span>:</span>        majority_count = len(nums)//<span class="hljs-number">2</span>        <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:            candidate = random.choice(nums)            <span class="hljs-keyword">if</span> sum(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> elem <span class="hljs-keyword">in</span> nums <span class="hljs-keyword">if</span> elem == candidate) &gt; majority_count:                <span class="hljs-keyword">return</span> candidate</code></pre><p>时间复杂度：理论上最坏情况下的时间复杂度为$O(\infty)$，因为如果我们的运气很差，这个算法会一直找不到众数，随机挑选无穷多次，所以最坏时间复杂度是没有上限的。然而，<strong>运行的期望时间是线性的。</strong><br>为了更简单地分析，先说服你自己：<strong>由于众数占据超过数组一半的位置，期望的随机次数会小于众数占据数组恰好一半的情况。</strong>因此，我们可以计算随机的期望次数（下标为<code>prob</code>为原问题，<code>mod</code>为众数恰好占据数组一半数目的问题）：</p><script type="math/tex; mode=display">\begin{aligned}    E(\textit{iters}_{prob}) &\leq E(\textit{iters}_{mod}) \\                    &= \lim_{n\to\infty} \sum_{i=1}^{n} i \cdot \frac{1}{2^i} \\                    &= 2\end{aligned}</script><p>计算方法为：当众数恰好占据数组的一半时，第一次随机我们有$\frac{1}{2}$的概率找到众数，如果没有找到，则第二次随机时，也就是第二次找到众数的概率为$\frac{1}{4}$，以此类推。因此期望的次数为$i <em> \frac{1}{2^i}$的和，可以计算出这个和为2，说明<em>*期望的随机次数是常数</em></em>。每一次随机后，我们需要$O(n)$的时间判断这个数是否为众数，因此期望的时间复杂度为$O(n)$。</p><p>计算方法为：当众数恰好占据数组的一半时，第一次随机我们有$\frac{1}{2}$的概率找到众数，如果没有找到，则第二次随机时，也就是第二次找到众数的概率为$\frac{1}{4}$，以此类推。因此期望的次数为$i * \frac{1}{2^i}$的和，可以计算出这个和为2，说明期望的随机次数是常数。每一次随机后，我们需要$O(n)$的时间判断这个数是否为众数，因此期望的时间复杂度为$O(n)$。</p><p>空间复杂度：$O(1)$。随机方法只需要常数级别的额外空间。</p><h2 id="方法四：分治"><a href="#方法四：分治" class="headerlink" title="方法四：分治"></a>方法四：分治</h2><p><strong>思路</strong><br>如果数<code>a</code>是数组<code>nums</code>的众数，如果将<code>nums</code>分为两部分，那么<code>a</code>必定是至少一部分的众数。</p><p>可以用反证法证明这个结论。假设<code>a</code>既不是左半部分的众数，也不是右半部分的众数，那么<code>a</code>出现的次数少于<code>l/2+r/2</code>次，其中<code>l</code>和<code>r</code>分别是左半部分和右半部分的长度。由于<code>l/2+r/2&lt;=(l+r)/2</code>，说明a不是数组<code>nums</code>的众数，因此出现了矛盾。所以这个结论时正确的。</p><p>说明我们可以使用分治法解决这个问题：<strong>将数组分成左右两个部分，分别求出左半部分的众数<code>a1</code>以及右半部分的众数<code>a2</code>，随后在<code>a1</code>和<code>a2</code>中选出正确的众数。</strong></p><p><strong>算法</strong><br>使用经典的分治算法递归求解，知道所有的子问题都是长度为<strong>1</strong>的数组，长度为<strong>1</strong>的子数组中唯一的数显然就是众数，直接返回即可。<br>如果回溯后某区间长度大于<code>1</code>，将左右子区间的值合并。如果众数相同，这一段区间的众数就确定下来。否则，需要比较两个众数在整个区间内出现的次数来确定该区间的众数。</p><p><strong>代码</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(self, nums, lo=<span class="hljs-number">0</span>, hi=None)</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majority_element_rec</span><span class="hljs-params">(lo, hi)</span>:</span><span class="hljs-comment"># basic case;the only element in an array of size 1 is the majority element.</span><span class="hljs-keyword">if</span> lo == hi:<span class="hljs-keyword">return</span> nums[lo]<span class="hljs-comment"># recurse on left and right halves of this slice.</span>mid = (hi - lo) // <span class="hljs-number">2</span> + loleft = majority_element_rec(lo, mid)right = majority_element_rec(mid+<span class="hljs-number">1</span>， hi)<span class="hljs-comment"># if the two halves agree on the majority element, return it.</span><span class="hljs-keyword">if</span> left == right:<span class="hljs-keyword">return</span> left<span class="hljs-comment"># otherwise, count each element and return the 'winner'.</span>left_count = sum(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(lo, hi+<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> nums[i] == left)right_count = sum(<span class="hljs-number">1</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(lo, hi+<span class="hljs-number">1</span>) <span class="hljs-keyword">if</span> nums[i] == right)<span class="hljs-keyword">return</span> left <span class="hljs-keyword">if</span> left_count &gt; right_count <span class="hljs-keyword">else</span> right<span class="hljs-keyword">return</span> majority_element_rec(<span class="hljs-number">0</span>, len(nums)<span class="hljs-number">-1</span>)</code></pre><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(n\log⁡n)$。函数<code>majority_element_rec()</code>会求解 2 个长度为$\dfrac{n}{2}$的子问题，并做两遍长度为$n$的线性扫描。因此，分治算法的时间复杂度可以表示为：</li></ul><script type="math/tex; mode=display">T(n) = 2T(\frac{n}{2}) + 2n</script><p>​        根据<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%AE%9A%E7%90%86/3463232?fr=aladdin" target="_blank" rel="noopener">主定理(百度百科，有条件去看wiki)</a>，本题满足第二种情况，所以时间复杂度可以表示为：</p><script type="math/tex; mode=display">\begin{aligned}    T(n) &= \Theta(n^{log_{b}a}\log n) \\         &= \Theta(n^{log_{2}2}\log n) \\         &= \Theta(n \log n) \\\end{aligned}</script><ul><li>空间复杂度：$O(\log n)$。尽管分治算法没有直接分配额外的数组空间，但在递归的过程中使用了额外的栈空间。算法每次将数组从中间分成两部分，所以数组长度变为<code>1</code>之前需要进行$O(\log n)$次递归，即空间复杂度为$O(\log n)$。</li></ul><h2 id="方法五：Boyer-Moore投票算法"><a href="#方法五：Boyer-Moore投票算法" class="headerlink" title="方法五：Boyer-Moore投票算法"></a>方法五：Boyer-Moore投票算法</h2><p><strong>思路</strong><br>如果我们把众数记为$+1$，把其他数记为$−1$，将它们全部加起来，显然和大于<code>0</code>，从结果本身我们可以看出众数比其他数多。</p><p><strong>算法</strong><br>Boyer-Moore 算法的本质和方法四中的分治十分类似。我们首先给出 Boyer-Moore 算法的详细步骤：</p><ul><li><p>我们维护一个候选众数<code>candidate</code>和它出现的次数<code>count</code>。初始时<code>candidate</code>可以为任意值，<code>count</code>为 0；</p></li><li><p>我们遍历数组 <code>nums</code> 中的所有元素，对于每个元素 <code>x</code>，在判断 <code>x</code> 之前，如果 <code>count</code> 的值为 <code>0</code>，我们先将 <code>x</code> 的值赋予 <code>candidate</code>，随后我们判断 <code>x</code>：</p><ul><li>如果 <code>x</code> 与 <code>candidate</code> 相等，那么计数器 <code>count</code> 的值增加 1；</li><li>如果 <code>x</code> 与 <code>candidate</code> 不等，那么计数器 <code>count</code> 的值减少 1。</li></ul></li><li><p>在遍历完成后，<code>candidate</code> 即为整个数组的众数。</p></li></ul><p>我们举一个具体的例子，例如下面的这个数组：</p><p class="note note-info">[7, 7, 5, 7, 5, 1 | 5, 7 | 5, 5, 7, 7 | 7, 7, 7, 7]</p><p>在遍历到数组中的第一个元素以及每个在 <code>|</code> 之后的元素时，<code>`candidate</code> 都会因为 <code>count</code> 的值变为 <code>0</code> 而发生改变。最后一次 <code>candidate</code> 的值从 <code>5</code> 变为 <code>7</code>，也就是这个数组中的众数。<br>简单的证明见官方题解。</p><p><strong>代码</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sollution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(self, nums)</span>:</span>        count = <span class="hljs-number">0</span>        candidate = <span class="hljs-literal">None</span>                <span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:            <span class="hljs-keyword">if</span> count == <span class="hljs-number">0</span>:                candidate = num            count += (<span class="hljs-number">1</span> <span class="hljs-keyword">if</span> num == candidate <span class="hljs-keyword">else</span> <span class="hljs-number">-1</span>)        <span class="hljs-keyword">return</span> candidate</code></pre><p>大部分借鉴了官方的解题思路，就是会简化一下，加上一点点自己的想法。如果直接扫一遍，就是从脑子里过一遍就没得了。。。记录下来印象会深刻一些。每日一题结束！</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/" target="_blank" rel="noopener">leetcode169官方题解</a></p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>分治、回溯</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git教程</title>
    <link href="/article/a022e3d6.html"/>
    <url>/article/a022e3d6.html</url>
    
    <content type="html"><![CDATA[<p>之前学过了git，然后懒得用，but学了不用=白学，所以写这篇文章有两个目的，首先是总结git的用法，其次是督促自己用起来。<br>本周更~</p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode78</title>
    <link href="/article/69d6fed9.html"/>
    <url>/article/69d6fed9.html</url>
    
    <content type="html"><![CDATA[<h1 id="leetcode-78-子集"><a href="#leetcode-78-子集" class="headerlink" title="leetcode 78.子集"></a>leetcode 78.子集</h1><p>给定一组<strong>不含重复元素</strong>的整数数组nums，返回该数组所有可能的子集（幂集）。<br><strong>说明：</strong>解集不能包含重复的子集。<br><strong>示例：</strong></p><pre><code class="hljs python">输入: nums = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]输出:[  [<span class="hljs-number">3</span>],  [<span class="hljs-number">1</span>],  [<span class="hljs-number">2</span>],  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],  [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>],  [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>],  []]全排列/组合/子集问题，比较相似，可以使用一些通用策略解决。首先，解空间非常大：</code></pre><ul><li>全排列：$N!$</li><li>组合：$N!$</li><li>子集：$2^N$，每个元素都可能存在或不存在。</li></ul><p>在它们的指数级解法中，要确保生成的结果 <strong><em>完整</em></strong> 且 <strong><em>无冗余</em></strong>，有三种常用的方法：</p><ul><li>递归</li><li>回溯</li><li>基于二进制位掩码和对应位掩码之间的映射字典生成排列/组合/子集</li></ul><p>相比前两种方法，第三种方法将每种情况都简化为二进制数，易于实现和验证。<br>此外，第三种方法具有最优的时间复杂度，可以生成按照字典顺序的输出结果。</p><h2 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h2><p><strong>思路</strong><br>开始假设输出子集为空，每一步都向子集添加新的整数，并生成新的子集。</p><p><img src="/article/69d6fed9/recursion.png" srcset="/img/loading.gif" alt="img"></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subsets</span><span class="hljs-params">(self, nums)</span>:</span>n = len(nums)output = [[]]<span class="hljs-keyword">for</span> num <span class="hljs-keyword">in</span> nums:output += [curr + [num] <span class="hljs-keyword">for</span> curr <span class="hljs-keyword">in</span> output]<span class="hljs-keyword">return</span> output</code></pre><p><strong>复杂度分析</strong></p><ul><li><p>时间复杂度：$O(N \times 2^N)$，生成所有子集，并复制到输出结果中。???</p></li><li><p>空间复杂度：$O(N \times 2^N)$，这是子集的数量。???</p><ul><li>对于给定的任意元素，它在子集中有两种情况，存在或者不存在（对应二进制中的 0 和 1）。因此，<em>N</em> 个数字共有$2^N$个子集。</li></ul></li></ul><h2 id="方法二：回溯"><a href="#方法二：回溯" class="headerlink" title="方法二：回溯"></a>方法二：回溯</h2><p><strong>算法</strong></p><blockquote><p>幂集是所有长度从0到n所有子集的组合。</p></blockquote><p>根据定义，该问题可以看作是从序列中生成幂集。<br>遍历子集长度，通过回溯生成所有给定长度的子集。<br><img src="/article/69d6fed9/combinations.png" srcset="/img/loading.gif" alt="img"></p><blockquote><p>回溯法是一种探索所有潜在可能性找到解决方案的算法。如果当前方案不是正确的解决方案，或者不是最后一个正确的解决方案，则回溯法通过修改上一步的值，则回溯法通过修改上一步的值继续寻找解决方案。</p></blockquote><p><img src="/article/69d6fed9/backtracking.png" srcset="/img/loading.gif" alt="img"></p><p><strong>算法</strong><br>定义一个回溯方法<code>backtrack(first, curr)</code>，第一个参数为索引 <code>first</code>，第二个参数为当前子集 <code>curr</code>。</p><ul><li>如果当前子集构造完成，将它添加到输出集合中。</li><li>否则，从 <code>first</code> 到 <code>n</code> 遍历索引 <code>i</code>。<ul><li>将整数 <code>nums[i]</code> 添加到当前子集 <code>curr</code>。</li><li>继续向子集中添加整数：<code>backtrack(i + 1, curr)</code></li><li>从 <code>curr</code> 中删除 <code>nums[i]</code> 进行回溯。</li></ul></li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subsets</span><span class="hljs-params">(self, nums: List[int] -&gt; List[List[int]])</span>:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(first = <span class="hljs-number">0</span>, curr = [])</span>:</span>            <span class="hljs-comment"># if the combination is done</span>            <span class="hljs-keyword">if</span> len(curr) == k:                output.append(curr[:])            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(first, n):                <span class="hljs-comment"># add nums[i] into the current combination</span>                curr.append(nums[i])                <span class="hljs-comment"># use next integers to complete the combination</span>                backtrack(i+<span class="hljs-number">1</span>, curr)                <span class="hljs-comment"># backtrack</span>                curr.pop()        output = []        n = len(nums)        <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> range(n + <span class="hljs-number">1</span>):            backtrack()       <span class="hljs-keyword">return</span> output</code></pre><p>这里改进了一下，找到了就直接返回上一级。</p><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：$O(N \times 2^N)$，生成所有子集，并复制到输出集合中。</li><li>空间复杂度：$O(N \times 2^N)$，存储所有子集，共n个元素，每个元素都有可能存在或者不存在。</li></ul><p>晚上又看到了一种回溯算法：</p><p>简化了上面的写法，不用k，也是bfs类似思想，每层的结果都放入output中。但是leetcode的运行时间变长了。(#`O′)</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subsets</span><span class="hljs-params">(self, nums)</span>:</span>        res = []        n = len(nums)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(i, tmp)</span>:</span>            res.append(tmp)            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(i, n):                backtrack(j+<span class="hljs-number">1</span>, tmp + [num[j]])       backtrack(<span class="hljs-number">0</span>, [])        <span class="hljs-keyword">return</span> res</code></pre><ul><li><p>append操作是在原List上的修改，不会返回一个新的值。</p></li><li><p>+运算是对于两个类型相同的变量之间的运算，不改变原有的变量，并返回一个新的值，是内容之间的拼接。</p></li><li>extend 也是在原有List上进行修改，没有返回值，可以扩展不同类型的变量，并将其内容以List变量的形式加入到原List中。<br>例子：从输出中可见如果extend的是字符串，则字符串会被拆分成字符数组，如果extend的是字典，则字典的key会被加入到List中。</li></ul><p><strong>所以这里的tmp+[]不能用tmp.append()替换！</strong>哎，猛男落泪，我验证了半天。</p><p><strong>本题中回溯类似于bfs，当然用dfs也是可以做的。</strong></p><h2 id="方法三：字典排序（二进制排序）子集"><a href="#方法三：字典排序（二进制排序）子集" class="headerlink" title="方法三：字典排序（二进制排序）子集"></a>方法三：字典排序（二进制排序）子集</h2><p><strong>思路</strong></p><p>该方法思路来自于Donald E. Knuth。</p><blockquote><p>将每个子集映射到长度为 n 的位掩码中，其中第 i 位掩码 nums[i] 为 1，表示第 i 个元素在子集中；如果第 i 位掩码 nums[i] 为 0，表示第 i 个元素不在子集中。</p></blockquote><p><img src="/article/69d6fed9/bitmask4.png" srcset="/img/loading.gif" alt="img"></p><p>例如，位掩码 0..00（全 0）表示空子集，位掩码 1..11（全 1）表示输入数组 nums。</p><p>因此要生成所有子集，只需要生成从 0..00 到 1..11 的所有 n 位掩码。</p><p>生成二进制数很简单，但如何处理左边填充 0 是一个问题。因为必须生成固定长度的位掩码：例如 001，而不是 1。因此可以使用一些位操作技巧：</p><pre><code class="hljs python">nth_bit = <span class="hljs-number">1</span> &lt;&lt; n<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>**n):    <span class="hljs-comment"># generate bitmask, from 0..00 to 1..11</span>    bitmask = bin(i | nth_bit)[<span class="hljs-number">3</span>:]</code></pre><p>以示例为例，就是把[0,7]跟8进行或操作，目的是为了取到前面的0，然后取0b1xxx后三位。</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>**n, <span class="hljs-number">2</span>**(n + <span class="hljs-number">1</span>)):    <span class="hljs-comment"># generate bitmask, from 0..00 to 1..11</span>    bitmask = bin(i)[<span class="hljs-number">3</span>:]</code></pre><p>或者直接从8到16，取后三位，效果是一样的。<br><strong>算法</strong></p><ul><li>生成所有长度为 n 的二进制位掩码。</li><li>将每个子集都映射到一个位掩码数：位掩码中第 <code>i</code> 位如果是 <code>1</code> 表示子集中存在 <code>nums[i]</code>，<code>0</code> 表示子集中不存在 <code>nums[i]</code>。</li><li>返回子集列表。</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">subsets</span><span class="hljs-params">(self, nums)</span>:</span>        n = len(nums)        output = []        n_bit = <span class="hljs-number">1</span> &lt;&lt; n        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">2</span>**n):            <span class="hljs-comment"># generate bitmask form 0..00 to 1..11</span>            bitmask = bin(i|n_bit)[<span class="hljs-number">3</span>:]            <span class="hljs-comment"># append subset corresponding to that bitmask</span>            output.append([num[j] <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(n) <span class="hljs-keyword">if</span> bitmask[n] == <span class="hljs-string">'1'</span>])   <span class="hljs-keyword">return</span> output</code></pre><p>结束！嗯~ o(<em>￣▽￣</em>)o，收回昨天的话，不难，就是第一次碰到是需要花时间理解，然后就是动手很重要。今日打卡get~</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/subsets/solution/zi-ji-by-leetcode/" target="_blank" rel="noopener">leetcode50官方解析</a></p><p>以前觉得只写代码就好了，注释真是太麻烦了。现在的我，只写代码就是耍流氓，要让人理解理解，可读性很很很很重要。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>分治、回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Task04-HOG特征描述算子-行人检测</title>
    <link href="/article/760e3967.html"/>
    <url>/article/760e3967.html</url>
    
    <content type="html"><![CDATA[<p>HOG（Histogram of Oriented Gradients）HOG特征在对象检测与模式匹配中是一种常见的特征提取技术（深度学习之前），是基于本地像素块进行特征直方图提取的一种算法，对象局部的变形与光照影响有很好的稳定性，最初是用HOG特征来来识别人像，通过HOG特征提取+SVM训练，可以得到很好的效果，OpenCV已经有相应的接口。</p><p>HOG特征实在2005年CVPR的会议发表，在图像手工特征提取方面具有里程碑式的意义，当时在行人检测领域获得了极大成功。</p><h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><h2 id="1-HOG特征描述符"><a href="#1-HOG特征描述符" class="headerlink" title="1. HOG特征描述符"></a>1. HOG特征描述符</h2><h3 id="主要思想"><a href="#主要思想" class="headerlink" title="主要思想"></a>主要思想</h3><p>&emsp;&emsp;局部目标的外表和形状可以被局部梯度的分布很好的描述，即使我们不知道对应的梯度和边缘的位置。(本质：梯度的统计信息，梯度主要存在于边缘edge或角落corner的地方)<!--局部目标的外表和形状可以被局部梯度或边缘方向的分布很好的描述，即使我们不知道对应的梯度和边缘的位置。(本质：梯度的统计信息，梯度主要存在于边缘edge或角落corner的地方)--></p><h3 id="宏观"><a href="#宏观" class="headerlink" title="宏观"></a>宏观</h3><p>&emsp;&emsp;特征描述符就是通过提取图像的有用信息，并且丢弃无关信息来简化图像的表示。</p><p>&emsp;&emsp;HOG特征描述符可以将3通道的彩色图像转换成一定长度的特征向量。</p><p>&emsp;&emsp;那么我们就需要定义什么是“有用的”，什么是“无关的”。这里的“有用”，是指对于什么目的有用，显然特征向量对于观察图像是没有用的，但是它对于像图像识别和目标检测这样的任务非常有用。当将这些特征向量输入到类似支持向量机（SVM）这样的图像分类算法中时，会得到较好的结果。</p><p>&emsp;&emsp;那什么样的“特征”对分类任务是有用，比如我们想检测出马路上的车道线，那么我们可以通过边缘检测来找到这些车道线，在这种情况下，边缘信息就是“有用的”，而颜色信息是无关的。</p><p>&emsp;&emsp;方向梯度直方图(HOG)特征描述符常和线性支持向量机(SVM)配合使用，用于训练高精度的目标分类器。</p><h3 id="微观（硬核）"><a href="#微观（硬核）" class="headerlink" title="微观（硬核）"></a>微观（硬核）</h3><p>在HOG特征描述符中，梯度方向的分布，也就是梯度方向的直方图被视作特征。图像的梯度(x和y导数)非常有用，因为边缘和拐角(强度突变的区域)周围的梯度幅度很大，并且边缘和拐角比平坦区域包含更多关于物体形状的信息。</p><p>HOG特征是一种图像局部特征，基本思路是将图像划分为很多小的连通区域，即细胞单元Cell，然后对Cell的<strong>梯度幅值和方向</strong>进行投票统计，形成基于梯度特性的直方图。把直方图在图像更大的范围内(又名区间或者Block)进行归一化。<strong>归一化的块描述符叫做HOG描述子feature descriptor。</strong>将检测窗口中的所有块的HOG描述子组合成最终的特征向量。然后使用SVM分类器进行目标和非目标的二分类（检测）。</p><p>HOG+SVM的工作流程如下：</p><p><img src="/article/760e3967/1328274-20180917143312309-1232187669.png" srcset="/img/loading.gif" alt="img"></p><p>首先对输入的图片进行预处理，然后计算像素点的梯度特性，包括梯度幅值和梯度方向。然后投票统计形成梯度直方图，然后对blocks进行normalize，最后收集到检测窗口的HOG feature(一行多维的vector)放入SVM里进行监督学习，实现行人的检测。接下来对上述HOG的主要步骤进行学习。（车轱辘话又来了一遍┗|｀O′|┛ 嗷~~）</p><p><font color="red">检测窗口在整个图像的所有位置和尺度进行扫描，并对输出的金字塔进行非极大值抑制来检测目标</font>（检测窗口的大小一般为128x64）</p><h2 id="2-HOG特征的原理"><a href="#2-HOG特征的原理" class="headerlink" title="2. HOG特征的原理"></a>2. HOG特征的原理</h2><p>接下来让我们进入到计算图像的HOG特征描述符的具体步骤。<br>以下面这张图片为例（宽高为100x200）:</p><p><img src="/article/760e3967/v2-2ccc671e60031942dca8a129410a0383_720w.jpg" srcset="/img/loading.gif" alt="img"></p><h3 id="图形预处理"><a href="#图形预处理" class="headerlink" title="图形预处理"></a>图形预处理</h3><p>预处理包括灰度化和Gamma变换。</p><p>灰度处理是可选操作，因为灰度图像和彩色图像都可以用于计算梯度图。对于彩色图像，先对三通道颜色值分别计算梯度，然后取梯度值最大的那个作为该像素的梯度。</p><p>然后进行伽马矫正，调节图像对比度，减少光照对图像的影响（包括光照不均和局部阴影），使过曝或者欠曝的图像恢复正常，更接近人眼看到的图像。更详细的内容参考<a href="https://www.cnblogs.com/qiqibaby/p/5325193.html" target="_blank" rel="noopener">图像处理之gamma矫正</a>。</p><p>Gamma矫正公式：$f(I) = I^{\gamma}$，其中$I$表示图像，$\gamma$表示幂指数。($\gamma$越大，图像越暗；为1时，表示没有变化。)<br>如图，当$\gamma$取不同的值时对应的输入输出曲线( $\gamma$=1时输入输出保持一致) ：<br>1） 当$\gamma$&lt;1时，输入图像的低灰度值区域动态范围变大，进而图像低灰度值区域对比度得以增强；在高灰度值区域，动态范围变小，进而图像高灰度值区域对比度得以降低。 最终，图像整体的灰度变亮。</p><p>2） 当$\gamma$&gt;1时，输入图像的低灰度值区域动态范围变小，进而图像低灰度值区域对比度得以降低；在高灰度值区域，动态范围变大，进而图像高灰度值区域对比度得以增强。 最终，图像整体的灰度变暗。</p><p><img src="/article/760e3967/image-1.jpg" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>代码：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> pltimg = cv2.imread(<span class="hljs-string">'*.png'</span>, <span class="hljs-number">0</span>)img = cv2.cvtColor(img,cv2.COLOR_BGR2RGB)img2 = np.power(img/float(np.max(img)),<span class="hljs-number">1</span>/<span class="hljs-number">2.2</span>)plt.imshow(img2)plt.axis(<span class="hljs-string">'off'</span>)plt.show()</code></pre><p>放图，左图是$\gamma=0.5$，中图是$\gamma=1$，右图是$\gamma=1.5$：</p><center class="half">    <img src="/article/760e3967/0_5_hog.jpg" srcset="/img/loading.gif" width="200" hight="400"><img src="/article/760e3967/1_hog.jpg" srcset="/img/loading.gif" width="200" hight="400"><img src="/article/760e3967/1_5_hog.jpg" srcset="/img/loading.gif" width="200" hight="400"></center><p>作者在他的博士论文里有提到，对于涉及大量的类内颜色变化，如猫，狗和马等动物，没标准化的RGB图效果更好，而牛，羊的图做gamma颜色校正后效果更好。是否用gamma校正分情况把。(●ˇ∀ˇ●)</p><h3 id="计算图像梯度"><a href="#计算图像梯度" class="headerlink" title="计算图像梯度"></a>计算图像梯度</h3><p>为了得到梯度直方图，那么首先需要计算图像水平方向和垂直方向梯度。可以通过使用以下内核过滤图像实现，分别用于计算水平梯度和垂直梯度。</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}d_x = I(x+1, y) - I(x-1,y) \\d_y = I(x, y+1) - I(x,y-1)\end{aligned}\end{equation}</script><p><img src="/article/760e3967/gradient-kernels.jpg" srcset="/img/loading.gif" alt="Gradient Kernels"></p><p>一般使用特定的卷积核对图像滤波实现，可选用的卷积模板有：sobel算子、Prewitt算子、Roberts模板等等。<br> 可以使用内核大小为1的sobel算子获取相同结果，OpenCV也是如此。<br>利用sobel水平和垂直算子与输入图像卷积计算$dx$、$dy$：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}Sobel_{X} &= \begin{bmatrix}1 \\ 0 \\ -1\end{bmatrix} *             \begin{bmatrix}1 & 2 &  1\end{bmatrix}            =  \begin{bmatrix}1 & 2 & 1\\                             0 & 0 & 0\\                             -1 & -2 & -1\end{bmatrix} \\Sobel_{Y} &= \begin{bmatrix}1 \\ 2 \\  1\end{bmatrix} *             \begin{bmatrix}1 & 0 & -1\end{bmatrix}            =  \begin{bmatrix}1 & 0 & -1\\                             2 & 0 & -2\\                             1 & 0 & -1\end{bmatrix} \\\end{aligned}\end{equation}</script><script type="math/tex; mode=display">\begin{equation}\begin{aligned}d_x = f(x, y)*Sobel_x(x,y) \\d_y = f(x, y)*Sobel_y(x,y)\end{aligned}\end{equation}</script><p>进一步得到图像梯度的幅值：$M(x,y) = \sqrt{d^{2}_{x}(x,y)+d^{2}_{y}(x,y)}$<br>（简化计算，幅值也可以做近似：$M(x,y) = |d_{x}(x,y)|+|d_{y}(x,y)|$）<br>图像梯度的方向：$\theta_{M} = \arctan(d_y/d_x)$</p><p>这里需要注意的是：梯度方向和图像边缘方向是互相正交的。</p><p><img src="/article/760e3967/20160511100108955" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>代码：</p><pre><code class="hljs python">mport cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment"># Read image</span>img = cv2.imread(<span class="hljs-string">'*.jpg'</span>)img = np.float32(img) / <span class="hljs-number">255.0</span>  <span class="hljs-comment"># 归一化</span><span class="hljs-comment"># 计算x和y方向的梯度</span>gx = cv2.Sobel(img, cv2.CV_32F, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, ksize=<span class="hljs-number">1</span>)gy = cv2.Sobel(img, cv2.CV_32F, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, ksize=<span class="hljs-number">1</span>)<span class="hljs-comment"># 计算合梯度的幅值和方向（角度）</span>mag, angle = cv2.cartToPolar(gx, gy, angleInDegrees=<span class="hljs-literal">True</span>)</code></pre><p>下图展示了梯度：</p><center class="half">    <img src="/article/760e3967/x_hog.jpg" srcset="/img/loading.gif" width="150" hight="300"><img src="/article/760e3967/y_hog.jpg" srcset="/img/loading.gif" width="150" hight="300"><img src="/article/760e3967/mag_hog.jpg" srcset="/img/loading.gif" width="150" hight="300"><img src="/article/760e3967/angle_hog.jpg" srcset="/img/loading.gif" width="150" hight="300"></center><p>第一个图：x-梯度的绝对值，第二个图：y梯度的绝对值 ，第三个图：梯度的幅值，第四个图：角度。<br>注意到，x-梯度在垂直线触发，y-梯度在水平线触发。梯度的幅值在有密集的剧烈改变时触发。当区域很平缓时，梯度没有明显变化。梯度图除去了很多不必要的信息（例如有颜色的背景），强调凸显线条。当你看到梯度图像，很容易想到这张图片有一个人。<br>在每个像素点，梯度有一个幅值和方向。对于有颜色的图像，计算三通道的梯度（如上图所示）。一个像素点的梯度的幅值是三通道中梯度幅值最大的值，角度也是最大梯度对应的角度。</p><h3 id="计算梯度直方图"><a href="#计算梯度直方图" class="headerlink" title="计算梯度直方图"></a>计算梯度直方图</h3><p>&emsp;&emsp; 此时，每一个像素点具有两个值：梯度幅值和梯度方向。<br>&emsp;&emsp; 在这一步中，图像被分成若干个8×8的Cell，如下图所示，例如我们将图像resize至64x128的大小，那么这幅图像就被划分为8x16个8x8的Cell单元，并为每个8×8的Cell计算梯度直方图。当然，Cell的划分也可以是其他值：16x16，8x16等，根据具体的场景确定。</p><p><img src="/article/760e3967/hog-cells.png" srcset="/img/loading.gif" alt="8x8 Cells of HOG"></p><p>计算梯度直方图之前，先了解一下为什么要把图像分为若干个Cell?<br>这是因为如果对一整张梯度图逐像素计算，其中的有效特征是非常稀疏的，不但运算量大，而且会受到一些噪声干扰。使用特征描述符便提供了紧凑的表示。一个8x8的图像块包含8x8x3=192个像素值。一个8x8的Cell包含了8x8x2 = 128个值（每个像素包括梯度的大小和方向）。128个值将由9-bin的直方图（存储9个值的向量，想想坐标应该就明白了）。同时，计算Cell上的梯度直方图更具鲁棒性。逐像素计算梯度会产生噪音，直方图表示对噪音更不敏感。</p><p>&emsp;&emsp; 好，回到主题。<br>&emsp;&emsp; 在HOG中，每个8x8的Cell的梯度直方图本质是一个由9个数值组成的向量， 对应于0、20、40、60…160的梯度方向(角度)。那么原本Cell中8x8x2 = 128个值就由长度为9的向量来表示，用这种梯度直方图的表示方法，大大降低了计算量，同时又对光照等环境变化更加地鲁棒。<br>如下图所示，左图是衣服64x128的图像，被划分为8x16个8x8的Cell；中间的图像表示一个Cell中的梯度矢量，箭头朝向代表梯度方向，箭头长度代表梯度大小。<br>右图是 8×8 的Cell中表示梯度的原始数值，注意角度的范围介于0到180度之间，而不是0到360度， 这被称为“无符号”梯度，因为两个完全相反的方向被认为是相同的。0$^\circ$和180$^\circ$是相同的。（经验表明这样处理对于行人检测效果更好。）</p><p><img src="/article/760e3967/20200613153022928.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>接下来，计算Cell中像素的梯度直方图，将0-180度分成9等份，称为9个bins，分别是0，20，40…160。然后对每个bin中梯度的贡献进行统计：</p><p><img src="/article/760e3967/hog-histogram-1.png" srcset="/img/loading.gif" alt="Histogram computation in HOG"></p><p>&emsp;&emsp;这里采用加权投票统计，比如上面方向图中蓝圈包围的像素，角度为80度，这个像素对应的幅值为2，所以在直方图80度对应的bin加上2。红圈包围的像素，角度为10度，介于0度和20度之间，其幅值为4，那么这个梯度值就被按比例分给0度和20度对应的bin，也就是各加上2。</p><p><img src="/article/760e3967/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8xMzA1NjcxMy1mMDgzNzBkZGVmMmVhYzE1LnBuZw" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>&emsp;&emsp;再比如：（如上图所示）某像素的梯度幅值为13.6，方向为36，36度两侧的角度bin分别为20度和40度，那么按一定加权比例分别在20度和40度对应的bin加上梯度值，加权公式为：<br>20度对应的bin：(（40-36）/20) x13.6，<strong>分母的20表示20等份，其中4份给20度对应的bin</strong>；<br>40度对应的bin：(（36-20）/20) x13.6，<strong>分母的20表示20等份,其中16份给20度对应的bin</strong>；<br>&emsp;&emsp;还有一个细节需要注意，如果某个像素的梯度角度大于160度，也就是在160度到180度之间，那么把这个像素对应的梯度值按比例分给0度和160度对应的bin。如左下图绿色圆圈中的角度为165度，幅值为85，则按照同样的加权方式将85分别加到0度和160度对应的bin中。</p><p><img src="/article/760e3967/20200613160337781.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>&emsp;&emsp;对整个Cell进行投票统计，最终得到9-bin直方图：</p><p><img src="/article/760e3967/20200613161947892.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>&emsp;&emsp;可以看到直方图中，0度和160附近有很大的权重，说明了大多数像素的梯度向上或者向下，也就是这个Cell是个横向边缘。</p><h3 id="Block归一化"><a href="#Block归一化" class="headerlink" title="Block归一化"></a>Block归一化</h3><p>&emsp;&emsp;HOG特征将8×8的一个局部区域作为一个Cell，再以2×2个Cell作为一组，称为一个block，也就是说一个block表示16x16的区域。<br>&emsp;&emsp;由于每个Cell有9个值，一个block（2×2个Cell）则有36个值，HOG是通过滑动窗口的方式来得到block的，如下图所示：</p><p><img src="/article/760e3967/aHR0cHM6Ly9waWM0LnpoaW1nLmNvbS92Mi0yMzI0MTc3NDIwYzBhNzlkNDhkODQ0YjVlMTI0ZjFmM19iLndlYnA" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>为什么需要分Block呢？<br>我们已经为图像的8×8单元构造了基于梯度的直方图，但是图像的梯度对整体光照很敏感。这意味着对于特定的图像，图像的某些部分与其他部分相比会非常明亮。虽然不能从图像中完全消除，但是可以通过使用16×16个块来对梯度进行归一化来减少这种光照变化的影响。比如通过将所有像素值除以2来使图像变暗，那么梯度幅值将减小一半，因此直方图中的值也将减小一半。 </p><p>&emsp;&emsp;接下来对Block进行归一化。（再再再一次强调，归一化的目的是为了降低光照/迁移的影响）：<br>&emsp;&emsp;归一化的方法有很多：L1-norm、L2-norm、max/min等等，一般选择L2-norm。</p><script type="math/tex; mode=display">v←\frac{v}{\sqrt{\|v\|_2^2+\xi^2}} \quad (\xi是一个很小的数，主要是为了防止分母为0)；</script><p>&emsp;&emsp;例如对于一个[128，64，32]的三维向量来说，模长是$\sqrt{128^2+64^2+32^2}=146.64$，这叫做向量的L2范数。将这个向量的每个元素除以146.64就得到了归一化向量 [0.87, 0.43, 0.22]。<br>&emsp;&emsp;现在有一个新向量，是第一个向量的2倍 [128x2, 64x2, 32x2]，也就是 <code>[256, 128, 64]</code>，我们将这个向量进行归一化，你可以看到归一化后的结果与第一个向量归一化后的结果相同。所以，对向量进行归一化可以消除整体光照的影响。<br>&emsp;&emsp;知道了如何归一化，现在来对block的梯度直方图进行归一化（注意不是Cell），一个block有4个直方图，将这4个直方图拼接成长度为36的向量，然后对这个向量进行归一化。<br>&emsp;&emsp;因为使用的是滑动窗口，滑动步长为8个像素，一个Cell大小，每滑动一次，就在这个窗口上进行归一化计算得到长度为36的向量，并重复这个过程。如上图所示。</p><h3 id="获得HOG描述子"><a href="#获得HOG描述子" class="headerlink" title="获得HOG描述子"></a>获得HOG描述子</h3><p>每一个16x16大小的block将会得到一个长度为36x1的特征向量，并进行归一化。 那会得到多大的特征向量呢？<br>对于上图被划分8 x16个Cell ，每个block有2x2个Cell的话，那么Cell的个数为：(8-1)x(16-1)=105。<br>每个16x16 block由36x1维向量，合并所有105个block的特征，最终得到由36 x105=3780维向量表示的特征描述符。<br>获得HOG特征向量，就可以用来可视化和分类了。对于多维的HOG特征，SVM就可以排上用场了。</p><p>介绍以下Dalal等人的训练方法：</p><ol><li>提取正负样本的HOG特征；</li><li>用正负样本训练一个初始的分类器，然后由分类器生产检测器；</li><li>然后用初始分类器在负样本原图上进行行人检测，检测出来的矩形区域自然都是分类错误的负样本，这就是所谓的难例(hard examples)；</li><li>提取难例的HOG特征并结合第一步中的特征，重新训练，生成最终的检测器 ；</li></ol><p>这种二次训练的处理过程显著提高了每个检测器的表现，一般可以使得每个窗口的误报率(FPPW False Positives Per Window)下降5%。</p><h3 id="使用HOG特征数据"><a href="#使用HOG特征数据" class="headerlink" title="使用HOG特征数据"></a>使用HOG特征数据</h3><p>HOG特征本身是不支持旋转不变性与多尺度检测的，但是通过构建高斯金字塔实现多尺度的开窗检测就会得到不同分辨率的多尺度检测支持，如下图所示。详细内容可参考<a href="https://www.cnblogs.com/ronny/p/3886013.html" target="_blank" rel="noopener">尺度空间理论</a></p><p><img src="/article/760e3967/1328274-20180924221334307-1701938273.png" srcset="/img/loading.gif" alt="img"></p><p>OpenCV中HOG多尺度对象检测API如下：</p><pre><code class="hljs python">virtual void cv::HOGDescriptor::detectMultiScale(    InputArray  img,    std::vector&lt; Rect &gt; &amp;   foundLocations,    double  hitThreshold = <span class="hljs-number">0</span>,    Size    winStride = Size(),    Size    padding = Size(),    double  scale = <span class="hljs-number">1.05</span>,    double  finalThreshold = <span class="hljs-number">2.0</span>,    bool    useMeanshiftGrouping = false )Img-表示输入图像foundLocations-表示发现对象矩形框hitThreshold-表示SVM距离度量，默认<span class="hljs-number">0</span>表示，表示特征与SVM分类超平面之间winStride-表示窗口步长padding-表示填充scale-表示尺度空间finalThreshold-最终阈值，默认为<span class="hljs-number">2.0</span>useMeanshiftGrouping-不建议使用，速度太慢拉</code></pre><p>在<a href="https://sulimin-nb.github.io/article/ad28cab2.html">人脸检测之Haar分类器</a>这一节我们利用haar特征和级联分类器Adaboost检测人脸时我们使用过detectMultiScale()函数，级联分类器对象尝试在输入图像的不同尺度下检测对象，该函数有一个比较重要的参数scaleFactor(一般设置为1.3)，表示一个比率：即在每层金字塔中所获得的图像与上一层图像的比率，scaleFactor越小，金字塔的层数就越多，计算就越慢，计算量也会更大，但是计算结果相对更精确。</p><h1 id="基于OpenCV的简单实现"><a href="#基于OpenCV的简单实现" class="headerlink" title="基于OpenCV的简单实现"></a>基于OpenCV的简单实现</h1><h2 id="行人检测"><a href="#行人检测" class="headerlink" title="行人检测"></a>行人检测</h2><p>代码：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2 <span class="hljs-keyword">as</span> cv<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    src = cv.imread(<span class="hljs-string">"*.jpg"</span>)    cv.imshow(<span class="hljs-string">"input"</span>, src)        hog = cv.HOGDescriptor()    hog.setSVMDetector(cv.HOGDescriptor_getDefaultPeopleDetector())    <span class="hljs-comment"># Detect people in the image</span>    (rects, weights) = hog.detectMultiScale(src,                                            winStride=(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>),                                            padding=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>),                                            scale=<span class="hljs-number">1.2</span>,                                            useMeanshiftGrouping=<span class="hljs-literal">False</span>)    <span class="hljs-keyword">for</span> (x, y, w, h) <span class="hljs-keyword">in</span> rects:        cv.rectangle(src, (x, y), (x + w, y + h), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)    cv.imshow(<span class="hljs-string">"hog-detector"</span>, src)    cv.imwrite(<span class="hljs-string">"hog-detector.jpg"</span>,src)    cv.waitKey(<span class="hljs-number">0</span>)    cv.destroyAllWindows()</code></pre><p>待检测图片：</p><p><img src="/article/760e3967/v2-2ccc671e60031942dca8a129410a0383_720w.jpg" srcset="/img/loading.gif" alt="v2-2ccc671e60031942dca8a129410a0383_720w"></p><p>检测图片(有点不完美，调参调不动了，先酱~)：</p><p><img src="/article/760e3967/hog-detector.jpg" srcset="/img/loading.gif" alt="hog-detector"></p><h2 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h2><p><strong>feature.log函数：</strong></p><ul><li><code>image</code>：可以是灰度图或者彩色图；</li><li><code>orientations</code>：就是把180度分成几份，也就是bin的数量；</li><li><code>pixels_per_Cell</code>：一个Cell里包含的像素个数；</li><li><code>Cells_per_block</code>：一个block包含的Cell个数；</li><li><code>visualize</code>：是否返回一个hog图像用于显示，下面会显示这张图；</li></ul><p>为了显示效果，把Cell的尺寸改为(16, 16)，对于每一个Cell，画出它归一化后的梯度直方图。如下图所示，我们可以很明显的看出一个人的轮廓。</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> skimage <span class="hljs-keyword">import</span> feature, exposure<span class="hljs-keyword">import</span> cv2image = cv2.imread(<span class="hljs-string">'hog.jpg'</span>)fd, hog_image = feature.hog(image, orientations=<span class="hljs-number">9</span>, pixels_per_Cell=(<span class="hljs-number">16</span>, <span class="hljs-number">16</span>),                    Cells_per_block=(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>), visualize=<span class="hljs-literal">True</span>)<span class="hljs-comment"># Rescale histogram for better display</span>hog_image_rescaled = exposure.rescale_intensity(hog_image, in_range=(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>))cv2.imshow(<span class="hljs-string">'img'</span>, image)cv2.imshow(<span class="hljs-string">'hog'</span>, hog_image_rescaled)hog_image_rescaled = <span class="hljs-number">255.0</span> * hog_image_rescaledcv2.imwrite(<span class="hljs-string">'edge_hog.jpg'</span>, hog_image_rescaled)cv2.waitKey(<span class="hljs-number">0</span>)==ord(<span class="hljs-string">'q'</span>)</code></pre><p><img src="/article/760e3967/edge_hog.jpg" srcset="/img/loading.gif" alt="edge_hog"></p><h2 id="手动实现HOG特征"><a href="#手动实现HOG特征" class="headerlink" title="手动实现HOG特征"></a>手动实现HOG特征</h2><p>虽然opencv已经实现了HOG算法，但是手动实现的目的是为了加深我们对HOG的理解。参考了博客<a href="https://www.cnblogs.com/zyly/p/9651261.html" target="_blank" rel="noopener">基于传统图像处理的目标检测与识别</a><br>代码主要包括以下步骤：</p><ol><li>图像灰度化，归一化处理；</li><li>首先计算图像每一个像素点的梯度幅值和角度；</li><li>计算输入图像的每个Cell单元的梯度直方图(注意，我们在实现梯度直方图的时候，使用到的是双线性插值，这和上面介绍的理论略微有区别)，形成每个Cell的descriptor，比如输入图像为128×64 可以得到16×8个Cell，每个Cell由9个bin组成；</li><li>将2×2个Cell组成一个block，一个block内所有Cell的特征串联起来得到该block的HOG特征descriptor，并进行归一化处理，将图像内所有block的HOG特征descriptor串联起来得到该图像的HOG特征descriptor，这就是最终分类的特征向量；</li></ol><pre><code class="hljs python"><span class="hljs-comment">#代码来源GitHub:https://github.com/PENGZhaoqing/Hog-feature</span><span class="hljs-comment">#https://blog.csdn.net/ppp8300885/article/details/71078555</span><span class="hljs-comment">#https://www.leiphone.com/news/201708/ZKsGd2JRKr766wEd.html</span><span class="hljs-keyword">import</span> cv2<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> math<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Hog_descriptor</span><span class="hljs-params">()</span>:</span>    <span class="hljs-string">'''</span><span class="hljs-string">    HOG描述符的实现</span><span class="hljs-string">    '''</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, img, Cell_size=<span class="hljs-number">8</span>, bin_size=<span class="hljs-number">9</span>)</span>:</span>        <span class="hljs-string">'''</span><span class="hljs-string">        构造函数</span><span class="hljs-string">            默认参数，一个block由2x2个Cell组成，步长为1个Cell大小 </span><span class="hljs-string">        args:</span><span class="hljs-string">            img：输入图像(更准确的说是检测窗口)，这里要求为灰度图像  对于行人检测图像大小一般为128x64 即是输入图像上的一小块裁切区域</span><span class="hljs-string">            Cell_size：细胞单元的大小 如8，表示8x8个像素</span><span class="hljs-string">            bin_size：直方图的bin个数</span><span class="hljs-string">        '''</span>        self.img = img        <span class="hljs-string">'''</span><span class="hljs-string">        采用Gamma校正法对输入图像进行颜色空间的标准化（归一化），目的是调节图像的对比度，降低图像局部</span><span class="hljs-string">        的阴影和光照变化所造成的影响，同时可以抑制噪音。采用的gamma值为0.5。 f(I)=I^γ</span><span class="hljs-string">        '''</span>        self.img = np.sqrt(img*<span class="hljs-number">1.0</span> / float(np.max(img)))        self.img = self.img * <span class="hljs-number">255</span>        <span class="hljs-comment">#print('img',self.img.dtype)   #float64</span>        <span class="hljs-comment">#参数初始化</span>        self.Cell_size = Cell_size        self.bin_size = bin_size        self.angle_unit = <span class="hljs-number">180</span> / self.bin_size  <span class="hljs-comment">#这里采用180°</span>        <span class="hljs-keyword">assert</span> type(self.bin_size) == int, <span class="hljs-string">"bin_size should be integer,"</span>        <span class="hljs-keyword">assert</span> type(self.Cell_size) == int, <span class="hljs-string">"Cell_size should be integer,"</span>        <span class="hljs-keyword">assert</span> <span class="hljs-number">180</span> % self.bin_size == <span class="hljs-number">0</span>, <span class="hljs-string">"bin_size should be divisible by 180"</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">extract</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">'''</span><span class="hljs-string">        计算图像的HOG描述符，以及HOG-image特征图</span><span class="hljs-string">        '''</span>        height, width = self.img.shape        <span class="hljs-string">'''</span><span class="hljs-string">        1、计算图像每一个像素点的梯度幅值和角度</span><span class="hljs-string">        '''</span>        gradient_magnitude, gradient_angle = self.global_gradient()        gradient_magnitude = abs(gradient_magnitude)        <span class="hljs-string">'''</span><span class="hljs-string">        2、计算输入图像的每个Cell单元的梯度直方图，形成每个Cell的descriptor 比如输入图像为128x64 可以得到16x8个Cell，每个Cell由9个bin组成</span><span class="hljs-string">        '''</span>        Cell_gradient_vector = np.zeros((int(height / self.Cell_size), int(width / self.Cell_size), self.bin_size))        <span class="hljs-comment">#遍历每一行、每一列</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(Cell_gradient_vector.shape[<span class="hljs-number">0</span>]):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(Cell_gradient_vector.shape[<span class="hljs-number">1</span>]):                <span class="hljs-comment">#计算第[i][j]个Cell的特征向量</span>                Cell_magnitude = gradient_magnitude[i * self.Cell_size:(i + <span class="hljs-number">1</span>) * self.Cell_size,                                 j * self.Cell_size:(j + <span class="hljs-number">1</span>) * self.Cell_size]                Cell_angle = gradient_angle[i * self.Cell_size:(i + <span class="hljs-number">1</span>) * self.Cell_size,                             j * self.Cell_size:(j + <span class="hljs-number">1</span>) * self.Cell_size]                Cell_gradient_vector[i][j] = self.Cell_gradient(Cell_magnitude, Cell_angle)        <span class="hljs-comment">#将得到的每个Cell的梯度方向直方图绘出，得到特征图</span>        hog_image = self.render_gradient(np.zeros([height, width]), Cell_gradient_vector)                <span class="hljs-string">'''</span><span class="hljs-string">        3、将2x2个Cell组成一个block，一个block内所有Cell的特征串联起来得到该block的HOG特征descriptor</span><span class="hljs-string">           将图像image内所有block的HOG特征descriptor串联起来得到该image（检测目标）的HOG特征descriptor，</span><span class="hljs-string">           这就是最终分类的特征向量</span><span class="hljs-string">        '''</span>        hog_vector = []        <span class="hljs-comment">#默认步长为一个Cell大小，一个block由2x2个Cell组成，遍历每一个block</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(Cell_gradient_vector.shape[<span class="hljs-number">0</span>] - <span class="hljs-number">1</span>):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(Cell_gradient_vector.shape[<span class="hljs-number">1</span>] - <span class="hljs-number">1</span>):                <span class="hljs-comment">#提取第[i][j]个block的特征向量</span>                block_vector = []                block_vector.extend(Cell_gradient_vector[i][j])                block_vector.extend(Cell_gradient_vector[i][j + <span class="hljs-number">1</span>])                block_vector.extend(Cell_gradient_vector[i + <span class="hljs-number">1</span>][j])                block_vector.extend(Cell_gradient_vector[i + <span class="hljs-number">1</span>][j + <span class="hljs-number">1</span>])                <span class="hljs-string">'''块内归一化梯度直方图，去除光照、阴影等变化，增加鲁棒性'''</span>                <span class="hljs-comment">#计算l2范数</span>                mag = <span class="hljs-keyword">lambda</span> vector: math.sqrt(sum(i ** <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> vector))                   magnitude = mag(block_vector) + <span class="hljs-number">1e-5</span>                <span class="hljs-comment">#归一化</span>                <span class="hljs-keyword">if</span> magnitude != <span class="hljs-number">0</span>:                    normalize = <span class="hljs-keyword">lambda</span> block_vector, magnitude: [element / magnitude <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> block_vector]                    block_vector = normalize(block_vector, magnitude)                hog_vector.append(block_vector)                   <span class="hljs-keyword">return</span> np.asarray(hog_vector), hog_image    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">global_gradient</span><span class="hljs-params">(self)</span>:</span>        <span class="hljs-string">'''</span><span class="hljs-string">        分别计算图像沿x轴和y轴的梯度</span><span class="hljs-string">        '''</span>        gradient_values_x = cv2.Sobel(self.img, cv2.CV_64F, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, ksize=<span class="hljs-number">5</span>)        gradient_values_y = cv2.Sobel(self.img, cv2.CV_64F, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, ksize=<span class="hljs-number">5</span>)        <span class="hljs-comment">#计算梯度幅值 这个计算的是0.5*gradient_values_x + 0.5*gradient_values_y</span>        <span class="hljs-comment">#gradient_magnitude = cv2.addWeighted(gradient_values_x, 0.5, gradient_values_y, 0.5, 0)</span>        <span class="hljs-comment">#计算梯度方向</span>        <span class="hljs-comment">#gradient_angle = cv2.phase(gradient_values_x, gradient_values_y, angleInDegrees=True)</span>        gradient_magnitude, gradient_angle = cv2.cartToPolar(gradient_values_x,gradient_values_y,angleInDegrees=<span class="hljs-literal">True</span>)                <span class="hljs-comment">#角度大于180°的，减去180度</span>        gradient_angle[gradient_angle&gt;<span class="hljs-number">180.0</span>] -= <span class="hljs-number">180</span>         <span class="hljs-comment">#print('gradient',gradient_magnitude.shape,gradient_angle.shape,np.min(gradient_angle),np.max(gradient_angle))</span>        <span class="hljs-keyword">return</span> gradient_magnitude, gradient_angle    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">Cell_gradient</span><span class="hljs-params">(self, Cell_magnitude, Cell_angle)</span>:</span>        <span class="hljs-string">'''</span><span class="hljs-string">        为每个细胞单元构建梯度方向直方图</span><span class="hljs-string">        </span><span class="hljs-string">        args:</span><span class="hljs-string">            Cell_magnitude：Cell中每个像素点的梯度幅值</span><span class="hljs-string">            Cell_angle：Cell中每个像素点的梯度方向</span><span class="hljs-string">        return：</span><span class="hljs-string">            返回该Cell对应的梯度直方图，长度为bin_size</span><span class="hljs-string">        '''</span>        orientation_centers = [<span class="hljs-number">0</span>] * self.bin_size        <span class="hljs-comment">#遍历Cell中的每一个像素点</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(Cell_magnitude.shape[<span class="hljs-number">0</span>]):            <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> range(Cell_magnitude.shape[<span class="hljs-number">1</span>]):                <span class="hljs-comment">#梯度幅值</span>                gradient_strength = Cell_magnitude[i][j]                <span class="hljs-comment">#梯度方向</span>                gradient_angle = Cell_angle[i][j]                <span class="hljs-comment">#双线性插值</span>                min_angle, max_angle, weight = self.get_closest_bins(gradient_angle)                orientation_centers[min_angle] += (gradient_strength * (<span class="hljs-number">1</span> - weight))                orientation_centers[max_angle] += (gradient_strength *weight)        <span class="hljs-keyword">return</span> orientation_centers    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_closest_bins</span><span class="hljs-params">(self, gradient_angle)</span>:</span>        <span class="hljs-string">'''</span><span class="hljs-string">        计算梯度方向gradient_angle位于哪一个bin中，这里采用的计算方式为双线性插值</span><span class="hljs-string">        具体参考：https://www.leiphone.com/news/201708/ZKsGd2JRKr766wEd.html</span><span class="hljs-string">        例如：当我们把180°划分为9个bin的时候，分别对应对应0,20,40,...160这些角度。</span><span class="hljs-string">              角度是10，副值是4，因为角度10介于0-20度的中间(正好一半)，所以把幅值</span><span class="hljs-string">              一分为二地放到0和20两个bin里面去。</span><span class="hljs-string">        args:</span><span class="hljs-string">            gradient_angle:角度</span><span class="hljs-string">        return：</span><span class="hljs-string">            start,end,weight：起始bin索引，终止bin的索引，end索引对应bin所占权重</span><span class="hljs-string">        '''</span>        idx = int(gradient_angle / self.angle_unit)        mod = gradient_angle % self.angle_unit        <span class="hljs-keyword">return</span> idx % self.bin_size, (idx + <span class="hljs-number">1</span>) % self.bin_size, mod / self.angle_unit    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render_gradient</span><span class="hljs-params">(self, image, Cell_gradient)</span>:</span>        <span class="hljs-string">'''</span><span class="hljs-string">        将得到的每个Cell的梯度方向直方图绘出，得到特征图</span><span class="hljs-string">        args：</span><span class="hljs-string">            image：画布,和输入图像一样大 [h,w]</span><span class="hljs-string">            Cell_gradient：输入图像的每个Cell单元的梯度直方图,形状为[h/Cell_size,w/Cell_size,bin_size]</span><span class="hljs-string">        return：</span><span class="hljs-string">            image：特征图</span><span class="hljs-string">        '''</span>        Cell_width = self.Cell_size / <span class="hljs-number">2</span>        max_mag = np.array(Cell_gradient).max()        <span class="hljs-comment">#遍历每一个Cell</span>        <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> range(Cell_gradient.shape[<span class="hljs-number">0</span>]):            <span class="hljs-keyword">for</span> y <span class="hljs-keyword">in</span> range(Cell_gradient.shape[<span class="hljs-number">1</span>]):                <span class="hljs-comment">#获取第[i][j]个Cell的梯度直方图</span>                Cell_grad = Cell_gradient[x][y]                <span class="hljs-comment">#归一化</span>                Cell_grad /= max_mag                angle = <span class="hljs-number">0</span>                angle_gap = self.angle_unit                <span class="hljs-comment">#遍历每一个bin区间</span>                <span class="hljs-keyword">for</span> magnitude <span class="hljs-keyword">in</span> Cell_grad:                    <span class="hljs-comment">#转换为弧度</span>                    angle_radian = math.radians(angle)                    <span class="hljs-comment">#计算起始坐标和终点坐标，长度为幅值(归一化),幅值越大、绘制的线条越长、越亮</span>                    x1 = int(x * self.Cell_size + Cell_width + magnitude * Cell_width * math.cos(angle_radian))                    y1 = int(y * self.Cell_size + Cell_width + magnitude * Cell_width * math.sin(angle_radian))                    x2 = int(x * self.Cell_size + Cell_width - magnitude * Cell_width * math.cos(angle_radian))                    y2 = int(y * self.Cell_size + Cell_width - magnitude * Cell_width * math.sin(angle_radian))                    cv2.line(image, (y1, x1), (y2, x2), int(<span class="hljs-number">255</span> * math.sqrt(magnitude)))                    angle += angle_gap        <span class="hljs-keyword">return</span> image        <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:    <span class="hljs-comment">#加载图像</span>    img = cv2.imread(<span class="hljs-string">'./image/person.jpg'</span>)            width = <span class="hljs-number">64</span>    height = <span class="hljs-number">128</span>    img_copy = img[<span class="hljs-number">320</span>:<span class="hljs-number">320</span>+height,<span class="hljs-number">570</span>:<span class="hljs-number">570</span>+width][:,:,::<span class="hljs-number">-1</span>]        gray_copy = cv2.cvtColor(img_copy,cv2.COLOR_BGR2GRAY)        <span class="hljs-comment">#显示原图像</span>    plt.figure(figsize=(<span class="hljs-number">6.4</span>,<span class="hljs-number">2.0</span>*<span class="hljs-number">3.2</span>))    plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>)    plt.imshow(img_copy)        <span class="hljs-comment">#HOG特征提取</span>    hog = Hog_descriptor(gray_copy, Cell_size=<span class="hljs-number">8</span>, bin_size=<span class="hljs-number">9</span>)        hog_vector, hog_image = hog.extract()    print(<span class="hljs-string">'hog_vector'</span>,hog_vector.shape)    print(<span class="hljs-string">'hog_image'</span>,hog_image.shape)        <span class="hljs-comment">#绘制特征图</span>    plt.subplot(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)    plt.imshow(hog_image, cmap=plt.cm.gray)        plt.show()</code></pre><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>HOG算法具有以下优点：                            </p><ul><li>核心思想是所检测的局部物体外形能够被梯度或边缘方向的分布所描述，HOG能较好地捕捉局部形状信息，对几何和光学变化都有很好的不变性；             </li><li>HOG是在密集采样的图像块中求取的，在计算得到的HOG特征向量中隐含了该块与检测窗口之间的空间位置关系。                           </li></ul><p>HOG算法具有以下缺点：                 </p><ul><li>特征描述子获取过程复杂，维数较高，导致实时性差；                </li><li>很难处理遮挡问题，人体姿势动作幅度过大或物体方向改变也不易检测（这个问题后来在<a href="http://blog.csdn.net/masibuaa/article/details/17924671" target="_blank" rel="noopener">DPM</a>中采用可变形部件模型的方法得到了改善）；                  </li><li>跟SIFT相比，HOG没有选取主方向，也没有旋转梯度方向直方图，因而本身不具有旋转不变性（较大的方向变化），其旋转不变性是通过采用不同旋转方向的训练样本来实现的；</li><li>跟SIFT相比，HOG本身不具有尺度不变性，其尺度不变性是通过缩放检测窗口图像的大小来实现的；</li><li>此外，由于梯度的性质，HOG对噪点相当敏感，在实际应用中，在block和Cell划分之后，对于得到各个区域，有时候还会做一次高斯平滑去除噪点。               </li></ul><p><em>Q : How do you eat an elephant ?</em><br><em>A : One bite at a time!</em></p><p>参考链接：</p><p><a href="https://www.learnopencv.com/histogram-of-oriented-gradients/" target="_blank" rel="noopener">Histogram of Oriented Gradients(强烈推荐)</a><br><a href="https://cloud.tencent.com/developer/article/1419615" target="_blank" rel="noopener">HOG特征详解与行人检测</a><br><a href="https://www.cnblogs.com/zyly/p/9651261.html" target="_blank" rel="noopener">基于传统图像处理的目标检测与识别(很全面)</a><br><a href="https://zhuanlan.zhihu.com/p/85829145" target="_blank" rel="noopener">一文讲解方向梯度直方图HOG</a></p>]]></content>
    
    
    <categories>
      
      <category>图像处理下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leetcode50</title>
    <link href="/article/553b1469.html"/>
    <url>/article/553b1469.html</url>
    
    <content type="html"><![CDATA[<h1 id="实现power-x-n-，即计算x的n次幂函数。"><a href="#实现power-x-n-，即计算x的n次幂函数。" class="headerlink" title="实现power(x,n)，即计算x的n次幂函数。"></a>实现power(x,n)，即计算x的n次幂函数。</h1><p>示例1：</p><pre><code class="hljs python">输入: <span class="hljs-number">2.00000</span>, <span class="hljs-number">10</span>输出: <span class="hljs-number">1024.00000</span></code></pre><p>示例2：</p><pre><code class="hljs python">输入: <span class="hljs-number">2.10000</span>, <span class="hljs-number">3</span>输出: <span class="hljs-number">9.26100</span></code></pre><p>示例3：</p><pre><code class="hljs python">输入: <span class="hljs-number">2.00000</span>, <span class="hljs-number">-2</span>输出: <span class="hljs-number">0.25000</span>解释: <span class="hljs-number">2</span><span class="hljs-number">-2</span> = <span class="hljs-number">1</span>/<span class="hljs-number">22</span> = <span class="hljs-number">1</span>/<span class="hljs-number">4</span> = <span class="hljs-number">0.25</span></code></pre><p>说明：</p><ul><li>-100.0 &lt; x &lt; 100.0</li><li>$n$是32位有符号整数，其数值范围是$[-2^{31},2^{31}-1]$。</li></ul><p><strong>快速幂算法</strong>：递归和迭代两个版本。<br>当指数$n$为负数时，可以通过计算$x^{-n}$取倒数得到结果，因此只需要考虑$n$为自然数的情况。</p><h2 id="方法一：快速幂-递归-从右到左"><a href="#方法一：快速幂-递归-从右到左" class="headerlink" title="方法一：快速幂+递归(从右到左)"></a>方法一：快速幂+递归(从右到左)</h2><p>快速幂算法的本质是分治算法。<br>例子：</p><script type="math/tex; mode=display">x \rightarrow x^2 \rightarrow x^4 \rightarrow x^8 \rightarrow x^{16} \rightarrow x^{32} \rightarrow x^{64}</script><script type="math/tex; mode=display">x \rightarrow x^2 \rightarrow x^4 \rightarrow x^9 \rightarrow x^{19} \rightarrow x^{38} \rightarrow x^{77}</script><p>第一个直接把上一次的结果平方，第二个把上一个结果平方后，额外乘一个$x$。</p><ul><li><p>计算$x^n$时，递归计算出$y=x^{\lfloor n/2 \rfloor}$</p></li><li><p>根据递归计算的结果，如果$n$为偶数，那么$x^n=y^2$；如果$n$为奇数，那么$x^n=y^2*x$；</p></li><li>递归的边界为$n=0$，任意数的0次方均为1。</li></ul><p>由于每次递归都会使得指数减少一半，因此递归的层数为$O(logn)$，算法可以在很快的时间内得到结果。</p><p>复杂度分析：</p><ul><li>时间复杂度：$O(logn)$，即为递归的层数。</li><li>空间复杂度：$O(logn)$，即为递归的层数，这是由于递归的函数调用会使用栈空间。</li></ul><p>上代码，目前只会python（猛男落泪，等以后会了别的再加上）：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quickMul</span><span class="hljs-params">(N)</span>:</span>            <span class="hljs-keyword">if</span> N == <span class="hljs-number">0</span>:                <span class="hljs-keyword">return</span> <span class="hljs-number">1.0</span>            y = quickMul(N // <span class="hljs-number">2</span>)            <span class="hljs-keyword">return</span> y * y <span class="hljs-keyword">if</span> N % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> y * y * x        <span class="hljs-keyword">return</span> quickMul(n) <span class="hljs-keyword">if</span> n &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span> / quickMul(-n)</code></pre><h2 id="方法二：快速幂-迭代-从左到右"><a href="#方法二：快速幂-迭代-从左到右" class="headerlink" title="方法二：快速幂 + 迭代(从左到右)"></a>方法二：快速幂 + 迭代(从左到右)</h2><p>递归需要使用额外的栈空间。递归-&gt;迭代。<br>如果整数$n$的二进制拆分为 $n = 2^{i_0} + 2^{i_1} + \ldots + 2^{i_k}$<br>借助整数的二进制拆分，得到迭代计算的方法，一般地，如果整数$n$的二进制拆分为：</p><script type="math/tex; mode=display">n = 2^{i_0} + 2^{i_1} + \ldots + 2^{i_k}</script><p>那么</p><script type="math/tex; mode=display">x^n = x^{2^{i_0}} * x^{2^{i_1}} * \ldots * x^{2^{i_k}}</script><p>从$x$不断地进行平方，得到$x^2,x^4,x^8,x^{16},\ldots,$如果$n$的第$k$个（从右往左，从0开始计数）二进制位为1，那么我们就将对应的贡献$x^{2^k}$计入答案。<br>上代码：</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">myPow</span><span class="hljs-params">(self, x, n)</span>:</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quickMul</span><span class="hljs-params">(N)</span>:</span>            ans = <span class="hljs-number">1.0</span>            <span class="hljs-comment"># 贡献的初始值为x</span>            x_contribute = x            <span class="hljs-comment"># 在对N进行二进制拆分的同时计算答案</span>            <span class="hljs-keyword">while</span> N &gt; <span class="hljs-number">0</span>:                <span class="hljs-keyword">if</span> N % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>:                    <span class="hljs-comment"># 如果N二进制表示的最低位为1，那么需要计入贡献</span>                    ans *= x_contribute                <span class="hljs-comment"># 将贡献不断地平方</span>                x_contribute *= x_contribute                <span class="hljs-comment"># 舍弃N二进制表示的最低位，这样每次只要判断最低位即可</span>                N // = <span class="hljs-number">2</span>            <span class="hljs-keyword">return</span> ans        <span class="hljs-keyword">return</span> quickMul(n) <span class="hljs-keyword">if</span> n &gt;= <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> <span class="hljs-number">1.0</span> / quickMul(-n)</code></pre><h2 id="牛顿迭代法"><a href="#牛顿迭代法" class="headerlink" title="牛顿迭代法"></a>牛顿迭代法</h2><p>思路参考链接<a href="http://www.matrix67.com/blog/archives/361" target="_blank" rel="noopener">牛顿迭代法快速寻找平方根</a><br>代码参考链接<a href="http://www.voidcn.com/article/p-eudisdmk-zm.html" target="_blank" rel="noopener">leetcode sqrt(x):牛顿迭代法和Quake-III中的神奇方法</a></p><p><img src="/article/553b1469/200711241.gif" srcset="/img/loading.gif" alt="img"></p><p>具体求解：<a href="https://leetcode-cn.com/problems/powx-n/solution/niu-dun-die-dai-fa-by-cuo-mie-zong/" target="_blank" rel="noopener">牛顿迭代法求解</a><br>看了思路，数学真是一个全新的角度~</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://leetcode-cn.com/problems/powx-n/solution/50-powx-n-kuai-su-mi-qing-xi-tu-jie-by-jyd/" target="_blank" rel="noopener">优秀题解(推荐)</a>看了这个大佬的几个题解了，高手，思路很清晰，个人账号里面有一系列套题，剑指Offer之类的，非常具有参考价值。</p><p><font color="blue">第一次写，不是很流畅，思路和手都不太行。下周再做一遍，做完就把这行删掉，冲鸭</font><br>如此一来，每天水一篇，居然成为了日更博主，哈哈哈哈哈<br>不足的博文在后期有时间都会进行修改，做一个有质量(没人气)的博主，奥里给O(∩_∩)O。</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>分治、回溯</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LSTM_Elmo</title>
    <link href="/article/3b406ffc.html"/>
    <url>/article/3b406ffc.html</url>
    
    <content type="html"><![CDATA[<p>一、词的表示<br>one-hot编码：稀疏，向量之间均是正交关系，不能表示语义。<br>word class：将相同属性的词归为一类，但分类标准过意单一、片面。如cat、dag、bird都属于动物，但是dog、cat属于爬行动物，而bird属于飞行动物，难以区分。<br>word embedding：使用词向量表示词特征，相似的词、向量接近，在空间较近。但无法解决一词多义问题，即每个word只有一个词向量。<br>contextualized word embedding：同一个词在不同的上下文中有不同的表示。</p><p>二、LSTM概述<br>  长短记忆神经网络——通常称作LSTM，是一种特殊的RNN，能够学习长的依赖关系。是为了避免长依赖问题而精心设计的。记住较长的历史信息实际上是他们的默认行为，而不是他们努力学习的东西。<br>1<br>2.1 标准RNN结构如下(单个tanh层)</p><p>2.2 lstm 结构图如下</p><p>2.3 lstm的4层交互结构说明:<br>LSTM 的4大交互模块    结构片段    说明<br>遗忘门<br>遗忘门：由sigmoid决定丢弃那些信息，输出01序列，序列作用在单元格Ct-1上，1表示全保留，0全丢弃.<br>输入门<br>分为2步：①输入门：sigmoid决定更新哪些值<br>② tanh：创建候选向量Ct<br>旧值更新操作<br>将Ct-1更新成Ct, 对应实际删除旧主题信息，并添加新信息<br>输出门<br>决定输出什么，sigmoid决定输出哪些部分。然后tanh+输出哪些部分 得到输出.<br>三、ELMO模型概述<br>基于RNN的语言模型，直接从句子学习，无需标注。<br>1<br>3.1 问题引入<br>给定句子：“潮水 退了 就 知道 谁 没穿 裤子”</p><p>问题①：红框ELMO内部究竟是啥玩意?<br>问题②：是直接将词输入到ELMO模型吗？<br>问题③：ELMO输出的h1、h2、蓝柱是什么?<br>3.2 ELMO的内部构造图<br>elmo模型是一个多层(2层)双向的LSTM组成的LM(底层lstm捕获到句法、语义方面信息，如POS，高层捕获到词义的上下文信息，如语义消歧)<br>1</p><p>3.3 如何得到输入词的词向量<br>词向量的构建是动态的过程，会随着模型参数更新而更新。对于中文，原始输入的是词语；而对于类似英文，每个单词又是由多个字母构成，中文的词语等同于英文中的单词，词语中的词等同于单词中的字母(同一粒度)，本文中是针对英文而言的，中文类似</p><p>即input→词向量表示：对每个词进行字符卷积操作，从而得到词向量。(w2c系列是通过look_up_table得到词向量)</p><p>格式(batch, n_token, max_char, char_dim)，batch表示同时有多少个句子(样本)并行卷积，n_token表示句子在未去重条件下的单词数，char_dim表示每个字符的特征长度，max_char表示句子中词的最大字符数量。<br>使用大小”高为1，宽为n_width, 通道数为char_dim”(即维度[1, n_width, char_dim])的卷积核进行卷积, 得到[n_token, max_char-n_width+1]的特征图(备注：词字符少的感觉有个填充对齐操作以达到max_char大小)<br>最终再对图的每行进行一个max_pooling操作，得到batch个[n_token]。如输入(8, 16, 12, 64)，卷积核(1, 5, 64)， 即并行计算8个句子样本，样本最多有16单词，词中最大的字符数量是12个，每个字符用64个特征表示，最终获取8个(16, 12-5+1)特征图。<br>即为词向量<br>词向量卷积过程示例<br>示例：假设batch为1，句子 “I like China very much” , 如何卷积的?<br>即初始维度：(1, n_token, max_char, char_dim)，卷积核为(1, 2, char_dim), 卷积过程如下：</p><p>3.4 loss函数以及最终输出<br>3.4.1 loss函数<br>    训练是使用负对数似然作为损失函数。<br>1</p><p>3.4.2 输出向量表示<br>elmo在train过程中，每个词都由 正反向LSTM中间向量、正反向结果向量和静态向量(init时向量，也会同步更细)表示，故每个词都会有2L+1个表示向量：</p><p>3.4.3 最终结果计算<br>    ELMO考虑既考虑最后一层lstm的输出，同时兼顾静态词向量、中间词向量, 最终的结果与w2c类似，是预测位置上的可能概率分布。故输出结果表示如下：<br>1</p><p>3.5 ELMO事项说明<br>在实际任务中使用ELMO向量：<br> 结合监督任务训练时，可冻结(如设置权重标为0不更新该参数)EMLO模型中LSTM层的参数(静态词向量、正反向lstm中的参数[指的是权重，不是api的参数项])，只训练最后一层E函数中的权重值。此时可加入dropout(随机丢掉某些层的影响)或L2正则化(使E结果更接近lstm层输出的平均值)。<br> 结合方式有：</p><ol><li>直接在输入层的词向量拼上elmo表示</li><li>将elmo直接作用在RNN的输出上<br>改进：</li><li>ELMO对输出结果采用拼接方式融合特征，‘可能’ 弱于Bert一体化的融合方式</li><li>ELMO使用了LSTM作为特征抽取器，而非Transformer(研究表明Transformer特征提取能力远强于LSTM)</li><li>由RNN导致训练时间</li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Task03-Haar特征描述算子-人脸监测</title>
    <link href="/article/ad28cab2.html"/>
    <url>/article/ad28cab2.html</url>
    
    <content type="html"><![CDATA[<h1 id="3-1-算法由来"><a href="#3-1-算法由来" class="headerlink" title="3.1 算法由来"></a>3.1 算法由来</h1><p>&emsp;&emsp;Haar-like特征最早是由Papageorgiou等应用于人脸表示，2001年，Viola和Jones两位大牛发表了今典的《Rapid Object Detection using a Boosted Cascade of Simple Features》和《Robust Real-Time Face Detection》，在AdaBoost算法基础上，使用Haar-like小波特征和积分图方法进行人脸监测，并对AdaBoost训练出的强分类器进行级联。<br>&emsp;&emsp;这两个大咖不是最早提出使用小波特征的，单他们设计了针对人脸监测更有效的特征，可以说是人脸检测史上里程碑式的一笔了，当时这个算法被称为Viola-Jones检测器。又过了一段时间，Rainer Liehart和Jochen Maydt两位大咖把这个检测器进行扩展，最终形成了OpenCV现在的Haar分类器。</p><p>&emsp;&emsp;AdaBoost是Freund和Schapire在1995年提出的算法，是对传统Boosting算法的一大提升。Boosting算法的核心思想，是将弱学习方法提升成强学习算法，也就是“三个臭皮匠顶一个诸葛亮”。<a id="more"></a></p><font color="blue">Haar分类器 = Haar-like特征 + 积分图方法 + AdaBoost + 级联</font><p>Haar分类器算法的要点如下：</p><ol><li>使用Haar-like特征特征做监测</li><li>使用积分图(Integral Image)对Haar-like特征求值进行加速。</li><li>使用AdaBoost算法训练区分人脸和非人脸的强分类器。</li><li>使用筛选式级联把强分类器级联到一起，提高准确率。</li></ol><h1 id="3-2-算法理解"><a href="#3-2-算法理解" class="headerlink" title="3.2 算法理解"></a>3.2 算法理解</h1><h2 id="一、Haar-like特征"><a href="#一、Haar-like特征" class="headerlink" title="一、Haar-like特征"></a>一、Haar-like特征</h2><p>viola牛们提出的Haar-like特征：</p><p><img src="/article/ad28cab2/1346291481_8797.jpg" srcset="/img/loading.gif" alt="img"></p><p>Lienhart等牛们提出的Haar-like特征：</p><p><img src="/article/ad28cab2/图片4.png" srcset="/img/loading.gif" alt="img"></p><p>&emsp;&emsp;Haar特征分为四类：边缘特征、线性特征、中心特征和对角线特征，组合成特征模板。特征模板内有白色和黑色两种矩形。<font color="blue">并定义该模板的特征值为白色矩形像素和减去黑色矩形像素和</font>。Haar特征值反映了图形的灰度变化情况。例如：脸部的一些特征能由矩形特征简单的描述，单矩形特征只对一些简单的图形结构，如边缘、线段较敏感，所以只能描述特定走向(水平、垂直、对角)的结构。</p><p><img src="/article/ad28cab2/1328274-20180802215641326-115308739.png" srcset="/img/loading.gif" alt="img"></p><p>&emsp;&emsp;图中的A, B和D这类特征，特征数值计算公式为：v=Σ白-Σ黑。图C中，计算公式：v=Σ白-2*Σ黑。将黑色区域像素和乘以2，是为了使两种矩形区域中像素数目一致。我们希望当把矩形放到人脸区域计算出来的特征值和放到非人脸区域计算出来的特征值差别越大越好，这样就可以用来区分人脸和非人脸。<br>&emsp;&emsp;OpenCV(2.4.11版本)所使用的共计14种Haar特征，包括5种Basic特征、3种Core特征和6种Title(即$45^\circ$旋转)特征。mode为BASIC,使用前五个。mode为CORE，使用前8个。mode为ALL，使用全部14种。</p><p><img src="/article/ad28cab2/20180527174145244" srcset="/img/loading.gif" alt="img"></p><p>&emsp;&emsp;通过改变特征模板的大小和位置，可在图像子窗口中穷举出大量的特征。上图的特征模板称为“特征原型”；特征原型在图像子窗口中扩展（平移伸缩）得到的特征称为“矩形特征”；矩形特征的值称为“特征值”。</p><p><img src="/article/ad28cab2/1328274-20180815213149483-1209887019.png" srcset="/img/loading.gif" alt="img"></p><p>&emsp;&emsp;上图中两个矩形特征，表示出人脸的某些特征。比如中间一幅表示眼睛区域的颜色比脸颊区域的颜色深，右边一幅表示鼻梁两侧比鼻梁的颜色要深。同样，其他目标，如眼睛等，也可以用一些矩形特征来表示。<font color="blue">使用矩形特征比单纯地使用像素点具有很大的优越性，并且速度更快。</font><br>&emsp;&emsp;矩形特征可位于图像任意位置，大小也可以任意改变，所以矩形特征值是矩形模版类别、矩形位置和矩形大小这三个因素的函数。故类别、大小和位置的变化，使得很小的检测窗口含有非常多的矩形特征，如：在24*24像素大小的检测窗口内矩形特征数量可以达到16万个。这样就有两个问题需要解决了：</p><p>（1）如何快速计算那么多的特征？—-积分图大显神通；<br>（2）哪些矩形特征才是对分类器分类最有效的？—-如通过AdaBoost算法来训练。</p><h2 id="二、Haar-like特征计算-积分图"><a href="#二、Haar-like特征计算-积分图" class="headerlink" title="二、Haar-like特征计算-积分图"></a>二、Haar-like特征计算-积分图</h2><p>&emsp;&emsp;<font color="blue">积分图是只遍历一次图像就可求出图像中所有区域像素和的快速算法</font>，大大提高了图像特征值计算的效率。<br>&emsp;&emsp;积分图的主要思想是将图像从起点开始到各个点形成的矩形区域像素之和作为一个数组的元素提前保存在数组中。当要计算某个区域的像素和时，直接索引数组的元素进行线性计算即可，从而加快了计算速度。<br>&emsp;&emsp;积分图是一种能够描述全局信息的举证表示方法。积分图的构造方式是位置位置（𝑖,𝑗）处的值𝑖𝑖(𝑖,𝑗)是原图像(𝑖,𝑗)左上角方向所有像素𝑓(𝑘,𝑙)的和：</p><script type="math/tex; mode=display">𝑖𝑖(𝑖,𝑗)=\sum_{𝑘≤𝑖,𝑙≤𝑗}{𝑓(𝑘,𝑙)}</script><p>积分图构建算法：<br>1、用𝑠(𝑖,𝑗)表示行方向的累加和，初始化𝑠(𝑖,−1)=0；<br>2、使用𝑖𝑖(𝑖,𝑗)表示一个积分图像，初始化𝑖𝑖(−1,𝑖)=0；<br>3、逐行扫描图像，递归计算每个像素(𝑖,𝑗)行方向的累加和𝑠(𝑖,𝑗)和积分图像𝑖𝑖(𝑖,𝑗)的值：</p><script type="math/tex; mode=display">𝑠(𝑖,𝑗)=𝑠(𝑖,𝑗−1)+𝑓(𝑖,𝑗) \\𝑖𝑖(𝑖,𝑗)=𝑖𝑖(𝑖−1,𝑗)+𝑠(𝑖,𝑗)</script><p>4、扫描图像一遍，当到达图像右下角像素时，积分图像𝑖𝑖就构建好了。<br>积分图构造好之后，图像中任何矩阵区域像素累加和都可以通过简单运算得到如图所示：</p><p><img src="/article/ad28cab2/1328274-20180815205201934-1228753116.png" srcset="/img/loading.gif" alt="img"></p><p>设D的四个顶点分别为$\alpha,\beta,\gamma,\delta$，则D的像素和可以表示为：</p><script type="math/tex; mode=display">D_{sum} = ii(\alpha)+ii(\beta)-(ii(\gamma)+ii(\delta))</script><p>Haar-like特征值是两个矩阵像素和的差，同样可以在常数时间内完成。</p><h2 id="三、计算Haar特征值"><a href="#三、计算Haar特征值" class="headerlink" title="三、计算Haar特征值"></a>三、计算Haar特征值</h2><p>&emsp;&emsp;由二已知，一个区域的像素值的和，可以由该区域的端点的积分图计算。由前面特征模板的特征值的定义可推出，<font color="blue">矩形特征的特征值由特征端点的积分图计算得到</font>。以A矩形特征为例，如下图，使用积分图计算该特征值：</p><p><img src="/article/ad28cab2/1328274-20180816090314814-408684664.png" srcset="/img/loading.gif" alt="img"></p><p>区域A的像素值：$𝑖𝑖(5)+𝑖𝑖(1)−𝑖𝑖(2)−𝑖𝑖(4)$</p><p>区域B的像素值：$𝑖𝑖(6)+𝑖𝑖(2)−𝑖𝑖(5)−𝑖𝑖(3)$</p><p>所以：该矩形特征的特征值为：</p><script type="math/tex; mode=display">𝑖𝑖(5)+𝑖𝑖(1)−𝑖𝑖(2)−𝑖𝑖(4)−[𝑖𝑖(6)+𝑖𝑖(2)−𝑖𝑖(5)−𝑖𝑖(3)]</script><script type="math/tex; mode=display">=[𝑖𝑖(5)−𝑖𝑖(4)]+[𝑖𝑖(3)−𝑖𝑖(2)]−[𝑖𝑖(2)−𝑖𝑖(1)]−[𝑖𝑖(6)−𝑖𝑖(5)]</script><p>&emsp;&emsp;所以，矩形特征的特征值，只与特征矩形的端点的积分图有关。利用矩形特征的端点的积分图，再进行简单的加减运算，即可得到特征值，如此一来，特征的计算速度大大提高，也提高了目标的检测速度。<br>了解特征值计算后，接下来展示不同特征值的含义。</p><p>&emsp;&emsp;下图展示了20X20子窗口里面全部78,460个矩形特征对在全部2,706个人脸样本和4,381个非人脸样本的特征值平均值的分布图。由分布看出，特征的绝大部分的特征值平均值都是分布在0前后的范围内。<br>&emsp;&emsp;出乎意料的是，人脸样本与非人脸样本的分布曲线差别并不大，不过注意到特征值大于或小于某个值后，分布曲线出现了一致性的差别。说明了绝大部分特征对于识别人脸和非人脸的能力是很微小的，但是存在一些特征及相应的阈值，可以有效第区别人脸样本和非人脸样本。<img src="/article/ad28cab2/image-20200704225306093.png" srcset="/img/loading.gif" alt="image-20200704225306093"></p><p>&emsp;&emsp;为了更好地说明部分特征对于人脸和非人脸的区分作用，从78,460个矩形特征中随机抽取了两个特征A和B，这两个特征遍历2,706 个人脸样本和4,381 个非人脸样本，计算了每张图像对应的特征值，最后将特征值进行了从小到大的排序，并按照这个新的顺序表绘制了分布图如下所示：</p><center class="half">    <img src="/article/ad28cab2/20160921003959958" srcset="/img/loading.gif" width="350"><img src="/article/ad28cab2/20160921004018287" srcset="/img/loading.gif" width="350"></center><p>&emsp;&emsp;可以看出，矩形特征A在人脸样本和非人脸样本中的特征值分布相似，所以区分人脸和非人脸的能力很差。下面看矩形特征B在人脸样本和非人脸样本中特征值的分布：</p><center class="half">    <img src="/article/ad28cab2/20160921004748821" srcset="/img/loading.gif" width="350"><img src="/article/ad28cab2/20160921004808352" srcset="/img/loading.gif" width="350"></center><p>&emsp;&emsp;可以看出，矩形特征B的特征值分布，尤其是0点的位置，在人脸样本和非人脸样本中差别比较大，所以可以更好地实现对人脸分类。<br>&emsp;&emsp;特征 A 和特征 B 的表现大相径庭。<br>&emsp;&emsp;特征 A 对人脸和非人脸样本的特征值为0的点几乎处于相同位置（46.5%，51.5%），且都在所有特征的中间范围 (-5%)。这说明矩形特征 A对于人脸和非人脸几乎没有分辨能力。<br>&emsp;&emsp;特征 B 对非人脸样本的分布，符合我们的预想，特征值为 0的点处于所有特征的中间范围(59.4%)，这说明特征B也“ 看不到” 非人脸的特点。但是对于人脸样本，特征 B 表现了很一致的倾向性，93.4%的特征在 0 点的一侧，与非人脸样本的相差 34%。这说明特征 B 能够相当可靠地分辨人脸和非人脸。<br>&emsp;&emsp;上述的分析说明，确实存在优势的矩形特征，能够在一定的置信范围内区分人脸和非人脸。由于是使用统计的方法计算人脸图像和非人脸图像的差别，因此最后得到的区分阈值，是在某个概率范围内准确地进行区分。<br>上述总结如下：<br>（1）在检测窗口通过平移+缩放可以产生一系列Haar特征，这些特征由于位置和大小不同，分类效果也不同；<br>（2）通过计算Haar特征的特征值，可以有将图像矩阵映射为1维特征值，有效实现了降维。</p><h3 id="Haar特征值归一化-也可以采取标准归一化"><a href="#Haar特征值归一化-也可以采取标准归一化" class="headerlink" title="Haar特征值归一化(也可以采取标准归一化)"></a>Haar特征值归一化(也可以采取标准归一化)</h3><p>&emsp;&emsp;从上图中可发现，仅仅在正样本组中12*8大小的Haar特征计算出的特征值变化范围就达到了-2000~+6000，跨度非常大。这种跨度大的特征不利于量化评定特征值，这时候归一化就排上用场了。<font color="blue">对特征值进行归一化，压缩特征值范围。</font><br>&emsp;&emsp;假设当前检测窗口中的图像像素为$i(x,y)$，当前检测窗口为$w\times h$大小(例如上图中20x20大小)。<br>OpenCV采用如下方式归一化：<br>1、计算检测窗口中图像的灰度值和灰度值平方和：<font color="red">(这里的$i^2$怎么用积分图表示？？)</font></p><script type="math/tex; mode=display">sum=\sum{i(x,y)} \\sq_{sum}=\sum{i^2(x,y)}</script><p>2、计算平均值：</p><script type="math/tex; mode=display">mean = \frac{sum}{w*h}\\sq_{mean}=\frac{sq_{sum}}{w*h}</script><p>3、计算归一化因子：</p><script type="math/tex; mode=display">varNormFactor=\sqrt{sq_{mean}-mean^2}</script><p>4、归一化特征值：</p><script type="math/tex; mode=display">normValue=\frac{featureValue}{varNormFactor}</script><p>之后使用归一化的特征值𝑛𝑜𝑟𝑚𝑉𝑎𝑙𝑢𝑒与阈值对比。</p><h2 id="四、Adaboost级联分类器"><a href="#四、Adaboost级联分类器" class="headerlink" title="四、Adaboost级联分类器"></a>四、Adaboost级联分类器</h2><p>OpenCV中的Adaboost级联分类器的结构，弱分类器-&gt;强分类器-&gt;级联分类器；</p><h3 id="1-级联分类器"><a href="#1-级联分类器" class="headerlink" title="1.级联分类器"></a>1.级联分类器</h3><p>Adaboost级联分类器：<br>&emsp;&emsp;级联分类模型是树状结构，每一层—强分类器是树状结构，强分类器中的每一个弱分类器也是树状结构。如下图所示，每一个stage都代表一级强分类器：<br><img src="/article/ad28cab2/1328274-20180816100358784-868305710.png" srcset="/img/loading.gif" alt="img"><br>&emsp;&emsp;当检测窗口通过所有的强分类器时被认为是正样本。每一个强分类器对负样本的判别准确率高，任一级强分类器检测为负样本，就不再继续调用下面的强分类器，直接丢弃，减少了很多的检测时间。<br>&emsp;&emsp;一副图像中待检测的区域中很多是负样本，级联分类器在初期就会抛弃很多负样本的复杂检测，所以级联分类器的速度是非常快的，只有正样本才会送到下一个强分类器再次进行检验，这样就保证了最后输出的正样本的伪正(false positive)的可能性非常低。</p><h3 id="2-级联分类器的训练"><a href="#2-级联分类器的训练" class="headerlink" title="2.级联分类器的训练"></a>2.级联分类器的训练</h3><p>1)首先需要训练出m个弱分类器，然后把m个弱分类器按照一定的组合策略，得到一个强分类器，如下图所示：<br>2)重复1步骤n次得到n个强分类器，按照级联的方式组合起来，得到最终的Haar分类器。<br><img src="/article/ad28cab2/1328274-20180816150118683-1847072909.png" srcset="/img/loading.gif" alt="img"></p><p>&emsp;&emsp;一个弱分类器是和上图类似的决策树，最基本的弱分类器只包含一个Haar-like特征，即只包含一层决策树(树桩stump)。<br>&emsp;&emsp;以20*20图像为例，78,460个特征，若直接利用AdaBoost训练，78,460个弱分类器组合成强分类器，工作量是极其巨大的。所以必须要有个筛选过程。</p><p><font color="blue">首先筛选出T个优秀的最优弱分类器(特征值)，然后把T个最优弱分类器传给AdaBoost进行训练。</font><br><strong>训练最优弱分类器</strong><br>&emsp;&emsp;人脸样本2000张，非人脸样本4000张，这些样本都经过了归一化，大小都是20X20的图像。那么，对于78,460中的任一特征$f_i$，我们计算该特征在这2000人脸样本，4000非人脸样本上的值，得到6000个特征值。将这些特征值排序，然后选取一个最佳的特征值。在该特征值下，对于特征$f_i$而言，样本的加权错误率最低。<br>&emsp;&emsp;在确定了训练子窗口(20x20的图像)的矩形特征数量(78,460)和特征值后，需要对每一个特征$f$，训练一个弱分类器$h(x,f,\rho,\theta)$：</p><script type="math/tex; mode=display">h(x,f,\rho,\theta)=\begin{cases}1,   {\rho f(x)<\rho \theta}\\0,  {other}\end{cases}</script><p>&emsp;&emsp;其中$𝑥$代表一个检测子窗口，$𝑓$为矩形特征，$\theta$为阈值，$\rho$指示不等号的方向。对每个特征$𝑓$，训练一个弱分类器$ℎ(𝑥,𝑓,\rho,\theta)$，就是确定$𝑓$的最优阈值，使得这个弱分类器对所有的训练样本分类误差最小。<br>这里的最优不是指强分类器，只是一个误差相对较低的弱分类器。<br><strong>弱分类器训练的具体步骤：</strong><br>1、对于每个特征$f$，计算所有训练样本的特征值，并将其排序：<br>2、扫描一遍排好序的特征值，对排好序的表中的每个元素，计算下面四个值：<br>计算全部正例的权重和$𝑇^+$；<br>计算全部负例的权重和$T^-$；<br>计算该元素前之前的正例的权重和$𝑆^+$；<br>计算该元素前之前的负例的权重和$𝑆^−$；</p><p><img src="/article/ad28cab2/20160921003914442" srcset="/img/loading.gif" alt="这里写图片描述"></p><p>3、选取当前元素的特征值$F_{k,j}$和它前面的一个特征值$F_{k,j-1}$之间的数作为阈值，所得到的弱分类器就在当前元素处把样本分开 —— 也就是说这个阈值对应的弱分类器将当前元素前的所有元素分为非人脸（或人脸），而把当前元素后（含）的所有元素分为人脸（或非人脸）。该阈值的分类误差为：</p><script type="math/tex; mode=display">e=\min{(S^+ + (T^- - S^-), S^- + ( T^+ - S^+))}</script><p><strong>公式说明：前一个分类误差计算前提为阈值前为非人脸，后一个分类误差计算前提为阈值前为人脸。</strong><br>&emsp;&emsp;把排序表从头到尾扫描一遍就可以为弱分类器选择使分类误差最小的阈值（最优阈值），即选取了一个最优弱分类器。在本例中，一共有78,460个特征，因此会得到78,460个最优分类器。<br>结合三，可得出以下分析：<br>&emsp;&emsp;阈值$\theta$的含义就清晰可见了。方向指示符$p$ 用以改变不等号的方向。一个弱学习器（一个特征）的要求仅仅是：它能够以稍低于50%的错误率来区分人脸和非人脸图像，因此上面提到只能在某个概率范围内准确地进行区分就已经完全足够。按照这个要求，可以把所有错误率低于50% 的矩形特征都找到（适当地选择阈值，对于固定的训练集，几乎所有的矩形特征都可以满足上述要求）。每轮训练，将选取当轮中的最佳弱分类器（在算法中，迭代$T$次即是选择$T$个最佳弱分类器），最后将每轮得到的最佳弱分类器按照一定方法提升（Boosting）为强分类器。<!--什么意思？？？是先把弱分类器选出来，再Adaboost，那为啥要迭代，直接选前T个不就好了？？？黑人问号脸，啊啊啊啊，是我太蠢，还是讲话太糊,懂了一部分是最惨的--><br>AdaBoost算法的目的是从训练数据中学习一系列弱分类器，然后把这些弱分类器组合成一个强分类器。<br><strong>AdaBoost强分类器的训练步骤：</strong>参考<a href="https://blog.csdn.net/nk_wavelet/article/details/52601567" target="_blank" rel="noopener">AdaBoost人脸监测(3)</a> <a href="https://www.shuzhiduo.com/A/nAJvK1jx5r/" target="_blank" rel="noopener">图</a></p><p><font color="red">这里的公式还没有仔细厘清，先无脑抄了，整理好了再把这里删掉</font><br>给定训练数据集$T=\left(x_{i}, y_{i}\right), i=1,2,3, \ldots N$，共$N$个样本，其中样本$x \in X$，实例空间$x \in R^n$，$y_i \in Y=\{-1, +1\}$。$T$为迭代次数。<br><strong>步骤1：</strong>初始化训练数据的权值分布。每个训练数据初始都被赋予相同的权值：$\frac{1}{N}$</p><script type="math/tex; mode=display">D_1 = (w_{11},w_{12},\ldots,w_{1N}), \quad w_{1i}=\frac{1}{N}, \quad i=1,2,\ldots,N.</script><p><strong>步骤2：</strong>进行T轮迭代，用$t=1,2,3, \ldots T$表示迭代的次数。<br>①使用具有权值分布$D_m$的训练数据集测试，得到基本分类器(选取分类误差最低的阈值设计基本分类器)：$h_m(x):X \rightarrow \{−1, +1 \}$<br>②计算$h_m（x）$在训练数据集上的分类误差率：</p><script type="math/tex; mode=display">e_m = P(h_m(x_i)\neq y_i) = \sum_{i=1}^{N}{w_{mi}I(h_m(x_i) \neq y_i)}</script><p>由上述式子可知，$h_m(x)$在训练数据集上的误差$e_m$就是被$h_m(x)$误分类样本的权值之和。</p><script type="math/tex; mode=display">ω_{t,i}=\frac{ω_{t,i}}{\sum\limits_{j=1}^{n}ω_{t,j}}</script><p>②对每个(种)特征$f_j$，训练一个弱分类器$h_j$（如上），每个分类器只使用一种Haar特征进行训练。分类误差为：</p><script type="math/tex; mode=display">ε_j=\sum\limits_{i}ω_i|h_j(x_i)-y_i|</script><p>③从②确定的弱分类器中，找出一个具有最小分类误差的弱分类器$h_t$;<br>④更新每个样本对应的权重:</p><script type="math/tex; mode=display">\omega_{t+1, i}=\omega_{t, i} \beta_{t}^{1-e_{i}}</script><p>这里，如果样本$x_i$被正确分类，则$e_i=0$，否则$e_i=1$，而</p><script type="math/tex; mode=display">\beta_t=\frac{ε_t}{1-ε_t}</script><p>4、最终形成的强分类器组成为：</p><script type="math/tex; mode=display">h(x)=\left\{\begin{array}{cc}1 & \sum_{t-1}^{T} \alpha_{t} h_{t}(x) \geq 1 / 2 \sum_{t=1}^{T} \alpha_{t} \\0 & \text { otherwise }\end{array}\right.</script><p>其中：</p><script type="math/tex; mode=display">\alpha_t=log\frac{1}{\beta_t}</script><p>&emsp;&emsp;在使用Adaboost算法训练分类器之前，需要准备好正、负样本，根据样本特点选择和构造特征集。<br>&emsp;&emsp;由算法的训练过程可知，当弱分类器对样本分类正确，样本的权重会减小；而分类错误时，样本的权重会增加。这样，后面的分类器会加强对错分样本的训练。最后，组合所有的弱分类器形成强分类器，通过比较这些弱分类器投票的加权和与平均投票结果来检测图像。<br>&emsp;&emsp;OpenCV中，强分类器是由多个弱分类器“并列”构成，即强分类器中的弱分类器是两两相互独立的。在检测目标时，每个弱分类器独立运行并输出结果，然后把当前强分类器中每一个弱分类器的输出值相加，与本级强分类器的阈值相比，当且仅当结果大于阈值，认为当前检测窗口通过了该级强分类器。</p><h3 id="3-级联分类器的检测"><a href="#3-级联分类器的检测" class="headerlink" title="3.级联分类器的检测"></a>3.级联分类器的检测</h3><p>&emsp;&emsp;整合好了级联分类器，接下来就是高光时刻：检测！<br>&emsp;&emsp;检测是以显示中的一副图片作为输入，然后对图片进行多区域、多尺度的检测。</p><ul><li>多区域检测是指遍历整张图片。</li><li>多尺度检测有两种策略<br>1）搜索窗口的大小不变，不断缩放图片，在这种情况下需要对每个缩放后的图片进行区域特征值的运算，效率较低。<br>2）不断扩大搜索窗口，对图片进行特征值运算，效率较高。<strong>因为1）需要计算大小不同的图片的积分图，而2）只需对原图进行一次积分图即可。不同的搜索窗口的特征值计算在线性时间内即可完成。</strong></li></ul><p>&emsp;&emsp;放大+平移获得的子特征有多少个呢？Rainer Lienhart在其论文中做出了解释，假设检测窗口大小为$W<em>H$，矩形特征大小为$w</em>h$，X和Y表示矩形特征在水平和垂直方向上能放大的最大比例系数：</p><p><img src="/article/ad28cab2/20180527174205634" srcset="/img/loading.gif" alt="img"></p><p>&emsp;&emsp;如图5，在检测窗口window中，一般矩形特征的数量为：$XY(W+1-w\frac{X+1}{2})(    H+1-h\frac{Y+1}{2})$。对于之前x3特征在24*24大小的检测窗口中（W=H=24,w=3,h=1,X=8,Y=24），一共能产生27600个子特征。具体参考<a href="https://blog.csdn.net/liulina603/article/details/8617281" target="_blank" rel="noopener">Haar特征与积分图</a>。<br>&emsp;&emsp;无论哪种搜索方法，都会向级联分类器输入大量的子窗口图像，子窗口图像在筛选式级联分类器中依次被每一个节点筛选，丢弃或通过。最后利用并查集合并检测结果窗口。重叠窗口个数大于阈值时，选取其中之一作为检测结果，其余丢弃。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h3><p>总结Haar分类器的五大训练步骤：</p><ol><li>准备人脸、非人脸样本集</li><li>计算特征值和积分图</li><li>筛选出T个优秀的最优弱分类器(特征值)</li><li>把T个最优弱分类器传给AdaBoost进行训练，得到一个强分类器</li><li>重复3. 4.，将得到的n个强分类器级联成一个Adaboost级联分类器。</li></ol><p>以20*20窗口为例，有78,460个特征，筛选出T个优秀的最优弱分类器，然后把T个最优弱分类器传给AdaBoost进行训练得到一个强分类器，最后将n个强分类器级联成一个Adaboost级联分类器。</p><h2 id="五、分类器的检测"><a href="#五、分类器的检测" class="headerlink" title="五、分类器的检测"></a>五、分类器的检测</h2><p>OpenCV自带了训练器和检测器。如果想从头训练一个分类器检测汽车、飞机等其他物体，可以使用OpenCV构建。细节参考这里：<a href="http://docs.opencv.org/2.4/doc/user_guide/ug_traincascade.html" target="_blank" rel="noopener">Cascade Classifier Training</a>。<br>OpenCV自带的检测器在OpenCV库文件\haarcascades文件\xx.xml文件中。在我的电脑里，具体路径为C:\Users\susu\AppData\Roaming\Python\Python37\site-packages\cv2\data\中。这个文件夹下包含了检测人脸、眼睛、鼻子和嘴等部位的检测器。均需要正面、直立的人体图像。<br>xml文件包含了检测器的相关信息。具体可以参考<a href="https://blog.csdn.net/playezio/article/details/80471000" target="_blank" rel="noopener">haar+adaboost代码讲解(OpenCV)</a>。</p><h1 id="3-3-人脸检测-OpenCV简单实现"><a href="#3-3-人脸检测-OpenCV简单实现" class="headerlink" title="3.3 人脸检测(OpenCV简单实现)"></a>3.3 人脸检测(OpenCV简单实现)</h1><h2 id="一、静态图片中的人脸检测"><a href="#一、静态图片中的人脸检测" class="headerlink" title="一、静态图片中的人脸检测"></a>一、静态图片中的人脸检测</h2><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2<span class="hljs-comment"># 加载图像</span>img = cv2.imread(<span class="hljs-string">'image2.jpg'</span>, <span class="hljs-number">1</span>)<span class="hljs-comment"># 创建人脸和人眼的级联分类器，加载.xml分类器文件，即Haar特征的分类器（上一篇使用LBP特征的分类器）</span>face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades+<span class="hljs-string">'haarcascade_frontalface_default.xml'</span>)eye_cascade = cv2.CascadeClassifier(cv2.data.haarcascades+<span class="hljs-string">'haarcascade_eye.xml'</span>)<span class="hljs-comment"># 进行人脸检测，scaleFactor表示图像的压缩率，minNeighbors表示每个人脸矩形的邻近数目</span>faces = face_cascade.detectMultiScale(img, scaleFactor=<span class="hljs-number">1.3</span>, minNeighbors=<span class="hljs-number">5</span>)<span class="hljs-keyword">for</span> (x, y, w, h) <span class="hljs-keyword">in</span> faces:    <span class="hljs-comment"># 使用矩形框出人脸</span>    img = cv2.rectangle(img, (x, y), (x+w, y+h), (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)    face_area = img[y:y+h, x:x+w]    <span class="hljs-comment"># 在人脸上检测人眼</span>    eyes = eye_cascade.detectMultiScale(face_area)    <span class="hljs-comment"># 使用矩形框出人眼</span>    <span class="hljs-keyword">for</span> (ex, ey, ew, eh) <span class="hljs-keyword">in</span> eyes:        cv2.rectangle(face_area, (ex, ey), (ex+ew, ey+eh), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>)cv2.imshow(<span class="hljs-string">'img'</span>, img)cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()cv2.imwrite(<span class="hljs-string">'output.jpg'</span>, img)</code></pre><h2 id="二、实时人脸监测"><a href="#二、实时人脸监测" class="headerlink" title="二、实时人脸监测"></a>二、实时人脸监测</h2><pre><code class="hljs python"><span class="hljs-comment"># 调用电脑摄像头进行实时人脸+眼睛识别</span><span class="hljs-keyword">import</span> cv2face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades+<span class="hljs-string">'haarcascade_frontalface_default.xml'</span>)eye_cascade = cv2.CascadeClassifier(cv2.data.haarcascades+<span class="hljs-string">'haarcascade_eye.xml'</span>)smile_cascade = cv2.CascadeClassifier(cv2.data.haarcascades+<span class="hljs-string">'haarcascade_smile.xml'</span>)<span class="hljs-comment"># 调用摄像头</span>cap = cv2.VideoCapture(<span class="hljs-number">0</span>)cv2.namedWindow(<span class="hljs-string">'Dynamic'</span>)<span class="hljs-keyword">while</span>(<span class="hljs-literal">True</span>):    <span class="hljs-comment"># 获取摄像头拍摄到的画面</span>    ret, frame = cap.read()    <span class="hljs-comment"># ret为True表明图片读取成功。</span>    faces = face_cascade.detectMultiScale(frame, <span class="hljs-number">1.3</span>, <span class="hljs-number">2</span>)    img = frame    <span class="hljs-keyword">for</span> (x, y, w, h) <span class="hljs-keyword">in</span> faces:        <span class="hljs-comment"># 画出人脸框，蓝色，画笔宽度</span>        img = cv2.rectangle(img, (x, y), (x+w, y+h), (<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)        <span class="hljs-comment"># 框选出人脸区域，在人脸区域而不是全图中进行人眼检测，节省计算资源</span>        face_area = img[y:y+h, x:x+w]        eyes = eye_cascade.detectMultiScale(face_area, <span class="hljs-number">1.3</span>, <span class="hljs-number">10</span>)        <span class="hljs-comment"># 画出人眼框，绿色，画笔宽度为1</span>        <span class="hljs-keyword">for</span> (ex, ey, ew, eh) <span class="hljs-keyword">in</span> eyes:            eye_area = cv2.rectangle(face_area, (ex, ey), (ex+ew, ey+eh), (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">1</span>)        smile = smile_cascade.detectMultiScale(face_area, scaleFactor=<span class="hljs-number">1.16</span>, minNeighbors=<span class="hljs-number">65</span>, minSize=(<span class="hljs-number">25</span>, <span class="hljs-number">25</span>), flags=cv2.CASCADE_SCALE_IMAGE)        <span class="hljs-keyword">for</span> (ex, ey, ew, eh) <span class="hljs-keyword">in</span> smile:            cv2.rectangle(face_area, (ex, ey, ex+ew, ey+eh), (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">1</span>)            cv2.putText(img, <span class="hljs-string">'Smile'</span>, (x, y<span class="hljs-number">-7</span>), <span class="hljs-number">3</span>, <span class="hljs-number">1.2</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>, cv2.LINE_AA)    cv2.imshow(<span class="hljs-string">'frame2'</span>, img)    <span class="hljs-comment"># 按下q键退出</span>    <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">5</span>) &amp; <span class="hljs-number">0xFF</span> == ord(<span class="hljs-string">'q'</span>):        <span class="hljs-keyword">break</span>cap.release()cv2.destroyAllWindows()</code></pre><p>简单分析上面的代码:<br>&emsp;&emsp;创建一个级联分类器对象，加载xml检测器，进行人脸监测。</p><pre><code class="hljs python">face_cascade = cv2.CascadeClassifier(cv2.data.haarcascades+<span class="hljs-string">'haarcascade_frontalface_default.xml'</span>)</code></pre><p>&emsp;&emsp;将人脸图像放入监测。<strong>不同于LBP检测器，这里彩色的图像也是可以的。</strong></p><pre><code class="hljs python">detectMultiScale(image[,scaleFactor[,minNeighbors[,flags,[minSize,[maxSize]]]]])</code></pre><p>1）image：待检测的输入图像<br>2）scaleFactor：每一个图像的尺度参数。默认值为1.1。scaleFactor参数控制两个不同大小窗口扫描的间距。参数过大，可能会错过正确的人脸区域。<br>3）minNeighbors：每一个级联矩形应该保留的邻近个数，默认为3.minNeighbors控制与检测率。默认值为3，表明至少有3次重叠监测，认为人脸确实存在。<br>4）minSize：目标最小尺寸<br>5）maxSize：目标最大尺寸</p><p>这次想写得太多了，啥都想加，加到最后好累。。。sad，不知道应该挑几个重点还是都来。awsl</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/zyly/p/9410563.html" target="_blank" rel="noopener">人脸监测之Haar分类器</a><br><a href="https://blog.csdn.net/liulina603/article/details/8617281" target="_blank" rel="noopener">Haar特征与积分图(推荐)</a><br><a href="https://blog.csdn.net/nk_wavelet/article/details/52601567" target="_blank" rel="noopener">AdaBoost人脸检测介绍(3)</a></p>]]></content>
    
    
    <categories>
      
      <category>图像处理下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pandas下综合练习</title>
    <link href="/article/67aeaf8.html"/>
    <url>/article/67aeaf8.html</url>
    
    <content type="html"><![CDATA[<p>看了优秀的题解，还是把我的辣鸡题解更新一下好了~</p><h1 id="一、端午节的淘宝粽子交易"><a href="#一、端午节的淘宝粽子交易" class="headerlink" title="一、端午节的淘宝粽子交易"></a>一、端午节的淘宝粽子交易</h1><p>（1）请删除最后一列为缺失值的行，并求所有在杭州发货的商品单价均值。</p><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">'端午粽子数据.csv'</span>)df.head()</code></pre><p>输出：</p><p><img src="/article/67aeaf8/image-20200701220417701.png" srcset="/img/loading.gif" alt="image-20200701220417701"></p><p>列名中有些包含了空格，先去除。</p><pre><code class="hljs python">df.columns = df.columns.str.strip()df.columns</code></pre><p>输出：</p><p><img src="/article/67aeaf8/image-20200701220535004.png" srcset="/img/loading.gif" alt="image-20200701220535004"></p><p>然后将最后一列为空的行去除，使用dropna方法。再查看最后一列为空的行。</p><pre><code class="hljs python">df_clean = df.dropna(axis=<span class="hljs-number">0</span>,subset=[df.columns[<span class="hljs-number">-1</span>]])df_clean[df_clean[df_clean.columns[<span class="hljs-number">-1</span>]].isna()]</code></pre><p>输出：</p><p><img src="/article/67aeaf8/image-20200701220754043.png" srcset="/img/loading.gif" alt="image-20200701220754043"></p><p>确认已删除完毕。<br>将所有在杭州交易的记录取出。</p><pre><code class="hljs python">df_h = df_clean[df_clean[<span class="hljs-string">'发货地址'</span>].str.contains(<span class="hljs-string">'杭州'</span>)]</code></pre><p>查看其中价格列不能转换为float的行。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_number</span><span class="hljs-params">(x)</span>:</span>    <span class="hljs-keyword">try</span>:        float(x)        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>    <span class="hljs-keyword">except</span> (SyntaxError, ValueError) <span class="hljs-keyword">as</span> e:        <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>df_h[~df_h[<span class="hljs-string">'价格'</span>].map(is_number)]</code></pre><p>输出：</p><p><img src="/article/67aeaf8/image-20200701221103969.png" srcset="/img/loading.gif" alt="image-20200701221103969"></p><p>将其价格改为45。计算价格转换为float类型并计算均值。</p><pre><code class="hljs python">df_h.loc[<span class="hljs-number">4376</span>][<span class="hljs-string">'价格'</span>] = <span class="hljs-number">45</span>df_h[<span class="hljs-string">'价格'</span>].astype(<span class="hljs-string">'float'</span>).mean()<span class="hljs-comment"># to_numeric也是ok的~</span><span class="hljs-comment"># pd.to_numeric(df_h['价格']).mean()</span></code></pre><p>输出：</p><p><img src="/article/67aeaf8/image-20200701221222671.png" srcset="/img/loading.gif" alt="image-20200701221222671"></p><p>（2）商品标题带有”嘉兴”但发货地却不在嘉兴的商品有多少条记录？<br>直接使用contain方法求取即可。</p><pre><code class="hljs python">df_bj = df_clean[df_clean[<span class="hljs-string">'标题'</span>].str.contains(<span class="hljs-string">'嘉兴'</span>)]df_bj_nj =df_bj[~(df_bj[<span class="hljs-string">'发货地址'</span>].str.contains(<span class="hljs-string">'嘉兴'</span>))]df_bj_nj.shape</code></pre><p>输出：</p><pre><code class="hljs tex">(1032, 5)</code></pre><p>（3）请按照分位数将价格分为“高、较高、中、较低、低” 5个类别，再将类别结果插入到标题一列之后，最后对类别列进行降序排序。<br>查看价格列中异常值。</p><pre><code class="hljs python">df_clean[~df_clean[<span class="hljs-string">'价格'</span>].map(is_number)]</code></pre><p>输出：</p><p><img src="/article/67aeaf8/image-20200701221526292.png" srcset="/img/loading.gif" alt="image-20200701221526292"></p><p>修改为对应的正常值。</p><pre><code class="hljs python">df_clean.loc[<span class="hljs-number">538</span>][<span class="hljs-string">'价格'</span>] = <span class="hljs-number">45.9</span>df_clean.loc[<span class="hljs-number">4376</span>][<span class="hljs-string">'价格'</span>] = <span class="hljs-number">45</span></code></pre><p>使用qcut方法将价格按数量等分为5类。并重命名为“高、较高、中、较低、低” 5个类别。</p><pre><code class="hljs python">q_cut = pd.qcut(df_clean[<span class="hljs-string">'价格'</span>].astype(<span class="hljs-string">'float'</span>),<span class="hljs-number">5</span>)df_clean.loc[:,<span class="hljs-string">'类别'</span>] = q_cut.cat.rename_categories([<span class="hljs-string">'低'</span>,<span class="hljs-string">'较低'</span>,<span class="hljs-string">'中'</span>,<span class="hljs-string">'较高'</span>,<span class="hljs-string">'高'</span>])<span class="hljs-comment"># 上面两行可以优化为如下形式，效果一样的~</span>q_cut = pd.qcut(df_clean[<span class="hljs-string">'价格'</span>].astype(<span class="hljs-string">'float'</span>),<span class="hljs-number">5</span>, labels=([<span class="hljs-string">'低'</span>,<span class="hljs-string">'较低'</span>,<span class="hljs-string">'中'</span>,<span class="hljs-string">'较高'</span>,<span class="hljs-string">'高'</span>])df_clean.loc[:,<span class="hljs-string">'类别'</span>] = q_cut</code></pre><p>将列顺序按要求排列。并将表格按照类别进行降序排列。</p><pre><code class="hljs python">df_clean = df_clean[[<span class="hljs-string">'标题'</span>,<span class="hljs-string">'类别'</span>,<span class="hljs-string">'价格'</span>,<span class="hljs-string">'付款人数'</span>,<span class="hljs-string">'店铺'</span>,<span class="hljs-string">'发货地址'</span>]]df_clean = df_clean.sort_values(<span class="hljs-string">'类别'</span>, ascending=<span class="hljs-literal">False</span>)</code></pre><p>输出：</p><p><img src="/article/67aeaf8/image-20200701221901144.png" srcset="/img/loading.gif" alt="image-20200701221901144"></p><p>（4）付款人数一栏有缺失值吗？若有则请利用上一问的分类结果对这些缺失值进行合理估计并填充。<br>查看付款人数一栏有缺失值的行。</p><pre><code class="hljs python">df_clean[df_clean[<span class="hljs-string">'付款人数'</span>].isna()]</code></pre><p>输出：</p><p><img src="/article/67aeaf8/image-20200701221950329.png" srcset="/img/loading.gif" alt="image-20200701221950329"></p><p>（我想起来了，上次写到这，晚上11点多了，注释一个都不写了，直接粗暴贴代码o_o ….补上补上）<br>replace函数将付款人数一列的数字提取出来，然后根据付款人数对价格线性插值，这里线性插值需要把付款人数作为index索引。所以下一步就是把列重新排好序。</p><pre><code class="hljs gml">def replace(<span class="hljs-symbol">x</span>):    try:        <span class="hljs-symbol">x</span> = str(<span class="hljs-symbol">x</span>)        <span class="hljs-keyword">if</span> <span class="hljs-string">'万'</span> in <span class="hljs-symbol">x</span>:            i = <span class="hljs-symbol">x</span>.index(<span class="hljs-string">'万'</span>)            <span class="hljs-keyword">return</span> float(<span class="hljs-symbol">x</span>[:i]) * <span class="hljs-number">10000</span>        <span class="hljs-keyword">if</span> <span class="hljs-string">'+'</span> in <span class="hljs-symbol">x</span>:            i = <span class="hljs-symbol">x</span>.index(<span class="hljs-string">'+'</span>)        elif <span class="hljs-string">'人'</span> in <span class="hljs-symbol">x</span>:            i = <span class="hljs-symbol">x</span>.index(<span class="hljs-string">'人'</span>)        <span class="hljs-keyword">else</span>:            # print(<span class="hljs-symbol">x</span>)            <span class="hljs-keyword">return</span> None        <span class="hljs-keyword">return</span> int(<span class="hljs-symbol">x</span>[:i])    except:        print(<span class="hljs-symbol">x</span>)        <span class="hljs-keyword">return</span> None</code></pre><pre><code class="hljs python">df_clean[<span class="hljs-string">'付款人数'</span>] = df_clean[<span class="hljs-string">'付款人数'</span>].map(replace)df_clean = df_clean.set_index(<span class="hljs-string">'价格'</span>)df_clean[<span class="hljs-string">'付款人数'</span>] = df_clean[<span class="hljs-string">'付款人数'</span>].interpolate(method=<span class="hljs-string">'index'</span>)df_clean = df_clean.reset_index()df_clean = df_clean[[<span class="hljs-string">'标题'</span>,<span class="hljs-string">'类别'</span>,<span class="hljs-string">'价格'</span>,<span class="hljs-string">'付款人数'</span>,<span class="hljs-string">'店铺'</span>,<span class="hljs-string">'发货地址'</span>]]</code></pre><p>（5）请将数据后四列合并为如下格式的Series:商品发货地为xx，店铺为xx，共计xx人付款，单价为xx。</p><p>列合并，把列类型转换为str类型，然后相当于对字符串进行合并。</p><pre><code class="hljs prolog">result = <span class="hljs-string">'商品发货地为'</span>+df_clean[<span class="hljs-string">'发货地址'</span>]+<span class="hljs-string">',店铺为'</span>+df_clean[<span class="hljs-string">'店铺'</span>]+<span class="hljs-string">',共计'</span>+df_clean[<span class="hljs-string">'付款人数'</span>].astype(<span class="hljs-string">'str'</span>)+<span class="hljs-string">',单价为'</span>\                   + df_clean[<span class="hljs-string">'价格'</span>].astype(<span class="hljs-string">'str'</span>)+<span class="hljs-string">'元'</span></code></pre><p>输出：</p><p><img src="/article/67aeaf8/image-20200712121904797.png" srcset="/img/loading.gif" alt="image-20200712121904797"></p><pre><code class="hljs python"><span class="hljs-comment"># 错误题解</span>result.str.extract(<span class="hljs-string">r'商品发货地为(?P&lt;发货地址&gt;[\w]+),店铺为(?P&lt;店铺&gt;[\w]+) \</span><span class="hljs-string">                    ,共计(?P&lt;付款人数&gt;[\w]+),单价为(?P&lt;价格&gt;[?\d.\dh]+)元'</span>)</code></pre><p>（做题的时候，提取的时候失败了。。当然看了优秀题解的我又回来了）</p><pre><code class="hljs python">new_df = pd.DataFrame(index=df_clean.index)new_df[<span class="hljs-string">'发货地址'</span>] = result.str.extract(<span class="hljs-string">r'商品发货地为(.+),店'</span>)new_df[<span class="hljs-string">'店铺'</span>] = result.str.extract(<span class="hljs-string">r'店铺为(.+),共'</span>)new_df[<span class="hljs-string">'付款人数'</span>] = result.str.extract(<span class="hljs-string">r'共计(.+),单'</span>)new_df[<span class="hljs-string">'价格'</span>] = result.str.extract(<span class="hljs-string">r'单价为(.+)元'</span>)new_df.head()</code></pre><p>或者下面这种一步到位。</p><pre><code class="hljs python">result.str.extract(<span class="hljs-string">r'商品发货地为(?P&lt;发货地址&gt;.+),店铺为(?P&lt;店铺&gt;.+),共计(?P&lt;付款人数&gt;.+),单价为(?P&lt;价格&gt;.+)元'</span>)</code></pre><p>输出：</p><p><img src="/article/67aeaf8/image-20200712121822808.png" srcset="/img/loading.gif" alt="image-20200712121822808"></p><h1 id="二、墨尔本每日最低温度"><a href="#二、墨尔本每日最低温度" class="headerlink" title="二、墨尔本每日最低温度"></a>二、墨尔本每日最低温度</h1><p>(1) 剔除国庆节、五一劳动节和每月第一个周一，求每月的平均最低气温。</p><p>读取墨尔本每日温度数据。</p><pre><code class="hljs python">df2 = pd.read_csv(<span class="hljs-string">'墨尔本温度数据.csv'</span>, parse_dates=[<span class="hljs-string">'Date'</span>])df2.head()</code></pre><pre><code class="hljs tex">        Date  Temp0 1981-01-01  20.71 1981-01-02  17.92 1981-01-03  18.83 1981-01-04  14.64 1981-01-05  15.8</code></pre><p>把Data列转换为时间类型。</p><pre><code class="hljs python">df2[<span class="hljs-string">'Date'</span>] = pd.to_datetime(df2[<span class="hljs-string">'Date'</span>])</code></pre><p>把每月第一个周一、国庆节、五一劳动节的时间聚合在一起。按照时间顺序排列。</p><pre><code class="hljs python"><span class="hljs-comment">#d = pd.date_range(start='1981-1-1',end='1990-12-31')</span>d = df2[<span class="hljs-string">'Date'</span>]mask1 = (d.dt.weekday==<span class="hljs-number">0</span>) &amp; (d.dt.day&gt;<span class="hljs-number">0</span>) &amp;(d.dt.day&lt;=<span class="hljs-number">7</span>)mask10 = (d.dt.month == <span class="hljs-number">10</span>) &amp; (<span class="hljs-number">0</span>&lt;d.dt.day) &amp; (d.dt.day&lt;=<span class="hljs-number">8</span>)mask5 = (d.dt.month == <span class="hljs-number">5</span>) &amp; (d.dt.day&gt;<span class="hljs-number">0</span>) &amp; (d.dt.day&lt;=<span class="hljs-number">5</span>)holidays = d[mask1].append(d[mask5]).append(d[mask10]).sort_values()<span class="hljs-comment"># print(holidays)</span></code></pre><p>剔除holiday之后，对每月resample求平均值。</p><pre><code class="hljs python">result = df2[~df2[<span class="hljs-string">'Date'</span>].isin(holidays)].set_index(<span class="hljs-string">'Date'</span>).\resample(<span class="hljs-string">'MS'</span>).mean()result.head()</code></pre><p>输出：</p><pre><code class="hljs angelscript">                 TempDate                 <span class="hljs-number">1981</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span>  <span class="hljs-number">17.776667</span><span class="hljs-number">1981</span><span class="hljs-number">-02</span><span class="hljs-number">-01</span>  <span class="hljs-number">17.637037</span><span class="hljs-number">1981</span><span class="hljs-number">-03</span><span class="hljs-number">-01</span>  <span class="hljs-number">13.330000</span><span class="hljs-number">1981</span><span class="hljs-number">-04</span><span class="hljs-number">-01</span>  <span class="hljs-number">12.210345</span><span class="hljs-number">1981</span><span class="hljs-number">-05</span><span class="hljs-number">-01</span>   <span class="hljs-number">9.273077</span></code></pre><p>（2）季节指数是一种对于周期性变化序列的特征刻画。记数据集中第k年平均最低气温为$TY_k(k=1,…,10)$，第k年第j个平均最低气温为$TY_{kj}(j=1,…,10)$，定义$S_j=\frac{ \sum_{k} TM_{kj} }{ \sum_{k} TY_k }$。请按照如上定义，计算12个月的季节指数$S_j$。</p><p>就是把数据按照年Y聚合，求均值再求和得到$\sum_{k} TY_k$。把数据按照月聚合，按照月份求和得到$\sum_{k} TM_{kj}$，两者相除得到$S_j$。</p><pre><code class="hljs python">melbourne = df2.set_index(<span class="hljs-string">'Date'</span>)TY_K = melbourne.resample(<span class="hljs-string">'Y'</span>).mean()TY = TY_K.sum()TM_KJ = melbourne.resample(<span class="hljs-string">'MS'</span>).mean()<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>,<span class="hljs-number">13</span>):    result_i = TM_KJ[TM_KJ.index.month==i].sum() / TY    print(<span class="hljs-string">'S&#123;&#125;='</span>.format(i),result_i.values[<span class="hljs-number">0</span>].round(decimals=<span class="hljs-number">4</span>))</code></pre><p>输出：</p><pre><code class="hljs ini"><span class="hljs-attr">S1</span>= <span class="hljs-number">1.3447</span><span class="hljs-attr">S2</span>= <span class="hljs-number">1.3758</span><span class="hljs-attr">S3</span>= <span class="hljs-number">1.3031</span><span class="hljs-attr">S4</span>= <span class="hljs-number">1.0815</span><span class="hljs-attr">S5</span>= <span class="hljs-number">0.8827</span><span class="hljs-attr">S6</span>= <span class="hljs-number">0.6511</span><span class="hljs-attr">S7</span>= <span class="hljs-number">0.5987</span><span class="hljs-attr">S8</span>= <span class="hljs-number">0.706</span><span class="hljs-attr">S9</span>= <span class="hljs-number">0.8031</span><span class="hljs-attr">S10</span>= <span class="hljs-number">0.9223</span><span class="hljs-attr">S11</span>= <span class="hljs-number">1.1165</span><span class="hljs-attr">S12</span>= <span class="hljs-number">1.2394</span></code></pre><p>（3）移动平均法是一种时间序列的常见平滑方式，可分为k期移动平均和k期中心移动平均，都使用了某一时刻及其周围的数据对该时刻的数据进行平滑修正。设原序列为$x_1,\ldots,x_n$，对于$x_t$的k期移动平均修正$\tilde{x_t}$为$\frac{ \sum_{i=0}^{k-1} x_{t-i}}{k}$，对于k期中心移动平均修正为</p><script type="math/tex; mode=display">\tilde{x_t}= \begin{cases}\frac{1}{k}(\frac{1}{2} x_{t-\frac{k}{2}} + x_{t-\frac{k}{2}+1}+\ldots+x_t+\ldots+x_{t+\frac{k}{2}-1}+\frac{1}{2} x_{t+\frac{k}{2}}) & k \quad is \quad even \\\frac{1}{k}(x_{t-\frac{k-1}{2}} + x_{t-\frac{k-1}{2}+1}+\ldots+x_t+\ldots+x_{t+\frac{k-1}{2}-1}+ x_{t+\frac{k-1}{2}}) & else \\\end{cases}</script><p>（a）求原序列的5期移动平均序列。</p><p>这个第一次遇到，很巧妙。就是用rolling方法把window=5的窗口聚合，求和，然后往后移动两位，就是$\sum_{i=0}^{k-1} x_{t-i}$，再除以k就ok啦。</p><pre><code class="hljs python">melbourne.rolling(window=<span class="hljs-number">5</span>, min_periods=<span class="hljs-number">-5</span>).sum().shift(<span class="hljs-number">-2</span>)/<span class="hljs-number">5</span><span class="hljs-comment"># window和min_periods什么关系？</span></code></pre><p>输出：</p><pre><code class="hljs angelscript"> TempDate             <span class="hljs-number">1981</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span>  <span class="hljs-number">11.48</span><span class="hljs-number">1981</span><span class="hljs-number">-01</span><span class="hljs-number">-02</span>  <span class="hljs-number">14.40</span><span class="hljs-number">1981</span><span class="hljs-number">-01</span><span class="hljs-number">-03</span>  <span class="hljs-number">17.56</span><span class="hljs-number">1981</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>  <span class="hljs-number">16.58</span><span class="hljs-number">1981</span><span class="hljs-number">-01</span><span class="hljs-number">-05</span>  <span class="hljs-number">16.16</span>...           ...<span class="hljs-number">1990</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span>  <span class="hljs-number">13.72</span><span class="hljs-number">1990</span><span class="hljs-number">-12</span><span class="hljs-number">-28</span>  <span class="hljs-number">14.28</span><span class="hljs-number">1990</span><span class="hljs-number">-12</span><span class="hljs-number">-29</span>  <span class="hljs-number">13.96</span><span class="hljs-number">1990</span><span class="hljs-number">-12</span><span class="hljs-number">-30</span>    NaN<span class="hljs-number">1990</span><span class="hljs-number">-12</span><span class="hljs-number">-31</span>    NaN[<span class="hljs-number">3650</span> rows x <span class="hljs-number">1</span> columns]</code></pre><p>（b）求原序列的5期与6期中心移动平均序列。</p><p>跟上一题差不多的啦，就不写啦。</p><pre><code class="hljs python">(melbourne.shift(<span class="hljs-number">-3</span>)/<span class="hljs-number">2</span>+melbourne.shift(<span class="hljs-number">3</span>)/<span class="hljs-number">2</span>+melbourne.rolling(window=<span class="hljs-number">5</span>,min_periods=<span class="hljs-number">-5</span>).sum().shift(<span class="hljs-number">-2</span>))/<span class="hljs-number">6</span></code></pre><p>输出：</p><pre><code class="hljs angelscript">TempDate            <span class="hljs-number">1981</span><span class="hljs-number">-01</span><span class="hljs-number">-01</span>  <span class="hljs-number">57.4</span><span class="hljs-number">1981</span><span class="hljs-number">-01</span><span class="hljs-number">-02</span>  <span class="hljs-number">72.0</span><span class="hljs-number">1981</span><span class="hljs-number">-01</span><span class="hljs-number">-03</span>  <span class="hljs-number">87.8</span><span class="hljs-number">1981</span><span class="hljs-number">-01</span><span class="hljs-number">-04</span>  <span class="hljs-number">82.9</span><span class="hljs-number">1981</span><span class="hljs-number">-01</span><span class="hljs-number">-05</span>  <span class="hljs-number">80.8</span>...          ...<span class="hljs-number">1990</span><span class="hljs-number">-12</span><span class="hljs-number">-27</span>  <span class="hljs-number">68.6</span><span class="hljs-number">1990</span><span class="hljs-number">-12</span><span class="hljs-number">-28</span>  <span class="hljs-number">71.4</span><span class="hljs-number">1990</span><span class="hljs-number">-12</span><span class="hljs-number">-29</span>  <span class="hljs-number">69.8</span><span class="hljs-number">1990</span><span class="hljs-number">-12</span><span class="hljs-number">-30</span>   NaN<span class="hljs-number">1990</span><span class="hljs-number">-12</span><span class="hljs-number">-31</span>   NaN[<span class="hljs-number">3650</span> rows x <span class="hljs-number">1</span> columns]</code></pre><h1 id="三、2016年8月上海市摩拜单车骑行记录"><a href="#三、2016年8月上海市摩拜单车骑行记录" class="headerlink" title="三、2016年8月上海市摩拜单车骑行记录"></a>三、2016年8月上海市摩拜单车骑行记录</h1><p>（这题我吐槽我自己，写的太复杂啦。做了前2题半，用group做，是真的写的丑。时间序列那章没学好，统统删掉重写）<br>（1）平均而言，周末单天用车量比工作日单天用车量更大吗？</p><p>（第一题优秀题解有点问题，使用D是单天用车量。）</p><pre><code class="hljs python">df3 = pd.read_csv(<span class="hljs-string">'摩拜单车数据.csv'</span>)df3.head()</code></pre><p>输出：</p><pre><code class="hljs angelscript">orderid  bikeid  userid        start_time  start_location_x  \ <span class="hljs-number">0</span>    <span class="hljs-number">78387</span>  <span class="hljs-number">158357</span>   <span class="hljs-number">10080</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-20</span> <span class="hljs-number">06</span>:<span class="hljs-number">57</span>           <span class="hljs-number">121.348</span>   <span class="hljs-number">1</span>   <span class="hljs-number">891333</span>   <span class="hljs-number">92776</span>    <span class="hljs-number">6605</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">19</span>:<span class="hljs-number">09</span>           <span class="hljs-number">121.508</span>   <span class="hljs-number">2</span>  <span class="hljs-number">1106623</span>  <span class="hljs-number">152045</span>    <span class="hljs-number">8876</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-13</span> <span class="hljs-number">16</span>:<span class="hljs-number">17</span>           <span class="hljs-number">121.383</span>   <span class="hljs-number">3</span>  <span class="hljs-number">1389484</span>  <span class="hljs-number">196259</span>   <span class="hljs-number">10648</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-23</span> <span class="hljs-number">21</span>:<span class="hljs-number">34</span>           <span class="hljs-number">121.484</span>   <span class="hljs-number">4</span>   <span class="hljs-number">188537</span>   <span class="hljs-number">78208</span>   <span class="hljs-number">11735</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-16</span> <span class="hljs-number">07</span>:<span class="hljs-number">32</span>           <span class="hljs-number">121.407</span>      start_location_y          end_time  end_location_x  end_location_y  \<span class="hljs-number">0</span>            <span class="hljs-number">31.389</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-20</span> <span class="hljs-number">07</span>:<span class="hljs-number">04</span>         <span class="hljs-number">121.357</span>          <span class="hljs-number">31.388</span>   <span class="hljs-number">1</span>            <span class="hljs-number">31.279</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">19</span>:<span class="hljs-number">31</span>         <span class="hljs-number">121.489</span>          <span class="hljs-number">31.271</span>   <span class="hljs-number">2</span>            <span class="hljs-number">31.254</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-13</span> <span class="hljs-number">16</span>:<span class="hljs-number">36</span>         <span class="hljs-number">121.405</span>          <span class="hljs-number">31.248</span>   <span class="hljs-number">3</span>            <span class="hljs-number">31.320</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-23</span> <span class="hljs-number">21</span>:<span class="hljs-number">43</span>         <span class="hljs-number">121.471</span>          <span class="hljs-number">31.325</span>   <span class="hljs-number">4</span>            <span class="hljs-number">31.292</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-16</span> <span class="hljs-number">07</span>:<span class="hljs-number">41</span>         <span class="hljs-number">121.418</span>          <span class="hljs-number">31.288</span>                                                  track  <span class="hljs-number">0</span>  <span class="hljs-number">121.347</span>,<span class="hljs-number">31.392</span>#<span class="hljs-number">121.348</span>,<span class="hljs-number">31.389</span>#<span class="hljs-number">121.349</span>,<span class="hljs-number">31.390</span>#<span class="hljs-number">1.</span>..  <span class="hljs-number">1</span>  <span class="hljs-number">121.489</span>,<span class="hljs-number">31.270</span>#<span class="hljs-number">121.489</span>,<span class="hljs-number">31.271</span>#<span class="hljs-number">121.490</span>,<span class="hljs-number">31.270</span>#<span class="hljs-number">1.</span>..  <span class="hljs-number">2</span>  <span class="hljs-number">121.381</span>,<span class="hljs-number">31.251</span>#<span class="hljs-number">121.382</span>,<span class="hljs-number">31.251</span>#<span class="hljs-number">121.382</span>,<span class="hljs-number">31.252</span>#<span class="hljs-number">1.</span>..  <span class="hljs-number">3</span>  <span class="hljs-number">121.471</span>,<span class="hljs-number">31.325</span>#<span class="hljs-number">121.472</span>,<span class="hljs-number">31.325</span>#<span class="hljs-number">121.473</span>,<span class="hljs-number">31.324</span>#<span class="hljs-number">1.</span>..  <span class="hljs-number">4</span>  <span class="hljs-number">121.407</span>,<span class="hljs-number">31.291</span>#<span class="hljs-number">121.407</span>,<span class="hljs-number">31.292</span>#<span class="hljs-number">121.408</span>,<span class="hljs-number">31.291</span>#<span class="hljs-number">1.</span>..</code></pre><p>把start_time和end_time(str)转换为时间类型。把start_time设置为index。然后按照工作日和周末计算单天用车量。</p><pre><code class="hljs python">df3[<span class="hljs-string">'start_time'</span>] = pd.to_datetime(df3[<span class="hljs-string">'start_time'</span>])df3[<span class="hljs-string">'end_time'</span>] = pd.to_datetime(df3[<span class="hljs-string">'end_time'</span>])df_mobike = df3.set_index(<span class="hljs-string">'start_time'</span>, drop=<span class="hljs-literal">True</span>)df_count[df_count.index.dayofweek.isin([<span class="hljs-number">5</span>,<span class="hljs-number">6</span>])].mean()[<span class="hljs-number">0</span>]df_count[df_count.index.dayofweek.isin([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])].mean()[<span class="hljs-number">0</span>]</code></pre><p>输出：</p><pre><code class="hljs yaml"><span class="hljs-number">3275.125</span> <span class="hljs-comment"># 周末</span><span class="hljs-number">3311.304347826087</span> <span class="hljs-comment"># 工作日</span></code></pre><p>显然，平均而言，工作日的单天用车量更大。</p><p>（2）工作日每天的高峰时间段大致为上午7：30到9：30、下午17：00到19：00，请问8月里早高峰骑行记录量(以start_time为准)高于晚高峰的有几天？</p><p>早高峰是上午7：30到9：30，需要满足start_time早于9:30和end_time晚于7：30。晚高峰同理。<br>（本来想法是start_time分成start_hour,start_min,也是可以的，优秀题解简洁啊，但有丢丢问题，这里改正了。）</p><pre><code class="hljs python">days = []df_mobike_week = df_mobike[df_mobike.index.dayofweek.isin([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>])]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">31</span>):    day = <span class="hljs-string">'2016-8-&#123;&#125;'</span>.format(i+<span class="hljs-number">1</span>)    morning = df_mobike_week[(df_mobike_week.index &lt;=<span class="hljs-string">'&#123;&#125; 09:30'</span>.format(day)) &amp;(df_mobike_week.end_time &gt;=<span class="hljs-string">'&#123;&#125; 07:30'</span>.format(day)).values].count()[<span class="hljs-number">0</span>]    afternoon = df_mobike_week[(df_mobike_week.index &lt;=<span class="hljs-string">'&#123;&#125; 19:00'</span>.format(day)) &amp;(df_mobike_week.end_time &gt;=<span class="hljs-string">'&#123;&#125; 17:00'</span>.format(day)).values].count()[<span class="hljs-number">0</span>]    <span class="hljs-keyword">if</span> morning &gt; afternoon:        days.append(day)print(<span class="hljs-string">'8月早高峰骑行记录量高于晚上高峰的有&#123;&#125;天，分别是&#123;&#125;'</span>.format(len(days), days))</code></pre><p>输出：</p><pre><code class="hljs lsl"><span class="hljs-number">8</span>月早高峰骑行记录量高于晚上高峰的有<span class="hljs-number">5</span>天，分别是['<span class="hljs-number">2016</span><span class="hljs-number">-8</span><span class="hljs-number">-4</span>', '<span class="hljs-number">2016</span><span class="hljs-number">-8</span><span class="hljs-number">-27</span>', '<span class="hljs-number">2016</span><span class="hljs-number">-8</span><span class="hljs-number">-28</span>', '<span class="hljs-number">2016</span><span class="hljs-number">-8</span><span class="hljs-number">-29</span>', '<span class="hljs-number">2016</span><span class="hljs-number">-8</span><span class="hljs-number">-30</span>']</code></pre><p>（3）请给出在所有周五中(以start_time为准），记录条数最多的那个周五所在的日期，并在该天内分别按30分钟、2小时、6小时统计摩拜单车使用时间的均值。</p><p>找到周五(dayofweek=4)，然后对天聚合求出orderid总和最大的当天。</p><pre><code class="hljs python">max_friday = df_mobike[df_mobike.index.dayofweek==<span class="hljs-number">4</span>][<span class="hljs-string">'orderid'</span>].resample(<span class="hljs-string">'D'</span>).count().idxmax()print(<span class="hljs-string">"条数最多的那个周五是"</span>,max_friday.date())</code></pre><p>输出：</p><pre><code class="hljs angelscript">条数最多的那个周五是 <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span></code></pre><p>提取出当天的记录。重置索引。置新列usetime=start_time-end_time，并把单位换算成秒，即把时间间隔类型转换为float。</p><pre><code class="hljs python">df_mobike_friday = df_mobike[str(max_friday.date())].copy()df_mobike_friday = df_mobike_friday.reset_index()df_mobike_friday[<span class="hljs-string">'usetime'</span>] = (df_mobike_friday.end_time-df_mobike_friday.start_time).dt.total_seconds() <span class="hljs-comment">#转换为秒数</span></code></pre><p>再把start_time置为索引(上步重置索引是为了求出usetime)，按照30min，2h，6h聚合，统计使用时间usetime的均值。</p><pre><code class="hljs python">df_mobike_friday = df_mobike_friday.set_index(<span class="hljs-string">'start_time'</span>,drop=<span class="hljs-literal">False</span>)<span class="hljs-comment">#print(df_mobike_friday['usetime'])</span>display(    df_mobike_friday[<span class="hljs-string">'usetime'</span>].resample(<span class="hljs-string">'30min'</span>).mean().apply(<span class="hljs-keyword">lambda</span> x: pd.Timedelta(seconds=int(x))).head(),    df_mobike_friday[<span class="hljs-string">'usetime'</span>].resample(<span class="hljs-string">'2h'</span>).mean().apply(<span class="hljs-keyword">lambda</span> x: pd.Timedelta(seconds=int(x))).head(),        df_mobike_friday[<span class="hljs-string">'usetime'</span>].resample(<span class="hljs-string">'6h'</span>).mean().apply(<span class="hljs-keyword">lambda</span> x: pd.Timedelta(seconds=int(x))).head())</code></pre><p>输出：</p><pre><code class="hljs angelscript">start_time<span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>   <span class="hljs-number">00</span>:<span class="hljs-number">18</span>:<span class="hljs-number">56</span><span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">00</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span>   <span class="hljs-number">00</span>:<span class="hljs-number">26</span>:<span class="hljs-number">42</span><span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">01</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>   <span class="hljs-number">00</span>:<span class="hljs-number">13</span>:<span class="hljs-number">27</span><span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">01</span>:<span class="hljs-number">30</span>:<span class="hljs-number">00</span>   <span class="hljs-number">00</span>:<span class="hljs-number">15</span>:<span class="hljs-number">30</span><span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">02</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>   <span class="hljs-number">00</span>:<span class="hljs-number">17</span>:<span class="hljs-number">17</span>Freq: <span class="hljs-number">30</span>T, Name: usetime, dtype: timedelta64[ns]start_time<span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>   <span class="hljs-number">00</span>:<span class="hljs-number">19</span>:<span class="hljs-number">57</span><span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">02</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>   <span class="hljs-number">00</span>:<span class="hljs-number">19</span>:<span class="hljs-number">18</span><span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">04</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>   <span class="hljs-number">00</span>:<span class="hljs-number">13</span>:<span class="hljs-number">33</span><span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">06</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>   <span class="hljs-number">00</span>:<span class="hljs-number">11</span>:<span class="hljs-number">31</span><span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">08</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>   <span class="hljs-number">00</span>:<span class="hljs-number">11</span>:<span class="hljs-number">35</span>Freq: <span class="hljs-number">2</span>H, Name: usetime, dtype: timedelta64[ns]start_time<span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>   <span class="hljs-number">00</span>:<span class="hljs-number">17</span>:<span class="hljs-number">47</span><span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">06</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>   <span class="hljs-number">00</span>:<span class="hljs-number">11</span>:<span class="hljs-number">39</span><span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">12</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>   <span class="hljs-number">00</span>:<span class="hljs-number">16</span>:<span class="hljs-number">00</span><span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">18</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>   <span class="hljs-number">00</span>:<span class="hljs-number">21</span>:<span class="hljs-number">39</span>Freq: <span class="hljs-number">6</span>H, Name: usetime, dtype: timedelta64[ns]</code></pre><p>（4）请自行搜索相关代码或调用库，计算每条记录起点到终点的球面距离。</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> geopy.distance <span class="hljs-keyword">import</span> geodesicdf_mobike_dist = df_mobike.copy()df_mobike_dist[<span class="hljs-string">'se_dist'</span>] = df_mobike_dist.apply(<span class="hljs-keyword">lambda</span> x: geodesic((x.start_location_y,x.start_location_x),(x.end_location_y,x.end_location_x)).m,axis=<span class="hljs-number">1</span>)df_mobike_dist.head()</code></pre><p>输出：</p><p><img src="/article/67aeaf8/image-20200712123754538.png" srcset="/img/loading.gif" alt="image-20200712123754538"></p><p>（5）摩拜单车的骑行结束时间是以电子锁的记录时间为准，但有时候用户会忘记关锁，导致骑行时间出现异常。同时，正常人的骑行速度往往大致落在一个合理的区间，请结合上一问中的球面距离和骑行起始、结束时间、找出潜在的异常骑行记录。</p><p>usetime = end_time - start_time，通过se_dist/usetime得到平均速度，当速度小于一定值(这里选取0.05的分位数)，可以认为是潜在的异常骑行记录。</p><pre><code class="hljs python">df_mobike_dist[<span class="hljs-string">'usetime'</span>] = (df_mobike_dist.end_time-df_mobike_dist.index).dt.total_seconds() <span class="hljs-comment">#转换为绝对秒数</span>df_mobike_dist[<span class="hljs-string">'se_speed'</span>] = df_mobike_dist.apply(<span class="hljs-keyword">lambda</span> x:x.se_dist/x.usetime, axis=<span class="hljs-number">1</span>)print(<span class="hljs-string">'mean'</span>,df_mobike_dist.se_speed.mean())<span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> [<span class="hljs-number">0.95</span>,<span class="hljs-number">0.75</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.25</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0.05</span>,<span class="hljs-number">0.04</span>,<span class="hljs-number">0.03</span>,<span class="hljs-number">0.02</span>,<span class="hljs-number">0.01</span>,<span class="hljs-number">0.001</span>]:    print(q*<span class="hljs-number">100</span>,<span class="hljs-string">'分位数'</span>,df_mobike_dist.se_speed.quantile(q))<span class="hljs-comment"># 可能忘记锁车：</span>df_mobike_dist[df_mobike_dist.se_speed&lt;df_mobike_dist.se_speed.quantile(<span class="hljs-number">0.05</span>)].head()</code></pre><p>输出：</p><pre><code class="hljs angelscript">                     orderid  bikeid  userid  start_location_x  \start_time                                                       <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">09</span>:<span class="hljs-number">21</span>:<span class="hljs-number">00</span>   <span class="hljs-number">270836</span>   <span class="hljs-number">63136</span>   <span class="hljs-number">11361</span>           <span class="hljs-number">121.369</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">00</span>  <span class="hljs-number">1802934</span>  <span class="hljs-number">320611</span>    <span class="hljs-number">1211</span>           <span class="hljs-number">121.504</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">13</span>:<span class="hljs-number">32</span>:<span class="hljs-number">00</span>  <span class="hljs-number">1630164</span>  <span class="hljs-number">143066</span>   <span class="hljs-number">11182</span>           <span class="hljs-number">121.436</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-27</span> <span class="hljs-number">21</span>:<span class="hljs-number">52</span>:<span class="hljs-number">00</span>  <span class="hljs-number">1623489</span>  <span class="hljs-number">151285</span>   <span class="hljs-number">17526</span>           <span class="hljs-number">121.478</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-03</span> <span class="hljs-number">22</span>:<span class="hljs-number">08</span>:<span class="hljs-number">00</span>   <span class="hljs-number">748550</span>  <span class="hljs-number">136503</span>    <span class="hljs-number">7423</span>           <span class="hljs-number">121.483</span>                        start_location_y            end_time  end_location_x  \start_time                                                                  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">09</span>:<span class="hljs-number">21</span>:<span class="hljs-number">00</span>            <span class="hljs-number">31.252</span> <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">13</span>:<span class="hljs-number">43</span>:<span class="hljs-number">00</span>         <span class="hljs-number">121.376</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">00</span>            <span class="hljs-number">31.305</span> <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">22</span>:<span class="hljs-number">27</span>:<span class="hljs-number">00</span>         <span class="hljs-number">121.500</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">13</span>:<span class="hljs-number">32</span>:<span class="hljs-number">00</span>            <span class="hljs-number">31.328</span> <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">13</span>:<span class="hljs-number">44</span>:<span class="hljs-number">00</span>         <span class="hljs-number">121.439</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-27</span> <span class="hljs-number">21</span>:<span class="hljs-number">52</span>:<span class="hljs-number">00</span>            <span class="hljs-number">31.289</span> <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-27</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span>:<span class="hljs-number">00</span>         <span class="hljs-number">121.476</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-03</span> <span class="hljs-number">22</span>:<span class="hljs-number">08</span>:<span class="hljs-number">00</span>            <span class="hljs-number">31.237</span> <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-03</span> <span class="hljs-number">22</span>:<span class="hljs-number">26</span>:<span class="hljs-number">00</span>         <span class="hljs-number">121.484</span>                        end_location_y  \start_time                            <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">09</span>:<span class="hljs-number">21</span>:<span class="hljs-number">00</span>          <span class="hljs-number">31.233</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">00</span>          <span class="hljs-number">31.308</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">13</span>:<span class="hljs-number">32</span>:<span class="hljs-number">00</span>          <span class="hljs-number">31.327</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-27</span> <span class="hljs-number">21</span>:<span class="hljs-number">52</span>:<span class="hljs-number">00</span>          <span class="hljs-number">31.292</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-03</span> <span class="hljs-number">22</span>:<span class="hljs-number">08</span>:<span class="hljs-number">00</span>          <span class="hljs-number">31.234</span>                                                                    track  \start_time                                                               <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">09</span>:<span class="hljs-number">21</span>:<span class="hljs-number">00</span>  <span class="hljs-number">121.367</span>,<span class="hljs-number">31.238</span>#<span class="hljs-number">121.367</span>,<span class="hljs-number">31.239</span>#<span class="hljs-number">121.368</span>,<span class="hljs-number">31.240</span>#<span class="hljs-number">1.</span>..   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">00</span>  <span class="hljs-number">121.499</span>,<span class="hljs-number">31.308</span>#<span class="hljs-number">121.500</span>,<span class="hljs-number">31.308</span>#<span class="hljs-number">121.501</span>,<span class="hljs-number">31.308</span>#<span class="hljs-number">1.</span>..   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">13</span>:<span class="hljs-number">32</span>:<span class="hljs-number">00</span>  <span class="hljs-number">121.436</span>,<span class="hljs-number">31.328</span>#<span class="hljs-number">121.437</span>,<span class="hljs-number">31.328</span>#<span class="hljs-number">121.437</span>,<span class="hljs-number">31.329</span>#<span class="hljs-number">1.</span>..   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-27</span> <span class="hljs-number">21</span>:<span class="hljs-number">52</span>:<span class="hljs-number">00</span>  <span class="hljs-number">121.476</span>,<span class="hljs-number">31.292</span>#<span class="hljs-number">121.477</span>,<span class="hljs-number">31.289</span>#<span class="hljs-number">121.477</span>,<span class="hljs-number">31.290</span>#<span class="hljs-number">1.</span>..   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-03</span> <span class="hljs-number">22</span>:<span class="hljs-number">08</span>:<span class="hljs-number">00</span>  <span class="hljs-number">121.482</span>,<span class="hljs-number">31.235</span>#<span class="hljs-number">121.483</span>,<span class="hljs-number">31.234</span>#<span class="hljs-number">121.483</span>,<span class="hljs-number">31.235</span>#<span class="hljs-number">1.</span>..                            se_dist  usetime  se_speed  start_time                                           <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">09</span>:<span class="hljs-number">21</span>:<span class="hljs-number">00</span>  <span class="hljs-number">2209.621048</span>  <span class="hljs-number">15720.0</span>  <span class="hljs-number">0.140561</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-26</span> <span class="hljs-number">22</span>:<span class="hljs-number">05</span>:<span class="hljs-number">00</span>   <span class="hljs-number">505.608255</span>   <span class="hljs-number">1320.0</span>  <span class="hljs-number">0.383037</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">13</span>:<span class="hljs-number">32</span>:<span class="hljs-number">00</span>   <span class="hljs-number">306.300607</span>    <span class="hljs-number">720.0</span>  <span class="hljs-number">0.425418</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-27</span> <span class="hljs-number">21</span>:<span class="hljs-number">52</span>:<span class="hljs-number">00</span>   <span class="hljs-number">383.276389</span>   <span class="hljs-number">1320.0</span>  <span class="hljs-number">0.290361</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-03</span> <span class="hljs-number">22</span>:<span class="hljs-number">08</span>:<span class="hljs-number">00</span>   <span class="hljs-number">345.995048</span>   <span class="hljs-number">1080.0</span>  <span class="hljs-number">0.320366</span></code></pre><p>（6）由于路线的曲折性，起点到终点的球面距离往往不能充分反应行程的长度，请利用track列的路线坐标数据，计算估计实际骑行距离，并重新仿照上一问的方法找出可能的异常记录。</p><p>getdist把各个节点之间的距离和求出来，然后也是track_dist/usetime计算平均速度。当速度小于阈值(0.05分位数)时，认为是潜在的异常数据。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">getdist</span><span class="hljs-params">(track)</span>:</span>    tlist = []    dist = <span class="hljs-number">0</span>    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> track.split(<span class="hljs-string">'#'</span>):        <span class="hljs-keyword">for</span> tt <span class="hljs-keyword">in</span> t.split(<span class="hljs-string">','</span>):            (tlist.append(tt))    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(tlist)//<span class="hljs-number">2</span> - <span class="hljs-number">1</span>):        <span class="hljs-keyword">try</span>:            dist += geodesic((tlist[i*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>],tlist[i*<span class="hljs-number">2</span>]),(tlist[i*<span class="hljs-number">2</span>+<span class="hljs-number">3</span>],tlist[i*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>])).m        <span class="hljs-keyword">except</span> ValueError:            dist += <span class="hljs-number">0</span>    <span class="hljs-keyword">return</span> distdf_mobike_dist[<span class="hljs-string">'track_dist'</span>] = df_mobike_dist.track.apply(<span class="hljs-keyword">lambda</span> x: getdist(x))df_mobike_dist[<span class="hljs-string">'track_speed'</span>] = df_mobike_dist.apply(<span class="hljs-keyword">lambda</span> x: x.track_dist/x.usetime, axis=<span class="hljs-number">1</span>)print(<span class="hljs-string">'mean'</span>, df_mobike_dist.track_speed.mean())<span class="hljs-keyword">for</span> q <span class="hljs-keyword">in</span> [<span class="hljs-number">0.95</span>,<span class="hljs-number">0.75</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">0.25</span>,<span class="hljs-number">0.1</span>,<span class="hljs-number">0.05</span>,<span class="hljs-number">0.04</span>,<span class="hljs-number">0.03</span>,<span class="hljs-number">0.02</span>,<span class="hljs-number">0.01</span>,<span class="hljs-number">0.001</span>]:    print(q*<span class="hljs-number">100</span>,<span class="hljs-string">'分位数'</span>,df_mobike_dist.track_speed.quantile(q))<span class="hljs-comment"># 可能忘记锁车：</span>cut = df_mobike_dist.track_speed.quantile(<span class="hljs-number">0.05</span>)print(df_mobike_dist[df_mobike_dist.track_speed&lt;cut])</code></pre><p>输出：</p><pre><code class="hljs angelscript">mean <span class="hljs-number">4.7176424053972985</span><span class="hljs-number">95.0</span> 分位数 <span class="hljs-number">11.119561310481727</span><span class="hljs-number">75.0</span> 分位数 <span class="hljs-number">5.648633153477631</span><span class="hljs-number">50.0</span> 分位数 <span class="hljs-number">3.8691839481829473</span><span class="hljs-number">25.0</span> 分位数 <span class="hljs-number">2.6515407909180317</span><span class="hljs-number">10.0</span> 分位数 <span class="hljs-number">1.377678636142472</span><span class="hljs-number">5.0</span> 分位数 <span class="hljs-number">0.6461082249996972</span><span class="hljs-number">4.0</span> 分位数 <span class="hljs-number">0.5022487936821581</span><span class="hljs-number">3.0</span> 分位数 <span class="hljs-number">0.36700311152670406</span><span class="hljs-number">2.0</span> 分位数 <span class="hljs-number">0.2489091789770581</span><span class="hljs-number">1.0</span> 分位数 <span class="hljs-number">0.14214735328510836</span><span class="hljs-number">0.1</span> 分位数 <span class="hljs-number">0.03553589878569083</span>                     orderid  bikeid  userid  start_location_x  \start_time                                                       <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">09</span>:<span class="hljs-number">21</span>:<span class="hljs-number">00</span>   <span class="hljs-number">270836</span>   <span class="hljs-number">63136</span>   <span class="hljs-number">11361</span>           <span class="hljs-number">121.369</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-31</span> <span class="hljs-number">18</span>:<span class="hljs-number">15</span>:<span class="hljs-number">00</span>  <span class="hljs-number">1563430</span>  <span class="hljs-number">384828</span>     <span class="hljs-number">945</span>           <span class="hljs-number">121.606</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">07</span>:<span class="hljs-number">45</span>:<span class="hljs-number">00</span>    <span class="hljs-number">80889</span>  <span class="hljs-number">335198</span>   <span class="hljs-number">12380</span>           <span class="hljs-number">121.354</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-16</span> <span class="hljs-number">19</span>:<span class="hljs-number">56</span>:<span class="hljs-number">00</span>  <span class="hljs-number">1504315</span>   <span class="hljs-number">78807</span>     <span class="hljs-number">185</span>           <span class="hljs-number">121.480</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-12</span> <span class="hljs-number">22</span>:<span class="hljs-number">02</span>:<span class="hljs-number">00</span>  <span class="hljs-number">1419609</span>  <span class="hljs-number">106895</span>   <span class="hljs-number">11697</span>           <span class="hljs-number">121.515</span>   ...                      ...     ...     ...               ...   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-03</span> <span class="hljs-number">16</span>:<span class="hljs-number">39</span>:<span class="hljs-number">00</span>   <span class="hljs-number">373681</span>   <span class="hljs-number">85225</span>    <span class="hljs-number">7484</span>           <span class="hljs-number">121.449</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">20</span>:<span class="hljs-number">25</span>:<span class="hljs-number">00</span>  <span class="hljs-number">1777023</span>  <span class="hljs-number">313903</span>   <span class="hljs-number">13647</span>           <span class="hljs-number">121.363</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">20</span>:<span class="hljs-number">13</span>:<span class="hljs-number">00</span>  <span class="hljs-number">1774184</span>  <span class="hljs-number">103791</span>   <span class="hljs-number">15364</span>           <span class="hljs-number">121.530</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-14</span> <span class="hljs-number">20</span>:<span class="hljs-number">02</span>:<span class="hljs-number">00</span>  <span class="hljs-number">1459535</span>  <span class="hljs-number">150325</span>    <span class="hljs-number">5961</span>           <span class="hljs-number">121.359</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-31</span> <span class="hljs-number">19</span>:<span class="hljs-number">32</span>:<span class="hljs-number">00</span>  <span class="hljs-number">1678292</span>  <span class="hljs-number">172562</span>    <span class="hljs-number">2655</span>           <span class="hljs-number">121.531</span>                        start_location_y            end_time  end_location_x  \start_time                                                                  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">09</span>:<span class="hljs-number">21</span>:<span class="hljs-number">00</span>            <span class="hljs-number">31.252</span> <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">13</span>:<span class="hljs-number">43</span>:<span class="hljs-number">00</span>         <span class="hljs-number">121.376</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-31</span> <span class="hljs-number">18</span>:<span class="hljs-number">15</span>:<span class="hljs-number">00</span>            <span class="hljs-number">31.110</span> <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-31</span> <span class="hljs-number">18</span>:<span class="hljs-number">58</span>:<span class="hljs-number">00</span>         <span class="hljs-number">121.570</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">07</span>:<span class="hljs-number">45</span>:<span class="hljs-number">00</span>            <span class="hljs-number">31.226</span> <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">08</span>:<span class="hljs-number">28</span>:<span class="hljs-number">00</span>         <span class="hljs-number">121.356</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-16</span> <span class="hljs-number">19</span>:<span class="hljs-number">56</span>:<span class="hljs-number">00</span>            <span class="hljs-number">31.311</span> <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-16</span> <span class="hljs-number">20</span>:<span class="hljs-number">04</span>:<span class="hljs-number">00</span>         <span class="hljs-number">121.484</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-12</span> <span class="hljs-number">22</span>:<span class="hljs-number">02</span>:<span class="hljs-number">00</span>            <span class="hljs-number">31.291</span> <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-12</span> <span class="hljs-number">22</span>:<span class="hljs-number">17</span>:<span class="hljs-number">00</span>         <span class="hljs-number">121.537</span>   ...                               ...                 ...             ...   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-03</span> <span class="hljs-number">16</span>:<span class="hljs-number">39</span>:<span class="hljs-number">00</span>            <span class="hljs-number">31.269</span> <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-03</span> <span class="hljs-number">16</span>:<span class="hljs-number">57</span>:<span class="hljs-number">00</span>         <span class="hljs-number">121.432</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">20</span>:<span class="hljs-number">25</span>:<span class="hljs-number">00</span>            <span class="hljs-number">31.254</span> <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">20</span>:<span class="hljs-number">41</span>:<span class="hljs-number">00</span>         <span class="hljs-number">121.364</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">20</span>:<span class="hljs-number">13</span>:<span class="hljs-number">00</span>            <span class="hljs-number">31.324</span> <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">20</span>:<span class="hljs-number">20</span>:<span class="hljs-number">00</span>         <span class="hljs-number">121.524</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-14</span> <span class="hljs-number">20</span>:<span class="hljs-number">02</span>:<span class="hljs-number">00</span>            <span class="hljs-number">31.253</span> <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-14</span> <span class="hljs-number">20</span>:<span class="hljs-number">32</span>:<span class="hljs-number">00</span>         <span class="hljs-number">121.365</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-31</span> <span class="hljs-number">19</span>:<span class="hljs-number">32</span>:<span class="hljs-number">00</span>            <span class="hljs-number">31.284</span> <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-31</span> <span class="hljs-number">20</span>:<span class="hljs-number">01</span>:<span class="hljs-number">00</span>         <span class="hljs-number">121.543</span>                        end_location_y  \start_time                            <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">09</span>:<span class="hljs-number">21</span>:<span class="hljs-number">00</span>          <span class="hljs-number">31.233</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-31</span> <span class="hljs-number">18</span>:<span class="hljs-number">15</span>:<span class="hljs-number">00</span>          <span class="hljs-number">31.115</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">07</span>:<span class="hljs-number">45</span>:<span class="hljs-number">00</span>          <span class="hljs-number">31.225</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-16</span> <span class="hljs-number">19</span>:<span class="hljs-number">56</span>:<span class="hljs-number">00</span>          <span class="hljs-number">31.305</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-12</span> <span class="hljs-number">22</span>:<span class="hljs-number">02</span>:<span class="hljs-number">00</span>          <span class="hljs-number">31.301</span>   ...                             ...   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-03</span> <span class="hljs-number">16</span>:<span class="hljs-number">39</span>:<span class="hljs-number">00</span>          <span class="hljs-number">31.277</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">20</span>:<span class="hljs-number">25</span>:<span class="hljs-number">00</span>          <span class="hljs-number">31.255</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">20</span>:<span class="hljs-number">13</span>:<span class="hljs-number">00</span>          <span class="hljs-number">31.328</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-14</span> <span class="hljs-number">20</span>:<span class="hljs-number">02</span>:<span class="hljs-number">00</span>          <span class="hljs-number">31.252</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-31</span> <span class="hljs-number">19</span>:<span class="hljs-number">32</span>:<span class="hljs-number">00</span>          <span class="hljs-number">31.296</span>                                                                    track  \start_time                                                               <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">09</span>:<span class="hljs-number">21</span>:<span class="hljs-number">00</span>  <span class="hljs-number">121.367</span>,<span class="hljs-number">31.238</span>#<span class="hljs-number">121.367</span>,<span class="hljs-number">31.239</span>#<span class="hljs-number">121.368</span>,<span class="hljs-number">31.240</span>#<span class="hljs-number">1.</span>..   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-31</span> <span class="hljs-number">18</span>:<span class="hljs-number">15</span>:<span class="hljs-number">00</span>  <span class="hljs-number">121.606</span>,<span class="hljs-number">31.111</span>#<span class="hljs-number">121.607</span>,<span class="hljs-number">31.110</span>#<span class="hljs-number">121.609</span>,<span class="hljs-number">31.110</span>#<span class="hljs-number">1.</span>..   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">07</span>:<span class="hljs-number">45</span>:<span class="hljs-number">00</span>  <span class="hljs-number">121.351</span>,<span class="hljs-number">31.223</span>#<span class="hljs-number">121.353</span>,<span class="hljs-number">31.226</span>#<span class="hljs-number">121.354</span>,<span class="hljs-number">31.223</span>#<span class="hljs-number">1.</span>..   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-16</span> <span class="hljs-number">19</span>:<span class="hljs-number">56</span>:<span class="hljs-number">00</span>                      <span class="hljs-number">121.480</span>,<span class="hljs-number">31.311</span>#<span class="hljs-number">121.482</span>,<span class="hljs-number">31.311</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-12</span> <span class="hljs-number">22</span>:<span class="hljs-number">02</span>:<span class="hljs-number">00</span>                      <span class="hljs-number">121.515</span>,<span class="hljs-number">31.290</span>#<span class="hljs-number">121.516</span>,<span class="hljs-number">31.290</span>   ...                                                                ...   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-03</span> <span class="hljs-number">16</span>:<span class="hljs-number">39</span>:<span class="hljs-number">00</span>                      <span class="hljs-number">121.448</span>,<span class="hljs-number">31.270</span>#<span class="hljs-number">121.449</span>,<span class="hljs-number">31.269</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">20</span>:<span class="hljs-number">25</span>:<span class="hljs-number">00</span>  <span class="hljs-number">121.363</span>,<span class="hljs-number">31.254</span>#<span class="hljs-number">121.363</span>,<span class="hljs-number">31.255</span>#<span class="hljs-number">121.364</span>,<span class="hljs-number">31.255</span>#<span class="hljs-number">1.</span>..   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">20</span>:<span class="hljs-number">13</span>:<span class="hljs-number">00</span>       <span class="hljs-number">121.528</span>,<span class="hljs-number">31.324</span>#<span class="hljs-number">121.529</span>,<span class="hljs-number">31.324</span>#<span class="hljs-number">121.530</span>,<span class="hljs-number">31.324</span>   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-14</span> <span class="hljs-number">20</span>:<span class="hljs-number">02</span>:<span class="hljs-number">00</span>  <span class="hljs-number">121.359</span>,<span class="hljs-number">31.253</span>#<span class="hljs-number">121.360</span>,<span class="hljs-number">31.253</span>#<span class="hljs-number">121.361</span>,<span class="hljs-number">31.252</span>#<span class="hljs-number">1.</span>..   <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-31</span> <span class="hljs-number">19</span>:<span class="hljs-number">32</span>:<span class="hljs-number">00</span>  <span class="hljs-number">121.531</span>,<span class="hljs-number">31.284</span>#<span class="hljs-number">121.532</span>,<span class="hljs-number">31.284</span>#<span class="hljs-number">121.535</span>,<span class="hljs-number">31.285</span>#<span class="hljs-number">1.</span>..                            se_dist  usetime  se_speed   track_dist  track_speed  start_time                                                                     <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">09</span>:<span class="hljs-number">21</span>:<span class="hljs-number">00</span>  <span class="hljs-number">2209.621048</span>  <span class="hljs-number">15720.0</span>  <span class="hljs-number">0.140561</span>  <span class="hljs-number">6153.382509</span>     <span class="hljs-number">0.391437</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-31</span> <span class="hljs-number">18</span>:<span class="hljs-number">15</span>:<span class="hljs-number">00</span>  <span class="hljs-number">3478.566745</span>   <span class="hljs-number">2580.0</span>  <span class="hljs-number">1.348282</span>   <span class="hljs-number">432.445014</span>     <span class="hljs-number">0.167614</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-29</span> <span class="hljs-number">07</span>:<span class="hljs-number">45</span>:<span class="hljs-number">00</span>   <span class="hljs-number">220.465615</span>   <span class="hljs-number">2580.0</span>  <span class="hljs-number">0.085452</span>  <span class="hljs-number">1205.743298</span>     <span class="hljs-number">0.467342</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-16</span> <span class="hljs-number">19</span>:<span class="hljs-number">56</span>:<span class="hljs-number">00</span>   <span class="hljs-number">766.519391</span>    <span class="hljs-number">480.0</span>  <span class="hljs-number">1.596915</span>   <span class="hljs-number">190.385816</span>     <span class="hljs-number">0.396637</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-12</span> <span class="hljs-number">22</span>:<span class="hljs-number">02</span>:<span class="hljs-number">00</span>  <span class="hljs-number">2369.929234</span>    <span class="hljs-number">900.0</span>  <span class="hljs-number">2.633255</span>    <span class="hljs-number">95.214021</span>     <span class="hljs-number">0.105793</span>  ...                          ...      ...       ...          ...          ...  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-03</span> <span class="hljs-number">16</span>:<span class="hljs-number">39</span>:<span class="hljs-number">00</span>  <span class="hljs-number">1845.992264</span>   <span class="hljs-number">1080.0</span>  <span class="hljs-number">1.709252</span>   <span class="hljs-number">146.159845</span>     <span class="hljs-number">0.135333</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">20</span>:<span class="hljs-number">25</span>:<span class="hljs-number">00</span>   <span class="hljs-number">146.169464</span>    <span class="hljs-number">960.0</span>  <span class="hljs-number">0.152260</span>   <span class="hljs-number">463.165717</span>     <span class="hljs-number">0.482464</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-24</span> <span class="hljs-number">20</span>:<span class="hljs-number">13</span>:<span class="hljs-number">00</span>   <span class="hljs-number">723.055998</span>    <span class="hljs-number">420.0</span>  <span class="hljs-number">1.721562</span>   <span class="hljs-number">190.359665</span>     <span class="hljs-number">0.453237</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-14</span> <span class="hljs-number">20</span>:<span class="hljs-number">02</span>:<span class="hljs-number">00</span>   <span class="hljs-number">582.165645</span>   <span class="hljs-number">1800.0</span>  <span class="hljs-number">0.323425</span>   <span class="hljs-number">886.059173</span>     <span class="hljs-number">0.492255</span>  <span class="hljs-number">2016</span><span class="hljs-number">-08</span><span class="hljs-number">-31</span> <span class="hljs-number">19</span>:<span class="hljs-number">32</span>:<span class="hljs-number">00</span>  <span class="hljs-number">1753.760319</span>   <span class="hljs-number">1740.0</span>  <span class="hljs-number">1.007908</span>   <span class="hljs-number">738.228978</span>     <span class="hljs-number">0.424270</span>  [<span class="hljs-number">5118</span> rows x <span class="hljs-number">14</span> columns]</code></pre><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://blog.csdn.net/fire_i_ce/article/details/107074111" target="_blank" rel="noopener">优秀的题解</a></p>]]></content>
    
    
    <categories>
      
      <category>pandas下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4方差分析</title>
    <link href="/article/2ad44fb9.html"/>
    <url>/article/2ad44fb9.html</url>
    
    <content type="html"><![CDATA[<h1 id="方差分析"><a href="#方差分析" class="headerlink" title="方差分析"></a>方差分析</h1><h2 id="1-概要"><a href="#1-概要" class="headerlink" title="1 概要"></a>1 概要</h2><p><strong>方差分析</strong>(<strong>Analysis of variance, ANOVA</strong>) 主要研究分类变量作为自变量时，对因变量的影响是否是显著的。</p><p>方差分析的方法是由20世纪的统计学家Ronald Aylmer Fisher在1918年到1925年之间提出并陆续完善起来的，该方法刚开始是用于解决田间实验的数据分析问题，因此，方差分析的学习是和实验设计、实验数据的分析密不可分的。</p><p>实验设计和方差分析都有自己相应的语言。因此，在这里我们通过一个焦虑症治疗的实例，先了解一些术语，并且思考一下，方差分析主要用于解决什么样的问题。<a id="more"></a></p><p>以焦虑症治疗为例，现有两种治疗方案：认知行为疗法（CBT）和眼动脱敏再加工法（EMDR）。我们招募10位焦虑症患者作为志愿者，随机分配一半的人接受为期五周的CBT，另外一半接受为期五周的EMDR，设计方案如表1-1所示。在治疗结束时，要求每位患者都填写状态特质焦虑问卷（STAI），也就是一份焦虑度测量的自我评测报告。</p><p><strong>表1-1 单因素组间方差分析</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">CBT</th><th style="text-align:center">EMDR</th></tr></thead><tbody><tr><td style="text-align:center">s1</td><td style="text-align:center">s6</td></tr><tr><td style="text-align:center">s2</td><td style="text-align:center">s7</td></tr><tr><td style="text-align:center">s3</td><td style="text-align:center">s8</td></tr><tr><td style="text-align:center">s4</td><td style="text-align:center">s9</td></tr><tr><td style="text-align:center">s5</td><td style="text-align:center">s10</td></tr></tbody></table></div><p>在这个实验设计中，治疗方案是两水平（CBT、EMDR）的<strong>组间因子</strong>。之所以称其为<strong>组间因子</strong>，是因为每位患者都仅被分配到一个组别中，没有患者同时接受CBT和EMDR。表中字母s代表受试者（患者）。STAI是<strong>因变量</strong>，治疗方案是<strong>自变量</strong>。由于在每种治疗方案下观测数相等，因此这种设计也称为<strong>均衡设计</strong>（balanced design）；若观测数不同，则称作<strong>非均衡设计</strong>（unbalanced design）。</p><p>因为仅有一个类别型变量，表1的统计设计又称为<strong>单因素方差分析（one-way ANOVA）</strong>，或进一步称为<strong>单因素组间方差分析</strong>。方差分析主要通过F检验来进行效果评测，若治疗方案的F检验显著，则说明五周后两种疗法的STAI得分均值不同。</p><p>假设你只对CBT的效果感兴趣，则需将10个患者都放在CBT组中，然后在治疗五周和六个月后分别评价疗效，设计方案如表1-2所示。</p><p><strong>表1-2 单因素组内方差分析</strong></p><div class="table-container"><table><thead><tr><th></th><th>时间</th><th></th></tr></thead><tbody><tr><td><strong>患者</strong></td><td>5周</td><td>6个月</td></tr><tr><td>s1</td><td></td><td></td></tr><tr><td>s2</td><td></td><td></td></tr><tr><td>s3</td><td></td><td></td></tr><tr><td>s4</td><td></td><td></td></tr><tr><td>s5</td><td></td><td></td></tr><tr><td>s6</td><td></td><td></td></tr><tr><td>s7</td><td></td><td></td></tr><tr><td>s8</td><td></td><td></td></tr><tr><td>s9</td><td></td><td></td></tr><tr><td>s10</td><td></td></tr></tbody></table></div><p>此时，时间（time）是两水平（五周、六个月）的<strong>组内因子</strong>。因为每位患者在所有水平下都进行了测量，所以这种统计设计称<strong>单因素组内方差分析</strong>；又由于每个受试者都不止一次被测量，也称作<strong>重复测量方差分析</strong>。当时间的F检验显著时，说明患者的STAI得分均值在五周和六个月间发生了改变。</p><p>现假设你对治疗方案差异和它随时间的改变都感兴趣，则将两个设计结合起来即可：随机分配五位患者到CBT，另外五位到EMDR，在五周和六个月后分别评价他们的STAI结果（见表1-3）。</p><p><strong>表1-3 含组间和组内因子的双因素方差分析</strong></p><div class="table-container"><table><thead><tr><th></th><th></th><th>时间</th><th></th></tr></thead><tbody><tr><td><strong>疗法</strong></td><td><strong>患者</strong></td><td>5周</td><td>6个月</td></tr><tr><td>CBT</td><td>s1</td><td></td><td></td></tr><tr><td></td><td>s2</td><td></td><td></td></tr><tr><td></td><td>s3</td><td></td><td></td></tr><tr><td></td><td>s4</td><td></td><td></td></tr><tr><td></td><td>s5</td><td></td><td></td></tr><tr><td>EMDR</td><td>s6</td><td></td><td></td></tr><tr><td></td><td>s7</td><td></td><td></td></tr><tr><td></td><td>s8</td><td></td><td></td></tr><tr><td></td><td>s9</td><td></td><td></td></tr><tr><td></td><td>s10</td><td></td></tr></tbody></table></div><p>疗法（therapy）和时间（time）都作为因子时，我们既可分析疗法的影响（时间跨度上的平均）和时间的影响（疗法类型跨度上的平均），又可分析疗法和时间的交互影响。前两个称作<strong>主效应</strong>，交互部分称作<strong>交互效应</strong>。</p><p>当设计包含两个甚至更多的因子时，便是<strong>因素方差分析设计</strong>，比如两因子时称作<strong>双因素方差分析</strong>，三因子时称作三因素方差分析，以此类推。若因子设计包括组内和组间因子，又称作<strong>混合模型方差分析</strong>，当前的例子就是典型的双因素混合模型方差分析。</p><p>本例中，你将做三次F检验：疗法因素一次，时间因素一次，两者交。</p><p>15214互因素一次。若疗法结果显著，说明CBT和EMDR对焦虑症的治疗效果不同；若时间结果显著，说明焦虑度从五周到六个月发生了变化；若两者交互效应显著，说明两种疗法随着时间变化对焦虑症治疗影响不同（也就是说，焦虑度从五周到六个月的改变程度在两种疗法间是不同的）。</p><p>现在，我们对上面的实验设计稍微做些扩展。众所周知，抑郁症对病症治疗有影响，而且抑郁症和焦虑症常常同时出现。即使受试者被随机分配到不同的治疗方案中，在研究开始时，两组疗法中的患者抑郁水平就可能不同，任何治疗后的差异都有可能是最初的抑郁水平不同导致的，而不是由于实验的操作问题。抑郁症也可以解释因变量的组间差异，因此它常称为<strong>混淆因素</strong>（confounding factor）。由于你对抑郁症不感兴趣，它也被称作<strong>干扰变数</strong>（nuisance variable）。</p><p>假设招募患者时使用抑郁症的自我评测报告，比如白氏抑郁症量表（BDI），记录了他们的抑郁水平，那么你可以在评测疗法类型的影响前，对任何抑郁水平的组间差异进行统计性调整。本案例中，BDI为<strong>协变量</strong>，该设计为<strong>协方差分析</strong>（ANCOVA）。</p><p>以上设计只记录了单个因变量情况（STAI），为增强研究的有效性，可以对焦虑症进行其他的测量（比如家庭评分、医师评分，以及焦虑症对日常行为的影响评价）。当因变量不止一个时，设计被称作<strong>多元方差分析</strong>（MANOVA）， 若协变量也存在， 那么就叫<strong>多元协方差分析</strong>（MANCOVA）。</p><p>下面我们主要介绍单因素方差分析与双因素方差分析的原理与实现。</p><h2 id="2-单因素方差分析"><a href="#2-单因素方差分析" class="headerlink" title="2 单因素方差分析"></a>2 单因素方差分析</h2><h3 id="2-1-推导过程"><a href="#2-1-推导过程" class="headerlink" title="2.1 推导过程"></a>2.1 推导过程</h3><p>接下来我们使用种小麦的例子，去帮助理解方差分析里涉及的一些变量。</p><p>假设我们现在有若干品种的小麦，要在某一地区播种，我们想知道这些品种的产量有没有显著区别，为此我们先设计了一个田间实验，取一大块地将其分成形状大小都相同的$n$小块．设供选择的品种有$k$个，我们打算其中的$n_1$小块种植品种1, $n_2$小块种植品种2，等等，$n_1 + n_2 + … n_k = n$.</p><p>接下来，我们使用方差分析的方法去看不同小麦品种的产量是否有显著差异。</p><p>设问题中涉及一个因素$A$，有$k$个水平，如上例的$k$个种子品种，以$Y_{ij}$记第$i$个水平的第$j$个观察值，如上例$Y_{ij}$是种植品种$i$的第$j$小块地上的亩产量。模型为</p><script type="math/tex; mode=display">Y_{ij} = a_i + e_{ij},  j = 1,...,n_i, i = 1,...,k\qquad(2.1)</script><p>$a_i$表示水平$i$的理论平均值，称为水平$i$的效应。在小麦例子中，$a_i$就是品种$i$的平均亩产量，$e_{ij}$就是随机误差。并且我们假定：</p><script type="math/tex; mode=display">E(e_{ij})=0, 0<Var(e_{ij})={\sigma}^2<\infty,一切e_{ij}独立同分布\qquad(2.2)</script><p>因素$A$的各水平的高低优劣，取决于其理论平均$a_{i}$的大小。故对模型(2.1)，我们头一个关心的事情，就是诸$a_{i}$是否全相同。 如果是，则表示因素$A$对所考察的指标$Y$其实无影响．这时我们就说因素A的效应不显著，否则就说它显著。当然，在实际应用中，所谓“显著”，是指诸$a_{i}$之间的差异要大到一定的程度．这个 “一定的程度”，是从其实用上的意义着眼，而“统计显著性”，则是与随机误差相比而言．这点在下文的讨论中会有所体现．我们把所要检验的假设写为：</p><script type="math/tex; mode=display">H_0:a_1=a_2=\cdots=a_k \qquad (2.3)</script><p>为检验该假设，我们需要分析，为什么各个$Y_{ij}$会有差异？从模型(2.1)来看，无非两个原因：一是各$a_{i}$可能有差异．例如，若 $a_1&gt;a_2$, 这就使$Y_{1j}$倾向于大于$Y_{2j}$；二是随机误差的存在。这一分析启发了如下的想法：找一个衡量全部$y_{ij}$的变异的量：</p><script type="math/tex; mode=display">SS= \sum_{i=1}^{k}\sum_{j=1}^{n_i}\left ( Y_{ij}-\bar{Y} \right )^2, \qquad \bar{Y}=\sum_{i=1}^{k}\sum_{j=1}^{n_i}Y_{ij}/n \qquad (2.4)</script><p>$SS$愈大，表示$Y_{ij}$之间的差异越大。</p><p>接下来，把$SS$分为两部分，一部分表示随机误差的影响，记为$SS_e$；另一部分表示因素$A$的各水平理论平均值$a_i$不同带来的影响，记为$SS_A$。</p><p>关于$SS_e$，先固定一个$i$，此时对应的所有观测值$Y_{i1},Y_{i2},\cdots,Y_{in}$，他们之间的差异与每个水平的理论平均值不等无关，而是取决于随机误差，反映这些观察值差异程度的量是$\sum_{j=1}^{n_i}\left ( Y_{ij}-\bar{Y_i} \right )^2$，其中</p><script type="math/tex; mode=display">\bar{Y_i}=(Y_{i1}+Y_{i2}+\cdots+Y_{in})/n_i,\quad i=1, 2,\cdots,n \qquad (2.5)</script><p>$\bar{Y_i}$可以视为对$a_i$的估计。把上述平方和做累加得：</p><script type="math/tex; mode=display">SS_e=\sum_{i=1}^{k}\sum_{j=1}^{n_i}\left ( Y_{ij}-\bar{Y_i} \right )^2 \qquad (2.6)</script><p>可求得$SS_A$:</p><script type="math/tex; mode=display">\begin{align}SS_A &= SS-SS_e \\ &=\sum_{i=1}^{k}\sum_{j=1}^{n_i}\left ( Y_{ij}-\bar{Y} \right )^2-\sum_{i=1}^{k}\sum_{j=1}^{n_i}\left ( Y_{ij}-\bar{Y_i} \right )^2 \\&=\sum_{i=1}^{k}\sum_{j=1}^{n_i}\left ( (Y_{ij}-\bar{Y_i})-(\bar{Y}-\bar{Y_i}) \right )^2-\sum_{i=1}^{k}\sum_{j=1}^{n_i}\left ( Y_{ij}-\bar{Y_i} \right )^2 \\&=\sum_{i=1}^{k}\sum_{j=1}^{n_i}\left ( (Y_{ij}-\bar{Y_i})^2-2(Y_{ij}-\bar{Y_i})(\bar{Y}-\bar{Y_i})+(\bar{Y}-\bar{Y_i})^2 \right )-\sum_{i=1}^{k}\sum_{j=1}^{n_i}\left ( Y_{ij}-\bar{Y_i} \right )^2 \\&=\sum_{i=1}^{k}\sum_{j=1}^{n_i}(Y_{ij}-\bar{Y_i})^2 - 2\sum_{i=1}^{k}\sum_{j=1}^{n_i}\left ( (Y_{ij}-\bar{Y_i})(\bar{Y}-\bar{Y_i}) \right )+ \sum_{i=1}^{k}\sum_{j=1}^{n_i}(\bar{Y}-\bar{Y_i})^2 - \sum_{i=1}^{k}\sum_{j=1}^{n_i}\left ( Y_{ij}-\bar{Y_i} \right )^2 \\&= \sum_{i=1}^{k}\sum_{j=1}^{n_i}(\bar{Y_i}-\bar{Y})^2 - 2\sum_{i=1}^{k}\left ( (\bar{Y}-\bar{Y_i})\sum_{j=1}^{n_i}(Y_{ij}-\bar{Y_i}) \right ) \quad (ps:\sum_{j=1}^{n_i}(Y_{ij}-\bar{Y_i})=0) \\&= \sum_{i=1}^{k}n_i(\bar{Y_i}-\bar{Y})^2 \qquad (2.7)\end{align}</script><p>因为$\bar{Y_i}$可以视为对$a_i$的估计，$a_i$的差异越大，$\bar{Y_i}$之间的差异也越大，所以$SS_A$可以用来衡量不同水平之间的差异程度。</p><p>在统计学上，通常称$SS$为<strong>总平方和</strong>，$SS_A$为<strong>因素$A$的平方和</strong>，$SS_e$为<strong>误差平方和</strong>，分解式$SS=SS_A+SS_e$为该模型的<strong>方差分析</strong>。</p><p>基于上面的分析，我们可以得到假设（5.3）的一个检验方法：当比值$SS_A/SS_e$大于某一给定界限时，否定$H_0$，不然就接受$H_0$。为了构造$F$分布的检验统计量，我们假定随机误差$e_{ij}$满足正态分布$N(0, \sigma^2)$，同时我们也假定观察值$Y_{ij}$符合正态分布，此时，记</p><script type="math/tex; mode=display">MS_A = SS_A/(k-1), \quad MS_e = SS_e/(n-k) \qquad (2.8)</script><p>当$H_0$成立时，有：</p><script type="math/tex; mode=display">MS_A / MS_e \sim F_{k-1, n-k} \qquad (2.9)</script><p>据（5.9），在给定显著性水平$\alpha$时，即得（5.3）的假设$H_0$的检验如下：</p><script type="math/tex; mode=display">当MS_A / MS_e \leqslant  F_{k-1, n-k}(\alpha)时，接受H_0，不然就拒绝H_0 \qquad (2.10)</script><p>$MS_A$和$MS_e$分别被称为<strong>因素$A$和随机误差的平均平方和</strong>。被除数$k-1$和$n-k$，分别称为这两个平方和的<strong>自由度</strong>。$MS_e$的自由度为什么是$n-k$呢？因为平方和$\sum_{j=1}^{n_i}\left ( Y_{ij}-\bar{Y_i} \right )^2$的自由度为$n_i-1$，故对$i$求和，$SS_e$的自由度就是$n-k$。那么，$MS_A$的自由度为什么是$k-1$呢？因为一共有$k$个平均值$a_1,\cdots,a_k$等$k-1$个，故自由度为$k-1$，两者自由度之和为$n-1$，恰好是总平方和的自由度。</p><p>到这里，我们可以做出方差分析表如表2-1</p><p><strong>2-1 单因素方差分析的方差分析表</strong></p><div class="table-container"><table><thead><tr><th>项目</th><th>$SS$</th><th>自由度</th><th>$MS$</th><th>$F$比</th><th>显著性</th></tr></thead><tbody><tr><td>$A$</td><td>$SS_A$</td><td>$k-1$</td><td>$MS_A$</td><td>$MS_A / MS_e$</td><td><em>, *</em>, 或无</td></tr><tr><td>误差</td><td>$SS_e$</td><td>$n-k$</td><td>$MS_e$</td><td></td><td></td></tr><tr><td>总和</td><td>$SS$</td><td>$n-1$</td><td></td><td></td></tr></tbody></table></div><p>在上表中，对于显著性一栏，一般来说，我们把算出的$F$比，即$MS_A / MS_e$，与$F_{k-1, n-k}(0.05)=c_1$和$F_{k-1, n-k}(0.01)=c_2$比较。若$MS_A / MS_e&gt;c_2$，用**表示，表明A因素的效应是高度显著的，即在$\alpha=0.01$的显著性水平下，拒绝原假设（5.3）。同理，$c_2<MS_A ms_e<c_1$用$\ast $表示，$ms_a ms_e>c_1$时不显著。</MS_A></p><h3 id="2-2-代码实例"><a href="#2-2-代码实例" class="headerlink" title="2.2 代码实例"></a>2.2 代码实例</h3><h4 id="单因素方差分析的R语言实现"><a href="#单因素方差分析的R语言实现" class="headerlink" title="单因素方差分析的R语言实现"></a>单因素方差分析的R语言实现</h4><p>单因素方差分析中，你感兴趣的是比较分类因子定义的两个或多个组别中的因变量均值。以multcomp包中的cholesterol数据集为例，50个患者均接受降低胆固醇药物治疗（trt）五种疗法中的一种疗法。其中三种治疗条件使用药物相同，分别是20mg一天一次（1time）、10mg一天两次（2times）和5mg一天四次（4times）。剩下的两种方式（drugD和drugE）代表候选药物。</p><pre><code class="hljs angelscript">&gt; library(multcomp)&gt; attach(cholesterol)&gt; &gt; # 统计各组样本大小&gt; table(trt) trt <span class="hljs-number">1</span>time <span class="hljs-number">2</span>times <span class="hljs-number">4</span>times  drugD  drugE     <span class="hljs-number">10</span>     <span class="hljs-number">10</span>     <span class="hljs-number">10</span>     <span class="hljs-number">10</span>     <span class="hljs-number">10</span> &gt; &gt; # 各组均值&gt; aggregate(response, by=list(trt), FUN=mean)  Group<span class="hljs-number">.1</span>        x<span class="hljs-number">1</span>   <span class="hljs-number">1</span>time  <span class="hljs-number">5.78197</span><span class="hljs-number">2</span>  <span class="hljs-number">2</span>times  <span class="hljs-number">9.22497</span><span class="hljs-number">3</span>  <span class="hljs-number">4</span>times <span class="hljs-number">12.37478</span><span class="hljs-number">4</span>   drugD <span class="hljs-number">15.36117</span><span class="hljs-number">5</span>   drugE <span class="hljs-number">20.94752</span>&gt; &gt; # 各组标准差&gt; aggregate(response, by=list(trt), FUN=sd)  Group<span class="hljs-number">.1</span>        x<span class="hljs-number">1</span>   <span class="hljs-number">1</span>time <span class="hljs-number">2.878113</span><span class="hljs-number">2</span>  <span class="hljs-number">2</span>times <span class="hljs-number">3.483054</span><span class="hljs-number">3</span>  <span class="hljs-number">4</span>times <span class="hljs-number">2.923119</span><span class="hljs-number">4</span>   drugD <span class="hljs-number">3.454636</span><span class="hljs-number">5</span>   drugE <span class="hljs-number">3.345003</span>&gt; &gt; # 进行方差分析&gt; fit &lt;- aov(response ~ trt)&gt; summary(fit)            Df Sum Sq Mean Sq F value   Pr(&gt;F)    trt          <span class="hljs-number">4</span> <span class="hljs-number">1351.4</span>   <span class="hljs-number">337.8</span>   <span class="hljs-number">32.43</span> <span class="hljs-number">9.82e-13</span> ***Residuals   <span class="hljs-number">45</span>  <span class="hljs-number">468.8</span>    <span class="hljs-number">10.4</span>                     ---Signif. codes:  <span class="hljs-number">0</span> ‘***’ <span class="hljs-number">0.001</span> ‘**’ <span class="hljs-number">0.01</span> ‘*’ <span class="hljs-number">0.05</span> ‘.’ <span class="hljs-number">0.1</span> ‘ ’ <span class="hljs-number">1</span></code></pre><p>方差分析的结果中，各项数字的含义可以参照表2-1。</p><h4 id="查看各水平对应的组均值的差异"><a href="#查看各水平对应的组均值的差异" class="headerlink" title="查看各水平对应的组均值的差异"></a>查看各水平对应的组均值的差异</h4><p>gplots包中的plotmeans()可以用来绘制带有置信区间的组均值图形。如图9-1所示，图形展示了带有95%的置信区间的各疗法均值，可以清楚看到它们之间的差异。</p><pre><code class="hljs lisp">library(<span class="hljs-name">gplots</span>)plotmeans(<span class="hljs-name">response</span> ~ trt, xlab=<span class="hljs-string">"Treatment"</span>, ylab=<span class="hljs-string">"Response"</span>,          main=<span class="hljs-string">"Mean Plot\nwith 95% CI"</span>)detach(<span class="hljs-name">cholesterol</span>)</code></pre><p><img src="/article/2ad44fb9/2-1.png" srcset="/img/loading.gif" alt="2-1"></p><p><strong>2-1 五种降低胆固醇药物疗法的均值，含95%的置信区间</strong></p><h4 id="多重比较"><a href="#多重比较" class="headerlink" title="多重比较"></a>多重比较</h4><p>虽然ANOVA对各疗法的F检验表明五种药物疗法效果不同，但是并没有告诉你哪种疗法与其他疗法不同。多重比较可以解决这个问题。例如，TukeyHSD()函数提供了对各组均值差异的成对检验。</p><pre><code class="hljs angelscript">&gt; TukeyHSD(fit)  Tukey multiple comparisons of means    <span class="hljs-number">95</span>% family-wise confidence levelFit: aov(formula = response ~ trt)$trt                  diff        lwr       upr     p adj<span class="hljs-number">2</span>times<span class="hljs-number">-1</span>time   <span class="hljs-number">3.44300</span> <span class="hljs-number">-0.6582817</span>  <span class="hljs-number">7.544282</span> <span class="hljs-number">0.1380949</span><span class="hljs-number">4</span>times<span class="hljs-number">-1</span>time   <span class="hljs-number">6.59281</span>  <span class="hljs-number">2.4915283</span> <span class="hljs-number">10.694092</span> <span class="hljs-number">0.0003542</span>drugD<span class="hljs-number">-1</span>time    <span class="hljs-number">9.57920</span>  <span class="hljs-number">5.4779183</span> <span class="hljs-number">13.680482</span> <span class="hljs-number">0.0000003</span>drugE<span class="hljs-number">-1</span>time   <span class="hljs-number">15.16555</span> <span class="hljs-number">11.0642683</span> <span class="hljs-number">19.266832</span> <span class="hljs-number">0.0000000</span><span class="hljs-number">4</span>times<span class="hljs-number">-2</span>times  <span class="hljs-number">3.14981</span> <span class="hljs-number">-0.9514717</span>  <span class="hljs-number">7.251092</span> <span class="hljs-number">0.2050382</span>drugD<span class="hljs-number">-2</span>times   <span class="hljs-number">6.13620</span>  <span class="hljs-number">2.0349183</span> <span class="hljs-number">10.237482</span> <span class="hljs-number">0.0009611</span>drugE<span class="hljs-number">-2</span>times  <span class="hljs-number">11.72255</span>  <span class="hljs-number">7.6212683</span> <span class="hljs-number">15.823832</span> <span class="hljs-number">0.0000000</span>drugD<span class="hljs-number">-4</span>times   <span class="hljs-number">2.98639</span> <span class="hljs-number">-1.1148917</span>  <span class="hljs-number">7.087672</span> <span class="hljs-number">0.2512446</span>drugE<span class="hljs-number">-4</span>times   <span class="hljs-number">8.57274</span>  <span class="hljs-number">4.4714583</span> <span class="hljs-number">12.674022</span> <span class="hljs-number">0.0000037</span>drugE-drugD    <span class="hljs-number">5.58635</span>  <span class="hljs-number">1.4850683</span>  <span class="hljs-number">9.687632</span> <span class="hljs-number">0.0030633</span>&gt; par(las=<span class="hljs-number">2</span>)&gt; par(mar=c(<span class="hljs-number">5</span>,<span class="hljs-number">8</span>,<span class="hljs-number">4</span>,<span class="hljs-number">2</span>))&gt; plot(TukeyHSD(fit))</code></pre><p>成对比较图形如图2-2所示。图形中置信区间包含0的疗法说明差异不显著（p&gt;0.05）。</p><p><img src="/article/2ad44fb9/2-2.png" srcset="/img/loading.gif" alt="2-2"></p><p><strong>图2-2 Tukey HSD均值成对比较图</strong></p><h4 id="评估检验的假设条件"><a href="#评估检验的假设条件" class="headerlink" title="评估检验的假设条件"></a>评估检验的假设条件</h4><p>根据2.1中我们讲的关于方差分析的推导中，我们知道，方差分析结果的有效性是建立在一系列假设条件之上的，因此，在我们使用方差分析模型时，需要评估进行方差分析的数据，是否符合模型使用的假设条件。</p><h5 id="正态性检验"><a href="#正态性检验" class="headerlink" title="正态性检验"></a>正态性检验</h5><p>第一，在建立模型时，我们假设因变量是服从正态分布的，需要进行正态性检验。</p><p>正态性检验的方法有两种，一是通过QQ图进行检验。</p><pre><code class="hljs routeros"><span class="hljs-comment"># QQ plot</span>library(car)qqPlot(lm(response ~ trt, <span class="hljs-attribute">data</span>=cholesterol),       <span class="hljs-attribute">simulate</span>=<span class="hljs-literal">TRUE</span>, <span class="hljs-attribute">main</span>=<span class="hljs-string">"Q-Q Plot"</span>, <span class="hljs-attribute">labels</span>=<span class="hljs-literal">FALSE</span>)</code></pre><p><img src="/article/2ad44fb9/2-3.png" srcset="/img/loading.gif" alt="2-3"></p><p>除此之外，R里面也提供了一些package来进行正态性检验。</p><h6 id="K-S-test"><a href="#K-S-test" class="headerlink" title="K-S test"></a>K-S test</h6><p>统计学里, Kolmogorov–Smirnov 检验(亦称：K–S 检验)是用来检验数据是否符合某种分布的一种非参数检验。其原假设$H_0$:两个数据分布一致或者数据符合理论分布。在R语言里，我们可以使用<code>ks.test(x, pnorm)</code>进行正态性检验，若结果中的p值大于0.05，则数据符合正态分布。</p><h6 id="Anderson–Darling-test"><a href="#Anderson–Darling-test" class="headerlink" title="Anderson–Darling test"></a><strong>Anderson–Darling test</strong></h6><p>Anderson–Darling检验是一种用来检验给定的样本是否来自于某个确定的概率分布的统计检验方法。在R语言中，我们可以从<strong>nortest包</strong>中的<code>ad.test()</code>进行检验。若结果中的p值大于0.05，则数据符合正态分布。</p><h6 id="Shapiro-Wilk-test"><a href="#Shapiro-Wilk-test" class="headerlink" title="Shapiro-Wilk test"></a><strong>Shapiro-Wilk test</strong></h6><p>Shapiro-Wilk检验在小样本情况下，是很普通的正态性检验方法，<code>Shapiro.test()</code>在默认安装的<strong>stats</strong>包中。原假设$H_0$: 数据符合正态分布。</p><h6 id="Lilliefor-test"><a href="#Lilliefor-test" class="headerlink" title="Lilliefor test"></a><strong>Lilliefor test</strong></h6><p>Lilliefor test是基于Kolmogorov–Smirnov test的一种正态性检验。原假设$H_0$: 数据符合正态分布，<code>lillie.test()</code>也在<strong>nortest包</strong>中。</p><h5 id="方差齐性检验"><a href="#方差齐性检验" class="headerlink" title="方差齐性检验"></a>方差齐性检验</h5><p>因为方差分析的实质是检验多个水平的均值是否有显著差异，如果各个水平的观察值方差差异太大，只检验均值之间的差异就没有意义了，所以要进行方差齐性检验。</p><p>Bartlett test可以用来检验数据的方差齐性。</p><pre><code class="hljs armasm">&gt; <span class="hljs-keyword">bartlett.test(response </span>~ trt, <span class="hljs-meta">data</span><span class="hljs-symbol">=cholesterol</span>)<span class="hljs-keyword">Bartlett </span>test of homogeneity of variances<span class="hljs-symbol">data</span>:  response <span class="hljs-keyword">by </span>trt<span class="hljs-keyword">Bartlett's </span>K-squared = <span class="hljs-number">0</span>.<span class="hljs-number">57975</span>, df = <span class="hljs-number">4</span>, p-value = <span class="hljs-number">0</span>.<span class="hljs-number">9653</span></code></pre><p>Bartlett检验表明五组的方差并没有显著不同（p=0.97）。其他检验如Fligner-Killeen检验<br>（<code>fligner.test()</code>函数）和Brown-Forsythe检验（<strong>HH包</strong>中的<code>hov()</code>函数）此处没有做演示，但它们获得的结果与Bartlett检验相同。</p><p>不过，方差齐性分析对离群点非常敏感。可利用<strong>car包</strong>中的<code>outlierTest()</code>函数来检测离群点：</p><pre><code class="hljs yaml"><span class="hljs-string">outlierTest(fit)</span><span class="hljs-literal">No</span> <span class="hljs-string">Studentized</span> <span class="hljs-string">residuals</span> <span class="hljs-string">with</span> <span class="hljs-string">Bonferroni</span> <span class="hljs-string">p</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">0.05</span><span class="hljs-string">Largest</span> <span class="hljs-string">|rstudent|:</span>   <span class="hljs-string">rstudent</span> <span class="hljs-string">unadjusted</span> <span class="hljs-string">p-value</span> <span class="hljs-string">Bonferroni</span> <span class="hljs-string">p</span><span class="hljs-number">19</span> <span class="hljs-number">2.251149</span>           <span class="hljs-number">0.029422</span>           <span class="hljs-string">NA</span></code></pre><p>从输出结果来看，并没有证据说明胆固醇数据中含有离群点（当p&gt;1时将产生NA）。因此根据正态性检验、方差齐性检验和离群点检验，该数据似乎可以用ANOVA模型拟合得很好。<strong>这些方法反过来增强了我们对于所得结果的信心。</strong></p><h2 id="3-双因素方差分析"><a href="#3-双因素方差分析" class="headerlink" title="3 双因素方差分析"></a>3 双因素方差分析</h2><h3 id="3-1-推导过程"><a href="#3-1-推导过程" class="headerlink" title="3.1 推导过程"></a>3.1 推导过程</h3><p>在很多种情况下，只考虑一个指标对观察值的影响，显然是不够的，这时就会用到多因素方差分析。双因素方差分析和多因素方差分析在原理上是相似的，这里为了书写简便，我们只以双因素方差分析为例进行推导。</p><p>还是以田间实验的例子帮助理解推导过程，我们设有两个因素$A, B$，分别有$k, l$个水平（例如$A$为品种，有$k$个；$B$为播种量，考虑$l$种不同的数值，如20斤／亩，25斤／亩，……）．$A$的水平$i$与$B$的水平$j$的组合记为$(i,j)$，其试验结果记为 $Y_{ij}, i = 1, · · ·, k,j = 1,…, l$．统计模型定为</p><script type="math/tex; mode=display">Y_{ij} = \mu + a_i + b_j + e_{ij}，i= 1, · · ·, k,j = 1,· · ·, l\qquad (3.1)</script><p>为解释这模型，首先把右边分成两部分：$e_{ij}$为随机误差，它包含了未加控制的因素($A,B$以外的因素）及大量随机因素的影响．假定</p><script type="math/tex; mode=display">E(e_{ij})=0, 0<Var(e_{ij})={\sigma}^2<\infty,一切e_{ij}独立同分布\qquad(3.2)</script><p>另一部分$\mu + a_i + b_j$，它显示水平组合$(i,j)$的平均效应．它可以又分解为三部分：$\mu$是总平均（一切水平组合效应的平均），是一个基准．$a_i$表示由$A$的水平$i$带来的增加部分，称为因素$A$的水平$i$的效应．$b_j$有类似的解释．调整$\mu$的值，我们可以补充要求：</p><script type="math/tex; mode=display">a_1+···+a_k=0,b_1+···+b_l=0 \qquad (3.3)</script><p>如果$(3.3)$式不成立，则分别把$\mu$换为 $\mu + \bar{a}+\bar{b}$，$a_i$换为$a_i-\bar{a}$，$b_j$换为$b_j-\bar{b}$，则$(3.1)$式不变，而$(3.3)$式成立。</p><p>约束条件$(3.3)$给了$a_i，b_j$的意义一种更清晰的解释：$a_i&gt;0$ 表示A的水平$i$的效应在$A$的全部水平的平均效应之上，$a_i&lt;0$ 则相反。另外，这个约束条件也给了$\mu，a_i,b_j$的 一个适当的估计法：把$Y_{ij}$对一切$i,j$相加．注意到$(3.3)$，有</p><script type="math/tex; mode=display">\sum_{i=1}^{k}\sum_{j=1}^{l}Y_{ij}= kl\mu+\sum_{i=1}^{k}\sum_{j=1}^{l}e_{ij} \qquad (3.4)</script><p>由$(3.2)$得，</p><script type="math/tex; mode=display">\bar{Y}=\sum_{i=1}^{k}\sum_{j=1}^{l}Y_{ij}/kl \qquad (3.5)</script><p>是$\mu$的一个无偏估计。其次，有</p><script type="math/tex; mode=display">\sum_{j=1}^{l}Y_{ij}=l\mu+la+\sum_{j=1}^{l}e_{ij} \qquad (3.6)</script><p>于是，记</p><script type="math/tex; mode=display">\bar{Y_i}=\sum_{j=1}^{l}Y_{ij}/l, \quad \bar{Y_j}=\sum_{i=1}^{k}Y_{ij}/k \qquad (3.7)</script><p>由$(3.7)$知，$\bar{Y_j}$为$\mu+a_i$的一个无偏估计。于是得到$a_i$的一个无偏估计为</p><script type="math/tex; mode=display">\hat{a_i}=\bar{Y_i}-\bar{Y}, i=1,\cdots,k \qquad(3.8)</script><p>同理，</p><script type="math/tex; mode=display">\hat{b_j}=\bar{Y_j}-\bar{Y}, j=1,\cdots,l \qquad(3.9)</script><p>$\hat{a_i},\hat{b_j}$适合约束条件$(3.3)$。</p><p>下面进行方差分析，要设法把总平方和</p><script type="math/tex; mode=display">SS=\sum_{i=1}^{k}\sum_{j=1}^{l}(Y_{ij}-\bar{Y})^2</script><p>分解为三部分：$SS_A,SS_B,SS_e$，分别表示因素$A,B$和随机误差的影响。这种分解的主要目的是假设检验：</p><script type="math/tex; mode=display">H_{0A}:a_1=\cdots=a_k=0 \qquad(3.10)</script><p>和</p><script type="math/tex; mode=display">H_{0B}:b_1=\cdots=b_k=0 \qquad(3.11)</script><p>$H_0A$成立表示因素$A$对指标其实无影响。在实际问题中，绝对无影响的场合少见，但如影响甚小以致被随机误差所掩盖时，这种影响事实上等于没有。因此，拿$SS_A$和$SS_e$的比作为检验统计量正符合这一想法．</p><p>接下来讲一下方差分解的小技巧：</p><script type="math/tex; mode=display">Y_{ij}-\bar{Y}=(\bar{Y_i}-\bar{Y}) + (\bar{Y_j}-\bar{Y})+(Y_{ij}-\bar{Y_i}-\bar{Y_j}+\bar{Y})</script><p>两边平方，对$i,j$求和，结合约束条件(3.3)，注意到</p><script type="math/tex; mode=display">\sum_{i=1}^{l}(\bar{Y_{i}}-\bar{Y})=0， \sum_{j=1}^{k}(\bar{Y_{j}}-\bar{Y})=0，</script><script type="math/tex; mode=display">\sum_{i=1}^{k}(Y_{ij}-\bar{Y_i}-\bar{Y_j}+\bar{Y})=\sum_{j=1}^{l}(Y_{ij}-\bar{Y_i}-\bar{Y_j}+\bar{Y})=0</script><script type="math/tex; mode=display">\sum_{i=1}^{k}(Y_{ij}-\bar{Y_i}-\bar{Y_j}+\bar{Y}) = k\bar{Y_j}\\=\sum_{j=1}^{l}(Y_{ij}-\bar{Y_i}-\bar{Y_j}+\bar{Y}) = l\bar{Y_i}</script><p>即知所有交叉积之和皆为0，而得到</p><script type="math/tex; mode=display">\begin{align}SS&=l\sum_{i=1}^{k}(\bar{Y_{i}}-\bar{Y})^2+k\sum_{j=1}^{l}(\bar{Y_{j}}-\bar{Y})^2+\sum_{i=1}^{k}\sum_{j=1}^{l}(Y_{ij}-\bar{Y_i}-\bar{Y_j}+\bar{Y})^2 \\&=SS_A + SS_B + SS_e \qquad(3.12)\end{align}</script><p>第一个平方和可以作为因素$A$的影响的衡量，从前述$\bar{Y_{i}}-\bar{Y}$作为 $a_i$的估计可以理解第二个平方和同理。至于第三个平方和可作为随机误差的影响这一点， 直接看不甚明显。可以从两个角度去理解：在$SS$中去掉$SS_A$ 和$SS_B$后，剩余下的再没有其他系统性因素的影响，故只能作为$SS_e$。另外，由模型$(3.1)$及约束条件$(3.3)$，易知</p><script type="math/tex; mode=display">\begin{align}Y_{ij}-\bar{Y_i}-\bar{Y_j}+\bar{Y} &= (\mu + a_i + b_j + e_{ij}) - (\mu + a_i + \bar{e_{i}}) - (\mu + b_j + \bar{e_{j}} ) + (\mu + \bar{e})  \\&=e_{ij}-\bar{e_i}-\bar{e_j}+\bar{e} \qquad(3.13)\end{align}</script><p>这里面已经毫无$\mu,a_i,b_j$的影响，而只含随机误差。</p><p>得到分解式$(3.12)$后，我们就可以像单囚素情况那样，写出下面的方差分析表：<br>$SS_A , SS_B$ 自由度分别为其水平数减去1，这一点与单因素情况相同．总和自由度为全部观察值数目$kl$减去1．剩下的就是误差平方和自由度：</p><script type="math/tex; mode=display">(kl - 1) - (k - 1) - (l - 1) = (k - 1) (l - 1)</script><p><strong>表3.1 双因素方差分析表</strong></p><div class="table-container"><table><thead><tr><th>项目</th><th>$SS$</th><th>自由度</th><th>$MS$</th><th>$F$比</th><th>显著性</th></tr></thead><tbody><tr><td>$A$</td><td>$SS_A$</td><td>$k-1$</td><td>$MS_A$</td><td>$MS_A / MS_e$</td><td><em>, *</em>, 或无</td></tr><tr><td>$B$</td><td>$SS_B$</td><td>$l-1$</td><td>$MS_B$</td><td>$MS_B / MS_e$</td><td></td></tr><tr><td>误差</td><td>$SS_e$</td><td>$(k - 1) (l - 1)$</td><td>$MS_e$</td><td></td><td></td></tr><tr><td>总和</td><td>$SS$</td><td>$kl-1$</td><td></td><td></td></tr></tbody></table></div><p>还有一点要注意：在采纳模型$(3.1)$时，我们事实上引进了 一 种假定，即两因素$A,B$对指标的效应是可以叠加的．换一种方式说：因素$A$的各水平的优劣比较，与因素$B$处在哪个水平无关，反之亦然．更一般的情况是：$A,B$两因子有“交互作用 ＂ 。这时在模型(5.13)中，还要加上表示交互作用的项$c_{ij}$．这时不仅统计分析复杂化了，尤其是分析结果的解释也复杂化了．本文档暂不讨论这种情况。在一个特定的问题中，交互作用是否需要考虑，在很大程度上取决于问题的实际背景和经验．有时，通过试验数据的分析也可以看出一些问题。例如，若误差方差$\sigma^2$的估计$MS_e $反常地大，则有可能是由于交互作用所致．因为可以证明：若交互作用确实存在而未加考虑，则它的影响进入随机误差而增大了$MS_e$。</p><h3 id="3-2-代码实例"><a href="#3-2-代码实例" class="headerlink" title="3.2 代码实例"></a>3.2 代码实例</h3><p>在双因素方差分析中，受试者被分配到两因子的交叉类别组中。以基础安装中的ToothGrowth数据集为例，随机分配60只豚鼠，分别采用两种喂食方法（橙汁或维生素C），各喂食方法中抗坏血酸含量有三种水平（0.5mg、1mg或2mg），每种处理方式组合都被分配10只豚鼠，牙齿长度为因变量。</p><pre><code class="hljs angelscript">&gt; attach(ToothGrowth)&gt; table(supp, dose)    dosesupp <span class="hljs-number">0.5</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  OJ  <span class="hljs-number">10</span> <span class="hljs-number">10</span> <span class="hljs-number">10</span>  VC  <span class="hljs-number">10</span> <span class="hljs-number">10</span> <span class="hljs-number">10</span>&gt; &gt; aggregate(len, by=list(supp, dose), FUN=mean)  Group<span class="hljs-number">.1</span> Group<span class="hljs-number">.2</span>     x<span class="hljs-number">1</span>      OJ     <span class="hljs-number">0.5</span> <span class="hljs-number">13.23</span><span class="hljs-number">2</span>      VC     <span class="hljs-number">0.5</span>  <span class="hljs-number">7.98</span><span class="hljs-number">3</span>      OJ     <span class="hljs-number">1.0</span> <span class="hljs-number">22.70</span><span class="hljs-number">4</span>      VC     <span class="hljs-number">1.0</span> <span class="hljs-number">16.77</span><span class="hljs-number">5</span>      OJ     <span class="hljs-number">2.0</span> <span class="hljs-number">26.06</span><span class="hljs-number">6</span>      VC     <span class="hljs-number">2.0</span> <span class="hljs-number">26.14</span>&gt; &gt; aggregate(len, by=list(supp, dose), FUN=sd)  Group<span class="hljs-number">.1</span> Group<span class="hljs-number">.2</span>        x<span class="hljs-number">1</span>      OJ     <span class="hljs-number">0.5</span> <span class="hljs-number">4.459709</span><span class="hljs-number">2</span>      VC     <span class="hljs-number">0.5</span> <span class="hljs-number">2.746634</span><span class="hljs-number">3</span>      OJ     <span class="hljs-number">1.0</span> <span class="hljs-number">3.910953</span><span class="hljs-number">4</span>      VC     <span class="hljs-number">1.0</span> <span class="hljs-number">2.515309</span><span class="hljs-number">5</span>      OJ     <span class="hljs-number">2.0</span> <span class="hljs-number">2.655058</span><span class="hljs-number">6</span>      VC     <span class="hljs-number">2.0</span> <span class="hljs-number">4.797731</span>&gt; &gt; dose &lt;- factor(dose)#dose变量被转换为因子变量，这样aov()函数就会将它当做一个分组变量，而不是一个数值型协变量&gt; # condider <span class="hljs-built_in">int</span>eractive factor&gt; fit &lt;- aov(len ~ supp*dose)&gt; summary(fit)            Df Sum Sq Mean Sq F value   Pr(&gt;F)    supp         <span class="hljs-number">1</span>  <span class="hljs-number">205.4</span>   <span class="hljs-number">205.4</span>  <span class="hljs-number">15.572</span> <span class="hljs-number">0.000231</span> ***dose         <span class="hljs-number">2</span> <span class="hljs-number">2426.4</span>  <span class="hljs-number">1213.2</span>  <span class="hljs-number">92.000</span>  &lt; <span class="hljs-number">2e-16</span> ***supp:dose    <span class="hljs-number">2</span>  <span class="hljs-number">108.3</span>    <span class="hljs-number">54.2</span>   <span class="hljs-number">4.107</span> <span class="hljs-number">0.021860</span> *  Residuals   <span class="hljs-number">54</span>  <span class="hljs-number">712.1</span>    <span class="hljs-number">13.2</span>                     ---Signif. codes:  <span class="hljs-number">0</span> ‘***’ <span class="hljs-number">0.001</span> ‘**’ <span class="hljs-number">0.01</span> ‘*’ <span class="hljs-number">0.05</span> ‘.’ <span class="hljs-number">0.1</span> ‘ ’ <span class="hljs-number">1</span></code></pre><p>计算结果表明，主效应和交互效应都是显著的。</p><p>有多种方式对结果进行可视化处理。此处可用interaction.plot()函数来展示双因素方<br>差分析的交互效应。</p><pre><code class="hljs routeros"><span class="hljs-comment"># interactive effect</span>interaction.plot(dose, supp, len, <span class="hljs-attribute">type</span>=<span class="hljs-string">"b"</span>,                 <span class="hljs-attribute">col</span>=c("red","blue"), <span class="hljs-attribute">pch</span>=c(16, 18),                 main = <span class="hljs-string">"Interaction between Dose and Supplement Type"</span>)</code></pre><p><img src="/article/2ad44fb9/3-1.png" srcset="/img/loading.gif" alt="3-1"></p><p><strong>图3-1 各种剂量喂食下豚鼠牙齿长度的均值（interaction.plot()函数绘制）</strong></p><p>还可以用gplots包中的plotmeans()函数来展示交互效应。<img src="/article/2ad44fb9/3-2.png" srcset="/img/loading.gif" alt="3-2"><strong>图3-2 喂食方法和剂量对牙齿生长的交互作用。用plotmeans()函数绘制的95%的置</strong><br><strong>信区间的牙齿长度均值</strong></p><p>图形展示了均值、误差棒（95%的置信区间）和样本大小。<br>最后，你还能用HH包中的interaction2wt()函数来可视化结果，图形对任意顺序的因子设计的主效应和交互效应都会进行展示（图3-3）。</p><pre><code class="hljs lisp">library(<span class="hljs-name">HH</span>)interaction2wt(<span class="hljs-name">len</span>~supp*dose)&gt; &gt; detach(<span class="hljs-name">ToothGrowth</span>)</code></pre><p><img src="/article/2ad44fb9/3-3.png" srcset="/img/loading.gif" alt="3-3"></p><p><strong>图3-3 ToothGrowth数据集的主效应和交互效应。图形由interaction2wt()函数创建</strong></p><p>以上三幅图形都表明随着橙汁和维生素C中的抗坏血酸剂量的增加，牙齿长度变长。对于0.5mg和1mg剂量，橙汁比维生素C更能促进牙齿生长；对于2mg剂量的抗坏血酸，两种喂食方法下牙齿长度增长相同。</p><h4 id="参考书目："><a href="#参考书目：" class="headerlink" title="参考书目："></a>参考书目：</h4><ol><li>陈希孺，概率论与数理统计</li><li>Robert I. Kabacoff, R in Action.</li></ol>]]></content>
    
    
    <categories>
      
      <category>概率统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第九章-时序数据</title>
    <link href="/article/32af8df.html"/>
    <url>/article/32af8df.html</url>
    
    <content type="html"><![CDATA[<p><img src="/article/32af8df/时序数据.png" srcset="/img/loading.gif" alt="时序数据"></p><a id="more"></a>明天要考试了--明后天再补全了~回答有些过于简陋了问题1(a) <pre><code class="hljs prolog">df = pd.read_csv(<span class="hljs-string">'data/time_series_one.csv'</span>, parse_dates=[<span class="hljs-string">'日期'</span>])df[<span class="hljs-string">'日期'</span>].dt.dayofweek[df[<span class="hljs-string">'销售额'</span>].idxmax()]</code></pre><p>输出：</p><p>6<br>（b）</p><pre><code class="hljs routeros">holiday = pd.date_range(<span class="hljs-attribute">start</span>=<span class="hljs-string">'20170501'</span>, <span class="hljs-attribute">end</span>=<span class="hljs-string">'20170503'</span>).append(          pd.date_range(<span class="hljs-attribute">start</span>=<span class="hljs-string">'20171001'</span>, <span class="hljs-attribute">end</span>=<span class="hljs-string">'20171007'</span>)).append(          pd.date_range(<span class="hljs-attribute">start</span>=<span class="hljs-string">'20180215'</span>, <span class="hljs-attribute">end</span>=<span class="hljs-string">'20180221'</span>)).append(          pd.date_range(<span class="hljs-attribute">start</span>=<span class="hljs-string">'20180501'</span>, <span class="hljs-attribute">end</span>=<span class="hljs-string">'20180503'</span>)).append(          pd.date_range(<span class="hljs-attribute">start</span>=<span class="hljs-string">'20181001'</span>, <span class="hljs-attribute">end</span>=<span class="hljs-string">'20181007'</span>)).append(          pd.date_range(<span class="hljs-attribute">start</span>=<span class="hljs-string">'20190204'</span>, <span class="hljs-attribute">end</span>=<span class="hljs-string">'20190224'</span>)).append(          pd.date_range(<span class="hljs-attribute">start</span>=<span class="hljs-string">'20190501'</span>, <span class="hljs-attribute">end</span>=<span class="hljs-string">'20190503'</span>)).append(          pd.date_range(<span class="hljs-attribute">start</span>=<span class="hljs-string">'20191001'</span>, <span class="hljs-attribute">end</span>=<span class="hljs-string">'20191007'</span>))result = df[~df[<span class="hljs-string">'日期'</span>].isin(holiday)].set_index(<span class="hljs-string">'日期'</span>).resample(<span class="hljs-string">'MS'</span>).sum()result.head()</code></pre><p>(c)</p><pre><code class="hljs sas">result = df[df[<span class="hljs-string">'日期'</span>].dt.dayofweek.<span class="hljs-meta">isin(</span>[5,6])].<span class="hljs-meta">set</span><span class="hljs-meta">_index(</span><span class="hljs-string">'日期'</span>).resample(<span class="hljs-string">'QS'</span>)<span class="hljs-meta">.sum(</span>)result.head()</code></pre>]]></content>
    
    
    <categories>
      
      <category>pandas下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3常见分布与假设检验</title>
    <link href="/article/7c20a36d.html"/>
    <url>/article/7c20a36d.html</url>
    
    <content type="html"><![CDATA[<h2 id="1-一般随机变量"><a href="#1-一般随机变量" class="headerlink" title="1 一般随机变量"></a>1 一般随机变量</h2><h3 id="1-1-随机变量的两种类型"><a href="#1-1-随机变量的两种类型" class="headerlink" title="1.1 随机变量的两种类型"></a>1.1 随机变量的两种类型</h3><p>根据随机变量可能取值的个数分为离散型（取值有限）和连续型（取值无限）两类。</p><h3 id="1-2-离散型随机变量"><a href="#1-2-离散型随机变量" class="headerlink" title="1.2 离散型随机变量"></a>1.2 离散型随机变量</h3><p>对于离散型随机变量，使用概率质量函数（probability mass function），简称PMF，来描述其分布律。</p><p>假定离散型随机变量X，共有n个取值，$X_1$, $X_2$, ……, $X_n$, 那么</p><script type="math/tex; mode=display">P(X=X_n) \geq 0</script><script type="math/tex; mode=display">\Sigma_{1}^{n} P(X=X_n) =1</script><p>用到PMF的例子：二项分布，泊松分布<a id="more"></a></p><h3 id="1-3-连续型随机变量"><a href="#1-3-连续型随机变量" class="headerlink" title="1.3 连续型随机变量"></a>1.3 连续型随机变量</h3><p>对于连续型随机变量，使用概率密度函数（probability density function），简称PDF，来描述其分布情况。</p><p>连续型随机变量的特点在于取任何固定值的概率都为0，因此讨论其在特定值上的概率是没有意义的，应当讨论其在某一个区间范围内的概率，这就用到了概率密度函数的概念。</p><p>假定连续型随机变量X，f(x)为概率密度函数， 对于任意实数范围如[a,b]，有</p><script type="math/tex; mode=display">P \lbrace a\leq X \leq b\rbrace = \int ^b_a f(x) {\rm d}x</script><p>用到PDF的例子：均匀分布，正态分布，指数分布</p><p>对于连续型随机变量，通常还会用到累积分布函数 (cumulative distribution function)，简称CDF，来描述其性质，在数学上CDF是PDF的积分形式。</p><p>分布函数F(x)在点x处的函数值表示X落在区间(−∞,x]内的概率，所以分布函数就是定义域为R的一个普通函数，因此我们可以把概率问题转化为函数问题，从而可以利用普通的函数知识来研究概率问题，增大了概率的研究范围。</p><h2 id="2-常见分布"><a href="#2-常见分布" class="headerlink" title="2 常见分布"></a>2 常见分布</h2><p>本节通过一些实际例子来认识各种不同的分布及其应用场景</p><h3 id="2-1-离散型分布"><a href="#2-1-离散型分布" class="headerlink" title="2.1 离散型分布"></a>2.1 离散型分布</h3><h4 id="2-1-1-二项分布（Binomial-distribution）"><a href="#2-1-1-二项分布（Binomial-distribution）" class="headerlink" title="2.1.1 二项分布（Binomial distribution）"></a>2.1.1 二项分布（Binomial distribution）</h4><p>二项分布可以认为是一种只有两种结果（成功/失败)的单次试验重复多次后成功次数的分布概率。</p><p>二项分布需要满足以下条件：</p><ul><li>试验次数是固定的</li><li>每次试验都是独立的</li><li>对于每次试验成功的概率都是一样的</li></ul><p>一些二项分布的例子：</p><ul><li>销售电话成功的次数</li><li>一批产品中有缺陷的产品数量</li><li>掷硬币正面朝上的次数</li><li>在一袋糖果中取糖果吃，拿到红色包装的次数</li></ul><p>在n次试验中，单次试验成功率为p，失败率q=1-p，则出现成功次数的概率为</p><script type="math/tex; mode=display">P(X=x) = C_n^x p^x q^{n-x}</script><h4 id="2-1-2-泊松分布（Poisson-distribution）"><a href="#2-1-2-泊松分布（Poisson-distribution）" class="headerlink" title="2.1.2 泊松分布（Poisson distribution）"></a>2.1.2 泊松分布（Poisson distribution）</h4><p>泊松分布是用来描述泊松试验的一种分布，满足以下两个特征的试验可以认为是泊松试验：</p><ul><li>所考察的事件在任意两个长度相等的区间里发生一次的机会均等</li><li>所考察的事件在任何一个区间里发生与否和在其他区间里发生与否没有相互影响，即是独立的</li></ul><p>泊松分布需要满足一些条件：</p><ul><li>试验次数n趋向于无穷大</li><li>单次事件发生的概率p趋向于0</li><li>np是一个有限的数值</li></ul><p>泊松分布的一些例子：</p><ul><li>一定时间段内，某航空公司接到的订票电话数</li><li>一定时间内，到车站等候公交汽车的人数</li><li>一匹布上发现的瑕疵点的个数</li><li>一定页数的书刊上出现的错别字个数</li></ul><p>一个服从泊松分布的随机变量X，在具有比率参数（rate parameter）λ （λ=np）的一段固定时间间隔内，事件发生次数为i的概率为</p><script type="math/tex; mode=display">P\lbrace X= i \rbrace = e^{-λ} \frac{λ^i}{i!}</script><h4 id="2-1-3-二项分布，泊松分布，正态分布的关系"><a href="#2-1-3-二项分布，泊松分布，正态分布的关系" class="headerlink" title="2.1.3 二项分布，泊松分布，正态分布的关系"></a>2.1.3 二项分布，泊松分布，正态分布的关系</h4><p>这三个分布之间具有非常微妙的关联。</p><p>当n很大，p很小时，如<em>n</em> ≥ 100 and <em>np</em> ≤ 10时，二项分布可以近似为泊松分布。</p><p>当λ很大时，如λ≥1000时，泊松分布可以近似为正态分布。</p><p>当n很大时，np和n(1-p)都足够大时，如n ≥ 100 , np  ≥10，n(1-p) ≥10时，二项分布可以近似为正态分布。</p><h4 id="2-1-4-其他离散型随机分布"><a href="#2-1-4-其他离散型随机分布" class="headerlink" title="2.1.4 其他离散型随机分布"></a>2.1.4 其他离散型随机分布</h4><p>除了二项分布和泊松分布以外，还有其他一些不太常用的离散型分布。</p><h5 id="几何分布（Geometric-distribution）"><a href="#几何分布（Geometric-distribution）" class="headerlink" title="几何分布（Geometric distribution）"></a>几何分布（Geometric distribution）</h5><p>考虑独立重复试验，几何分布描述的是经过k次试验才首次获得成功的概率，假定每次成功率为p，</p><script type="math/tex; mode=display">P\lbrace X= n \rbrace = {(1-p)}^{n-1} p</script><h5 id="负二项分布（Negative-binomial-distribution）"><a href="#负二项分布（Negative-binomial-distribution）" class="headerlink" title="负二项分布（Negative binomial distribution）"></a>负二项分布（Negative binomial distribution）</h5><p>考虑独立重复试验，负二项分布描述的是试验一直进行到成功r次的概率，假定每次成功率为p，</p><script type="math/tex; mode=display">P\lbrace X= n \rbrace = C_{n-1}^{r-1} p^r {(1-p)}^{n-r}</script><h5 id="超几何分布（Hypergeometric-Distribution）"><a href="#超几何分布（Hypergeometric-Distribution）" class="headerlink" title="超几何分布（Hypergeometric Distribution）"></a>超几何分布（Hypergeometric Distribution）</h5><p>超几何分布描述的是在一个总数为N的总体中进行有放回地抽样，其中在总体中k个元素属于一组，剩余N-k个元素属于另一组，假定从总体中抽取n次，其中包含x个第一组的概率为</p><script type="math/tex; mode=display">P\lbrace X= n \rbrace = \frac {C_{k}^{x} C_{N-k}^{n-x}} {C_{N}^{n}}</script><h3 id="2-2-连续型分布"><a href="#2-2-连续型分布" class="headerlink" title="2.2 连续型分布"></a>2.2 连续型分布</h3><h4 id="2-2-1-均匀分布-（Uniform-distribution）"><a href="#2-2-1-均匀分布-（Uniform-distribution）" class="headerlink" title="2.2.1 均匀分布 （Uniform distribution）"></a>2.2.1 均匀分布 （Uniform distribution）</h4><p>均匀分布指的是一类在定义域内概率密度函数处处相等的统计分布。</p><p>若X是服从区间[a,b]上的均匀分布，则记作X~U[a,b]。</p><p>均匀分布X的概率密度函数为</p><script type="math/tex; mode=display">f(x)=\begin{cases}\frac {1} {b-a} ,  &  a \leq x  \leq b \\0, & others\end{cases}</script><p>分布函数为</p><script type="math/tex; mode=display">F(x)=\begin{cases}0 ,  &  x< a \\(x-a)(b-a), & a \leq x  \leq b \\1, & x>b\end{cases}</script><p>均匀分布的一些例子：</p><ul><li>一个理想的随机数生成器</li><li>一个理想的圆盘以一定力度旋转后静止时的角度</li></ul><h4 id="2-2-2-正态分布-（Normal-distribution）"><a href="#2-2-2-正态分布-（Normal-distribution）" class="headerlink" title="2.2.2 正态分布 （Normal distribution）"></a>2.2.2 正态分布 （Normal distribution）</h4><p>正态分布，也叫做高斯分布，是最为常见的统计分布之一，是一种对称的分布，概率密度呈现钟摆的形状，其概率密度函数为</p><script type="math/tex; mode=display">f(x)=\frac{1}{\sqrt{2π}\sigma}e^{\frac{-(x-u)^2}{2\sigma^2}}</script><p>记为X ~ N(μ, $σ^2$) , 其中μ为正态分布的均值，σ为正态分布的标准差</p><p>有了一般正态分布后，可以通过公式变换将其转变为标准正态分布 Z ~ N(0,1)，</p><script type="math/tex; mode=display">Z=\frac {X-μ} {σ}</script><p>正态分布的一些例子：</p><ul><li>成人的身高</li><li>不同方向的气体分子的运动速度</li><li>测量物体质量时的误差</li></ul><p>正态分布在现实生活有着非常多的例子，这一点可以从中心极限定理来解释，中心极限定理说的是一组独立同分布的随机样本的平均值近似为正态分布，无论随机变量的总体符合何种分布。</p><h4 id="2-2-3-指数分布-（Exponential-distribution）"><a href="#2-2-3-指数分布-（Exponential-distribution）" class="headerlink" title="2.2.3 指数分布 （Exponential distribution）"></a>2.2.3 指数分布 （Exponential distribution）</h4><p>指数分布通常被广泛用在描述一个特定事件发生所需要的时间，在指数分布随机变量的分布中，有着很少的大数值和非常多的小数值。</p><p>指数分布的概率密度函数为</p><script type="math/tex; mode=display">f(x)=\begin{cases}λe^{-λx} ,  &   x  \geq 0 \\0, & x < 0\end{cases}</script><p>记为 X~E（λ),   其中λ被称为率参数（rate parameter），表示每单位时间发生该事件的次数。</p><p>分布函数为</p><script type="math/tex; mode=display">F(a) = P\{X \leq a\} = 1-e^{-λa},  a\geq 0</script><p>指数分布的一些例子：</p><ul><li>顾客到达一家店铺的时间间隔</li><li>从现在开始到发生地震的时间间隔</li><li>在产线上收到一个问题产品的时间间隔</li></ul><p>关于指数分布还有一个有趣的性质的是指数分布是无记忆性的，假定在等候事件发生的过程中已经过了一些时间，此时距离下一次事件发生的时间间隔的分布情况和最开始是完全一样的，就好像中间等候的那一段时间完全没有发生一样，也不会对结果有任何影响，用数学语言来表述是</p><script type="math/tex; mode=display">P\{X>s+t | X> t\} =P\{X>s\}</script><h4 id="2-2-4-其他连续分布"><a href="#2-2-4-其他连续分布" class="headerlink" title="2.2.4 其他连续分布"></a>2.2.4 其他连续分布</h4><p><strong>$\Gamma$分布</strong></p><p>常用来描述某个事件总共要发生n次的等待时间的分布</p><p><strong>威布尔分布 （Weibull distribution）</strong></p><p>常用来描述在工程领域中某类具有“最弱链”对象的寿命</p><h3 id="2-3-常见分布的均值和方差汇总"><a href="#2-3-常见分布的均值和方差汇总" class="headerlink" title="2.3 常见分布的均值和方差汇总"></a>2.3 常见分布的均值和方差汇总</h3><p>离散型分布</p><p><img src="/article/7c20a36d/discreteoverall.PNG" srcset="/img/loading.gif" alt="discreteoverall"></p><p>连续型分布</p><p><img src="/article/7c20a36d/continuousoverall.PNG" srcset="/img/loading.gif" alt="continuousoverall"></p><p>图片来自于 [Statistical Inference by Casella and Berger]</p><h3 id="2-4-Python-代码实战"><a href="#2-4-Python-代码实战" class="headerlink" title="2.4 Python 代码实战"></a>2.4 Python 代码实战</h3><h4 id="2-4-1-生成一组符合特定分布的随机数"><a href="#2-4-1-生成一组符合特定分布的随机数" class="headerlink" title="2.4.1 生成一组符合特定分布的随机数"></a>2.4.1 生成一组符合特定分布的随机数</h4><p>在Numpy库中，提供了一组random类可以生成特定分布的随机数</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy<span class="hljs-comment"># 生成大小为1000的符合b(10,0.5)二项分布的样本集</span>s = numpy.random.binomial(n=<span class="hljs-number">10</span>,p=<span class="hljs-number">0.5</span>,size=<span class="hljs-number">1000</span>)<span class="hljs-comment"># 生成大小为1000的符合P(1)的泊松分布的样本集</span>s = numpy.random.poisson(lam=<span class="hljs-number">1</span>,size=<span class="hljs-number">1000</span>)<span class="hljs-comment"># 生成大小为1000的符合U(0,1)均匀分布的样本集，注意在此方法中边界值为左闭右开区间</span>s = numpy.random.uniform(low=<span class="hljs-number">0</span>,high=<span class="hljs-number">1</span>,size=<span class="hljs-number">1000</span>)<span class="hljs-comment"># 生成大小为1000的符合N(0,1)正态分布的样本集，可以用normal函数自定义均值，标准差，也可以直接使用standard_normal函数</span>s = numpy.random.normal(loc=<span class="hljs-number">0</span>,scale=<span class="hljs-number">1</span>,size=<span class="hljs-number">1000</span>)s = numpy.random.standard_normal(size=<span class="hljs-number">1000</span>)<span class="hljs-comment"># 生成大小为1000的符合E(1/2)指数分布的样本集，注意该方法中的参数为指数分布参数λ的倒数</span>s = numpy.random.exponential(scale=<span class="hljs-number">2</span>,size=<span class="hljs-number">1000</span>)</code></pre><p>除了Numpy，Scipy也提供了一组生成特定分布随机数的方法</p><pre><code class="hljs python"><span class="hljs-comment"># 以均匀分布为例，rvs可用来生成一组随机变量的值</span><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> statsstats.uniform.rvs(size=<span class="hljs-number">10</span>)</code></pre><h4 id="2-4-2-计算统计分布的PMF和PDF"><a href="#2-4-2-计算统计分布的PMF和PDF" class="headerlink" title="2.4.2 计算统计分布的PMF和PDF"></a>2.4.2 计算统计分布的PMF和PDF</h4><p>Scipy库提供了一组用于计算离散型随机变量PMF和连续型随机变量PDF的方法。</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<span class="hljs-comment"># 计算二项分布B(10,0.5)的PMF</span>x=range(<span class="hljs-number">11</span>)p=stats.binom.pmf(x, n=<span class="hljs-number">10</span>, p=<span class="hljs-number">0.5</span>)<span class="hljs-comment"># 计算泊松分布P(1)的PMF</span>x=range(<span class="hljs-number">11</span>)p=stats.poisson.pmf(x, mu=<span class="hljs-number">1</span>)<span class="hljs-comment"># 计算均匀分布U(0,1)的PDF</span>x = numpy.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)p= stats.uniform.pdf(x,loc=<span class="hljs-number">0</span>, scale=<span class="hljs-number">1</span>)<span class="hljs-comment"># 计算正态分布N(0,1)的PDF</span>x = numpy.linspace(<span class="hljs-number">-3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1000</span>)p= stats.norm.pdf(x,loc=<span class="hljs-number">0</span>, scale=<span class="hljs-number">1</span>)<span class="hljs-comment"># 计算指数分布E(1)的PDF</span>x = numpy.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1000</span>)p= stats.expon.pdf(x,loc=<span class="hljs-number">0</span>,scale=<span class="hljs-number">1</span>)</code></pre><h4 id="2-4-3-计算统计分布的CDF"><a href="#2-4-3-计算统计分布的CDF" class="headerlink" title="2.4.3 计算统计分布的CDF"></a>2.4.3 计算统计分布的CDF</h4><p>类似计算概率质量/密度函数的方法，只需将上节中的pmf或pdf替换为cdf，即可得到分布函数的值</p><pre><code class="hljs python"><span class="hljs-comment"># 以正态分布为例，计算正态分布N(0,1)的CDF</span>x = numpy.linspace(<span class="hljs-number">-3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1000</span>)p = stats.norm.cdf(x,loc=<span class="hljs-number">0</span>, scale=<span class="hljs-number">1</span>)</code></pre><h4 id="2-4-4-统计分布可视化"><a href="#2-4-4-统计分布可视化" class="headerlink" title="2.4.4 统计分布可视化"></a>2.4.4 统计分布可视化</h4><h5 id="二项分布"><a href="#二项分布" class="headerlink" title="二项分布"></a><strong>二项分布</strong></h5><p>比较n=10，p=0.5的二项分布的真实概率质量和10000次随机抽样的结果</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> snsx = range(<span class="hljs-number">11</span>)  <span class="hljs-comment"># 二项分布成功的次数（X轴）</span>t = stats.binom.rvs(<span class="hljs-number">10</span>,<span class="hljs-number">0.5</span>,size=<span class="hljs-number">10000</span>) <span class="hljs-comment"># B(10,0.5)随机抽样10000次</span>p = stats.binom.pmf(x, <span class="hljs-number">10</span>, <span class="hljs-number">0.5</span>) <span class="hljs-comment"># B(10,0.5)真实概率质量</span>fig, ax = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)sns.distplot(t,bins=<span class="hljs-number">10</span>,hist_kws=&#123;<span class="hljs-string">'density'</span>:<span class="hljs-literal">True</span>&#125;, kde=<span class="hljs-literal">False</span>,label = <span class="hljs-string">'Distplot from 10000 samples'</span>)sns.scatterplot(x,p,color=<span class="hljs-string">'purple'</span>)sns.lineplot(x,p,color=<span class="hljs-string">'purple'</span>,label=<span class="hljs-string">'True mass density'</span>)plt.title(<span class="hljs-string">'Binomial distribution'</span>)plt.legend(bbox_to_anchor=(<span class="hljs-number">1.05</span>, <span class="hljs-number">1</span>))</code></pre><p><img src="/article/7c20a36d/binomial.png" srcset="/img/loading.gif" alt="binomial"></p><h5 id="泊松分布"><a href="#泊松分布" class="headerlink" title="泊松分布"></a><strong>泊松分布</strong></h5><p>比较λ=2的泊松分布的真实概率质量和10000次随机抽样的结果</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> snsx=range(<span class="hljs-number">11</span>)t= stats.poisson.rvs(<span class="hljs-number">2</span>,size=<span class="hljs-number">10000</span>)p=stats.poisson.pmf(x, <span class="hljs-number">2</span>)fig, ax = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)sns.distplot(t,bins=<span class="hljs-number">10</span>,hist_kws=&#123;<span class="hljs-string">'density'</span>:<span class="hljs-literal">True</span>&#125;, kde=<span class="hljs-literal">False</span>,label = <span class="hljs-string">'Distplot from 10000 samples'</span>)sns.scatterplot(x,p,color=<span class="hljs-string">'purple'</span>)sns.lineplot(x,p,color=<span class="hljs-string">'purple'</span>,label=<span class="hljs-string">'True mass density'</span>)plt.title(<span class="hljs-string">'Poisson distribution'</span>)plt.legend()</code></pre><p><img src="/article/7c20a36d/poisson.png" srcset="/img/loading.gif" alt="poisson"></p><p>比较不同参数λ对应的概率质量函数，可以验证随着参数增大，泊松分布开始逐渐变得对称，分布也越来越均匀，趋近于正态分布</p><pre><code class="hljs python">x=range(<span class="hljs-number">50</span>)fig, ax = plt.subplots()<span class="hljs-keyword">for</span>  lam <span class="hljs-keyword">in</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">20</span>] :        p=stats.poisson.pmf(x, lam)        sns.lineplot(x,p,label=<span class="hljs-string">'lamda= '</span>+ str(lam))plt.title(<span class="hljs-string">'Poisson distribution'</span>)plt.legend()</code></pre><p><img src="/article/7c20a36d/poisson2.png" srcset="/img/loading.gif" alt="poisson2"></p><h5 id="均匀分布"><a href="#均匀分布" class="headerlink" title="均匀分布"></a><strong>均匀分布</strong></h5><p>比较U(0,1)的均匀分布的真实概率密度和10000次随机抽样的结果</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> snsx=numpy.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">100</span>)t= stats.uniform.rvs(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,size=<span class="hljs-number">10000</span>)p=stats.uniform.pdf(x, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)fig, ax = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)sns.distplot(t,bins=<span class="hljs-number">10</span>,hist_kws=&#123;<span class="hljs-string">'density'</span>:<span class="hljs-literal">True</span>&#125;, kde=<span class="hljs-literal">False</span>,label = <span class="hljs-string">'Distplot from 10000 samples'</span>)sns.lineplot(x,p,color=<span class="hljs-string">'purple'</span>,label=<span class="hljs-string">'True mass density'</span>)plt.title(<span class="hljs-string">'Uniforml distribution'</span>)plt.legend(bbox_to_anchor=(<span class="hljs-number">1.05</span>, <span class="hljs-number">1</span>))</code></pre><p><img src="/article/7c20a36d/uniform.png" srcset="/img/loading.gif" alt="uniform"></p><h5 id="正态分布"><a href="#正态分布" class="headerlink" title="正态分布"></a><strong>正态分布</strong></h5><p>比较N(0,1)的正态分布的真实概率密度和10000次随机抽样的结果</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> snsx=numpy.linspace(<span class="hljs-number">-3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">100</span>)t= stats.norm.rvs(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,size=<span class="hljs-number">10000</span>)p=stats.norm.pdf(x, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)fig, ax = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)sns.distplot(t,bins=<span class="hljs-number">100</span>,hist_kws=&#123;<span class="hljs-string">'density'</span>:<span class="hljs-literal">True</span>&#125;, kde=<span class="hljs-literal">False</span>,label = <span class="hljs-string">'Distplot from 10000 samples'</span>)sns.lineplot(x,p,color=<span class="hljs-string">'purple'</span>,label=<span class="hljs-string">'True mass density'</span>)plt.title(<span class="hljs-string">'Normal distribution'</span>)plt.legend(bbox_to_anchor=(<span class="hljs-number">1.05</span>, <span class="hljs-number">1</span>))</code></pre><p><img src="/article/7c20a36d/normal.png" srcset="/img/loading.gif" alt="normal"></p><p>比较不同均值和标准差组合的正态分布的概率密度函数</p><pre><code class="hljs python">x=numpy.linspace(<span class="hljs-number">-6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">100</span>)p=stats.norm.pdf(x, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)fig, ax = plt.subplots()<span class="hljs-keyword">for</span>  mean, std <span class="hljs-keyword">in</span> [(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>),(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)]:         p=stats.norm.pdf(x, mean, std)        sns.lineplot(x,p,label=<span class="hljs-string">'Mean: '</span>+ str(mean) + <span class="hljs-string">', std: '</span>+ str(std))plt.title(<span class="hljs-string">'Normal distribution'</span>)plt.legend()</code></pre><p><img src="/article/7c20a36d/uniform2.png" srcset="/img/loading.gif" alt="uniform2"></p><h5 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a><strong>指数分布</strong></h5><p>比较E(1)的指数分布的真实概率密度和10000次随机抽样的结果</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy <span class="hljs-keyword">import</span> stats<span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> seaborn <span class="hljs-keyword">as</span> snsx=numpy.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>)t= stats.expon.rvs(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,size=<span class="hljs-number">10000</span>)p=stats.expon.pdf(x, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)fig, ax = plt.subplots(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)sns.distplot(t,bins=<span class="hljs-number">100</span>,hist_kws=&#123;<span class="hljs-string">'density'</span>:<span class="hljs-literal">True</span>&#125;, kde=<span class="hljs-literal">False</span>,label = <span class="hljs-string">'Distplot from 10000 samples'</span>)sns.lineplot(x,p,color=<span class="hljs-string">'purple'</span>,label=<span class="hljs-string">'True mass density'</span>)plt.title(<span class="hljs-string">'Exponential distribution'</span>)plt.legend(bbox_to_anchor=(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))</code></pre><p><img src="/article/7c20a36d/expo.png" srcset="/img/loading.gif" alt="expo"></p><p>比较不同参数的指数分布的概率密度函数</p><pre><code class="hljs python">x=numpy.linspace(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>,<span class="hljs-number">100</span>)fig, ax = plt.subplots()<span class="hljs-keyword">for</span>  scale <span class="hljs-keyword">in</span> [<span class="hljs-number">0.2</span>,<span class="hljs-number">0.5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>] :        p=stats.expon.pdf(x, scale=scale)        sns.lineplot(x,p,label=<span class="hljs-string">'lamda= '</span>+ str(<span class="hljs-number">1</span>/scale))plt.title(<span class="hljs-string">'Exponential distribution'</span>)plt.legend()</code></pre><p><img src="/article/7c20a36d/expo2.png" srcset="/img/loading.gif" alt="expo2"></p><h2 id="3-假设检验"><a href="#3-假设检验" class="headerlink" title="3 假设检验"></a>3 假设检验</h2><h3 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h3><p>假设检验问题是统计推断中的一类重要问题，在总体的分布函数完全未知或只知其形式，不知其参数的情况，为了推断总体的某些未知特性，提出某些关于总体的假设，这类问题被称为假设检验。</p><h3 id="3-2-基本步骤"><a href="#3-2-基本步骤" class="headerlink" title="3.2 基本步骤"></a>3.2 基本步骤</h3><p>一个假设检验问题可以分为5步，无论细节如果变化，都一定会遵循这5个步骤。</p><ol><li>陈述研究假设，包含原假设（null hypothesis）和备择假设（alternate hypothesis）</li><li>为验证假设收集数据</li><li>构造合适的统计测试量并测试</li><li>决定是接受还是拒绝原假设</li><li>展示结论</li></ol><p>步骤1：</p><p>通常来说，我们会把原假设的描述写成变量之间不存在某种差异，或不存在某种关联，备择假设则为存在某种差异或关联。</p><p>例如，原假设：男人和女人的平均身高没有差别， 备择假设男人和女人的平均身高存在显著差别。</p><p>步骤2:</p><p>为了统计检验的结果真实可靠，需要根据实际的假设命题从总体中抽取样本，要求抽样的数据要具有代表性，例如在上述男女平均身高的命题中，抽取的样本要能覆盖到各类社会阶级，各个国家等所有可能影响到身高的因素。</p><p>步骤3：</p><p>统计检验量有很多种类，但是所有的统计检验都是基于组内方差和组间方差的比较，如果组间方差足够大，使得不同组之间几乎没有重叠，那么统计量会反映出一个非常小的P值，意味着不同组之间的差异不可能是由偶然性导致的。</p><p>步骤4：</p><p>基于统计量的结果做出接受或拒绝原假设的判断，通常我们会以P=0.05作为临界值（单侧检验）。</p><p>步骤5：</p><p>展示结论。</p><h3 id="3-3-统计量的选择"><a href="#3-3-统计量的选择" class="headerlink" title="3.3 统计量的选择"></a>3.3 统计量的选择</h3><p>选择合适的统计量是进行假设检验的关键步骤，最常用的统计检验包括回归检验(regression test)，比较检验(comparison test)和关联检验(correlation test)三类。</p><p><strong>回归检验</strong></p><p>回归检验适用于预测变量是数值型的情况，根据预测变量的数量和结果变量的类型又分为以下几种。</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">预测变量</th><th style="text-align:center">结果变量</th></tr></thead><tbody><tr><td style="text-align:center">简单线性回归</td><td style="text-align:center">单个，连续数值</td><td style="text-align:center">连续数值</td></tr><tr><td style="text-align:center">多重线性回归</td><td style="text-align:center">多个，连续数值</td><td style="text-align:center">连续数值</td></tr><tr><td style="text-align:center">Logistic回归</td><td style="text-align:center">连续数值</td><td style="text-align:center">二元类别</td></tr></tbody></table></div><p><strong>比较检验</strong></p><p>比较检验适用于预测变量是类别型，结果变量是数值型的情况，根据预测变量的分组数量和结果变量的数量又可以分为以下几种。</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">预测变量</th><th style="text-align:center">结果变量</th></tr></thead><tbody><tr><td style="text-align:center">Paired t-test</td><td style="text-align:center">两组，类别</td><td style="text-align:center">组来自同一总体，数值</td></tr><tr><td style="text-align:center">Independent t-test</td><td style="text-align:center">两组，类别</td><td style="text-align:center">组来自不同总体，数值</td></tr><tr><td style="text-align:center">ANOVA</td><td style="text-align:center">两组及以上，类别</td><td style="text-align:center">单个，数值</td></tr><tr><td style="text-align:center">MANOVA</td><td style="text-align:center">两组及以上，类别</td><td style="text-align:center">两个及以上，数值</td></tr></tbody></table></div><p><strong>关联检验</strong></p><p>关联检验常用的只有卡方检验一种，适用于预测变量和结果变量均为类别型的情况。</p><p><strong>非参数检验</strong></p><p>此外，由于一般来说上述参数检验都需满足一些前提条件，样本之间独立，不同组的组内方差近似和数据满足正态性，所以当这些条件不满足的时候，我们可以尝试用非参数检验来代替参数检验。</p><div class="table-container"><table><thead><tr><th style="text-align:center">非参数检验</th><th style="text-align:center">用于替代的参数检验</th></tr></thead><tbody><tr><td style="text-align:center">Spearman</td><td style="text-align:center">回归和关联检验</td></tr><tr><td style="text-align:center">Sign test</td><td style="text-align:center">T-test</td></tr><tr><td style="text-align:center">Kruskal–Wallis</td><td style="text-align:center">ANOVA</td></tr><tr><td style="text-align:center">ANOSIM</td><td style="text-align:center">MANOVA</td></tr><tr><td style="text-align:center">Wilcoxon Rank-Sum test</td><td style="text-align:center">Independent t-test</td></tr><tr><td style="text-align:center">Wilcoxon Signed-rank test</td><td style="text-align:center">Paired t-test</td></tr><tr><td style="text-align:center"></td></tr></tbody></table></div><h3 id="3-4-两类错误"><a href="#3-4-两类错误" class="headerlink" title="3.4 两类错误"></a>3.4 两类错误</h3><p>事实上当我们进行假设检验的过程中是存在犯错误的可能的，并且理论上来说错误是无法完全避免的。根据定义，错误分为两类，一类错误（type I error）和二类错误（type II error）。</p><ul><li><p>一类错误：拒绝真的原假设</p></li><li><p>二类错误：接受错误的原假设</p></li></ul><p>一类错误可以通过α值来控制，在假设检验中选择的 α（显著性水平）对一类错误有着直接影响。α可以认为是我们犯一类错误的最大可能性。以95%的置信水平为例，a=0.05，这意味着我们拒绝一个真的原假设的可能性是5%。从长期来看，每做20次假设检验会有一次犯一类错误的事件发生。</p><p>二类错误通常是由小样本或高样本方差导致的，二类错误的概率可以用β来表示，和一类错误不同的是，此类错误是不能通过设置一个错误率来直接控制的。对于二类错误，可以从功效的角度来估计，首先进行功效分析（power analysis）计算出功效值1-β，进而得到二类错误的估计值β。</p><p>一般来说这两类错误是无法同时降低的，在降低犯一类错误的前提下会增加犯二类错误的可能性，在实际案例中如何平衡这两类错误取决于我们更能接受一类错误还是二类错误。</p><h3 id="3-5-Python代码实战"><a href="#3-5-Python代码实战" class="headerlink" title="3.5 Python代码实战"></a>3.5 Python代码实战</h3><p>本节通过一些例子来讲解如何使用python进行假设检验。</p><h4 id="3-5-1-正态检验"><a href="#3-5-1-正态检验" class="headerlink" title="3.5.1 正态检验"></a>3.5.1 正态检验</h4><p>Shapiro-Wilk Test是一种经典的正态检验方法。</p><p>H0: 样本总体服从正态分布</p><p>H1: 样本总体不服从正态分布 </p><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> shapirodata_nonnormal = np.random.exponential(size=<span class="hljs-number">100</span>)data_normal = np.random.normal(size=<span class="hljs-number">100</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">normal_judge</span><span class="hljs-params">(data)</span>:</span>stat, p = shapiro(data)<span class="hljs-keyword">if</span> p &gt; <span class="hljs-number">0.05</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">'stat=&#123;:.3f&#125;, p = &#123;:.3f&#125;, probably gaussian'</span>.format(stat,p)<span class="hljs-keyword">else</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">'stat=&#123;:.3f&#125;, p = &#123;:.3f&#125;, probably not gaussian'</span>.format(stat,p)<span class="hljs-comment"># output</span>normal_judge(data_nonnormal)<span class="hljs-comment"># 'stat=0.850, p = 0.000, probably not gaussian'</span>normal_judge(data_normal)<span class="hljs-comment"># 'stat=0.987, p = 0.415, probably gaussian'</span></code></pre><h4 id="3-5-2-卡方检验"><a href="#3-5-2-卡方检验" class="headerlink" title="3.5.2 卡方检验"></a>3.5.2 卡方检验</h4><p>目的：检验两组类别变量是相关的还是独立的</p><p>H0: 两个样本是独立的</p><p>H1: 两组样本不是独立的</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> chi2_contingencytable = [[<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>],[<span class="hljs-number">6</span>,  <span class="hljs-number">9</span>,  <span class="hljs-number">17</span>]]stat, p, dof, expected = chi2_contingency(table)print(<span class="hljs-string">'stat=%.3f, p=%.3f'</span> % (stat, p))<span class="hljs-keyword">if</span> p &gt; <span class="hljs-number">0.05</span>:print(<span class="hljs-string">'Probably independent'</span>)<span class="hljs-keyword">else</span>:print(<span class="hljs-string">'Probably dependent'</span>) <span class="hljs-comment"># output</span><span class="hljs-comment">#stat=0.272, p=0.873</span><span class="hljs-comment">#Probably independent</span></code></pre><h4 id="3-5-3-T-test"><a href="#3-5-3-T-test" class="headerlink" title="3.5.3 T-test"></a>3.5.3 T-test</h4><p>目的：检验两个独立样本集的均值是否具有显著差异</p><p>H0: 均值是相等的</p><p>H1: 均值是不等的</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> ttest_ind<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npdata1 = np.random.normal(size=<span class="hljs-number">10</span>)data2 = np.random.normal(size=<span class="hljs-number">10</span>)stat, p = ttest_ind(data1, data2)print(<span class="hljs-string">'stat=%.3f, p=%.3f'</span> % (stat, p))<span class="hljs-keyword">if</span> p &gt; <span class="hljs-number">0.05</span>:print(<span class="hljs-string">'Probably the same distribution'</span>)<span class="hljs-keyword">else</span>:print(<span class="hljs-string">'Probably different distributions'</span>)    <span class="hljs-comment"># output</span><span class="hljs-comment"># stat=-1.382, p=0.184</span><span class="hljs-comment"># Probably the same distribution</span></code></pre><h4 id="3-5-4-ANOVA"><a href="#3-5-4-ANOVA" class="headerlink" title="3.5.4 ANOVA"></a>3.5.4 ANOVA</h4><p>目的：与t-test类似，ANOVA可以检验两组及以上独立样本集的均值是否具有显著差异</p><p>H0: 均值是相等的</p><p>H1: 均值是不等的</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> f_oneway<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npdata1 = np.random.normal(size=<span class="hljs-number">10</span>)data2 = np.random.normal(size=<span class="hljs-number">10</span>)data3 = np.random.normal(size=<span class="hljs-number">10</span>)stat, p = f_oneway(data1, data2, data3)print(<span class="hljs-string">'stat=%.3f, p=%.3f'</span> % (stat, p))<span class="hljs-keyword">if</span> p &gt; <span class="hljs-number">0.05</span>:print(<span class="hljs-string">'Probably the same distribution'</span>)<span class="hljs-keyword">else</span>:print(<span class="hljs-string">'Probably different distributions'</span>) <span class="hljs-comment"># output</span><span class="hljs-comment"># stat=0.189, p=0.829</span><span class="hljs-comment"># Probably the same distribution</span></code></pre><h4 id="3-5-5-Mann-Whitney-U-Test"><a href="#3-5-5-Mann-Whitney-U-Test" class="headerlink" title="3.5.5 Mann-Whitney U Test"></a>3.5.5 Mann-Whitney U Test</h4><p>目的：检验两个样本集的分布是否相同</p><p>H0: 两个样本集的分布相同</p><p>H1: 两个样本集的分布不同</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> mannwhitneyudata1 = [<span class="hljs-number">0.873</span>, <span class="hljs-number">2.817</span>, <span class="hljs-number">0.121</span>, <span class="hljs-number">-0.945</span>, <span class="hljs-number">-0.055</span>, <span class="hljs-number">-1.436</span>, <span class="hljs-number">0.360</span>, <span class="hljs-number">-1.478</span>, <span class="hljs-number">-1.637</span>, <span class="hljs-number">-1.869</span>]data2 = [<span class="hljs-number">1.142</span>, <span class="hljs-number">-0.432</span>, <span class="hljs-number">-0.938</span>, <span class="hljs-number">-0.729</span>, <span class="hljs-number">-0.846</span>, <span class="hljs-number">-0.157</span>, <span class="hljs-number">0.500</span>, <span class="hljs-number">1.183</span>, <span class="hljs-number">-1.075</span>, <span class="hljs-number">-0.169</span>]stat, p = mannwhitneyu(data1, data2)print(<span class="hljs-string">'stat=%.3f, p=%.3f'</span> % (stat, p))<span class="hljs-keyword">if</span> p &gt; <span class="hljs-number">0.05</span>:print(<span class="hljs-string">'Probably the same distribution'</span>)<span class="hljs-keyword">else</span>:print(<span class="hljs-string">'Probably different distributions'</span>)<span class="hljs-comment"># output</span><span class="hljs-comment"># stat=40.000, p=0.236</span><span class="hljs-comment"># Probably the same distribution</span></code></pre><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li>Ross S . 概率论基础教程[M]. 人民邮电出版社, 2007.</li><li>盛骤, 谢式千, 潘承毅, 等. 概率论与数理统计 (第四版)[J]. 2008.</li><li><a href="https://machinelearningmastery.com/statistical-hypothesis-tests-in-python-cheat-sheet/" target="_blank" rel="noopener">https://machinelearningmastery.com/statistical-hypothesis-tests-in-python-cheat-sheet/</a></li><li><a href="https://www.scipy.org/" target="_blank" rel="noopener">https://www.scipy.org/</a></li><li><a href="https://www.thoughtco.com/difference-between-type-i-and-type-ii-errors-3126414" target="_blank" rel="noopener">https://www.thoughtco.com/difference-between-type-i-and-type-ii-errors-3126414</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>概率统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第八章-分类数据</title>
    <link href="/article/28c12c7e.html"/>
    <url>/article/28c12c7e.html</url>
    
    <content type="html"><![CDATA[<p><img src="/article/28c12c7e/分类数据.png" srcset="/img/loading.gif" alt></p><a id="more"></a><h1 id="问题与练习"><a href="#问题与练习" class="headerlink" title="问题与练习"></a>问题与练习</h1><p>【问题一】如何使用union_categoricals方法，它的作用是什么？</p><ul><li>如果要组合不一定具有相同类别的类别，union_categoricals函数将组合类似列表的类别。新类别将是合并的类别的并集。如下所示：</li></ul><pre><code class="hljs python"><span class="hljs-keyword">from</span> pandas.api.types <span class="hljs-keyword">import</span> union_categoricalsa = pd.Categorical([<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>])b = pd.Categorical([<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>])union_categoricals([a,b])</code></pre><p>输出：</p><p><img src="/article/28c12c7e/image-1.png" srcset="/img/loading.gif" alt="image-20200627224024855"></p><ul><li>默认情况下，生成的类别将按照在数据中显示的顺序排列。如果要对类别进行排序，可使用sort_categories=True参数。</li><li>union_categoricals也适用于组合相同类别和顺序信息的两个分类。</li><li>union_categoricals可以在合并分类时重新编码类别的整数代码。</li></ul><p>【问题二】利用concat方法将两个序列纵向拼接，它的结果一定是分类变量吗？什么情况下不是？</p><ul><li>pd.concat对象只能是pd.Series或pd.DataFrame，所以结果是object。</li><li>使用union_categoricals拼接两个分类变量可得到分类变量。</li></ul><p>【问题三】当使用groupby方法或者value_counts方法时，分类变量的统计结果和普通变量有什么区别？</p><ul><li>分类变量的groupby方法/value_counts方法，统计对象是类别。</li><li>普通变量groupby方法/value_counts方法，统计对象是唯一值(不包含NA)。</li></ul><p>【问题四】下面的代码说明了Series创建分类变量的什么”缺陷”？如何避免？（提示使用Series的copy参数）</p><pre><code class="hljs python">cat = pd.Categorical([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">10</span>], categories=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">10</span>])s = pd.Series(cat, name=<span class="hljs-string">"cat"</span>)cat</code></pre><p>输出：</p><pre><code class="hljs tex">[1, 2, 3, 10]Categories (5, int64): [1, 2, 3, 4, 10]</code></pre><hr><pre><code class="hljs python">s.iloc[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>cat</code></pre><p>输出：</p><pre><code class="hljs tex">[10, 10, 3, 10]Categories (5, int64): [1, 2, 3, 4, 10]</code></pre><p>分类变量在Series改动时也被改动了。<br><strong>使用copy参数避免分类变量被修改。</strong></p><pre><code class="hljs python">cat = pd.Categorical([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">10</span>],categories=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">10</span>])s = pd.Series(cat, name=<span class="hljs-string">'cat'</span>, copy=<span class="hljs-literal">True</span>)print(cat)s.iloc[<span class="hljs-number">0</span>:<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>print(cat)</code></pre><p>输出：</p><p><img src="/article/28c12c7e/image-2.png" srcset="/img/loading.gif" alt="image-20200627230102057"></p><p>【练习一】现继续使用第四章中的地震数据集，请解决以下问题：<br>（a）现在将深度分为七个等级：[0.5,10,15,20,30,50,np.inf]，请以深度Ⅰ,Ⅱ,Ⅲ,Ⅳ,Ⅴ,Ⅵ,Ⅶ为索引并按照由浅到深的顺序进行排序。</p><p>使用cut方法对列表中的深度划分，并将该列作为索引值。然后按索引排序即可。</p><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">'data/Earthquake.csv'</span>)df_result = df.copy()df_result[<span class="hljs-string">'深度'</span>] = pd.cut(df[<span class="hljs-string">'深度'</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">50</span>,np.inf], right=<span class="hljs-literal">False</span>, labels=[<span class="hljs-string">'Ⅰ'</span>,<span class="hljs-string">'Ⅱ'</span>,<span class="hljs-string">'Ⅲ'</span>,<span class="hljs-string">'Ⅳ'</span>,<span class="hljs-string">'Ⅴ'</span>,<span class="hljs-string">'Ⅵ'</span>,<span class="hljs-string">'Ⅶ'</span>])df_result = df_result.set_index(<span class="hljs-string">'深度'</span>).sort_index()df_result.head()</code></pre><p>输出：</p><p><img src="/article/28c12c7e/image-3.png" srcset="/img/loading.gif" alt="image-20200627231333013"></p><p>（b）在(a)的基础上，将烈度分为4个等级：[0,3,4,5,np.inf]，依次对南部地区的深度和烈度等级建立多级索引排序。</p><p>跟(a)很相似，cut方法对深度，烈度进行切分，把index设为[‘深度’，‘烈度’]，然后进行索引排序即可。</p><pre><code class="hljs python">df[<span class="hljs-string">'烈度'</span>] = pd.cut(df[<span class="hljs-string">'烈度'</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,np.inf], right=<span class="hljs-literal">False</span>, labels=[<span class="hljs-string">'Ⅰ'</span>,<span class="hljs-string">'Ⅱ'</span>,<span class="hljs-string">'Ⅲ'</span>,<span class="hljs-string">'Ⅳ'</span>])df[<span class="hljs-string">'深度'</span>] = pd.cut(df[<span class="hljs-string">'深度'</span>],[<span class="hljs-number">0</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>,<span class="hljs-number">15</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">50</span>,np.inf], right=<span class="hljs-literal">False</span>, labels=[<span class="hljs-string">'Ⅰ'</span>,<span class="hljs-string">'Ⅱ'</span>,<span class="hljs-string">'Ⅲ'</span>,<span class="hljs-string">'Ⅳ'</span>,<span class="hljs-string">'Ⅴ'</span>,<span class="hljs-string">'Ⅵ'</span>,<span class="hljs-string">'Ⅶ'</span>])df_ds = df.set_index([<span class="hljs-string">'深度'</span>,<span class="hljs-string">'烈度'</span>])df_ds.sort_index()</code></pre><p>【练习二】 对于分类变量而言，调用第4章中的变形函数会出现一个BUG（目前的版本下还未修复）：例如对于crosstab函数，按照<a href="https://pandas.pydata.org/pandas-docs/version/1.0.0/user_guide/reshaping.html#cross-tabulations" target="_blank" rel="noopener">官方文档的说法</a>，即使没有出现的变量也会在变形后的汇总结果中出现，但事实上并不是这样，比如下面的例子就缺少了原本应该出现的行’c’和列’f’。基于这一问题，请尝试设计my_crosstab函数，在功能上能够返回正确的结果。<br>因为Categories中肯定包含出现的变量。所以将第一个参数作为index，第二个参数作为columns，建立一个DataFrame，然后把出现的变量组合起来，对应位置填入1即可。</p><pre><code class="hljs python">foo = pd.Categorical([<span class="hljs-string">'b'</span>,<span class="hljs-string">'a'</span>], categories=[<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>])bar = pd.Categorical([<span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>], categories=[<span class="hljs-string">'d'</span>, <span class="hljs-string">'e'</span>, <span class="hljs-string">'f'</span>])<span class="hljs-keyword">import</span> numpy<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_crosstab</span><span class="hljs-params">(a, b)</span>:</span>    s1 = pd.Series(list(foo.categories), name=<span class="hljs-string">'row'</span>)    s2 = list(bar.categories)    df = pd.DataFrame(np.zeros((len(s1), len(s2)),int),index=s1, columns=s2)    index_1 = list(foo)    index_2 = list(bar)    <span class="hljs-keyword">for</span> loc <span class="hljs-keyword">in</span> zip(index_1, index_2):        df.loc[loc] = <span class="hljs-number">1</span>    <span class="hljs-keyword">return</span> dfmy_crosstab(foo, bar)</code></pre><p>输出：</p><p><img src="/article/28c12c7e/image-4.png" srcset="/img/loading.gif" alt="image-20200627232221247"></p>]]></content>
    
    
    <categories>
      
      <category>pandas下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第7章 文本数据</title>
    <link href="/article/88685a55.html"/>
    <url>/article/88685a55.html</url>
    
    <content type="html"><![CDATA[<p><img src="/article/88685a55/文本数据.png" srcset="/img/loading.gif" alt></p><h1 id="六、问题与练习"><a href="#六、问题与练习" class="headerlink" title="六、问题与练习"></a>六、问题与练习</h1><h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1.问题"></a>1.问题</h2><p>【问题一】 str对象方法和df/Series对象方法有什么区别?</p><ul><li><p>str对象方法有很多针对字符串的方法</p></li><li><p>在replace方法上，二者有较大差异：</p><p>1）str.replace针对object类型或string类型，默认操作：正则表达式</p><p>​      replace针对任意类型的序列或数据框，正则表达式替换：regex=True。使用字典可以支持      多列替换。</p><p>2）str.replace类型赋值参数不能是pd.NA。</p><p>3）对于string类型Series，使用replace函数不能使用正则表达式替换。</p></li></ul><p>【问题二】 给出一列string类型，如何判断单元格是否是数值型数据？</p><ul><li>正则表达式进行匹配。</li><li>str.isnumeric有一定的局限性。</li></ul><p>【问题三】str.split方法的作用是什么？在什么场合下使用？</p><ul><li>使用分隔符对每个字符串进行分割并返回列表。</li><li>可以使用str方法进行元素选择。</li></ul><p>【问题四】在本章的第二到第四节分别介绍了字符串类型的5类操作，请思考这些操作的应用场景？</p><ul><li>拆分：</li><li>拼接</li><li>替换</li><li>字符匹配</li><li>字符提取</li></ul><h2 id="2-练习"><a href="#2-练习" class="headerlink" title="2.练习"></a>2.练习</h2><p>【练习一】现有一份关于字符串的数据集，请解决以下问题：</p><p>（a）先对字符串编码存储人员信息（在编号后添加ID列），使用如下格式：”xxx(名字)：x国人，性别x，生于x年x月x日“</p><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">'data/String_data_one.csv'</span>,index_col=<span class="hljs-string">'人员编号'</span>, dtype=<span class="hljs-string">'string'</span>)df[<span class="hljs-string">'ID'</span>] = df[<span class="hljs-string">'姓名'</span>].str.cat([<span class="hljs-string">': '</span>+df[<span class="hljs-string">'国籍'</span>]+<span class="hljs-string">'国人,'</span>,<span class="hljs-string">'性别'</span>+df[<span class="hljs-string">'性别'</span>]+<span class="hljs-string">','</span>,<span class="hljs-string">'生于'</span>+df[<span class="hljs-string">'出生年'</span>]+<span class="hljs-string">'年'</span>,df[<span class="hljs-string">'出生月'</span>]+<span class="hljs-string">'月'</span>, df[<span class="hljs-string">'出生日'</span>] +<span class="hljs-string">'日'</span>],na_rep=<span class="hljs-string">'*'</span>)df[<span class="hljs-string">'ID'</span>].head()</code></pre><p>输出：</p><p><img src="/article/88685a55/image-1.png" srcset="/img/loading.gif" alt="image-20200627003713531"></p><p>（b）将（a）中的人员生日信息部分修改为用中文表示（如一九七四年十月二十三日），其余返回格式不变。</p><p>（c）将（b）中的ID列结果拆分为原列表相应的5列，并使用equals检验是否一致。</p><p>【练习二】现有一份半虚拟的数据集，第一列包含了新型冠状病毒的一些新闻标题，请解决以下问题：</p><p>（a）选出所有关于北京市和上海市新闻标题的所在行。</p><pre><code class="hljs python">df = pd.read_csv(<span class="hljs-string">'data/String_data_two.csv'</span>)df[<span class="hljs-string">'col1'</span>].str.extract(<span class="hljs-string">r'(?P&lt;name_1&gt;北京|上海)'</span>).dropna().index</code></pre><p>输出：</p><p><img src="/article/88685a55/image-2.png" srcset="/img/loading.gif" alt="image-20200626233841173"></p><p>（b）求col2的均值。</p><p>（c）求col3的均值。</p>]]></content>
    
    
    <categories>
      
      <category>pandas下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>pandas</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Task02-LBP特征描述算子-人脸检测</title>
    <link href="/article/50afbda.html"/>
    <url>/article/50afbda.html</url>
    
    <content type="html"><![CDATA[<p>学习任务：</p><p><strong>本文主要包含以下两部分</strong>：</p><ul><li><strong>理论部分</strong>：掌握LBP特征描述算子原理</li><li><strong>练习部分</strong>：使用OpenCV的LBP检测器完成人脸检测任务</li></ul><p>LBP是指局部二值模式(Local Binary Pattern)，是一种用来描述图像局部特征的算子，具有灰<br>度不变性和旋转不变性等显著优点。<a id="more"></a></p><h1 id="2-1-算法理论"><a href="#2-1-算法理论" class="headerlink" title="2.1 算法理论"></a>2.1 算法理论</h1><h2 id="LBP概念"><a href="#LBP概念" class="headerlink" title="LBP概念"></a>LBP概念</h2><p>LBP指的是局部二值模式，英文全称：Local Binary Pattern，是一种用来描述图像局部特征的算子。<br>LBP特征比较出名的应用是人脸识别和目标检测中。<br>计算机视觉开源库OpenCV：</p><ul><li>使用LBP特征实现人脸识别的接口。</li><li>使用LBP特征实现目标检测分类器的接口。</li></ul><p>本文将会对上述第一点做简单实现。</p><h2 id="基本LBP-纹理特征"><a href="#基本LBP-纹理特征" class="headerlink" title="基本LBP:纹理特征"></a>基本LBP:纹理特征</h2><p>基本LBP特征描述</p><ol><li>基本的LBP算子定义在像素3*3的领域内；</li><li>以领域中文像素为阈值，相邻8个像素的灰度值与中心像素的灰度值比较，若周围像素大于中心像素，标记为1，否则标记为0；</li><li>3*3领域内的8个点经过第二步后产生8个二进制数，依次排列为一个二进制序列。</li><li>8位二进制序列共有$2^8$即256种LBP值。中心像素的LBP值反映了该像素周围区域的纹理信息。中心像素的灰度值决定了局部区域的整体亮度。</li></ol><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/20200605193831589.png#pic_center" srcset="/img/loading.gif">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图 2.3.1 LBP计算示意图</div></center><p>​        中心像素坐标$(x_0,y_0)$局部领域中像素个数为$P(P&gt;1)$，$g_c$表示中心像素的灰度值，$g_p$ 表示领域像素的灰度值。</p><p>​        基本LBP表示为：$LBP(x_0,y_0)=\sum_{p=0}^{P-1} s(g_{p}-g_{c}) 2^{p}$<br>​        s是示性函数：$s(x)=\left\{\begin{array}{l}1, x \geq 0 \\<br>0, x&lt;0<br>\end{array}\right.$</p><p>&emsp;&emsp; <font color="blue">基本LBP具有灰度不变性。</font>对光照变化是鲁棒的。</p><h2 id="圆形LBP算子"><a href="#圆形LBP算子" class="headerlink" title="圆形LBP算子"></a>圆形LBP算子</h2><p>&emsp;基本LBP算子的缺陷：只覆盖了固定半径范围的小区域，不能适应不同尺度和频率纹理的变化。<br>&emsp;圆形LBP(Circular LBP or Extended LBP)：<strong>将局部领域扩展到任意领域，用圆形领域代替正方形领域。</strong><br>&emsp;改进后的LBP算子允许半径为R的圆形领域有任意多个像素点。<br>    使用可变半径的圆对近邻像素进行编码，可得到如下近邻：</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/article/50afbda/20190527221543821.png" srcset="/img/loading.gif">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图 2.3.2 五种编码对应的LBP</div></center><p>​    半径为R的圆形区域内含有P个采样点的LBP算子，表示为$LBP^{R}_P$；</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/20200605202407325.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTk0MDUxMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图 2.3.2 圆形LBP示意图</div></center><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/article/50afbda/20190527221655965.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTk0MDUxMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif">    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图 2.3.2 LBP扩展与多尺度表达</div></center><p>​        对于给定中心点$(x_c,y_c)$,其邻域像素位置为$(x_p,y_p)$，$p∈P$，其采样点$(x_p,y_p)$用如下公式计算：</p><script type="math/tex; mode=display">{x}_{p}=x_{c}+\operatorname{Rcos}\left(\frac{2 \pi p}{P}\right) \\y_{p}=y_{c}+\operatorname{Rsin}\left(\frac{2 \pi p}{P}\right)</script><p>​    &emsp;R是采样半径，p是第p个采样点，P是采样数目。如果近邻点不在整数位置上，就需要进行插值运算，然后使用计算出的插值点。OpenCV使用的是双线性插值。</p><h2 id="旋转不变性LBP"><a href="#旋转不变性LBP" class="headerlink" title="旋转不变性LBP"></a>旋转不变性LBP</h2><p>实现：<strong>不断旋转圆形邻域得到一系列初始定义的LPB值，取最小值作为中心像素点的LBP特征。</strong></p><script type="math/tex; mode=display">L B P_{P R}^{ri}=\min \left(R O R\left(L B P_{P, R}, i\right) | i=0,1, \ldots, P-1\right)\tag{2-7}</script><p>&emsp;其中$L B P_{P R}^{ri}$表示具有旋转不变性的LBP特征。$ROR(x, i)$为旋转函数，表示将P-bit​数右循环i位。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/20200606135438907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTk0MDUxMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif">    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图 2.3.3 求取旋转不变的LBP特征示意图</div></center><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/article/50afbda/v55RgEh.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTk0MDUxMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif">    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图 2.3.3 36种不同的旋转不变性LBP特征(P=8)</div></center><h2 id="Uniform-Pattern-LBP特征"><a href="#Uniform-Pattern-LBP特征" class="headerlink" title="Uniform Pattern LBP特征"></a>Uniform Pattern LBP特征</h2><p>Uniform Pattern，也被称为等价模式或均匀模式。<br>        将LBP算子用于纹理分类或人脸识别时，常用于LBP模式的统计直方图来表达图像的信息，较多的模式种类将使得数据量过大，且直方图过于稀疏。因此，需要对原始的LBP进行降维，使得数据量减少的情况下更好地表达图像信息。<br>        为了解决二进制模式过多的问题，提高统计性，Ojala提出了采用一种“<strong>等价模式</strong>”(Uniform Pattern)来对LBP算子的模式种类<strong>进行降维</strong>。<br>        <strong>在实际图像中，绝大多数LBP模式最多只包含两次从1到0或从0到1的跳变。</strong></p><ul><li>将<strong>等价模式</strong>定义为：当某个LBP所对应的循环二进制数从0到1或从1到0最多有两次跳变时，该LBP所对应的二进制就称为一个等价模式类。<strong>如00000000(0次跳变)，00000111(只含一次从0到1的跳变)，10001111(先由1跳到0，再由0跳到1，共两次跳变)</strong>,都是等价模式类。</li><li>除等价模式类以外的模式都归为另一类，称为<strong>混合模式类</strong>。<strong>例如10010111(共四次跳变)</strong>。</li></ul><p>&emsp;&emsp;<strong>检查某种模式是否是等价模式</strong>：将当前位置和移动一位后的二进制模式按位相减。并绝对值求和。若U$\left(G_{p}\right)$ 小于等于2，则为等价模式。</p><script type="math/tex; mode=display">U\left(G_{p}\right)=\left|s\left(g_{p_{-1}}-g_{c}\right)-s\left(g_{0}-g_{c}\right)\right|+\sum_{p=1}^{P_{-1}}\left|s\left(g_{p}-g_{c}\right)-s\left(g_{P-1}-g_{c}\right)\right|</script><p>&emsp;&emsp;二进制模式数量由原来的$2^P$种减少为了$P(P-1)+2+1$种。其中等价模式类为$P(P-1)+2$种，在LBP特征图的灰度值为$1-[P(P-1)+2]$，混合模式类为1种，灰度值为0。因此等价模式LBP特征图像整体偏暗。</p><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="/article/50afbda/image-20200628174535833.png" srcset="/img/loading.gif">    <br>    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图 2.3.3 LBP等价模式类(P=8)</div></center><h2 id="LBPH特征"><a href="#LBPH特征" class="headerlink" title="LBPH特征"></a>LBPH特征</h2><p>LBPH特征：全称为Local Binary Patterns Histograms，即LBP特征的统计直方图。LBPH将LBP特征与图像的空间信息结合在一起。</p><p>一幅图具体的计算LBPH过程如下：</p><p>1.计算图像的LBP特征图像；</p><p>2.将LBP特征图像进行分块，OpenCV中将LBP特征图像分成8行8列64块区域；</p><p>3.计算每块区域特征图像的直方图cell_LBPH，并将直方图进行归一化，直方图大小为 1*numPatterns；</p><p>4.将上面计算的每块区域特征图像的直方图按分块的空间顺序依次排列成一列，形成LBP特征分量，其大小为 1<em>(numPatterns</em>64)；</p><p>5.用机器学习的方式对LBP特征向量进行训练，用来检测和识别目标。</p><h1 id="2-2-基于OpenCV的LBP人脸检测"><a href="#2-2-基于OpenCV的LBP人脸检测" class="headerlink" title="2.2 基于OpenCV的LBP人脸检测"></a>2.2 基于OpenCV的LBP人脸检测</h1><h2 id="多级级联对人脸图像进行检测："><a href="#多级级联对人脸图像进行检测：" class="headerlink" title="多级级联对人脸图像进行检测："></a>多级级联对人脸图像进行检测：</h2><center>    <img style="border-radius: 0.3125em;    box-shadow: 0 2px 4px 0 rgba(34,36,38,.12),0 2px 10px 0 rgba(34,36,38,.08);" src="https://img-blog.csdnimg.cn/20200606145525679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTk0MDUxMg==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif">    <div style="color:orange; border-bottom: 1px solid #d9d9d9;    display: inline-block;    color: #999;    padding: 2px;">图 2.3.5 人脸检测流程图</div></center><h2 id="基于OpenCV的实现"><a href="#基于OpenCV的实现" class="headerlink" title="基于OpenCV的实现"></a>基于OpenCV的实现</h2><ul><li>使用OpenCV预训练模型</li><li>将haarcascade_frontalface_default.xml下载至本地以方便调用，下载链接：<a href="https://github.com/opencv/opencv/blob/master/data/lbpcascades/lbpcascade_frontalface_improved.xml" target="_blank" rel="noopener">https://github.com/opencv/opencv/blob/master/data/lbpcascades/lbpcascade_frontalface_improved.xml</a>   </li></ul><p>函数：<br>detectMultiScale(self, image, scaleFactor=None, minNeighbors=None, flags=None, minSize=None, maxSize=None)<br>参数:<br>1）scaleFactor: 图像缩放比例<br>2）minNeighbors: 每个候选矩形保留的邻居个数，值越大-&gt;精度越大<br>3）minSize：检测到的最小矩形大小<br>4）maxSize: 检测到的最大矩形大小</p><p>待测人脸图像(网上随意摘取一张)：</p><p><img src="/article/50afbda/image2.jpg" srcset="/img/loading.gif" alt="image2"></p><pre><code class="hljs python"><span class="hljs-comment"># 利用LBP进行人脸检测</span><span class="hljs-keyword">import</span> cv2img = cv2.imread(<span class="hljs-string">'image2.jpg'</span>)<span class="hljs-comment"># cv2.imshow('test', img)</span>face_detect = cv2.CascadeClassifier(<span class="hljs-string">'lbpcascade_frontalface_improved.xml'</span>)<span class="hljs-comment"># ======================检测人脸==============================</span><span class="hljs-comment"># 灰度处理</span>gray = cv2.cvtColor(img, code=cv2.COLOR_BGR2GRAY)<span class="hljs-comment"># 检测人脸 按照1.1倍放到 周围最小像素为5</span>face_zone = face_detect.detectMultiScale(gray, scaleFactor=<span class="hljs-number">1.1</span>, minNeighbors=<span class="hljs-number">2</span>)print(face_zone)<span class="hljs-comment"># 绘制矩形检测人脸</span><span class="hljs-keyword">for</span> (x, y, w, h) <span class="hljs-keyword">in</span> face_zone:    <span class="hljs-comment"># 绘制矩形人脸区域</span>    print(x,y,w,h)    cv2.rectangle(img, pt1=(x, y), pt2=(x+w, y+h), color=[<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>], thickness=<span class="hljs-number">2</span>)<span class="hljs-comment"># 显示图片</span>cv2.imshow(<span class="hljs-string">"output"</span>, img)<span class="hljs-comment"># 等待显示，设置任意键退出程序</span>cv2.waitKey(<span class="hljs-number">0</span>)cv2.destroyAllWindows()</code></pre><p>检测结果：</p><p><img src="/article/50afbda/output.jpg" srcset="/img/loading.gif" alt="output"></p><p>简单示意例子：<a href="https://sharky93.github.io/docs/gallery/auto_examples/plot_local_binary_pattern.html" target="_blank" rel="noopener">https://sharky93.github.io/docs/gallery/auto_examples/plot_local_binary_pattern.html</a></p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://blog.csdn.net/qq_34246778/article/details/90613779?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase" target="_blank" rel="noopener">LBP(Local Binary Patterns特征)</a></p><p><a href="https://blog.csdn.net/YhL_Leo/article/details/52120195" target="_blank" rel="noopener">局部二值模式（Local Binary Patterns）纹理灰度与旋转不变性</a></p><p><a href="https://github.com/datawhalechina/team-learning/blob/master/03 计算机视觉/计算机视觉基础：图像处理（下）/Task02 LBP特征描述算子.md" target="_blank" rel="noopener">Task02 LBP特征描述算子</a></p>]]></content>
    
    
    <categories>
      
      <category>图像处理下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Task01 Harris特征点检测器-兴趣点检测</title>
    <link href="/article/8b3bd9dd.html"/>
    <url>/article/8b3bd9dd.html</url>
    
    <content type="html"><![CDATA[<h1 id="Harris特征点检测器-兴趣点检测"><a href="#Harris特征点检测器-兴趣点检测" class="headerlink" title="Harris特征点检测器-兴趣点检测"></a>Harris特征点检测器-兴趣点检测</h1><p><strong>特则点</strong>又称为兴趣点或角点，通常具有旋转不变性和光照不变性和视角不变性等优点，是图像的重要特征之一，常被应用到目标匹配、目标跟踪、三维重建等应用中。</p><p><strong>点特征</strong>主要是指图像中的明显点，如突出的角点、边缘端点、权值点等等。</p><p><strong>兴趣点提取(检测)算子</strong>是用于点特征提取的算子<a id="more"></a>，常用的有</p><ul><li>Harris角点检测：用于检测角点</li><li>FAST特征检测：用于检测角点</li><li>SIFT特征检测：用于检测斑点</li><li>SURF特征检测：用于检测角点</li><li>BRIEF特征检测：用于检测斑点</li><li>ORB：该算法代表带方向的FAST算法和具有旋转不变性的BRIEF算法</li></ul><p><strong>特征匹配</strong>：</p><ul><li>暴力(Brute-Force)匹配法</li><li>基于FLANN匹配法</li></ul><h2 id="一、Harris特征点检测算法的思想和数学原理"><a href="#一、Harris特征点检测算法的思想和数学原理" class="headerlink" title="一、Harris特征点检测算法的思想和数学原理"></a>一、Harris特征点检测算法的思想和数学原理</h2><h2 id="1-1-基础知识"><a href="#1-1-基础知识" class="headerlink" title="1.1 基础知识"></a>1.1 基础知识</h2><ul><li><p><strong>角点</strong></p><p>左图表示一个平坦区域，在各个方向移动，窗口内像素值均没有太大变化；</p><p>中图表示一个边缘特征(Edges)，若沿着水平方向移动(梯度方向)，像素值会发生跳变；若沿着边缘移动(平行于边缘)，像素值不变发生变化；</p><p>右图表示一个角(Corners)，它朝哪个方向移动，像素值都会发生很大变化。即为<font color="red">角点</font>。</p></li></ul><p><img src="https://camo.githubusercontent.com/460ac04994bec25117ee2724563058da99e5bf1e/68747470733a2f2f696d672d626c6f672e6373646e696d672e636e2f32303230303630393230343234393231392e706e673f782d6f73732d70726f636573733d696d6167652f77617465726d61726b2c747970655f5a6d46755a33706f5a57356e6147567064476b2c736861646f775f31302c746578745f6148523063484d364c7939696247396e4c6d4e7a5a473475626d56304c33646c61586870626c38304d4459304e7a67784f513d3d2c73697a655f312c636f6c6f725f4646464646462c745f3730237069635f63656e746572" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li><strong>图像梯度</strong>:图像局部内，图像梯度越大表示该局部内像素值变化越大。图形梯度在数学上可用微分或者积分表示,使用差分来近似导数：$G_x(x,y)=H(x+1,y)-H(x-1,y)$,</li><li><strong>补充</strong>：对图像求梯度通常是考虑图像的每个像素的某个领域内的灰度变化，因此通常对原始图像中像素某个领域设置梯度算子，然后采用小区域模板进行卷积计算，常用的有Prewitt算子、Sobel算子、Robinson算子、Laplace算子等。</li></ul><h2 id="1-2-Harris角点检测算法原理"><a href="#1-2-Harris角点检测算法原理" class="headerlink" title="1.2 Harris角点检测算法原理"></a>1.2 Harris角点检测算法原理</h2><h3 id="1-2-1-计算窗口内部的像素值变化量-E-x-y"><a href="#1-2-1-计算窗口内部的像素值变化量-E-x-y" class="headerlink" title="1.2.1 计算窗口内部的像素值变化量$E(x,y)$"></a>1.2.1 计算窗口内部的像素值变化量$E(x,y)$</h3><p><strong>建立数学模型，确定哪些窗口会引起较大的灰度值变化</strong></p><p>窗口$W$对应的像素坐标位置$(x,y)$，窗口的大小决定了有多少位置。</p><p>像素位置坐标$(x,y)$对应的像素灰度值为$I(x,y)$，窗口分别向$x$和$y$方向上移动$(u,v)$，到达$(x+u,y+v)$上，对应的像素灰度值$I(x+u,y+v)$。</p><p>窗口移动引起的灰度值的变化量为$I(x+u,y+v)-I(x,y)$。</p><p>$(x,y)$位置的窗口函数为$w(x,y)$。即为窗口内各像素的权重。</p><p><img src="/article/8b3bd9dd/image1-2.png" srcset="/img/loading.gif" alt="image-20200623143300133"></p><p><strong>窗口移动(u,v)引起的灰度值的加权变化量</strong>：</p><script type="math/tex; mode=display">E(u,v) = \sum_{x,y}{w(x,y){[I(x+u,y+v)-I(x,y)]}^{2}}</script><p>根据二维泰勒公式展开：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}E(u,v) &\approx \sum_{x,y \in W}{w(x,y){[I(x,y)+uI_x+vI_y-I(x,y)]}^{2}} \\  &= \sum_{x,y\in W}{w(x,y){(uI_x+vI_y)}^{2}} \\  &= \sum_{x,y\in W}{w(x,y){(u^2I_x^2+vI_y^2+2uvI_xI_y)}^{2}} \\  &= \sum_{x,y\in W}{w(x,y)\begin{bmatrix}u&v\end{bmatrix}\begin{bmatrix}I_x^2 & I_xI_y\\                                       I_xI_y & I_y^2\end{bmatrix} \begin{bmatrix}u\\v\end{bmatrix}} \\  &= \begin{bmatrix}u&v\end{bmatrix}(\sum_{x,y\in W}{w(x,y) \begin{bmatrix}I_x^2 & I_xI_y\\                                     I_xI_y & I_y^2\end{bmatrix} })\begin{bmatrix}u\\v\end{bmatrix}                                      \\  &= \begin{bmatrix}u&v\end{bmatrix}M\begin{bmatrix}u\\v\end{bmatrix}\end{aligned}\end{equation}</script><p>其中$I_x,I_y$分别为窗口内像素点$(x,y)$在$x$方向上和$y$方向上的梯度值。矩阵$M$为：</p><script type="math/tex; mode=display">\begin{equation}\begin{aligned}M &= \sum_{(x,y)\in W}{w(x,y) \begin{bmatrix}I_x^2 & I_xI_y\\                                       I_xI_y & I_y^2\end{bmatrix}}\\  &=R^{-1}\begin{bmatrix}\lambda_1 & 0\\0 & \lambda_2\end{bmatrix}R\end{aligned}\end{equation}</script><p>最后使用实对称矩阵对角化处理后得到我们想要的结果。</p><h3 id="1-2-2-计算对应的角点响应函数-R"><a href="#1-2-2-计算对应的角点响应函数-R" class="headerlink" title="1.2.2 计算对应的角点响应函数$R$"></a>1.2.2 计算对应的角点响应函数$R$</h3><p>通过矩阵的梯度变化可以得到协方差矩阵M，协方差矩阵M决定了灰度值的加权变化量。因此通过计算<strong>角点响应函数R</strong>得到每个窗口对应的得分:</p><script type="math/tex; mode=display">R = det(M)-k(trace(M))^2</script><p>其中$det(M)=\lambda_1\lambda_2$为矩阵的行列式，$trace(M)=\lambda_1+\lambda_2$为矩阵的迹。</p><p>$k$是一个经验常数，需要经验确定它的合适大小，通常在(0.04,0.06)之间取值。</p><h3 id="1-2-3-角点判定"><a href="#1-2-3-角点判定" class="headerlink" title="1.2.3 角点判定"></a>1.2.3 角点判定</h3><p>根据R值判断窗口是平面、边缘还是角点：</p><ul><li>平面：$|R|$值非常小，$\lambda_1$和$\lambda_2$都较小，窗口区域的像素点的梯度变化小。</li><li>边缘：$|R|$值为负数，$\lambda_1 \gg \lambda_2$或$\lambda_2 \gg \lambda_1$，像素点的某个方向的梯度幅值变化比较明显，另一个方向上的梯度变化比较弱。</li><li>角点：$|R|$值很大，$(I_x,I_y)$对应的$\lambda_1$和$\lambda_2$都很大。像素点的梯度分布比较散，梯度变化程度比较大。</li></ul><p>如下图所示：</p><p><img src="https://camo.githubusercontent.com/c6eef9fa98b4f1e099bc722b21536c73c6b9bf9f/68747470733a2f2f696d67636f6e766572742e6373646e696d672e636e2f6148523063484d364c7939706257466e5a584d794d4445314c6d4e75596d78765a334d75593239744c324a73623263764e4455784e6a59774c7a49774d5459774e4338304e5445324e6a41744d6a41784e6a41304d6a45784d5441314e4455354f5445744e4451304e6a6b314e5445344c6e42755a773f782d6f73732d70726f636573733d696d6167652f666f726d61742c706e67237069635f63656e746572" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>Harris角点检测：设定一个阈值，高于阈值的像素对应角点。</p><ul><li>补充：角点的非极大值原理—在一个窗口内，如果有很多角点则用值最大的那个角点，其他的角点都删除。</li></ul><h2 id="1-3-Shi-Tomasi角点检测器"><a href="#1-3-Shi-Tomasi角点检测器" class="headerlink" title="1.3 Shi-Tomasi角点检测器"></a>1.3 Shi-Tomasi角点检测器</h2><p><strong>Shi-Tomasi 角点检测</strong>：《Good_Features_to_Track》论文提出的Harris改进版。</p><p>Harris角点检测中每个窗口的分数公式：$R=\lambda_1\lambda_2 - k(\lambda_1+\lambda_2)^2$</p><p>缺陷：Harris角点检测算法的稳定性和k值有关，但k是经验值，不好设定最佳值。</p><p>改进：角点稳定性与矩阵$M$的较小特征值有关，Shi-Tomasi 直接采用较小的特征值作为分数。(如此一来就不用调整k值啦)</p><p>Shi-Tomasi角点检测中每个窗口的分数公式：$R=min(\lambda_1,\lambda_2)$</p><p>判定角点的方式不变：分数大于设定的阈值，即为角点。</p><h2 id="二、OpenCV的Harris算子进行兴趣点检测"><a href="#二、OpenCV的Harris算子进行兴趣点检测" class="headerlink" title="二、OpenCV的Harris算子进行兴趣点检测"></a>二、OpenCV的Harris算子进行兴趣点检测</h2><h2 id="2-1-Harris角点检测"><a href="#2-1-Harris角点检测" class="headerlink" title="2.1 Harris角点检测"></a>2.1 Harris角点检测</h2><p><strong>opencv</strong>提供了实现<strong>Harris</strong>角点检测函数：<a href="https://link.zhihu.com/?target=https%3A//docs.opencv.org/master/dd/d1a/group__imgproc__feature.html%23gac1fc3598018010880e370e2f709b4345">cv2.cornerHarris</a>，下面调用该接口进行<strong>Harris</strong>特征点检测。</p><p>函数：<strong>cv2.cornerHarris(src, blockSize, ksize, k[, dst[, borderType]])​</strong></p><p>函数功能：对于每一个像素 $(x,y)$，在 ($blockSize$ x $blockSize$) 邻域内，计算梯度图的协方差矩阵$M(x,y)$，通过计算角点响应函数得到结果图。该结果图的局部最大值即图像中的角点。</p><p>函数参数：</p><ul><li><strong>src</strong>:待检测的灰度图像(float32类型)</li><li><strong>blockSize</strong>:用于角点检测的领域大小，即窗口尺寸</li><li><strong>ksize</strong>:用于计算梯度图的Sobel算子的尺寸</li><li><strong>k</strong>:用于计算角点响应函数的参数k，取值范围在0.04~0.06之间</li></ul><p>待检测的图片：</p><p><img src="/article/8b3bd9dd/image1.jpg" srcset="/img/loading.gif" alt="image1"></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2 <span class="hljs-keyword">as</span> cv<span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-comment"># 检测参数</span>block_size = <span class="hljs-number">3</span>sobel_size = <span class="hljs-number">3</span>k = <span class="hljs-number">0.06</span>image = cv.imread(<span class="hljs-string">'image1.jpg'</span>)print(image.shape)height = image.shape[<span class="hljs-number">0</span>]width = image.shape[<span class="hljs-number">1</span>]channels = image.shape[<span class="hljs-number">2</span>]print(<span class="hljs-string">"width: %s height: %s channel: %s"</span>%(width, height, channels))<span class="hljs-comment"># 将图像转换为灰度图</span>gray_img = cv.cvtColor(image, cv.COLOR_BGR2GRAY)<span class="hljs-comment"># 将数据格式转换为32位浮点数</span>gray_img = np.float32(gray_img)<span class="hljs-comment"># 使用合适值作为输入参数检测角点，得到的结果图用来标出角点</span>corners_img = cv.cornerHarris(gray_img, block_size, sobel_size, k)</code></pre><p>输出：</p><pre><code class="hljs tex">(225, 225, 3)width: 225 height: 225 channel: 3</code></pre><pre><code class="hljs python">kernel = cv.getStructuringElement(cv.MORPH_RECT,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>))dst = cv.dilate(corners_img, kernel)<span class="hljs-comment"># dst = cv.dilate(corners_img,None)</span><span class="hljs-comment"># image[dst&gt;0.05*dst.max()] = [255,0,0]</span><span class="hljs-comment"># num = dst &gt; 0.05 * dst.max()</span><span class="hljs-comment"># count = np.sum(num)</span><span class="hljs-comment"># print(count)</span>count = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> range(height):    <span class="hljs-keyword">for</span> c <span class="hljs-keyword">in</span> range(width):        pix = dst[r,c]        <span class="hljs-comment"># 阈值，蓝色标记角点</span>        <span class="hljs-keyword">if</span> pix &gt; <span class="hljs-number">0.05</span> * dst.max():            cv.circle(image,(c,r),<span class="hljs-number">2</span>,(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),<span class="hljs-number">-1</span>)            count += <span class="hljs-number">1</span>print(count)cv.imwrite(<span class="hljs-string">'harris_img1.jpg'</span>,image)</code></pre><p>输出：</p><pre><code class="hljs tex">741</code></pre><p>处理后图片如下：</p><p><img src="/article/8b3bd9dd/harris_img1.jpg" srcset="/img/loading.gif" alt="harris_img1"></p><pre><code class="hljs python"><span class="hljs-comment"># 使用点画图，点小一点，好看一丢丢把。。。</span>image[dst&gt;<span class="hljs-number">0.05</span>*dst.max()] = [<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]</code></pre><p><img src="/article/8b3bd9dd/harris_img2.jpg" srcset="/img/loading.gif" alt="harris_img1"></p><h2 id="2-2-Shi-Tomasi角点检测"><a href="#2-2-Shi-Tomasi角点检测" class="headerlink" title="2.2 Shi-Tomasi角点检测"></a>2.2 Shi-Tomasi角点检测</h2><p>opencv提供了实现Shi-Tomasi 角点检测函数：<strong>cv2.goodFeaturesToTrack()</strong>，下面调用该接口进行Harris特征点检测。</p><p>函数：<strong>goodFeaturesToTrack(image, maxCorners, qualityLevel, minDistance[, corners[, mask[, blockSize[, useHarrisDetector[, k]]]]])</strong></p><p>函数功能：流程大体与Harris相似。不同之处在于窗口分数计算公式不同。在检测到的角点中，所有低于质量水平的角点都会被忽略，合格角点按角点质量进行降序排列，保留质量最高的一个角点，将它附近（最小距离之内）的角点都删掉（类似于非极大值抑制），按这样的方式最后得到 N 个最佳角点。</p><p>函数参数：</p><ul><li><strong>image</strong>：输入灰度图像，float32类型</li><li><strong>maxCorners</strong>：返回角点的最大数目，值为0表表示不设置最大值限制，返回所有检测到的角点。</li><li><strong>qualityLevel</strong>：质量系数（小于1.0的正数，一般在0.01-0.1之间），表示可接受角点的最低质量水平。该系数乘以最好的角点分数（也就是上面较小的那个特征值），作为可接受的最小分数；例如，如果最好的角点分数值为1500且质量系数为0.01，那么所有质量分数小于15的角都将被忽略。</li><li><strong>minDistance</strong>：角之间最小欧式距离，忽略小于此距离的点。</li><li><strong>corners</strong>：输出角点坐标</li><li><strong>mask</strong>：可选的感兴趣区域，指定想要检测角点的区域。</li><li><strong>blockSize</strong>：默认为3，角点检测的邻域大小（窗口尺寸）</li><li><strong>useHarrisDetector</strong>：用于指定角点检测的方法，如果是true则使用Harris角点检测，false则使用Shi Tomasi算法。默认为False。</li><li><strong>k</strong>：默认为0.04，Harris角点检测时使用。</li></ul><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<span class="hljs-keyword">import</span> cv2maxCorners = <span class="hljs-number">600</span>qualityLevel = <span class="hljs-number">0.01</span>minDistance = <span class="hljs-number">10</span>img = cv2.imread(<span class="hljs-string">'image1.jpg'</span>)gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)corners = cv2.goodFeaturesToTrack(gray, maxCorners, qualityLevel, minDistance)corners = np.int0(corners)count = <span class="hljs-number">0</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> corners:    x,y = i.ravel()    cv2.circle(img,(x,y), <span class="hljs-number">2</span>, (<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),<span class="hljs-number">-1</span>)    <span class="hljs-comment"># img[y,x] = [255,0,0]</span>    count += <span class="hljs-number">1</span>cv.imwrite(<span class="hljs-string">'Shi-Tomasi.jpg'</span>,img)img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)print(count)</code></pre><p><img src="Task01-Harris特征点检测器-兴趣点检测//Tomasi.jpg" srcset="/img/loading.gif" alt></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Harris和Shi-Tomasi都是基于梯度计算的角点检测方式。</p><p>Harris角点检测的性质：</p><ul><li><p>阈值界定角点数量</p></li><li><p>Harris角点算子对亮度和对比度的变化不敏感</p><p>因为在进行Harris角点检测时，使用了微分算子对图像进行微分运算，而微分运算对图像密度的拉升或收缩和对亮度的抬高或下降不敏感。换言之，对亮度和对比度的仿射变换并不改变Harris响应的极值点出现的位置，但是，由于阈值的选择，可能会影响角点检测的数量。</p><p><img src="/article/8b3bd9dd/image1-3.png" srcset="/img/loading.gif" alt="image-20200623145505861"></p><p>左图表示亮度变化，右图表示对比度变化。</p></li><li><p>Harris角点检测算子具有旋转不变性</p><p>Harris角点检测算子使用的是角点附近的区域灰度二阶矩矩阵。而二阶矩矩阵可以表示成一个椭圆，椭圆的长短轴正是二阶矩矩阵特征值平方根的倒数。当特征椭圆转动时，特征值并不发生变化，所以判断角点响应值RR也不发生变化，由此说明Harris角点检测算子具有旋转不变性。</p></li><li><p>Harris角点检测算子不具有尺度不变性</p><p><img src="/article/8b3bd9dd/image1-1.png" srcset="/img/loading.gif" alt="image-20200623003833148"></p><p>如上图所示，当图像被缩小时，在检测窗口尺寸不变的前提下，在窗口内所包含图像的内容是完全不同的。左侧的图像可能被检测为边缘或曲线，而右侧的图像则可能被检测为一个角点。</p></li></ul><p>基于梯度的角点检测器的缺点：计算复杂度高、图像中的噪声阻碍梯度计算。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/datawhalechina/team-learning/blob/master/03%20%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%EF%BC%88%E4%B8%8B%EF%BC%89/Task01%20Harris%E7%89%B9%E5%BE%81%E7%82%B9%E6%A3%80%E6%B5%8B.md" target="_blank" rel="noopener">Task01 Harris特征点检测器-兴趣点检测</a></p><p><a href="https://zhuanlan.zhihu.com/p/83064609" target="_blank" rel="noopener">角点检测：Harris 与 Shi-Tomasi</a></p><p><a href="https://www.cnblogs.com/zyly/p/9508131.html" target="_blank" rel="noopener">Harris角点检测原理(赋源码)</a></p>]]></content>
    
    
    <categories>
      
      <category>图像处理下</category>
      
    </categories>
    
    
    <tags>
      
      <tag>图像处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Introduction_and_Word_Vectors</title>
    <link href="/article/fd8e5887.html"/>
    <url>/article/fd8e5887.html</url>
    
    <content type="html"><![CDATA[<h1 id="Task1-Introduction-and-Word-Vectors"><a href="#Task1-Introduction-and-Word-Vectors" class="headerlink" title="Task1: Introduction and Word Vectors"></a>Task1: Introduction and Word Vectors</h1><p>理论部分</p><ul><li>介绍NLP研究的对象</li><li>如何表示单词的含义</li><li>Word2Vec方法的基本原理</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>2数理统计与描述性统计</title>
    <link href="/article/83114b11.html"/>
    <url>/article/83114b11.html</url>
    
    <content type="html"><![CDATA[<h1 id="一、数理统计概念"><a href="#一、数理统计概念" class="headerlink" title="一、数理统计概念"></a>一、数理统计概念</h1><h2 id="1-基本概念释义"><a href="#1-基本概念释义" class="headerlink" title="1.基本概念释义"></a>1.基本概念释义</h2><p><span style="color:blue">总体</span>：</p><p>研究对象的全体，通常用一个随机变量表示。</p><p><span style="color:blue">个体</span>：</p><p>组成总体的每个基本单元。<a id="more"></a></p><p>从总体$X$中随机抽取一部分个体$X_1,X_2,…,X_n$，称$X_1,X_2,…,X_n$为取自$X$的容量为$n$的样本。实际上，数理统计学中的总体是指与总体相联系的某个(某几个)数量指标$X$取值的全体。</p><p><span style="color:red">样本具有两重性，在一次具体抽样后是一组确定的数值。一般叙述中由于采取随机抽样，样本是一组随机变量(结果未知)。</span></p><p>一般地，用$X_1,X_2,…,X_n$，表示随机样本，取到的值记为$x_1,x_2,…,x_n$称为样本观测值。$n$为样本容量。</p><p><span style="color:blue">样本分布</span>：样本作为随机变量的概率分布。显然，样本分布取决于总体的性质和样本的性质。</p><h2 id="2-统计量与抽样"><a href="#2-统计量与抽样" class="headerlink" title="2.统计量与抽样"></a>2.统计量与抽样</h2><p>数理统计的任务是采集和处理带有随机影响的数据，或者说收集样本并对之进行加工，在此基础上对研究的问题进行分析并作出一定的结论，这一过程称为<span style="color:blue">统计推断</span>。在统计推断过程中，对样本进行加工整理，实际上就是根据样本计算出一些量，把研究问题相关的信息集中起来。这种根据样本计算出的量就是<span style="color:blue">统计量</span>。因此，统计量是样本的某种函数。</p><p>定义：设 $X_1,X_2,…,X_n $ 是总体 $X$ 的一个简单随机样本， $T(X_1, X_2,…,X_n)$ 为一个 $n$ 元连续函数，且 $T$ 中不包含任何关于总体的未知参数，则称 $T(X_1, X_2,…,X_n)$ 是一个统计量，称统计量的分布为抽样分布。</p><h3 id="常用的统计量"><a href="#常用的统计量" class="headerlink" title="常用的统计量"></a>常用的统计量</h3><p><span style="color:blue">样本均值</span></p><p>设 $X_1,X_2,…,X_n $ 是总体 $X$ 的一个简单随机样本，称$\overline X =  \frac{1} {n} {\sum_{i=1}^{n}X_i}$为样本均值。通常用样本均值来估计总体分布的均值和对有关总体分布均值的假设作检验。</p><p><span style="color:blue">样本方差</span></p><p>设 $X_1,X_2,…,X_n $ 是总体 $X$ 的一个简单随机样本，$\overline X$ 为样本均值，称$S^2 =  \frac{1} {n-1} {\sum_{i=1}^{n}(X_i-\overline X)^2}$为样本方差。</p><p>通常用样本方差来估计总体分布的方差和对有关总体分布均值或方差的假设作检验。</p><p><span style="color:blue">k阶样本原点矩</span></p><p>设 $X_1,X_2,…,X_n $ 是总体 $X$ 的一个简单随机样本，称$A_k =  \frac{1} {n} {\sum_{i=1}^{n}X_i^k}$</p><p>为样本的 $k$ 阶原点矩（可以看到 $k=1$ 时，相当于样本均值），通常用样本的无阶原点矩来估计总体分布的 $k$ 阶原点矩。（可以看到 $k=1$ 时，相当于样本均值）</p><p>通常用样本的无阶原点矩来估计总体分布的 $k$ 阶原点矩。</p><p><span style="color:blue">k阶样本中心矩</span></p><p>设 $X_1,X_2,…,X_n $ 是总体 $X$ 的一个简单随机样本，$\overline X$ 为样本均值，称$M_k =  \frac{1} {n} {\sum_{i=1}^{n}(X_i-\overline X)^k}$为样本的 $k$ 阶中心矩。</p><p>通常用样本的 $k$ 阶中心矩来估计总体分布的 $k$ 阶中心矩。</p><p><span style="color:blue">顺序统计量</span></p><p>设 $X_1,X_2,…,X_n $ 是抽自总体 $X$ 的样本，$x_1,x_2,…，x_n$  为样本观测值。将 $x_1,x_2,…，x_n$  按照从小到大的顺序排列为$x_{(1)}&lt;=x_{(2)}&lt;=…&lt;=x_{(n)}$。</p><p>当样本 $X_1,X_2,…,X_n $ 取值 $x_1,x_2,…，x_n$  时，定义 $X_{(k)}$ 取值 $X_{(k)}(k=1,2，…,n)$，称  $X_{(1)},X_{(2)},…,X_{(n)} $ 为 $X_1,X_2,…,X_n $ 的顺序统计量。</p><p>显然，$X_{(1)} =min {X_i}$ 是样本观察中最小的一个，称为最小顺序统计量。$X_{(n)} =max {X_i}$ 是样本观测值中取值最大的一个，成为最大顺序统计量。称$X_{（r）}$ 为第 $r$ 个顺序统计量。</p><h1 id="二、描述性统计"><a href="#二、描述性统计" class="headerlink" title="二、描述性统计"></a>二、描述性统计</h1><h2 id="1-数据集中趋势的度量"><a href="#1-数据集中趋势的度量" class="headerlink" title="1.数据集中趋势的度量"></a>1.数据集中趋势的度量</h2><p><span style="color:blue">平均数</span></p><p>是表示一组数据集中趋势的量数，是指在一组数据中所有数据之和再除以这组数据的个数。</p><script type="math/tex; mode=display">\overline X =  \frac{1} {n} {\sum_{i=1}^{n}X_i}</script><p><span style="color:blue">中位数</span></p><p>是指在一组数据，按顺序排列后，居于中间位置的数。中位数描述数据中心位置的数字特征。</p><p>对于对称分布的数据，均值与中位数比较接近；对于偏态分布的数据，均值与中位数不同。中位数不受异常值的影响，具有稳健性。</p><script type="math/tex; mode=display">m_p=\left\{\begin{array}{lcl}x_{[np]+1},       &      & {当np不是整数}\\\frac{1}{2}(x_{(np)}+x_{(np+1)})     &      & {当np是整数时}\\\end{array} \right.</script><p><span style="color:blue">频数</span></p><p>同一观测值在一组数据中出现的次数（掷骰子中，一共掷了20次，出现数字5的次数）。</p><p><span style="color:blue">众数</span></p><p>就是一组数据中，出现次数最多的那个数（几个数）。</p><p><span style="color:blue">均值 vs 中位数 vs 众数</span></p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">均值</td><td style="text-align:center">充分利用所有数据，适用性强</td><td style="text-align:center">容易受极端值影响</td></tr><tr><td style="text-align:center">中位数</td><td style="text-align:center">不受极端值影响</td><td style="text-align:center">缺乏敏感性</td></tr><tr><td style="text-align:center">众数</td><td style="text-align:center">不受极端值影响；当数据具有明显的集中趋势时，代表性好</td><td style="text-align:center">缺乏唯一性</td></tr></tbody></table></div><p><span style="color:blue">百分位数</span></p><p>百分位数是中位数的推广，将数据按从小到大排列后，对于$0 \leq p &lt; 1$，它的p分位点定义为</p><script type="math/tex; mode=display">m_p=\left\{\begin{array}{lcl}x_{[np]+1},       &      & {当np不是整数}\\\frac{1}{2}(x_{(np)}+x_{(np+1)})     &      & {当np是整数时}\\\end{array} \right.</script><p>其中，<strong>[np]</strong>表示<strong>np</strong>的整数部分。所以，0.5分位数（第50百分位数）就是中位数。</p><p><img src="/article/83114b11/百分位数图.png" srcset="/img/loading.gif" alt></p><h3 id="python实现"><a href="#python实现" class="headerlink" title="python实现"></a>python实现</h3><p><img src="/article/83114b11/image1" srcset="/img/loading.gif" alt="image-20200624144415651"></p><h2 id="2-数据离散趋势的度量"><a href="#2-数据离散趋势的度量" class="headerlink" title="2.数据离散趋势的度量"></a>2.数据离散趋势的度量</h2><p>表示数据分散（离散，差异）程度的特征量有方差，标准差，极差以及变异系数等。</p><p><span style="color:blue">方差</span></p><p>用来计算每一个变量（观察值）与总体均数之间的差异。实际工作中，总体均数难以得到时，应用样本统计量代替总体参数，经校正后，样本方差计算公式:</p><script type="math/tex; mode=display">s^2 = \frac{1}{n-1}\sum_{i=1}^{n}{(x_i-\overline{x})}^2</script><p><span style="color:blue">标准差</span></p><p>样本方差的开平方成为样本标准差。</p><script type="math/tex; mode=display">s=\sqrt{s^2}=\sqrt{\frac{1}{n-1}\sum_{1}^{n-1}{(x_i-\overline{x})}^2}</script><p><span style="color:blue">极差</span></p><script type="math/tex; mode=display">R=X_{(n)}-x_{(1)}=\max(x)-\min(x)</script><p>数据越分散，极差越大。</p><p><span style="color:blue">变异系数</span></p><ul><li>是刻画数据相对分散性的一种度量。变异系数只在平均值不为零时有定义，而且一般适用于平均值大于零的情况。变异系数也被称为<strong>标准离差率</strong>或<strong>单位风险</strong>。</li><li>当需要比较两组数据离散程度大小的时候，如果两组数据的测量尺度相差太大，或者数据量纲的不同，变异系数可以消除测量尺度和量纲的影响。</li></ul><script type="math/tex; mode=display">CV=100\times\frac{s}{x}(\%)</script><p><span style="color:blue">四分位差</span></p><p>样本上、下四分位数之差称为四分位差(或半极差)。</p><script type="math/tex; mode=display">R_1 = Q_3 - Q_1</script><p>它也是度量样本分散性的重要数字特征，特别对于具有异常值的数据，它作为分散性具有稳健性<span style="color:red">  <strong>（见百分位数示意图）</strong></span>。</p><h3 id="python实现-1"><a href="#python实现-1" class="headerlink" title="python实现"></a>python实现</h3><p><img src="/article/83114b11/image2.PNG" srcset="/img/loading.gif" alt="image2" style="zoom:80%;"></p><h2 id="3-分布特征"><a href="#3-分布特征" class="headerlink" title="3.分布特征"></a>3.分布特征</h2><p> <strong>引言：</strong>描述一个随机变量，不仅要说明它能够取那些值，而且还要关心它取这些值的概率（可能性）。</p><p><span style="color:blue">离散变量和连续变量</span></p><ul><li><span style="color:blue">离散型随机变量</span>：其数值只能用<strong>自然数或整数</strong>单位表示。例如，<span style="color:red">  班级人数，电脑台数等，</span>只能按计量单位数计数，这种变量的数值一般用计数方法取得。</li><li><span style="color:blue">连续变量</span>：在一定区间内可以任意取值的变量。例如，<span style="color:red">人体测量的身高，体重等。</span></li></ul><p><span style="color:blue">概率函数</span>：用函数的形式来表达概率。</p><ul><li><strong>连续型随机变量</strong>的概率函数就叫做<strong>概率密度函数</strong>。</li><li><strong>离散型随机变量</strong>的概率函数就叫做<strong>概率质量函数</strong>。</li></ul><p><span style="color:blue">分布函数</span></p><p>设$X$是一个随机变量，对任意的实数$x$，令$F(x)=P(X&lt;=x),x \in (-\infty,+\infty)$，则称$F(x)$是随机变量$X$的分布函数(概率累积函数)。</p><p><img src="/article/83114b11/分布函数与密度函数的关系.png" srcset="/img/loading.gif" alt></p><center class="half"><span style="color:red">密度函数与分布函数关系</span></center> <p><span style="color:blue">正态分布</span>：也称高斯分布，是一个非常常见的连续概率分布，概率密度函数为</p><script type="math/tex; mode=display">f(x) = \frac{1}{\sqrt{2\pi}\sigma}\exp{\{- \frac{(x-u)^2}{2\sigma^2} \}}, \qquad -\infty<x<+\infty</script><p>则称$X$服从$N(u,\sigma^2)$分布。</p><p><img src="/article/83114b11/uniform2.png" srcset="/img/loading.gif" alt="uniform2"></p><center class="half"><span style="color:red">正态分布的概率密度函数曲线</span></center> <p><img src="/article/83114b11/标准正态分布.png" srcset="/img/loading.gif" alt="标准正态分布"></p><center class="half"><span style="color:red">标准正态分布和对应区间上积分（面积）的百分比</span> </center><p>这个概念可以推广到一般正态分布。$[u-3\sigma,u+3\sigma]$的概率密度曲线之下的面积占总面积的99.7%，是著名的$3\sigma$原则。</p><h2 id="4-偏度与峰度"><a href="#4-偏度与峰度" class="headerlink" title="4. 偏度与峰度"></a>4. 偏度与峰度</h2><p><span style="color:blue">偏度（skewness）</span>：也称为偏态，是统计数据分布偏斜方向和程度的度量，是统计数据分布非对称程度的数字特征。直观看来就是密度函数曲线尾部的相对长度。<strong>偏度刻画的是分布函数（数据）的对称性。</strong></p><p>关于均值对称的数据其偏度系数为0，右侧更分散的数据偏度系数为正，左侧更分散的数据偏度系数为负.</p><ul><li><p><strong>正态分布的偏度为0，两侧尾部长度对称。</strong></p></li><li><p><strong>左偏:</strong>   </p><p>1）若以$b_s$表示偏度。$b_s&lt;0$称分布具有<strong>负偏离</strong>，也称左偏态；</p><p>2）此时数据位于均值左边的比位于右边的少，直观表现为左边的尾部相对于与右边的尾部要长；</p><p>3）<strong>因为有少数变量值很小，使曲线左侧尾部拖得很长；</strong></p></li><li><p><strong>右偏：</strong></p><p>1）$b_s&gt;0$称分布具有<strong>正偏离</strong>，也称右偏态；</p><p>2）此时数据位于均值右边的比位于左边的少，直观表现为右边的尾部相对于与左边的尾部要长；</p><p>3）<strong>因为有少数变量值很大，使曲线右侧尾部拖得很长；</strong></p></li></ul><p><span style="color:blue">峰度(peakedness;kurtosis)</span>：说明的是分布曲线在平均值处峰值高低的特征数。直观看来，峰度反映了峰部的尖度。样本的峰度是和正态分布相比较而言统计量，如果峰度大于正态分布峰度，峰的形状比较尖，比正态分布峰要陡峭。反之亦然。<strong>峰度刻画的是分布函数的集中和分散程度。</strong></p><p><img src="/article/83114b11/偏态与峰度.png" srcset="/img/loading.gif" alt></p><h3 id="公式与python实现"><a href="#公式与python实现" class="headerlink" title="公式与python实现"></a>公式与python实现</h3><p><span style="color:blue">样本偏度系数</span>：</p><script type="math/tex; mode=display">g_1 = \frac{n}{(n-1)(n-2)s^3}\sum_{i=1}^{n}{(x_i-\overline{x})}^3=\frac{n^2 u_3}{(n-1)(n-2)s^3}</script><p><span style="color:blue">样本峰度系数</span>：</p><script type="math/tex; mode=display">g_2 = \frac{n(n+1)}{(n-1)(n-2)(n-3)s^4}\sum_{i=1}^{n}{(x_i-\overline{x})}^4-3\frac{(n-1)^2}{(n-2)(n-3)}</script><p><img src="/article/83114b11/image3.PNG" srcset="/img/loading.gif" style="zoom:80%;"></p>]]></content>
    
    
    <categories>
      
      <category>概率统计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>概率统计</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
